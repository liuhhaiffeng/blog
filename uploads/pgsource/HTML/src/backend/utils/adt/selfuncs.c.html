<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\utils\adt\selfuncs.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\utils\adt\selfuncs.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:54 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * selfuncs.c 
 *    Selectivity functions and index cost estimation functions for 
 *    standard operators and index access methods. 
 * 
 *    Selectivity routines are registered in the pg_operator catalog 
 *    in the "oprrest" and "oprjoin" attributes. 
 * 
 *    Index cost functions are located via the index AM's API struct, 
 *    which is obtained from the handler function registered in pg_am. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/utils/adt/selfuncs.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/*---------- 
 * Operator selectivity estimation functions are called to estimate the 
 * selectivity of WHERE clauses whose top-level operator is their operator. 
 * We divide the problem into two cases: 
 *      Restriction clause estimation: the clause involves vars of just 
 *          one relation. 
 *      Join clause estimation: the clause involves vars of multiple rels. 
 * Join selectivity estimation is far more difficult and usually less accurate 
 * than restriction estimation. 
 * 
 * When dealing with the inner scan of a nestloop join, we consider the 
 * join's joinclauses as restriction clauses for the inner relation, and 
 * treat vars of the outer relation as parameters (a/k/a constants of unknown 
 * values).  So, restriction estimators need to be able to accept an argument 
 * telling which relation is to be treated as the variable. 
 * 
 * The call convention for a restriction estimator (oprrest function) is 
 * 
 *      Selectivity oprrest (PlannerInfo *root, 
 *                           Oid operator, 
 *                           List *args, 
 *                           int varRelid); 
 * 
 * root: general information about the query (rtable and RelOptInfo lists 
 * are particularly important for the estimator). 
 * operator: OID of the specific operator in question. 
 * args: argument list from the operator clause. 
 * varRelid: if not zero, the relid (rtable index) of the relation to 
 * be treated as the variable relation.  May be zero if the args list 
 * is known to contain vars of only one relation. 
 * 
 * This is represented at the SQL level (in pg_proc) as 
 * 
 *      float8 oprrest (internal, oid, internal, int4); 
 * 
 * The result is a selectivity, that is, a fraction (0 to 1) of the rows 
 * of the relation that are expected to produce a TRUE result for the 
 * given operator. 
 * 
 * The call convention for a join estimator (oprjoin function) is similar 
 * except that varRelid is not needed, and instead join information is 
 * supplied: 
 * 
 *      Selectivity oprjoin (PlannerInfo *root, 
 *                           Oid operator, 
 *                           List *args, 
 *                           JoinType jointype, 
 *                           SpecialJoinInfo *sjinfo); 
 * 
 *      float8 oprjoin (internal, oid, internal, int2, internal); 
 * 
 * (Before Postgres 8.4, join estimators had only the first four of these 
 * parameters.  That signature is still allowed, but deprecated.)  The 
 * relationship between jointype and sjinfo is explained in the comments for 
 * clause_selectivity() --- the short version is that jointype is usually 
 * best ignored in favor of examining sjinfo. 
 * 
 * Join selectivity for regular inner and outer joins is defined as the 
 * fraction (0 to 1) of the cross product of the relations that is expected 
 * to produce a TRUE result for the given operator.  For both semi and anti 
 * joins, however, the selectivity is defined as the fraction of the left-hand 
 * side relation's rows that are expected to have a match (ie, at least one 
 * row with a TRUE result) in the right-hand side. 
 * 
 * For both oprrest and oprjoin functions, the operator's input collation OID 
 * (if any) is passed using the standard fmgr mechanism, so that the estimator 
 * function can fetch it with PG_GET_COLLATION().  Note, however, that all 
 * statistics in pg_statistic are currently built using the database's default 
 * collation.  Thus, in most cases where we are looking at statistics, we 
 * should ignore the actual operator collation and use DEFAULT_COLLATION_OID. 
 * We expect that the error induced by doing this is usually not large enough 
 * to justify complicating matters. 
 *---------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;ctype.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;float.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;math.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/brin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/gin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/sysattr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/index.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_am.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_collation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_operator.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_opfamily.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_statistic.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_statistic_ext.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"mb/pg_wchar.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/plancat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/predtest.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/restrictinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_clause.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"statistics/statistics.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/acl.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/bytea.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/date.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/datum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/fmgroids.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/index_selfuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/nabstime.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/pg_locale.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/selfuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/spccache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timestamp.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/typcache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/varlena.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Hooks for plugins to get control when we ask for stats */ 
</span><a name="LN153"></a><a href="../../../include/utils/selfuncs.h.html#LN141"><span class='Ref_to_Typedef'>get_relation_stats_hook_type</span></a> <span class='Declare_Var'>get_relation_stats_hook</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN154"></a><a href="../../../include/utils/selfuncs.h.html#LN146"><span class='Ref_to_Typedef'>get_index_stats_hook_type</span></a> <span class='Declare_Var'>get_index_stats_hook</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN156"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>eqsel_internal</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN157"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>var_eq_const</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN158"></a>             <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>constval</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>constisnull</span><span class='Delimiter'>, 
</span><a name="LN159"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>varonleft</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN160"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>var_eq_non_const</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN161"></a>                 <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>other</span><span class='Delimiter'>, 
</span><a name="LN162"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>varonleft</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN163"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>ineq_histogram_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN164"></a>                           <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, 
</span><a name="LN165"></a>                           <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>opproc</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isgt</span><span class='Delimiter'>, 
</span><a name="LN166"></a>                           <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>constval</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>consttype</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN167"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>eqjoinsel_inner</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN168"></a>                <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata1</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN169"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>eqjoinsel_semi</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN170"></a>               <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata1</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata2</span><span class='Delimiter'>, 
</span><a name="LN171"></a>               <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN172"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>estimate_multivariate_ndistinct</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN173"></a>                        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>varinfos</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>ndistinct</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN174"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>convert_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>valuetypid</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledvalue</span><span class='Delimiter'>, 
</span><a name="LN175"></a>                  <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>lobound</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>hibound</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>boundstypid</span><span class='Delimiter'>, 
</span><a name="LN176"></a>                  <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledlobound</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledhibound</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN177"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>convert_numeric_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN178"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>convert_string_to_scalar</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>value</span><span class='Delimiter'>, 
</span><a name="LN179"></a>                         <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledvalue</span><span class='Delimiter'>, 
</span><a name="LN180"></a>                         <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>lobound</span><span class='Delimiter'>, 
</span><a name="LN181"></a>                         <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledlobound</span><span class='Delimiter'>, 
</span><a name="LN182"></a>                         <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>hibound</span><span class='Delimiter'>, 
</span><a name="LN183"></a>                         <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledhibound</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN184"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>convert_bytea_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, 
</span><a name="LN185"></a>                        <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledvalue</span><span class='Delimiter'>, 
</span><a name="LN186"></a>                        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>lobound</span><span class='Delimiter'>, 
</span><a name="LN187"></a>                        <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledlobound</span><span class='Delimiter'>, 
</span><a name="LN188"></a>                        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>hibound</span><span class='Delimiter'>, 
</span><a name="LN189"></a>                        <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledhibound</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN190"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>convert_one_string_to_scalar</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>value</span><span class='Delimiter'>, 
</span><a name="LN191"></a>                             <span class='Keyword'>int </span><span class='Declare_Parameter'>rangelo</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>rangehi</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN192"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>convert_one_bytea_to_scalar</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>valuelen</span><span class='Delimiter'>, 
</span><a name="LN193"></a>                            <span class='Keyword'>int </span><span class='Declare_Parameter'>rangelo</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>rangehi</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN194"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Prototype'>convert_string_datum</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN195"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>convert_timevalue_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN196"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>examine_simple_variable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>var</span><span class='Delimiter'>, 
</span><a name="LN197"></a>                        <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN198"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>get_variable_range</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, 
</span><a name="LN199"></a>                   <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortop</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>min</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>max</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN200"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>get_actual_variable_range</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN201"></a>                          <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, 
</span><a name="LN202"></a>                          <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortop</span><span class='Delimiter'>, 
</span><a name="LN203"></a>                          <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>min</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>max</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN204"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>find_join_input_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>relids</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN205"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Prototype'>prefix_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN206"></a>                   <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, 
</span><a name="LN207"></a>                   <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>vartype</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opfamily</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prefixcon</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN208"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Prototype'>like_selectivity</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>patt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>pattlen</span><span class='Delimiter'>, 
</span><a name="LN209"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>case_insensitive</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN210"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Prototype'>regex_selectivity</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>patt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>pattlen</span><span class='Delimiter'>, 
</span><a name="LN211"></a>                  <span class='Keyword'>bool </span><span class='Declare_Parameter'>case_insensitive</span><span class='Delimiter'>, 
</span><a name="LN212"></a>                  <span class='Keyword'>int </span><span class='Declare_Parameter'>fixed_prefix_len</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN213"></a><span class='Keyword'>static </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Prototype'>string_to_datum</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datatype</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN214"></a><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>string_to_const</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datatype</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN215"></a><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>string_to_bytea_const</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span>size_t <span class='Declare_Parameter'>str_len</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN216"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>add_predicate_to_quals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>index</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexQuals</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *      eqsel           - Selectivity of "=" for any data types. 
 * 
 * Note: this routine is also used to estimate selectivity for some 
 * operators that are not "=" but have comparable selectivity behavior, 
 * such as "~=" (geometric approximate-match).  Even for "=", we must 
 * keep in mind that the left and right datatypes may differ. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN228"></a><span class='Declare_Function'>eqsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN156"><span class='Ref_to_Proto'>eqsel_internal</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Common code for eqsel() and neqsel() 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN237"></a><span class='Declare_Function'>eqsel_internal</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN239"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN240"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>PG_GETARG_OID</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN241"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN242"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>varRelid</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN233"><span class='Ref_to_Macro'>PG_GETARG_INT32</span></a><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN243"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN244"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>other</span><span class='Delimiter'>; 
</span><a name="LN245"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>varonleft</span><span class='Delimiter'>; 
</span><a name="LN246"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When asked about &LT;&GT;, we do the estimation using the corresponding = 
     * operator, then convert to &LT;&GT; via "1.0 - eq_selectivity - nullfrac". 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN237"><span class='Ref_to_Parameter'>negate</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN254"></a>        <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>get_negator</span><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Use default selectivity (should we raise an error instead?) */ 
</span>            <span class='Control'>return</span> <span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="../../../include/utils/selfuncs.h.html#LN33"><span class='Ref_to_Const'>DEFAULT_EQ_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If expression is not variable = something or something = variable, then 
     * punt and return a default estimate. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/selfuncs.h.html#LN157"><span class='Ref_to_Proto'>get_restriction_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN239"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN241"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN242"><span class='Ref_To_Local'>varRelid</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="selfuncs.c.html#LN243"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN244"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN245"><span class='Ref_To_Local'>varonleft</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="selfuncs.c.html#LN237"><span class='Ref_to_Parameter'>negate</span></a> <span class='Operator'>? </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="../../../include/utils/selfuncs.h.html#LN33"><span class='Ref_to_Const'>DEFAULT_EQ_SEL</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="../../../include/utils/selfuncs.h.html#LN33"><span class='Ref_to_Const'>DEFAULT_EQ_SEL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can do a lot better if the something is a constant.  (Note: the 
     * Const might result from estimation rather than being a simple constant 
     * in the query.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN244"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <a href="selfuncs.c.html#LN246"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN157"><span class='Ref_to_Proto'>var_eq_const</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN243"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Keyword'>operator</span><span class='Delimiter'>, 
</span>                             <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN244"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>, 
</span>                             <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN244"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Delimiter'>, 
</span>                             <a href="selfuncs.c.html#LN245"><span class='Ref_To_Local'>varonleft</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN237"><span class='Ref_to_Parameter'>negate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN246"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN160"><span class='Ref_to_Proto'>var_eq_non_const</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN243"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Keyword'>operator</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN244"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, 
</span>                                 <a href="selfuncs.c.html#LN245"><span class='Ref_To_Local'>varonleft</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN237"><span class='Ref_to_Parameter'>negate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN243"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN246"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end eqsel_internal &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * var_eq_const --- eqsel for var = const case 
 * 
 * This is split out so that some other estimation functions can use it. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN295"></a><span class='Declare_Function'>var_eq_const</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN296"></a>             <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>constval</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>constisnull</span><span class='Delimiter'>, 
</span><a name="LN297"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>varonleft</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN299"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN300"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN301"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault</span><span class='Delimiter'>; 
</span><a name="LN302"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opfuncoid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the constant is NULL, assume operator is strict and return zero, ie, 
     * operator will never return TRUE.  (It's zero even for a negator op.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN296"><span class='Ref_to_Parameter'>constisnull</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Grab the nullfrac for use below.  Note we allow use of nullfrac 
     * regardless of security check. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN317"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN317"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN300"><span class='Ref_To_Local'>nullfrac</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN317"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we matched the var to a unique index or DISTINCT clause, assume 
     * there is exactly one match regardless of anything else.  (This is 
     * slightly bogus, since the index or clause's equality operator might be 
     * different from ours, but it's much more likely to be right than 
     * ignoring the information.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN76"><span class='Ref_to_Member'>isunique</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>             <a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, 
</span>                                         <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN302"><span class='Ref_To_Local'>opfuncoid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>))))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN338"></a>        <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span><a name="LN339"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>match</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN340"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Is the constant "=" to any of the column's most common values? 
         * (Although the given operator may not really be "=", we will assume 
         * that seeing whether it returns TRUE is an appropriate test.  If you 
         * don't like this, maybe you shouldn't be using eqsel for your 
         * operator...) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a> <span class='Operator'>| </span><a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN353"></a>            <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>eqproc</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN302"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN353"><span class='Ref_To_Local'>eqproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* be careful to apply operator right way 'round */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN297"><span class='Ref_to_Parameter'>varonleft</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN339"><span class='Ref_To_Local'>match</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN353"><span class='Ref_To_Local'>eqproc</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                                           <a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                                           <a href="selfuncs.c.html#LN296"><span class='Ref_to_Parameter'>constval</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="selfuncs.c.html#LN339"><span class='Ref_To_Local'>match</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN353"><span class='Ref_To_Local'>eqproc</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                                           <a href="selfuncs.c.html#LN296"><span class='Ref_to_Parameter'>constval</span></a><span class='Delimiter'>, 
</span>                                                           <a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN339"><span class='Ref_To_Local'>match</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if get_attstatsslot(&ssl... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* no most-common-value info available */ 
</span>            <a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN339"><span class='Ref_To_Local'>match</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Constant is "=" to this common value.  We know selectivity 
             * exactly (or as exactly as ANALYZE could calculate it, anyway). 
             */ 
</span>            <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Comparison is against a constant that is neither NULL nor any 
             * of the common values.  Its selectivity cannot be more than 
             * this: 
             */ 
</span><a name="LN395"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>sumcommon</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN396"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>otherdistinct</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN395"><span class='Ref_To_Local'>sumcommon</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN340"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN395"><span class='Ref_To_Local'>sumcommon</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN300"><span class='Ref_To_Local'>nullfrac</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * and in fact it's probably a good deal less. We approximate that 
             * all the not-common values share this remaining fraction 
             * equally, so we divide by the number of other distinct values. 
             */ 
</span>            <a href="selfuncs.c.html#LN396"><span class='Ref_To_Local'>otherdistinct</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN301"><span class='Ref_To_Local'>isdefault</span></a><span class='Parentheses'>) </span><span class='Operator'>- 
</span>                <a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN396"><span class='Ref_To_Local'>otherdistinct</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>/= </span><a href="selfuncs.c.html#LN396"><span class='Ref_To_Local'>otherdistinct</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Another cross-check: selectivity shouldn't be estimated as more 
             * than the least common "most common value". 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN338"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * No ANALYZE stats available, so make a guess using estimated number 
         * of distinct values and assuming they are equally common. (The guess 
         * is unlikely to be very good, but we do know a few special cases.) 
         */ 
</span>        <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN295"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN301"><span class='Ref_To_Local'>isdefault</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* now adjust if we wanted &LT;&GT; rather than = */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN297"><span class='Ref_to_Parameter'>negate</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN300"><span class='Ref_To_Local'>nullfrac</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* result should be in range, but make sure... */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN299"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end var_eq_const &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * var_eq_non_const --- eqsel for var = something-other-than-const case 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN447"></a><span class='Declare_Function'>var_eq_non_const</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN448"></a>                 <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>other</span><span class='Delimiter'>, 
</span><a name="LN449"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>varonleft</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN451"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN452"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN453"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Grab the nullfrac for use below. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN460"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN460"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN452"><span class='Ref_To_Local'>nullfrac</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN460"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we matched the var to a unique index or DISTINCT clause, assume 
     * there is exactly one match regardless of anything else.  (This is 
     * slightly bogus, since the index or clause's equality operator might be 
     * different from ours, but it's much more likely to be right than 
     * ignoring the information.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN76"><span class='Ref_to_Member'>isunique</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN479"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>ndistinct</span><span class='Delimiter'>; 
</span><a name="LN480"></a>        <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Search is for a value that we do not know a priori, but we will 
         * assume it is not NULL.  Estimate the selectivity as non-null 
         * fraction divided by number of distinct values, so that we get a 
         * result averaged over all possible values whether common or 
         * uncommon.  (Essentially, we are assuming that the not-yet-known 
         * comparison value is equally likely to be any of the possible 
         * values, regardless of their frequency in the table.  Is that a good 
         * idea?) 
         */ 
</span>        <a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN452"><span class='Ref_To_Local'>nullfrac</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN479"><span class='Ref_To_Local'>ndistinct</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN453"><span class='Ref_To_Local'>isdefault</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN479"><span class='Ref_To_Local'>ndistinct</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>/= </span><a href="selfuncs.c.html#LN479"><span class='Ref_To_Local'>ndistinct</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Cross-check: selectivity should never be estimated as more than the 
         * most common value's. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN480"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN480"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN480"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN480"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN480"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * No ANALYZE stats available, so make a guess using estimated number 
         * of distinct values and assuming they are equally common. (The guess 
         * is unlikely to be very good, but we do know a few special cases.) 
         */ 
</span>        <a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN447"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN453"><span class='Ref_To_Local'>isdefault</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* now adjust if we wanted &LT;&GT; rather than = */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN449"><span class='Ref_to_Parameter'>negate</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN452"><span class='Ref_To_Local'>nullfrac</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* result should be in range, but make sure... */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN451"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end var_eq_non_const &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      neqsel          - Selectivity of "!=" for any data types. 
 * 
 * This routine is also used for some operators that are not "!=" 
 * but have comparable selectivity behavior.  See above comments 
 * for eqsel(). 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN538"></a><span class='Declare_Function'>neqsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN156"><span class='Ref_to_Proto'>eqsel_internal</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  scalarineqsel       - Selectivity of "&LT;", "&LT;=", "&GT;", "&GT;=" for scalars. 
 * 
 * This is the guts of both scalarltsel and scalargtsel.  The caller has 
 * commuted the clause, if necessary, so that we can treat the variable as 
 * being on the left.  The caller must also make sure that the other side 
 * of the clause is a non-null Const, and dissect same into a value and 
 * datatype. 
 * 
 * This routine works for any datatype (or pair of datatypes) known to 
 * convert_to_scalar().  If it is applied to some other datatype, 
 * it will return a default estimate. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN557"></a><span class='Declare_Function'>scalarineqsel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isgt</span><span class='Delimiter'>, 
</span><a name="LN558"></a>              <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>constval</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>consttype</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN560"></a>    <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span><a name="LN561"></a>    <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>opproc</span><span class='Delimiter'>; 
</span><a name="LN562"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>mcv_selec</span><span class='Delimiter'>, 
</span><a name="LN563"></a>                <span class='Declare_Local'>hist_selec</span><span class='Delimiter'>, 
</span><a name="LN564"></a>                <span class='Declare_Local'>sumcommon</span><span class='Delimiter'>; 
</span><a name="LN565"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN558"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* no stats available, so default result */ 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="selfuncs.c.html#LN560"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN558"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN561"><span class='Ref_To_Local'>opproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have most-common-values info, add up the fractions of the MCV 
     * entries that satisfy MCV OP CONST.  These fractions contribute directly 
     * to the result selectivity.  Also add up the total fraction represented 
     * by MCV entries. 
     */ 
</span>    <a href="selfuncs.c.html#LN562"><span class='Ref_To_Local'>mcv_selec</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN168"><span class='Ref_to_Proto'>mcv_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN558"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN561"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN558"><span class='Ref_to_Parameter'>constval</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="selfuncs.c.html#LN564"><span class='Ref_To_Local'>sumcommon</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is a histogram, determine which bin the constant falls in, and 
     * compute the resulting contribution to selectivity. 
     */ 
</span>    <a href="selfuncs.c.html#LN563"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN163"><span class='Ref_to_Proto'>ineq_histogram_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN557"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN558"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN561"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN557"><span class='Ref_to_Parameter'>isgt</span></a><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN558"><span class='Ref_to_Parameter'>constval</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN558"><span class='Ref_to_Parameter'>consttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now merge the results from the MCV and histogram calculations, 
     * realizing that the histogram covers only the non-null values that are 
     * not listed in MCV. 
     */ 
</span>    <a href="selfuncs.c.html#LN565"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN560"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac <span class='Operator'>- </span><a href="selfuncs.c.html#LN564"><span class='Ref_To_Local'>sumcommon</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN563"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN565"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN563"><span class='Ref_To_Local'>hist_selec</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If no histogram but there are values not accounted for by MCV, 
         * arbitrarily assume half of them will match. 
         */ 
</span>        <a href="selfuncs.c.html#LN565"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>*= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="selfuncs.c.html#LN565"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN562"><span class='Ref_To_Local'>mcv_selec</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* result should be in range, but make sure... */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN565"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN565"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end scalarineqsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  mcv_selectivity         - Examine the MCV list for selectivity estimates 
 * 
 * Determine the fraction of the variable's MCV population that satisfies 
 * the predicate (VAR OP CONST), or (CONST OP VAR) if !varonleft.  Also 
 * compute the fraction of the total column population represented by the MCV 
 * list.  This code will work for any boolean-returning predicate operator. 
 * 
 * The function result is the MCV selectivity, and the fraction of the 
 * total population is returned into *sumcommonp.  Zeroes are returned 
 * if there is no MCV list. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN631"></a><span class='Declare_Function'>mcv_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>opproc</span><span class='Delimiter'>, 
</span><a name="LN632"></a>                <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>constval</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>varonleft</span><span class='Delimiter'>, 
</span><a name="LN633"></a>                <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>sumcommonp</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN635"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>mcv_selec</span><span class='Delimiter'>, 
</span><a name="LN636"></a>                <span class='Declare_Local'>sumcommon</span><span class='Delimiter'>; 
</span><a name="LN637"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span><a name="LN638"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN635"><span class='Ref_To_Local'>mcv_selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN636"><span class='Ref_To_Local'>sumcommon</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN631"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN631"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN631"><span class='Ref_to_Parameter'>opproc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN58"><span class='Ref_to_Member'>fn_oid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN637"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN631"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a> <span class='Operator'>| </span><a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN638"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN638"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN637"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN638"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN632"><span class='Ref_to_Parameter'>varonleft</span></a> <span class='Operator'>? 
</span>                <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN631"><span class='Ref_to_Parameter'>opproc</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN637"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN638"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                               <a href="selfuncs.c.html#LN632"><span class='Ref_to_Parameter'>constval</span></a><span class='Parentheses'>))</span> <span class='Operator'>: 
</span>                <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN631"><span class='Ref_to_Parameter'>opproc</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN632"><span class='Ref_to_Parameter'>constval</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN637"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN638"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span> 
                <a href="selfuncs.c.html#LN635"><span class='Ref_To_Local'>mcv_selec</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN637"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN638"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="selfuncs.c.html#LN636"><span class='Ref_To_Local'>sumcommon</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN637"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN638"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN637"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN633"><span class='Ref_to_Parameter'>sumcommonp</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN636"><span class='Ref_To_Local'>sumcommon</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN635"><span class='Ref_To_Local'>mcv_selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end mcv_selectivity &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  histogram_selectivity   - Examine the histogram for selectivity estimates 
 * 
 * Determine the fraction of the variable's histogram entries that satisfy 
 * the predicate (VAR OP CONST), or (CONST OP VAR) if !varonleft. 
 * 
 * This code will work for any boolean-returning predicate operator, whether 
 * or not it has anything to do with the histogram sort operator.  We are 
 * essentially using the histogram just as a representative sample.  However, 
 * small histograms are unlikely to be all that representative, so the caller 
 * should be prepared to fall back on some other estimation approach when the 
 * histogram is missing or very small.  It may also be prudent to combine this 
 * approach with another one when the histogram is small. 
 * 
 * If the actual histogram size is not at least min_hist_size, we won't bother 
 * to do the calculation at all.  Also, if the n_skip parameter is &GT; 0, we 
 * ignore the first and last n_skip histogram elements, on the grounds that 
 * they are outliers and hence not very representative.  Typical values for 
 * these parameters are 10 and 1. 
 * 
 * The function result is the selectivity, or -1 if there is no histogram 
 * or it's smaller than min_hist_size. 
 * 
 * The output parameter *hist_size receives the actual histogram size, 
 * or zero if no histogram.  Callers may use this number to decide how 
 * much faith to put in the function result. 
 * 
 * Note that the result disregards both the most-common-values (if any) and 
 * null entries.  The caller is expected to combine this result with 
 * statistics for those portions of the column population.  It may also be 
 * prudent to clamp the result range, ie, disbelieve exact 0 or 1 outputs. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN703"></a><span class='Declare_Function'>histogram_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>opproc</span><span class='Delimiter'>, 
</span><a name="LN704"></a>                      <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>constval</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>varonleft</span><span class='Delimiter'>, 
</span><a name="LN705"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>min_hist_size</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>n_skip</span><span class='Delimiter'>, 
</span><a name="LN706"></a>                      <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>hist_size</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN708"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN709"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check sanity of parameters */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN705"><span class='Ref_to_Parameter'>n_skip</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN705"><span class='Ref_to_Parameter'>min_hist_size</span></a> <span class='Operator'>&GT; </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="selfuncs.c.html#LN705"><span class='Ref_to_Parameter'>n_skip</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN703"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN703"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN703"><span class='Ref_to_Parameter'>opproc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN58"><span class='Ref_to_Member'>fn_oid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN703"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/catalog/pg_statistic.h.html#LN221"><span class='Ref_to_Const'>STATISTIC_KIND_HISTOGRAM</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN706"><span class='Ref_to_Parameter'>hist_size</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN705"><span class='Ref_to_Parameter'>min_hist_size</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN724"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>nmatch</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN725"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN725"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN705"><span class='Ref_to_Parameter'>n_skip</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN725"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN705"><span class='Ref_to_Parameter'>n_skip</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN725"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN704"><span class='Ref_to_Parameter'>varonleft</span></a> <span class='Operator'>? 
</span>                    <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN703"><span class='Ref_to_Parameter'>opproc</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                                   <a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN725"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                                   <a href="selfuncs.c.html#LN704"><span class='Ref_to_Parameter'>constval</span></a><span class='Parentheses'>))</span> <span class='Operator'>: 
</span>                    <a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN703"><span class='Ref_to_Parameter'>opproc</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                                   <a href="selfuncs.c.html#LN704"><span class='Ref_to_Parameter'>constval</span></a><span class='Delimiter'>, 
</span>                                                   <a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN725"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span> 
                    <a href="selfuncs.c.html#LN724"><span class='Ref_To_Local'>nmatch</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="selfuncs.c.html#LN708"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN724"><span class='Ref_To_Local'>nmatch</span></a><span class='Parentheses'>)</span> <span class='Operator'>/ </span><span class='Parentheses'>((</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>- </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="selfuncs.c.html#LN705"><span class='Ref_to_Parameter'>n_skip</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sslot.nvalues&GT;=min_hi... &raquo; </span> 
        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN708"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN709"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN706"><span class='Ref_to_Parameter'>hist_size</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN708"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN708"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end histogram_selectivity &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  ineq_histogram_selectivity  - Examine the histogram for scalarineqsel 
 * 
 * Determine the fraction of the variable's histogram population that 
 * satisfies the inequality condition, ie, VAR &LT; CONST or VAR &GT; CONST. 
 * 
 * Returns -1 if there is no histogram (valid results will always be &GT;= 0). 
 * 
 * Note that the result disregards both the most-common-values (if any) and 
 * null entries.  The caller is expected to combine this result with 
 * statistics for those portions of the column population. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN768"></a><span class='Declare_Function'>ineq_histogram_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN769"></a>                           <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, 
</span><a name="LN770"></a>                           <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>opproc</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isgt</span><span class='Delimiter'>, 
</span><a name="LN771"></a>                           <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>constval</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>consttype</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN773"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>hist_selec</span><span class='Delimiter'>; 
</span><a name="LN774"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Someday, ANALYZE might store more than one histogram per rel/att, 
     * corresponding to more than one possible sort ordering defined for the 
     * column type.  However, to make that work we will need to figure out 
     * which staop to search for --- it's not necessarily the one we have at 
     * hand!  (For example, we might have a '&LT;=' operator rather than the '&LT;' 
     * operator that will appear in staop.)  For now, assume that whatever 
     * appears in pg_statistic is sorted the same way our operator sorts, or 
     * the reverse way if isgt is TRUE. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN769"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN769"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN770"><span class='Ref_to_Parameter'>opproc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN58"><span class='Ref_to_Member'>fn_oid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN769"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/catalog/pg_statistic.h.html#LN221"><span class='Ref_to_Const'>STATISTIC_KIND_HISTOGRAM</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Use binary search to find proper location, ie, the first slot 
             * at which the comparison fails.  (If the given operator isn't 
             * actually sort-compatible with the histogram, you'll get garbage 
             * results ... but probably not any more garbage-y than you would 
             * from the old linear search.) 
             * 
             * If the binary search accesses the first or last histogram 
             * entry, we try to replace that endpoint with the true column min 
             * or max as found by get_actual_variable_range().  This 
             * ameliorates misestimates when the min or max is moving as a 
             * result of changes since the last ANALYZE.  Note that this could 
             * result in effectively including MCVs into the histogram that 
             * weren't there before, but we don't try to correct for that. 
             */ 
</span><a name="LN811"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>histfrac</span><span class='Delimiter'>; 
</span><a name="LN812"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>lobound</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* first possible slot to search */ 
</span><a name="LN813"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>hibound</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* last+1 slot to search */ 
</span><a name="LN814"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_end</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If there are only two histogram entries, we'll want up-to-date 
             * values for both.  (If there are more than two, we need at most 
             * one of them to be updated, so we deal with that within the 
             * loop.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>== </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN814"><span class='Ref_To_Local'>have_end</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN200"><span class='Ref_to_Proto'>get_actual_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN768"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                     <a href="selfuncs.c.html#LN769"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, 
</span>                                                     <a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN45"><span class='Ref_to_Member'>staop</span></a><span class='Delimiter'>, 
</span>                                                     <span class='Operator'>&</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                                     <span class='Operator'>&</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN812"><span class='Ref_To_Local'>lobound</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN813"><span class='Ref_To_Local'>hibound</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN831"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>probe</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN812"><span class='Ref_To_Local'>lobound</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN813"><span class='Ref_To_Local'>hibound</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Delimiter'>; 
</span><a name="LN832"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>ltcmp</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If we find ourselves about to compare to the first or last 
                 * histogram entry, first try to replace it with the actual 
                 * current min or max (unless we already did so above). 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN831"><span class='Ref_To_Local'>probe</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>&GT; </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN814"><span class='Ref_To_Local'>have_end</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN200"><span class='Ref_to_Proto'>get_actual_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN768"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                         <a href="selfuncs.c.html#LN769"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, 
</span>                                                         <a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN45"><span class='Ref_to_Member'>staop</span></a><span class='Delimiter'>, 
</span>                                                         <span class='Operator'>&</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                                         <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN831"><span class='Ref_To_Local'>probe</span></a> <span class='Operator'>== </span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>- </span><span class='Number'>1</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>&GT; </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN814"><span class='Ref_To_Local'>have_end</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN200"><span class='Ref_to_Proto'>get_actual_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN768"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                         <a href="selfuncs.c.html#LN769"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, 
</span>                                                         <a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN45"><span class='Ref_to_Member'>staop</span></a><span class='Delimiter'>, 
</span>                                                         <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                       <span class='Operator'>&</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN831"><span class='Ref_To_Local'>probe</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="selfuncs.c.html#LN832"><span class='Ref_To_Local'>ltcmp</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN770"><span class='Ref_to_Parameter'>opproc</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                                       <a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN831"><span class='Ref_To_Local'>probe</span></a><span class='Delimiter'>], 
</span>                                                       <a href="selfuncs.c.html#LN771"><span class='Ref_to_Parameter'>constval</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN770"><span class='Ref_to_Parameter'>isgt</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN832"><span class='Ref_To_Local'>ltcmp</span></a> <span class='Operator'>= !</span><a href="selfuncs.c.html#LN832"><span class='Ref_To_Local'>ltcmp</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN832"><span class='Ref_To_Local'>ltcmp</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN812"><span class='Ref_To_Local'>lobound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN831"><span class='Ref_To_Local'>probe</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="selfuncs.c.html#LN813"><span class='Ref_To_Local'>hibound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN831"><span class='Ref_To_Local'>probe</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while lobound&LT;hibound &raquo; </span> 
 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN812"><span class='Ref_To_Local'>lobound</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Constant is below lower histogram boundary. */ 
</span>                <a href="selfuncs.c.html#LN811"><span class='Ref_To_Local'>histfrac</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN812"><span class='Ref_To_Local'>lobound</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Constant is above upper histogram boundary. */ 
</span>                <a href="selfuncs.c.html#LN811"><span class='Ref_To_Local'>histfrac</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span><a name="LN876"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN812"><span class='Ref_To_Local'>lobound</span></a><span class='Delimiter'>; 
</span><a name="LN877"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>val</span><span class='Delimiter'>, 
</span><a name="LN878"></a>                            <span class='Declare_Local'>high</span><span class='Delimiter'>, 
</span><a name="LN879"></a>                            <span class='Declare_Local'>low</span><span class='Delimiter'>; 
</span><a name="LN880"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>binfrac</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We have values[i-1] &LT;= constant &LT;= values[i]. 
                 * 
                 * Convert the constant and the two nearest bin boundary 
                 * values to a uniform comparison scale, and do a linear 
                 * interpolation within this bin. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN174"><span class='Ref_to_Proto'>convert_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN771"><span class='Ref_to_Parameter'>constval</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN771"><span class='Ref_to_Parameter'>consttype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN877"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>, 
</span>                                      <a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN876"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN876"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                      <a href="selfuncs.c.html#LN769"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN73"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="selfuncs.c.html#LN879"><span class='Ref_To_Local'>low</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN878"><span class='Ref_To_Local'>high</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN878"><span class='Ref_To_Local'>high</span></a> <span class='Operator'>&LT;= </span><a href="selfuncs.c.html#LN879"><span class='Ref_To_Local'>low</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* cope if bin boundaries appear identical */ 
</span>                        <a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN877"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>&LT;= </span><a href="selfuncs.c.html#LN879"><span class='Ref_To_Local'>low</span></a><span class='Parentheses'>) 
</span>                        <a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN877"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN878"><span class='Ref_To_Local'>high</span></a><span class='Parentheses'>) 
</span>                        <a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN877"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN879"><span class='Ref_To_Local'>low</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN878"><span class='Ref_To_Local'>high</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN879"><span class='Ref_To_Local'>low</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * Watch out for the possibility that we got a NaN or 
                         * Infinity from the division.  This can happen 
                         * despite the previous checks, if for example "low" 
                         * is -Infinity. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/test/expected/pgtypeslib-nan_test.c.html#LN30"><span class='Ref_to_Macro'>isnan</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                            <a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                            <a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if convert_to_scalar(con... &raquo; </span> 
                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Ideally we'd produce an error here, on the grounds that 
                     * the given operator shouldn't have scalarXXsel 
                     * registered as its selectivity func unless we can deal 
                     * with its operand types.  But currently, all manner of 
                     * stuff is invoking scalarXXsel, so give a default 
                     * estimate until that can be fixed. 
                     */ 
</span>                    <a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Now, compute the overall selectivity across the values 
                 * represented by the histogram.  We have i-1 full bins and 
                 * binfrac partial bin below the constant. 
                 */ 
</span>                <a href="selfuncs.c.html#LN811"><span class='Ref_To_Local'>histfrac</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN876"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="selfuncs.c.html#LN880"><span class='Ref_To_Local'>binfrac</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN811"><span class='Ref_To_Local'>histfrac</span></a> <span class='Operator'>/= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Now histfrac = fraction of histogram entries below the 
             * constant. 
             * 
             * Account for "&LT;" vs "&GT;" 
             */ 
</span>            <a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN770"><span class='Ref_to_Parameter'>isgt</span></a> <span class='Operator'>? </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN811"><span class='Ref_To_Local'>histfrac</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="selfuncs.c.html#LN811"><span class='Ref_To_Local'>histfrac</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The histogram boundaries are only approximate to begin with, 
             * and may well be out of date anyway.  Therefore, don't believe 
             * extremely small or large selectivity estimates --- unless we 
             * got actual current endpoint values from the table. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN814"><span class='Ref_To_Local'>have_end</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0001</span><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0001</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>9999</span><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>9999</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sslot.nvalues&GT;1 &raquo; </span> 
 
        <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN774"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN773"><span class='Ref_To_Local'>hist_selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ineq_histogram_selectivity &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      scalarltsel     - Selectivity of "&LT;" (also "&LT;=") for scalars. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN975"></a><span class='Declare_Function'>scalarltsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN977"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN978"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>PG_GETARG_OID</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN979"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN980"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>varRelid</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN233"><span class='Ref_to_Macro'>PG_GETARG_INT32</span></a><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN981"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN982"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>other</span><span class='Delimiter'>; 
</span><a name="LN983"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>varonleft</span><span class='Delimiter'>; 
</span><a name="LN984"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>constval</span><span class='Delimiter'>; 
</span><a name="LN985"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>consttype</span><span class='Delimiter'>; 
</span><a name="LN986"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isgt</span><span class='Delimiter'>; 
</span><a name="LN987"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If expression is not variable op something or something op variable, 
     * then punt and return a default estimate. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/selfuncs.h.html#LN157"><span class='Ref_to_Proto'>get_restriction_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN977"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN979"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN980"><span class='Ref_To_Local'>varRelid</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="selfuncs.c.html#LN981"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN982"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN983"><span class='Ref_To_Local'>varonleft</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Can't do anything useful if the something is not a constant, either. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN982"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN981"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the constant is NULL, assume operator is strict and return zero, ie, 
     * operator will never return TRUE. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN982"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN981"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="selfuncs.c.html#LN984"><span class='Ref_To_Local'>constval</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN982"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN985"><span class='Ref_To_Local'>consttype</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN982"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>consttype<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Force the var to be on the left to simplify logic in scalarineqsel. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN983"><span class='Ref_To_Local'>varonleft</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* we have var &LT; other */ 
</span>        <a href="selfuncs.c.html#LN986"><span class='Ref_To_Local'>isgt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* we have other &LT; var, commute to make var &GT; other */ 
</span><a name="LN1029"></a>        <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>get_commutator</span><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Keyword'>operator</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Use default selectivity (should we raise an error instead?) */ 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN981"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="selfuncs.c.html#LN986"><span class='Ref_To_Local'>isgt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="selfuncs.c.html#LN987"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN556"><span class='Ref_to_Func'>scalarineqsel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN977"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Keyword'>operator</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN986"><span class='Ref_To_Local'>isgt</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN981"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN984"><span class='Ref_To_Local'>constval</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN985"><span class='Ref_To_Local'>consttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN981"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN987"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end scalarltsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      scalargtsel     - Selectivity of "&GT;" (also "&GT;=") for integers. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1050"></a><span class='Declare_Function'>scalargtsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1052"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1053"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>PG_GETARG_OID</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1054"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1055"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>varRelid</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN233"><span class='Ref_to_Macro'>PG_GETARG_INT32</span></a><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1056"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN1057"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>other</span><span class='Delimiter'>; 
</span><a name="LN1058"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>varonleft</span><span class='Delimiter'>; 
</span><a name="LN1059"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>constval</span><span class='Delimiter'>; 
</span><a name="LN1060"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>consttype</span><span class='Delimiter'>; 
</span><a name="LN1061"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isgt</span><span class='Delimiter'>; 
</span><a name="LN1062"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If expression is not variable op something or something op variable, 
     * then punt and return a default estimate. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/selfuncs.h.html#LN157"><span class='Ref_to_Proto'>get_restriction_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1052"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1054"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1055"><span class='Ref_To_Local'>varRelid</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="selfuncs.c.html#LN1056"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1057"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1058"><span class='Ref_To_Local'>varonleft</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Can't do anything useful if the something is not a constant, either. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1057"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1056"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the constant is NULL, assume operator is strict and return zero, ie, 
     * operator will never return TRUE. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1057"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1056"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="selfuncs.c.html#LN1059"><span class='Ref_To_Local'>constval</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1057"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN1060"><span class='Ref_To_Local'>consttype</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1057"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>consttype<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Force the var to be on the left to simplify logic in scalarineqsel. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1058"><span class='Ref_To_Local'>varonleft</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* we have var &GT; other */ 
</span>        <a href="selfuncs.c.html#LN1061"><span class='Ref_To_Local'>isgt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* we have other &GT; var, commute to make var &LT; other */ 
</span><a name="LN1104"></a>        <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>get_commutator</span><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Keyword'>operator</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Use default selectivity (should we raise an error instead?) */ 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1056"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="selfuncs.c.html#LN1061"><span class='Ref_To_Local'>isgt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="selfuncs.c.html#LN1062"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN556"><span class='Ref_to_Func'>scalarineqsel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1052"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Keyword'>operator</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1061"><span class='Ref_To_Local'>isgt</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1056"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1059"><span class='Ref_To_Local'>constval</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1060"><span class='Ref_To_Local'>consttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1056"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1062"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end scalargtsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * patternsel           - Generic code for pattern-match selectivity. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN1125"></a><span class='Declare_Function'>patternsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN87"><span class='Ref_to_Typedef'>Pattern_Type</span></a> <span class='Declare_Parameter'>ptype</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1127"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1128"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>PG_GETARG_OID</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1129"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1130"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>varRelid</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN233"><span class='Ref_to_Macro'>PG_GETARG_INT32</span></a><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1131"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>collation</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN162"><span class='Ref_to_Macro'>PG_GET_COLLATION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><a name="LN1132"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN1133"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>other</span><span class='Delimiter'>; 
</span><a name="LN1134"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>varonleft</span><span class='Delimiter'>; 
</span><a name="LN1135"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>constval</span><span class='Delimiter'>; 
</span><a name="LN1136"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>consttype</span><span class='Delimiter'>; 
</span><a name="LN1137"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>vartype</span><span class='Delimiter'>; 
</span><a name="LN1138"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opfamily</span><span class='Delimiter'>; 
</span><a name="LN1139"></a>    <a href="../../../include/utils/selfuncs.h.html#LN93"><span class='Ref_to_Typedef'>Pattern_Prefix_Status</span></a> <span class='Declare_Local'>pstatus</span><span class='Delimiter'>; 
</span><a name="LN1140"></a>    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>patt</span><span class='Delimiter'>; 
</span><a name="LN1141"></a>    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>prefix</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1142"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>rest_selec</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1143"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1144"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this is for a NOT LIKE or similar operator, get the corresponding 
     * positive-match operator and work with that.  Set result to the correct 
     * default estimate, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1125"><span class='Ref_to_Parameter'>negate</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1153"></a>        <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>get_negator</span><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>))</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"patternsel called for operator without a negator"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="../../../include/utils/selfuncs.h.html#LN42"><span class='Ref_to_Const'>DEFAULT_MATCH_SEL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN42"><span class='Ref_to_Const'>DEFAULT_MATCH_SEL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If expression is not variable op constant, then punt and return a 
     * default estimate. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/selfuncs.h.html#LN157"><span class='Ref_to_Proto'>get_restriction_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1127"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1129"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1130"><span class='Ref_To_Local'>varRelid</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1133"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1134"><span class='Ref_To_Local'>varonleft</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN1134"><span class='Ref_To_Local'>varonleft</span></a> <span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1133"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the constant is NULL, assume operator is strict and return zero, ie, 
     * operator will never return TRUE.  (It's zero even for a negator op.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1133"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="selfuncs.c.html#LN1135"><span class='Ref_To_Local'>constval</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1133"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN1136"><span class='Ref_To_Local'>consttype</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1133"><span class='Ref_To_Local'>other</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>consttype<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The right-hand const is type text or bytea for all supported operators. 
     * We do not expect to see binary-compatible types here, since 
     * const-folding should have relabeled the const to exactly match the 
     * operator's declared type. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1136"><span class='Ref_To_Local'>consttype</span></a> <span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN1136"><span class='Ref_To_Local'>consttype</span></a> <span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Similarly, the exposed type of the left-hand side should be one of 
     * those we know.  (Do not look at vardata.atttype, which might be 
     * something binary-compatible but different.)  We can use it to choose 
     * the index opfamily from which we must draw the comparison operators. 
     * 
     * NOTE: It would be more correct to use the PATTERN opfamilies than the 
     * simple ones, but at the moment ANALYZE will not generate statistics for 
     * the PATTERN operators.  But our results are so approximate anyway that 
     * it probably hardly matters. 
     */ 
</span>    <a href="selfuncs.c.html#LN1137"><span class='Ref_To_Local'>vartype</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN73"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1137"><span class='Ref_To_Local'>vartype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN1138"><span class='Ref_To_Local'>opfamily</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_opfamily.h.html#LN104"><span class='Ref_to_Const'>TEXT_BTREE_FAM_OID</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN48"><span class='Ref_to_Const'>BPCHAROID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN1138"><span class='Ref_To_Local'>opfamily</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_opfamily.h.html#LN67"><span class='Ref_to_Const'>BPCHAR_BTREE_FAM_OID</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN20"><span class='Ref_to_Const'>NAMEOID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN1138"><span class='Ref_To_Local'>opfamily</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_opfamily.h.html#LN92"><span class='Ref_to_Const'>NAME_BTREE_FAM_OID</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN1138"><span class='Ref_To_Local'>opfamily</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_opfamily.h.html#LN70"><span class='Ref_to_Const'>BYTEA_BTREE_FAM_OID</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Grab the nullfrac for use below. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1237"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN1237"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1143"><span class='Ref_To_Local'>nullfrac</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1237"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Pull out any fixed prefix implied by the pattern, and estimate the 
     * fractional selectivity of the remainder of the pattern.  Unlike many of 
     * the other functions in this file, we use the pattern operator's actual 
     * collation for this step.  This is not because we expect the collation 
     * to make a big difference in the selectivity estimate (it seldom would), 
     * but because we want to be sure we cache compiled regexps under the 
     * right cache key, so that they can be re-used at runtime. 
     */ 
</span>    <a href="selfuncs.c.html#LN1140"><span class='Ref_To_Local'>patt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1133"><span class='Ref_To_Local'>other</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN1139"><span class='Ref_To_Local'>pstatus</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN176"><span class='Ref_to_Proto'>pattern_fixed_prefix</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1140"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1125"><span class='Ref_to_Parameter'>ptype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1131"><span class='Ref_To_Local'>collation</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>&</span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1142"><span class='Ref_To_Local'>rest_selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If necessary, coerce the prefix constant to the right type. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a> <span class='Operator'>!= </span><a href="selfuncs.c.html#LN1137"><span class='Ref_To_Local'>vartype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1261"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>prefixstr</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1261"><span class='Ref_To_Local'>prefixstr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1261"><span class='Ref_To_Local'>prefixstr</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN571"><span class='Ref_to_Macro'>DatumGetCString</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN583"><span class='Ref_to_Macro'>DirectFunctionCall1</span></a><span class='Parentheses'>(</span><a href="varlena.c.html#LN349"><span class='Ref_to_Func'>byteaout</span></a><span class='Delimiter'>, 
</span>                                                        <a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized consttype: %u"</span><span class='Delimiter'>, 
</span>                     <a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/indxpath.c.html#LN190"><span class='Ref_to_Proto'>string_to_const</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1261"><span class='Ref_To_Local'>prefixstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1137"><span class='Ref_To_Local'>vartype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1261"><span class='Ref_To_Local'>prefixstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if prefix&&prefix-&GT;const... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1139"><span class='Ref_To_Local'>pstatus</span></a> <span class='Operator'>== </span><a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_Exact</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Pattern specifies an exact match, so pretend operator is '=' 
         */ 
</span><a name="LN1287"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eqopr</span> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1138"><span class='Ref_To_Local'>opfamily</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1137"><span class='Ref_To_Local'>vartype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1137"><span class='Ref_To_Local'>vartype</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1287"><span class='Ref_To_Local'>eqopr</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no = operator for opfamily %u"</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1138"><span class='Ref_To_Local'>opfamily</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN157"><span class='Ref_to_Proto'>var_eq_const</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1287"><span class='Ref_To_Local'>eqopr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>, 
</span>                              <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Not exact-match pattern.  If we have a sufficiently large 
         * histogram, estimate selectivity for the histogram part of the 
         * population by counting matches in the histogram.  If not, estimate 
         * selectivity of the fixed prefix and remainder of pattern 
         * separately, then combine the two to get an estimate of the 
         * selectivity for the part of the column population represented by 
         * the histogram.  (For small histograms, we combine these 
         * approaches.) 
         * 
         * We then add up data for any most-common-values values; these are 
         * not in the histogram population, and we can get exact answers for 
         * them by applying the pattern operator, so there's no reason to 
         * approximate.  (If the MCVs cover a significant part of the total 
         * population, this gives us a big leg up in accuracy.) 
         */ 
</span><a name="LN1313"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN1314"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>hist_size</span><span class='Delimiter'>; 
</span><a name="LN1315"></a>        <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>opproc</span><span class='Delimiter'>; 
</span><a name="LN1316"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>mcv_selec</span><span class='Delimiter'>, 
</span><a name="LN1317"></a>                    <span class='Declare_Local'>sumcommon</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Try to use the histogram entries to get selectivity */ 
</span>        <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1315"><span class='Ref_To_Local'>opproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN171"><span class='Ref_to_Proto'>histogram_selectivity</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1315"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1135"><span class='Ref_To_Local'>constval</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                      <span class='Number'>10</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1314"><span class='Ref_To_Local'>hist_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If not at least 100 entries, use the heuristic method */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1314"><span class='Ref_To_Local'>hist_size</span></a> <span class='Operator'>&LT; </span><span class='Number'>100</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1328"></a>            <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>heursel</span><span class='Delimiter'>; 
</span><a name="LN1329"></a>            <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>prefixsel</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1139"><span class='Ref_To_Local'>pstatus</span></a> <span class='Operator'>== </span><a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_Partial</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN1329"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN205"><span class='Ref_to_Proto'>prefix_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1127"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1137"><span class='Ref_To_Local'>vartype</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN1138"><span class='Ref_To_Local'>opfamily</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN1329"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN1328"><span class='Ref_To_Local'>heursel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1329"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN1142"><span class='Ref_To_Local'>rest_selec</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* fewer than 10 histogram entries? */ 
</span>                <a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1328"><span class='Ref_To_Local'>heursel</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * For histogram sizes from 10 to 100, we combine the 
                 * histogram and heuristic selectivities, putting increasingly 
                 * more trust in the histogram for larger sizes. 
                 */ 
</span><a name="LN1347"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>hist_weight</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1314"><span class='Ref_To_Local'>hist_size</span></a> <span class='Operator'>/ </span><span class='Number'>100</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN1347"><span class='Ref_To_Local'>hist_weight</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN1328"><span class='Ref_To_Local'>heursel</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1347"><span class='Ref_To_Local'>hist_weight</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if hist_size&LT;100 &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* In any case, don't believe extremely small or large estimates. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0001</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0001</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>9999</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>9999</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have most-common-values info, add up the fractions of the MCV 
         * entries that satisfy MCV OP PATTERN.  These fractions contribute 
         * directly to the result selectivity.  Also add up the total fraction 
         * represented by MCV entries. 
         */ 
</span>        <a href="selfuncs.c.html#LN1316"><span class='Ref_To_Local'>mcv_selec</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN168"><span class='Ref_to_Proto'>mcv_selectivity</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1315"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1135"><span class='Ref_To_Local'>constval</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><a href="selfuncs.c.html#LN1317"><span class='Ref_To_Local'>sumcommon</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now merge the results from the MCV and histogram calculations, 
         * realizing that the histogram covers only the non-null values that 
         * are not listed in MCV. 
         */ 
</span>        <a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>*= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1143"><span class='Ref_To_Local'>nullfrac</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1317"><span class='Ref_To_Local'>sumcommon</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN1316"><span class='Ref_To_Local'>mcv_selec</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1313"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* now adjust if we wanted not-match rather than match */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1125"><span class='Ref_to_Parameter'>negate</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1143"><span class='Ref_To_Local'>nullfrac</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* result should be in range, but make sure... */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1141"><span class='Ref_To_Local'>prefix</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1132"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN1144"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end patternsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      regexeqsel      - Selectivity of regular-expression pattern match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1400"></a><span class='Declare_Function'>regexeqsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      icregexeqsel    - Selectivity of case-insensitive regex match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1409"></a><span class='Declare_Function'>icregexeqsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      likesel         - Selectivity of LIKE pattern match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1418"></a><span class='Declare_Function'>likesel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      iclikesel           - Selectivity of ILIKE pattern match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1427"></a><span class='Declare_Function'>iclikesel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      regexnesel      - Selectivity of regular-expression pattern non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1436"></a><span class='Declare_Function'>regexnesel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      icregexnesel    - Selectivity of case-insensitive regex non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1445"></a><span class='Declare_Function'>icregexnesel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      nlikesel        - Selectivity of LIKE pattern non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1454"></a><span class='Declare_Function'>nlikesel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      icnlikesel      - Selectivity of ILIKE pattern non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1463"></a><span class='Declare_Function'>icnlikesel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1124"><span class='Ref_to_Func'>patternsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      boolvarsel      - Selectivity of Boolean variable. 
 * 
 * This can actually be called on any boolean-valued expression.  If it 
 * involves only Vars of the specified relation, and if there are statistics 
 * about the Var or expression (the latter is possible if it's indexed) then 
 * we'll produce a real estimate; otherwise it's just a default. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN1477"></a><span class='Declare_Function'>boolvarsel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>varRelid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1479"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN1480"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1477"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1477"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1477"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1479"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1479"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * A boolean variable V is equivalent to the clause V = 't', so we 
         * compute the selectivity as if that is what we have. 
         */ 
</span>        <a href="selfuncs.c.html#LN1480"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN157"><span class='Ref_to_Proto'>var_eq_const</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1479"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_operator.h.html#LN113"><span class='Ref_to_Const'>BooleanEqualOperator</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN20"><span class='Ref_to_Macro'>is_funcclause</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1477"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we have no stats and it's a function call, estimate 0.3333333. 
         * This seems a pretty unprincipled choice, but Postgres has been 
         * using that estimate for function calls since 1992.  The hoariness 
         * of this behavior suggests that we should not be in too much hurry 
         * to use another value. 
         */ 
</span>        <a href="selfuncs.c.html#LN1480"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>3333333</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Otherwise, the default estimate is 0.5 */ 
</span>        <a href="selfuncs.c.html#LN1480"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1479"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN1480"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end boolvarsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      booltestsel     - Selectivity of BooleanTest Node. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN1516"></a><span class='Declare_Function'>booltestsel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1193"><span class='Ref_to_Enum'>BoolTestType</span></a> <span class='Declare_Parameter'>booltesttype</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Delimiter'>, 
</span><a name="LN1517"></a>            <span class='Keyword'>int </span><span class='Declare_Parameter'>varRelid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1519"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN1520"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1517"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1519"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1519"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1526"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span><a name="LN1527"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>freq_null</span><span class='Delimiter'>; 
</span><a name="LN1528"></a>        <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN1526"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1519"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1526"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1528"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1519"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a> <span class='Operator'>| </span><a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>&& </span><a href="selfuncs.c.html#LN1528"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1538"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>freq_true</span><span class='Delimiter'>; 
</span><a name="LN1539"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>freq_false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Get first MCV frequency and derive frequency for true. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1528"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                <a href="selfuncs.c.html#LN1538"><span class='Ref_To_Local'>freq_true</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1528"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN1538"><span class='Ref_To_Local'>freq_true</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1528"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>- </span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Next derive frequency for false. Then use these as appropriate 
             * to derive frequency for each case. 
             */ 
</span>            <a href="selfuncs.c.html#LN1539"><span class='Ref_To_Local'>freq_false</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1538"><span class='Ref_To_Local'>freq_true</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>booltesttype</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_UNKNOWN</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select only NULL values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_UNKNOWN</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select non-NULL values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_TRUE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select only TRUE values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1538"><span class='Ref_To_Local'>freq_true</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_TRUE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select non-TRUE values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1538"><span class='Ref_To_Local'>freq_true</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select only FALSE values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1539"><span class='Ref_To_Local'>freq_false</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_FALSE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select non-FALSE values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1539"><span class='Ref_To_Local'>freq_false</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized booltesttype: %d"</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>booltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Keep compiler quiet */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch booltesttype &raquo; </span> 
 
            <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1528"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if get_attstatsslot(&ssl... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * No most-common-value info available. Still have null fraction 
             * information, so use it for IS [NOT] UNKNOWN. Otherwise adjust 
             * for null fraction and assume a 50-50 split of TRUE and FALSE. 
             */ 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>booltesttype</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_UNKNOWN</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select only NULL values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_UNKNOWN</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* select non-NULL values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_TRUE</span></a><span class='Operator'>: 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* Assume we select half of the non-NULL values */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_TRUE</span></a><span class='Operator'>: 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_FALSE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* Assume we select NULLs plus half of the non-NULLs */ 
</span>                    <span class='Comment_Multi_Line'>/* equiv. to freq_null + (1.0 - freq_null) / 2.0 */ 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1527"><span class='Ref_To_Local'>freq_null</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized booltesttype: %d"</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>booltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Keep compiler quiet */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch booltesttype &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we can't get variable statistics for the argument, perhaps 
         * clause_selectivity can do something with it.  We ignore the 
         * possibility of a NULL value when using clause_selectivity, and just 
         * assume the value is either TRUE or FALSE. 
         */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>booltesttype</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_UNKNOWN</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN48"><span class='Ref_to_Const'>DEFAULT_UNK_SEL</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_UNKNOWN</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN49"><span class='Ref_to_Const'>DEFAULT_NOT_UNK_SEL</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_TRUE</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_FALSE</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/cost.h.html#LN202"><span class='Ref_to_Proto'>clause_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>, 
</span>                                                    <a href="selfuncs.c.html#LN1517"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, 
</span>                                                    <a href="selfuncs.c.html#LN1517"><span class='Ref_to_Parameter'>jointype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1517"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_FALSE</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1195"><span class='Ref_to_EnumConst'>IS_NOT_TRUE</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/cost.h.html#LN202"><span class='Ref_to_Proto'>clause_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>, 
</span>                                                          <a href="selfuncs.c.html#LN1517"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, 
</span>                                                          <a href="selfuncs.c.html#LN1517"><span class='Ref_to_Parameter'>jointype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1517"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized booltesttype: %d"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1516"><span class='Ref_to_Parameter'>booltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Keep compiler quiet */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch booltesttype &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1519"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* result should be in range, but make sure... */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1520"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end booltestsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      nulltestsel     - Selectivity of NullTest Node. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN1674"></a><span class='Declare_Function'>nulltestsel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1170"><span class='Ref_to_Enum'>NullTestType</span></a> <span class='Declare_Parameter'>nulltesttype</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Delimiter'>, 
</span><a name="LN1675"></a>            <span class='Keyword'>int </span><span class='Declare_Parameter'>varRelid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1677"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN1678"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1674"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1674"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1675"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1677"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1677"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1684"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span><a name="LN1685"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>freq_null</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN1684"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1677"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1685"><span class='Ref_To_Local'>freq_null</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1684"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1674"><span class='Ref_to_Parameter'>nulltesttype</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Use freq_null directly. 
                 */ 
</span>                <a href="selfuncs.c.html#LN1678"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1685"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Select not unknown (not null) values. Calculate from 
                 * freq_null. 
                 */ 
</span>                <a href="selfuncs.c.html#LN1678"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1685"><span class='Ref_To_Local'>freq_null</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized nulltesttype: %d"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1674"><span class='Ref_to_Parameter'>nulltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nulltesttype &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * No ANALYZE stats available, so make a guess 
         */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1674"><span class='Ref_to_Parameter'>nulltesttype</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1678"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN48"><span class='Ref_to_Const'>DEFAULT_UNK_SEL</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a><span class='Operator'>: 
</span>                <a href="selfuncs.c.html#LN1678"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN49"><span class='Ref_to_Const'>DEFAULT_NOT_UNK_SEL</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized nulltesttype: %d"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1674"><span class='Ref_to_Parameter'>nulltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1677"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* result should be in range, but make sure... */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1678"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1678"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end nulltestsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * strip_array_coercion - strip binary-compatible relabeling from an array expr 
 * 
 * For array values, the parser normally generates ArrayCoerceExpr conversions, 
 * but it seems possible that RelabelType might show up.  Also, the planner 
 * is not currently tense about collapsing stacked ArrayCoerceExpr nodes, 
 * so we need to be ready to deal with more than one level. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>* 
</span><a name="LN1750"></a><span class='Declare_Function'>strip_array_coercion</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>elemfuncid <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* We don't really expect this case, but may as well cope */ 
</span>            <a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN1750"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end strip_array_coercion &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      scalararraysel      - Selectivity of ScalarArrayOpExpr Node. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN1774"></a><span class='Declare_Function'>scalararraysel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1775"></a>               <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN1776"></a>               <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_join_clause</span><span class='Delimiter'>, 
</span><a name="LN1777"></a>               <span class='Keyword'>int </span><span class='Declare_Parameter'>varRelid</span><span class='Delimiter'>, 
</span><a name="LN1778"></a>               <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN1779"></a>               <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1781"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>operator</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN537"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span><a name="LN1782"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>useOr</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN539"><span class='Ref_to_Member'>useOr</span></a><span class='Delimiter'>; 
</span><a name="LN1783"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isEquality</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1784"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isInequality</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1785"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftop</span><span class='Delimiter'>; 
</span><a name="LN1786"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rightop</span><span class='Delimiter'>; 
</span><a name="LN1787"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>nominal_element_type</span><span class='Delimiter'>; 
</span><a name="LN1788"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>nominal_element_collation</span><span class='Delimiter'>; 
</span><a name="LN1789"></a>    <a href="../../../include/utils/typcache.h.html#LN28"><span class='Ref_to_Struct'>TypeCacheEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>typentry</span><span class='Delimiter'>; 
</span><a name="LN1790"></a>    <a href="../../../include/c.h.html#LN394"><span class='Ref_to_Typedef'>RegProcedure</span></a> <span class='Declare_Local'>oprsel</span><span class='Delimiter'>; 
</span><a name="LN1791"></a>    <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>oprselproc</span><span class='Delimiter'>; 
</span><a name="LN1792"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>s1</span><span class='Delimiter'>; 
</span><a name="LN1793"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>s1disjoint</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First, deconstruct the expression */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN1785"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* aggressively reduce both sides to constants */ 
</span>    <a href="selfuncs.c.html#LN1785"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1785"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* get nominal (after relabeling) element type of rightop */ 
</span>    <a href="selfuncs.c.html#LN1787"><span class='Ref_To_Local'>nominal_element_type</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN160"><span class='Ref_to_Proto'>get_base_element_type</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1787"><span class='Ref_To_Local'>nominal_element_type</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* probably shouldn't happen */ 
</span>    <span class='Comment_Multi_Line'>/* get nominal collation, too, for generating constants */ 
</span>    <a href="selfuncs.c.html#LN1788"><span class='Ref_To_Local'>nominal_element_collation</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* look through any binary-compatible relabeling of rightop */ 
</span>    <a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1749"><span class='Ref_to_Func'>strip_array_coercion</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Detect whether the operator is the default equality or inequality 
     * operator of the array element type. 
     */ 
</span>    <a href="selfuncs.c.html#LN1789"><span class='Ref_To_Local'>typentry</span></a> <span class='Operator'>= </span><a href="../../../include/utils/typcache.h.html#LN142"><span class='Ref_to_Proto'>lookup_type_cache</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1787"><span class='Ref_To_Local'>nominal_element_type</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/typcache.h.html#LN109"><span class='Ref_to_Const'>TYPECACHE_EQ_OPR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1789"><span class='Ref_To_Local'>typentry</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/typcache.h.html#LN53"><span class='Ref_to_Member'>eq_opr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>operator </span><span class='Operator'>== </span><a href="selfuncs.c.html#LN1789"><span class='Ref_To_Local'>typentry</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/typcache.h.html#LN53"><span class='Ref_to_Member'>eq_opr</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN107"><span class='Ref_to_Proto'>get_negator</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="selfuncs.c.html#LN1789"><span class='Ref_To_Local'>typentry</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/typcache.h.html#LN53"><span class='Ref_to_Member'>eq_opr</span></a><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN1784"><span class='Ref_To_Local'>isInequality</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it is equality or inequality, we might be able to estimate this as a 
     * form of array containment; for instance "const = ANY(column)" can be 
     * treated as "ARRAY[const] &LT;@ column".  scalararraysel_containment tries 
     * that, and returns the selectivity estimate if successful, or -1 if not. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN1784"><span class='Ref_To_Local'>isInequality</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="selfuncs.c.html#LN1776"><span class='Ref_to_Parameter'>is_join_clause</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="array_selfuncs.c.html#LN81"><span class='Ref_to_Func'>scalararraysel_containment</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1785"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN1787"><span class='Ref_To_Local'>nominal_element_type</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1777"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look up the underlying operator's selectivity estimator. Punt if it 
     * hasn't got one. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1776"><span class='Ref_to_Parameter'>is_join_clause</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN109"><span class='Ref_to_Proto'>get_oprjoin</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN108"><span class='Ref_to_Proto'>get_oprrest</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>    <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1791"><span class='Ref_To_Local'>oprselproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In the array-containment check above, we must only believe that an 
     * operator is equality or inequality if it is the default btree equality 
     * operator (or its negator) for the element type, since those are the 
     * operators that array containment will use.  But in what follows, we can 
     * be a little laxer, and also believe that any operators using eqsel() or 
     * neqsel() as selectivity estimator act like equality or inequality. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a> <span class='Operator'>== </span>F_EQSEL <span class='Operator'>|| </span><a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a> <span class='Operator'>== </span>F_EQJOINSEL<span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a> <span class='Operator'>== </span>F_NEQSEL <span class='Operator'>|| </span><a href="selfuncs.c.html#LN1790"><span class='Ref_To_Local'>oprsel</span></a> <span class='Operator'>== </span>F_NEQJOINSEL<span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN1784"><span class='Ref_To_Local'>isInequality</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We consider three cases: 
     * 
     * 1. rightop is an Array constant: deconstruct the array, apply the 
     * operator's selectivity function for each array element, and merge the 
     * results in the same way that clausesel.c does for AND/OR combinations. 
     * 
     * 2. rightop is an ARRAY[] construct: apply the operator's selectivity 
     * function for each element of the ARRAY[] construct, and merge. 
     * 
     * 3. otherwise, make a guess ... 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1881"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>arraydatum</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span><a name="LN1882"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>arrayisnull</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Delimiter'>; 
</span><a name="LN1883"></a>        <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span><a name="LN1884"></a>        <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>elmlen</span><span class='Delimiter'>; 
</span><a name="LN1885"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>elmbyval</span><span class='Delimiter'>; 
</span><a name="LN1886"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>elmalign</span><span class='Delimiter'>; 
</span><a name="LN1887"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>num_elems</span><span class='Delimiter'>; 
</span><a name="LN1888"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>elem_values</span><span class='Delimiter'>; 
</span><a name="LN1889"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>elem_nulls</span><span class='Delimiter'>; 
</span><a name="LN1890"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1882"><span class='Ref_To_Local'>arrayisnull</span></a><span class='Parentheses'>)</span>        <span class='Comment_Single_Line'>/* qual can't succeed if null array */ 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1883"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1881"><span class='Ref_To_Local'>arraydatum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN136"><span class='Ref_to_Proto'>get_typlenbyvalalign</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1883"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="selfuncs.c.html#LN1884"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1885"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1886"><span class='Ref_To_Local'>elmalign</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1883"><span class='Ref_To_Local'>arrayval</span></a><span class='Delimiter'>, 
</span>                          <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1883"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <a href="selfuncs.c.html#LN1884"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1885"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1886"><span class='Ref_To_Local'>elmalign</span></a><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="selfuncs.c.html#LN1888"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1889"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1887"><span class='Ref_To_Local'>num_elems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For generic operators, we assume the probability of success is 
         * independent for each array element.  But for "= ANY" or "&LT;&GT; ALL", 
         * if the array elements are distinct (which'd typically be the case) 
         * then the probabilities are disjoint, and we should just sum them. 
         * 
         * If we were being really tense we would try to confirm that the 
         * elements are all distinct, but that would be expensive and it 
         * doesn't seem to be worth the cycles; it would amount to penalizing 
         * well-written queries in favor of poorly-written ones.  However, we 
         * do protect ourselves a little bit by checking whether the 
         * disjointness assumption leads to an impossible (out of range) 
         * probability; if so, we fall back to the normal calculation. 
         */ 
</span>        <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a> <span class='Operator'>? </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1890"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN1890"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN1887"><span class='Ref_To_Local'>num_elems</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN1890"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1920"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN1921"></a>            <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>s2</span><span class='Delimiter'>; 
</span> 
            <a href="selfuncs.c.html#LN1920"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1785"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1787"><span class='Ref_To_Local'>nominal_element_type</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN1788"><span class='Ref_To_Local'>nominal_element_collation</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN1884"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN1888"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN1890"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                        <a href="selfuncs.c.html#LN1889"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN1890"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                        <a href="selfuncs.c.html#LN1885"><span class='Ref_To_Local'>elmbyval</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1776"><span class='Ref_to_Parameter'>is_join_clause</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN1921"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN520"><span class='Ref_to_Proto'>FunctionCall5Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1791"><span class='Ref_To_Local'>oprselproc</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1920"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1778"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1779"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN1921"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN517"><span class='Ref_to_Proto'>FunctionCall4Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1791"><span class='Ref_To_Local'>oprselproc</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1920"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1777"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN1921"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN1921"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN1921"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN1921"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1784"><span class='Ref_To_Local'>isInequality</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN1921"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;num_elems;i++ &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* accept disjoint-probability estimate if in range */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a> <span class='Operator'>? </span><a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a> <span class='Operator'>: </span><a href="selfuncs.c.html#LN1784"><span class='Ref_To_Local'>isInequality</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rightop&&IsA(rightop,... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>             <span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>multidims<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1969"></a>        <a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN1786"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>; 
</span><a name="LN1970"></a>        <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>elmlen</span><span class='Delimiter'>; 
</span><a name="LN1971"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>elmbyval</span><span class='Delimiter'>; 
</span><a name="LN1972"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1969"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN952"><span class='Ref_to_Member'>element_typeid</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="selfuncs.c.html#LN1970"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1971"><span class='Ref_To_Local'>elmbyval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We use the assumption of disjoint probabilities here too, although 
         * the odds of equal array elements are rather higher if the elements 
         * are not all constants (which they won't be, else constant folding 
         * would have reduced the ArrayExpr to a Const).  In this path it's 
         * critical to have the sanity check on the s1disjoint estimate. 
         */ 
</span>        <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a> <span class='Operator'>? </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1972"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1969"><span class='Ref_To_Local'>arrayexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN953"><span class='Ref_to_Member'>elements</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1988"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>elem</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1972"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1989"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN1990"></a>            <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>s2</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Theoretically, if elem isn't of nominal_element_type we should 
             * insert a RelabelType, but it seems unlikely that any operator 
             * estimation function would really care ... 
             */ 
</span>            <a href="selfuncs.c.html#LN1989"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1785"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN1988"><span class='Ref_To_Local'>elem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1776"><span class='Ref_to_Parameter'>is_join_clause</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN1990"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN520"><span class='Ref_to_Proto'>FunctionCall5Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1791"><span class='Ref_To_Local'>oprselproc</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1989"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1778"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1779"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN1990"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN517"><span class='Ref_to_Proto'>FunctionCall4Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1791"><span class='Ref_To_Local'>oprselproc</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1989"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1777"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN1990"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN1990"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN1990"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN1990"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1784"><span class='Ref_To_Local'>isInequality</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN1990"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* accept disjoint-probability estimate if in range */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a> <span class='Operator'>? </span><a href="selfuncs.c.html#LN1783"><span class='Ref_To_Local'>isEquality</span></a> <span class='Operator'>: </span><a href="selfuncs.c.html#LN1784"><span class='Ref_To_Local'>isInequality</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1793"><span class='Ref_To_Local'>s1disjoint</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rightop&&IsA(rightop,... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2035"></a>        <a href="../../../include/nodes/primnodes.h.html#LN931"><span class='Ref_to_Struct'>CaseTestExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dummyexpr</span><span class='Delimiter'>; 
</span><a name="LN2036"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span><span class='Delimiter'>; 
</span><a name="LN2037"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>s2</span><span class='Delimiter'>; 
</span><a name="LN2038"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We need a dummy rightop to pass to the operator selectivity 
         * routine.  It can be pretty much anything that doesn't look like a 
         * constant; CaseTestExpr is a convenient choice. 
         */ 
</span>        <a href="selfuncs.c.html#LN2035"><span class='Ref_To_Local'>dummyexpr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN931"><span class='Ref_to_Struct'>CaseTestExpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2035"><span class='Ref_To_Local'>dummyexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN934"><span class='Ref_to_Member'>typeId</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1787"><span class='Ref_To_Local'>nominal_element_type</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2035"><span class='Ref_To_Local'>dummyexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN935"><span class='Ref_to_Member'>typeMod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2035"><span class='Ref_To_Local'>dummyexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN936"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2036"><span class='Ref_To_Local'>args</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1785"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2035"><span class='Ref_To_Local'>dummyexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1776"><span class='Ref_to_Parameter'>is_join_clause</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN2037"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN520"><span class='Ref_to_Proto'>FunctionCall5Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1791"><span class='Ref_To_Local'>oprselproc</span></a><span class='Delimiter'>, 
</span>                                                  <a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2036"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1778"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1779"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN2037"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN517"><span class='Ref_to_Proto'>FunctionCall4Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN1791"><span class='Ref_To_Local'>oprselproc</span></a><span class='Delimiter'>, 
</span>                                                  <a href="selfuncs.c.html#LN1775"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1774"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2036"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1777"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a> <span class='Operator'>? </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Arbitrarily assume 10 elements in the eventual array value (see 
         * also estimate_array_length).  We don't risk an assumption of 
         * disjoint probabilities here. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2038"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2038"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><span class='Number'>10</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2038"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1782"><span class='Ref_To_Local'>useOr</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN2037"><span class='Ref_To_Local'>s2</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN2037"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN2037"><span class='Ref_To_Local'>s2</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* result should be in range, but make sure... */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN1792"><span class='Ref_To_Local'>s1</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end scalararraysel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate number of elements in the array yielded by an expression. 
 * 
 * It's important that this agree with scalararraysel. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN2093"></a><span class='Declare_Function'>estimate_array_length</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>arrayexpr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* look through any binary-compatible relabeling of arrayexpr */ 
</span>    <a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN1749"><span class='Ref_to_Func'>strip_array_coercion</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2100"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>arraydatum</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span><a name="LN2101"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>arrayisnull</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Delimiter'>; 
</span><a name="LN2102"></a>        <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2101"><span class='Ref_To_Local'>arrayisnull</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2102"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2100"><span class='Ref_To_Local'>arraydatum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="arrayutils.c.html#LN73"><span class='Ref_to_Func'>ArrayGetNItems</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2102"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2102"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>             <span class='Operator'>!</span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>multidims<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN947"><span class='Ref_to_Struct'>ArrayExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2093"><span class='Ref_to_Parameter'>arrayexpr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>elements<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* default guess --- see also scalararraysel */ 
</span>        <span class='Control'>return</span> <span class='Number'>10</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end estimate_array_length &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      rowcomparesel       - Selectivity of RowCompareExpr Node. 
 * 
 * We estimate RowCompare selectivity by considering just the first (high 
 * order) columns, which makes it equivalent to an ordinary OpExpr.  While 
 * this estimate could be refined by considering additional columns, it 
 * seems unlikely that we could do a lot better without multi-column 
 * statistics. 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN2131"></a><span class='Declare_Function'>rowcomparesel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN2132"></a>              <a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN2133"></a>              <span class='Keyword'>int </span><span class='Declare_Parameter'>varRelid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2135"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>s1</span><span class='Delimiter'>; 
</span><a name="LN2136"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opno</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN112"><span class='Ref_to_Macro'>linitial_oid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2132"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2137"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputcollid</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN112"><span class='Ref_to_Macro'>linitial_oid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2132"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1032"><span class='Ref_to_Member'>inputcollids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2138"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>opargs</span><span class='Delimiter'>; 
</span><a name="LN2139"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_join_clause</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build equivalent arg list for single operator */ 
</span>    <a href="selfuncs.c.html#LN2138"><span class='Ref_To_Local'>opargs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2132"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2132"><span class='Ref_to_Parameter'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Decide if it's a join clause.  This should match clausesel.c's 
     * treat_as_join_clause(), except that we intentionally consider only the 
     * leading columns and not the rest of the clause. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2133"><span class='Ref_to_Parameter'>varRelid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Caller is forcing restriction mode (eg, because we are examining an 
         * inner indexscan qual). 
         */ 
</span>        <a href="selfuncs.c.html#LN2139"><span class='Ref_To_Local'>is_join_clause</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2133"><span class='Ref_to_Parameter'>sjinfo</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * It must be a restriction clause, since it's being evaluated at a 
         * scan node. 
         */ 
</span>        <a href="selfuncs.c.html#LN2139"><span class='Ref_To_Local'>is_join_clause</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Otherwise, it's a join if there's more than one relation used. 
         */ 
</span>        <a href="selfuncs.c.html#LN2139"><span class='Ref_To_Local'>is_join_clause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN75"><span class='Ref_to_Proto'>NumRelids</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2138"><span class='Ref_To_Local'>opargs</span></a><span class='Parentheses'>)</span> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2139"><span class='Ref_To_Local'>is_join_clause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Estimate selectivity for a join clause. */ 
</span>        <a href="selfuncs.c.html#LN2135"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/plancat.h.html#LN50"><span class='Ref_to_Proto'>join_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2131"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2136"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, 
</span>                              <a href="selfuncs.c.html#LN2138"><span class='Ref_To_Local'>opargs</span></a><span class='Delimiter'>, 
</span>                              <a href="selfuncs.c.html#LN2137"><span class='Ref_To_Local'>inputcollid</span></a><span class='Delimiter'>, 
</span>                              <a href="selfuncs.c.html#LN2133"><span class='Ref_to_Parameter'>jointype</span></a><span class='Delimiter'>, 
</span>                              <a href="selfuncs.c.html#LN2133"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Estimate selectivity for a restriction clause. */ 
</span>        <a href="selfuncs.c.html#LN2135"><span class='Ref_To_Local'>s1</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/plancat.h.html#LN44"><span class='Ref_to_Proto'>restriction_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2131"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2136"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, 
</span>                                     <a href="selfuncs.c.html#LN2138"><span class='Ref_To_Local'>opargs</span></a><span class='Delimiter'>, 
</span>                                     <a href="selfuncs.c.html#LN2137"><span class='Ref_To_Local'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                     <a href="selfuncs.c.html#LN2133"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN2135"><span class='Ref_To_Local'>s1</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rowcomparesel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      eqjoinsel       - Join selectivity of "=" 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2198"></a><span class='Declare_Function'>eqjoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2200"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2201"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>PG_GETARG_OID</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2202"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> NOT_USED 
<a name="LN2205"></a>    <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Local'>jointype</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN235"><span class='Ref_to_Macro'>PG_GETARG_INT16</span></a><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<a name="LN2207"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2208"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN2209"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata1</span><span class='Delimiter'>; 
</span><a name="LN2210"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata2</span><span class='Delimiter'>; 
</span><a name="LN2211"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>join_is_reversed</span><span class='Delimiter'>; 
</span><a name="LN2212"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>inner_rel</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN161"><span class='Ref_to_Proto'>get_join_variables</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2200"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2202"><span class='Ref_To_Local'>args</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2207"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>, 
</span>                       <span class='Operator'>&</span><a href="selfuncs.c.html#LN2209"><span class='Ref_To_Local'>vardata1</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2210"><span class='Ref_To_Local'>vardata2</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2211"><span class='Ref_To_Local'>join_is_reversed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2207"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN2208"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN167"><span class='Ref_to_Proto'>eqjoinsel_inner</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2209"><span class='Ref_To_Local'>vardata1</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2210"><span class='Ref_To_Local'>vardata2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Look up the join's inner relation.  min_righthand is sufficient 
             * information because neither SEMI nor ANTI joins permit any 
             * reassociation into or out of their RHS, so the righthand will 
             * always be exactly that set of rels. 
             */ 
</span>            <a href="selfuncs.c.html#LN2212"><span class='Ref_To_Local'>inner_rel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN204"><span class='Ref_to_Proto'>find_join_input_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2200"><span class='Ref_To_Local'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2207"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN2211"><span class='Ref_To_Local'>join_is_reversed</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN2208"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN169"><span class='Ref_to_Proto'>eqjoinsel_semi</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2209"><span class='Ref_To_Local'>vardata1</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2210"><span class='Ref_To_Local'>vardata2</span></a><span class='Delimiter'>, 
</span>                                       <a href="selfuncs.c.html#LN2212"><span class='Ref_To_Local'>inner_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN2208"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN169"><span class='Ref_to_Proto'>eqjoinsel_semi</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="selfuncs.c.html#LN2210"><span class='Ref_To_Local'>vardata2</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2209"><span class='Ref_To_Local'>vardata1</span></a><span class='Delimiter'>, 
</span>                                       <a href="selfuncs.c.html#LN2212"><span class='Ref_To_Local'>inner_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* other values not expected here */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized join type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2207"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN2208"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch sjinfo-&GT;jointype &raquo; </span> 
 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2209"><span class='Ref_To_Local'>vardata1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2210"><span class='Ref_To_Local'>vardata2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2208"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2208"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end eqjoinsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * eqjoinsel_inner --- eqjoinsel for normal inner join 
 * 
 * We also use this for LEFT/FULL outer joins; it's not presently clear 
 * that it's worth trying to distinguish them here. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN2266"></a><span class='Declare_Function'>eqjoinsel_inner</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN2267"></a>                <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata1</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2269"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN2270"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nd1</span><span class='Delimiter'>; 
</span><a name="LN2271"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nd2</span><span class='Delimiter'>; 
</span><a name="LN2272"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault1</span><span class='Delimiter'>; 
</span><a name="LN2273"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault2</span><span class='Delimiter'>; 
</span><a name="LN2274"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opfuncoid</span><span class='Delimiter'>; 
</span><a name="LN2275"></a>    <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats1</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2276"></a>    <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats2</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2277"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_mcvs1</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2278"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_mcvs2</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2279"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot1</span><span class='Delimiter'>; 
</span><a name="LN2280"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot2</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN2270"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2272"><span class='Ref_To_Local'>isdefault1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN2271"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2273"><span class='Ref_To_Local'>isdefault2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN2274"><span class='Ref_To_Local'>opfuncoid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* note we allow use of nullfrac regardless of security check */ 
</span>        <a href="selfuncs.c.html#LN2275"><span class='Ref_To_Local'>stats1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2274"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Parentheses'>))</span> 
            <a href="selfuncs.c.html#LN2277"><span class='Ref_To_Local'>have_mcvs1</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a> <span class='Operator'>| </span><a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* note we allow use of nullfrac regardless of security check */ 
</span>        <a href="selfuncs.c.html#LN2276"><span class='Ref_To_Local'>stats2</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2274"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Parentheses'>))</span> 
            <a href="selfuncs.c.html#LN2278"><span class='Ref_To_Local'>have_mcvs2</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2267"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a> <span class='Operator'>| </span><a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2277"><span class='Ref_To_Local'>have_mcvs1</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN2278"><span class='Ref_To_Local'>have_mcvs2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have most-common-value lists for both relations.  Run through 
         * the lists to see which MCVs actually join to each other with the 
         * given operator.  This allows us to determine the exact join 
         * selectivity for the portion of the relations represented by the MCV 
         * lists.  We still have to estimate for the remaining population, but 
         * in a skewed distribution this gives us a big leg up in accuracy. 
         * For motivation see the analysis in Y. Ioannidis and S. 
         * Christodoulakis, "On the propagation of errors in the size of join 
         * results", Technical Report 1018, Computer Science Dept., University 
         * of Wisconsin, Madison, March 1991 (available from ftp.cs.wisc.edu). 
         */ 
</span><a name="LN2324"></a>        <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>eqproc</span><span class='Delimiter'>; 
</span><a name="LN2325"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>hasmatch1</span><span class='Delimiter'>; 
</span><a name="LN2326"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>hasmatch2</span><span class='Delimiter'>; 
</span><a name="LN2327"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac1</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2275"><span class='Ref_To_Local'>stats1</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span><a name="LN2328"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac2</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2276"><span class='Ref_To_Local'>stats2</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span><a name="LN2329"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>matchprodfreq</span><span class='Delimiter'>, 
</span><a name="LN2330"></a>                    <span class='Declare_Local'>matchfreq1</span><span class='Delimiter'>, 
</span><a name="LN2331"></a>                    <span class='Declare_Local'>matchfreq2</span><span class='Delimiter'>, 
</span><a name="LN2332"></a>                    <span class='Declare_Local'>unmatchfreq1</span><span class='Delimiter'>, 
</span><a name="LN2333"></a>                    <span class='Declare_Local'>unmatchfreq2</span><span class='Delimiter'>, 
</span><a name="LN2334"></a>                    <span class='Declare_Local'>otherfreq1</span><span class='Delimiter'>, 
</span><a name="LN2335"></a>                    <span class='Declare_Local'>otherfreq2</span><span class='Delimiter'>, 
</span><a name="LN2336"></a>                    <span class='Declare_Local'>totalsel1</span><span class='Delimiter'>, 
</span><a name="LN2337"></a>                    <span class='Declare_Local'>totalsel2</span><span class='Delimiter'>; 
</span><a name="LN2338"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN2339"></a>                    <span class='Declare_Local'>nmatches</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2274"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2324"><span class='Ref_To_Local'>eqproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2325"><span class='Ref_To_Local'>hasmatch1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2326"><span class='Ref_To_Local'>hasmatch2</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note we assume that each MCV will match at most one member of the 
         * other MCV list.  If the operator isn't really equality, there could 
         * be multiple matches --- but we don't look for them, both for speed 
         * and because the math wouldn't add up... 
         */ 
</span>        <a href="selfuncs.c.html#LN2329"><span class='Ref_To_Local'>matchprodfreq</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2339"><span class='Ref_To_Local'>nmatches</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2355"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2355"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2355"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2355"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2326"><span class='Ref_To_Local'>hasmatch2</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2355"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2324"><span class='Ref_To_Local'>eqproc</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                                   <a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                                   <a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2355"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="selfuncs.c.html#LN2325"><span class='Ref_To_Local'>hasmatch1</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="selfuncs.c.html#LN2326"><span class='Ref_To_Local'>hasmatch2</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2355"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="selfuncs.c.html#LN2329"><span class='Ref_To_Local'>matchprodfreq</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>* </span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2355"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span>                    <a href="selfuncs.c.html#LN2339"><span class='Ref_To_Local'>nmatches</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;sslot1.nvalues;... &raquo; </span> 
        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2329"><span class='Ref_To_Local'>matchprodfreq</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Sum up frequencies of matched and unmatched MCVs */ 
</span>        <a href="selfuncs.c.html#LN2330"><span class='Ref_To_Local'>matchfreq1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2332"><span class='Ref_To_Local'>unmatchfreq1</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2325"><span class='Ref_To_Local'>hasmatch1</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN2330"><span class='Ref_To_Local'>matchfreq1</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN2332"><span class='Ref_To_Local'>unmatchfreq1</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2330"><span class='Ref_To_Local'>matchfreq1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2332"><span class='Ref_To_Local'>unmatchfreq1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2331"><span class='Ref_To_Local'>matchfreq2</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2333"><span class='Ref_To_Local'>unmatchfreq2</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2326"><span class='Ref_To_Local'>hasmatch2</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN2331"><span class='Ref_To_Local'>matchfreq2</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN2333"><span class='Ref_To_Local'>unmatchfreq2</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2331"><span class='Ref_To_Local'>matchfreq2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2333"><span class='Ref_To_Local'>unmatchfreq2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2325"><span class='Ref_To_Local'>hasmatch1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2326"><span class='Ref_To_Local'>hasmatch2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute total frequency of non-null values that are not in the MCV 
         * lists. 
         */ 
</span>        <a href="selfuncs.c.html#LN2334"><span class='Ref_To_Local'>otherfreq1</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2327"><span class='Ref_To_Local'>nullfrac1</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2330"><span class='Ref_To_Local'>matchfreq1</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2332"><span class='Ref_To_Local'>unmatchfreq1</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2335"><span class='Ref_To_Local'>otherfreq2</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2328"><span class='Ref_To_Local'>nullfrac2</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2331"><span class='Ref_To_Local'>matchfreq2</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2333"><span class='Ref_To_Local'>unmatchfreq2</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2334"><span class='Ref_To_Local'>otherfreq1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2335"><span class='Ref_To_Local'>otherfreq2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can estimate the total selectivity from the point of view of 
         * relation 1 as: the known selectivity for matched MCVs, plus 
         * unmatched MCVs that are assumed to match against random members of 
         * relation 2's non-MCV population, plus non-MCV values that are 
         * assumed to match against random members of relation 2's unmatched 
         * MCVs plus non-MCV values. 
         */ 
</span>        <a href="selfuncs.c.html#LN2336"><span class='Ref_To_Local'>totalsel1</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2329"><span class='Ref_To_Local'>matchprodfreq</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2271"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN2336"><span class='Ref_To_Local'>totalsel1</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2332"><span class='Ref_To_Local'>unmatchfreq1</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN2335"><span class='Ref_To_Local'>otherfreq2</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2271"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2271"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN2339"><span class='Ref_To_Local'>nmatches</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN2336"><span class='Ref_To_Local'>totalsel1</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2334"><span class='Ref_To_Local'>otherfreq1</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2335"><span class='Ref_To_Local'>otherfreq2</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN2333"><span class='Ref_To_Local'>unmatchfreq2</span></a><span class='Parentheses'>) </span><span class='Operator'>/ 
</span>                <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2271"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2339"><span class='Ref_To_Local'>nmatches</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Same estimate from the point of view of relation 2. */ 
</span>        <a href="selfuncs.c.html#LN2337"><span class='Ref_To_Local'>totalsel2</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2329"><span class='Ref_To_Local'>matchprodfreq</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2270"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN2337"><span class='Ref_To_Local'>totalsel2</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2333"><span class='Ref_To_Local'>unmatchfreq2</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN2334"><span class='Ref_To_Local'>otherfreq1</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2270"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2270"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN2339"><span class='Ref_To_Local'>nmatches</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN2337"><span class='Ref_To_Local'>totalsel2</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2335"><span class='Ref_To_Local'>otherfreq2</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2334"><span class='Ref_To_Local'>otherfreq1</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN2332"><span class='Ref_To_Local'>unmatchfreq1</span></a><span class='Parentheses'>) </span><span class='Operator'>/ 
</span>                <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2270"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2339"><span class='Ref_To_Local'>nmatches</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Use the smaller of the two estimates.  This can be justified in 
         * essentially the same terms as given below for the no-stats case: to 
         * a first approximation, we are estimating from the point of view of 
         * the relation with smaller nd. 
         */ 
</span>        <a href="selfuncs.c.html#LN2269"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2336"><span class='Ref_To_Local'>totalsel1</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2337"><span class='Ref_To_Local'>totalsel2</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="selfuncs.c.html#LN2336"><span class='Ref_To_Local'>totalsel1</span></a> <span class='Operator'>: </span><a href="selfuncs.c.html#LN2337"><span class='Ref_To_Local'>totalsel2</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if have_mcvs1&&have_mcvs... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We do not have MCV lists for both sides.  Estimate the join 
         * selectivity as MIN(1/nd1,1/nd2)*(1-nullfrac1)*(1-nullfrac2). This 
         * is plausible if we assume that the join operator is strict and the 
         * non-null values are about equally distributed: a given non-null 
         * tuple of rel1 will join to either zero or N2*(1-nullfrac2)/nd2 rows 
         * of rel2, so total join rows are at most 
         * N1*(1-nullfrac1)*N2*(1-nullfrac2)/nd2 giving a join selectivity of 
         * not more than (1-nullfrac1)*(1-nullfrac2)/nd2. By the same logic it 
         * is not more than (1-nullfrac1)*(1-nullfrac2)/nd1, so the expression 
         * with MIN() is an upper bound.  Using the MIN() means we estimate 
         * from the point of view of the relation with smaller nd (since the 
         * larger nd is determining the MIN).  It is reasonable to assume that 
         * most tuples in this rel will have join partners, so the bound is 
         * probably reasonably tight and should be taken as-is. 
         * 
         * XXX Can we be smarter if we have an MCV list for just one side? It 
         * seems that if we assume equal distribution for the other side, we 
         * end up with the same answer anyway. 
         */ 
</span><a name="LN2459"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac1</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2275"><span class='Ref_To_Local'>stats1</span></a> <span class='Operator'>? </span><a href="selfuncs.c.html#LN2275"><span class='Ref_To_Local'>stats1</span></a><span class='Operator'>-&GT;</span>stanullfrac <span class='Operator'>: </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2460"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac2</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2276"><span class='Ref_To_Local'>stats2</span></a> <span class='Operator'>? </span><a href="selfuncs.c.html#LN2276"><span class='Ref_To_Local'>stats2</span></a><span class='Operator'>-&GT;</span>stanullfrac <span class='Operator'>: </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN2269"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2459"><span class='Ref_To_Local'>nullfrac1</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2460"><span class='Ref_To_Local'>nullfrac2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2270"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN2271"><span class='Ref_To_Local'>nd2</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN2269"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>/= </span><a href="selfuncs.c.html#LN2270"><span class='Ref_To_Local'>nd1</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN2269"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>/= </span><a href="selfuncs.c.html#LN2271"><span class='Ref_To_Local'>nd2</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2279"><span class='Ref_To_Local'>sslot1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2280"><span class='Ref_To_Local'>sslot2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN2269"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end eqjoinsel_inner &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * eqjoinsel_semi --- eqjoinsel for semi join 
 * 
 * (Also used for anti join, which we are supposed to estimate the same way.) 
 * Caller has ensured that vardata1 is the LHS variable. 
 * Unlike eqjoinsel_inner, we have to cope with operator being InvalidOid. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN2483"></a><span class='Declare_Function'>eqjoinsel_semi</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>operator</span><span class='Delimiter'>, 
</span><a name="LN2484"></a>               <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata1</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata2</span><span class='Delimiter'>, 
</span><a name="LN2485"></a>               <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2487"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN2488"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nd1</span><span class='Delimiter'>; 
</span><a name="LN2489"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nd2</span><span class='Delimiter'>; 
</span><a name="LN2490"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault1</span><span class='Delimiter'>; 
</span><a name="LN2491"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault2</span><span class='Delimiter'>; 
</span><a name="LN2492"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opfuncoid</span><span class='Delimiter'>; 
</span><a name="LN2493"></a>    <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats1</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2494"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_mcvs1</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2495"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_mcvs2</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN2496"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot1</span><span class='Delimiter'>; 
</span><a name="LN2497"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot2</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN2488"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2490"><span class='Ref_To_Local'>isdefault1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2491"><span class='Ref_To_Local'>isdefault2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN2492"><span class='Ref_To_Local'>opfuncoid</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2497"><span class='Ref_To_Local'>sslot2</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2497"><span class='Ref_To_Local'>sslot2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We clamp nd2 to be not more than what we estimate the inner relation's 
     * size to be.  This is intuitively somewhat reasonable since obviously 
     * there can't be more than that many distinct values coming from the 
     * inner rel.  The reason for the asymmetry (ie, that we don't clamp nd1 
     * likewise) is that this is the only pathway by which restriction clauses 
     * applied to the inner rel will affect the join result size estimate, 
     * since set_joinrel_size_estimates will multiply SEMI/ANTI selectivity by 
     * only the outer rel's size.  If we clamped nd1 we'd be double-counting 
     * the selectivity of outer-rel restrictions. 
     * 
     * We can apply this clamping both with respect to the base relation from 
     * which the join variable comes (if there is just one), and to the 
     * immediate inner input relation of the current join. 
     * 
     * If we clamp, we can treat nd2 as being a non-default estimate; it's not 
     * great, maybe, but it didn't come out of nowhere either.  This is most 
     * helpful when the inner relation is empty and consequently has no stats. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN2491"><span class='Ref_To_Local'>isdefault2</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN2485"><span class='Ref_to_Parameter'>inner_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2485"><span class='Ref_to_Parameter'>inner_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2491"><span class='Ref_To_Local'>isdefault2</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* note we allow use of nullfrac regardless of security check */ 
</span>        <a href="selfuncs.c.html#LN2493"><span class='Ref_To_Local'>stats1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2492"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Parentheses'>))</span> 
            <a href="selfuncs.c.html#LN2494"><span class='Ref_To_Local'>have_mcvs1</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a> <span class='Operator'>| </span><a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2492"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN2495"><span class='Ref_To_Local'>have_mcvs2</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2497"><span class='Ref_To_Local'>sslot2</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2484"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* note: currently don't need stanumbers from RHS */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2494"><span class='Ref_To_Local'>have_mcvs1</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN2495"><span class='Ref_To_Local'>have_mcvs2</span></a> <span class='Operator'>&& </span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have most-common-value lists for both relations.  Run through 
         * the lists to see which MCVs actually join to each other with the 
         * given operator.  This allows us to determine the exact join 
         * selectivity for the portion of the relations represented by the MCV 
         * lists.  We still have to estimate for the remaining population, but 
         * in a skewed distribution this gives us a big leg up in accuracy. 
         */ 
</span><a name="LN2569"></a>        <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>eqproc</span><span class='Delimiter'>; 
</span><a name="LN2570"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>hasmatch1</span><span class='Delimiter'>; 
</span><a name="LN2571"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>hasmatch2</span><span class='Delimiter'>; 
</span><a name="LN2572"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac1</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2493"><span class='Ref_To_Local'>stats1</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span><a name="LN2573"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>matchfreq1</span><span class='Delimiter'>, 
</span><a name="LN2574"></a>                    <span class='Declare_Local'>uncertainfrac</span><span class='Delimiter'>, 
</span><a name="LN2575"></a>                    <span class='Declare_Local'>uncertain</span><span class='Delimiter'>; 
</span><a name="LN2576"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN2577"></a>                    <span class='Declare_Local'>nmatches</span><span class='Delimiter'>, 
</span><a name="LN2578"></a>                    <span class='Declare_Local'>clamped_nvalues2</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The clamping above could have resulted in nd2 being less than 
         * sslot2.nvalues; in which case, we assume that precisely the nd2 
         * most common values in the relation will appear in the join input, 
         * and so compare to only the first nd2 members of the MCV list.  Of 
         * course this is frequently wrong, but it's the best bet we can make. 
         */ 
</span>        <a href="selfuncs.c.html#LN2578"><span class='Ref_To_Local'>clamped_nvalues2</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2497"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2492"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2569"><span class='Ref_To_Local'>eqproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2570"><span class='Ref_To_Local'>hasmatch1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2571"><span class='Ref_To_Local'>hasmatch2</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2578"><span class='Ref_To_Local'>clamped_nvalues2</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note we assume that each MCV will match at most one member of the 
         * other MCV list.  If the operator isn't really equality, there could 
         * be multiple matches --- but we don't look for them, both for speed 
         * and because the math wouldn't add up... 
         */ 
</span>        <a href="selfuncs.c.html#LN2577"><span class='Ref_To_Local'>nmatches</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2602"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2602"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2602"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2578"><span class='Ref_To_Local'>clamped_nvalues2</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2602"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2571"><span class='Ref_To_Local'>hasmatch2</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2602"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2569"><span class='Ref_To_Local'>eqproc</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                                   <a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                                   <a href="selfuncs.c.html#LN2497"><span class='Ref_To_Local'>sslot2</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2602"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="selfuncs.c.html#LN2570"><span class='Ref_To_Local'>hasmatch1</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="selfuncs.c.html#LN2571"><span class='Ref_To_Local'>hasmatch2</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2602"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="selfuncs.c.html#LN2577"><span class='Ref_To_Local'>nmatches</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* Sum up frequencies of matched MCVs */ 
</span>        <a href="selfuncs.c.html#LN2573"><span class='Ref_To_Local'>matchfreq1</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2570"><span class='Ref_To_Local'>hasmatch1</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN2573"><span class='Ref_To_Local'>matchfreq1</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN2576"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2573"><span class='Ref_To_Local'>matchfreq1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2570"><span class='Ref_To_Local'>hasmatch1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2571"><span class='Ref_To_Local'>hasmatch2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now we need to estimate the fraction of relation 1 that has at 
         * least one join partner.  We know for certain that the matched MCVs 
         * do, so that gives us a lower bound, but we're really in the dark 
         * about everything else.  Our crude approach is: if nd1 &LT;= nd2 then 
         * assume all non-null rel1 rows have join partners, else assume for 
         * the uncertain rows that a fraction nd2/nd1 have join partners. We 
         * can discount the known-matched MCVs from the distinct-values counts 
         * before doing the division. 
         * 
         * Crude as the above is, it's completely useless if we don't have 
         * reliable ndistinct values for both sides.  Hence, if either nd1 or 
         * nd2 is default, punt and assume half of the uncertain rows have 
         * join partners. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN2490"><span class='Ref_To_Local'>isdefault1</span></a> <span class='Operator'>&& !</span><a href="selfuncs.c.html#LN2491"><span class='Ref_To_Local'>isdefault2</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN2488"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>-= </span><a href="selfuncs.c.html#LN2577"><span class='Ref_To_Local'>nmatches</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>-= </span><a href="selfuncs.c.html#LN2577"><span class='Ref_To_Local'>nmatches</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2488"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>&LT;= </span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN2574"><span class='Ref_To_Local'>uncertainfrac</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN2574"><span class='Ref_To_Local'>uncertainfrac</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN2488"><span class='Ref_To_Local'>nd1</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN2574"><span class='Ref_To_Local'>uncertainfrac</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2575"><span class='Ref_To_Local'>uncertain</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2573"><span class='Ref_To_Local'>matchfreq1</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2572"><span class='Ref_To_Local'>nullfrac1</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2575"><span class='Ref_To_Local'>uncertain</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN2487"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2573"><span class='Ref_To_Local'>matchfreq1</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN2574"><span class='Ref_To_Local'>uncertainfrac</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN2575"><span class='Ref_To_Local'>uncertain</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if have_mcvs1&&have_mcvs... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Without MCV lists for both sides, we can only use the heuristic 
         * about nd1 vs nd2. 
         */ 
</span><a name="LN2666"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>nullfrac1</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2493"><span class='Ref_To_Local'>stats1</span></a> <span class='Operator'>? </span><a href="selfuncs.c.html#LN2493"><span class='Ref_To_Local'>stats1</span></a><span class='Operator'>-&GT;</span>stanullfrac <span class='Operator'>: </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN2490"><span class='Ref_To_Local'>isdefault1</span></a> <span class='Operator'>&& !</span><a href="selfuncs.c.html#LN2491"><span class='Ref_To_Local'>isdefault2</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2488"><span class='Ref_To_Local'>nd1</span></a> <span class='Operator'>&LT;= </span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN2487"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2666"><span class='Ref_To_Local'>nullfrac1</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN2487"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2489"><span class='Ref_To_Local'>nd2</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN2488"><span class='Ref_To_Local'>nd1</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2666"><span class='Ref_To_Local'>nullfrac1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN2487"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2666"><span class='Ref_To_Local'>nullfrac1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2496"><span class='Ref_To_Local'>sslot1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2497"><span class='Ref_To_Local'>sslot2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN2487"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end eqjoinsel_semi &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      neqjoinsel      - Join selectivity of "!=" 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2689"></a><span class='Declare_Function'>neqjoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2691"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>root</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2692"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Keyword'>operator </span><span class='Operator'>= </span><span class='Declare_Local'>PG_GETARG_OID</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2693"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>args</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2694"></a>    <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Local'>jointype</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN235"><span class='Ref_to_Macro'>PG_GETARG_INT16</span></a><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2695"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/fmgr.h.html#LN240"><span class='Ref_to_Macro'>PG_GETARG_POINTER</span></a><span class='Parentheses'>(</span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2696"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eqop</span><span class='Delimiter'>; 
</span><a name="LN2697"></a>    <a href="../../../include/c.h.html#LN380"><span class='Ref_to_Typedef'>float8</span></a>      <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We want 1 - eqjoinsel() where the equality operator is the one 
     * associated with this != operator, that is, its negator. 
     */ 
</span>    <a href="selfuncs.c.html#LN2696"><span class='Ref_To_Local'>eqop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN107"><span class='Ref_to_Proto'>get_negator</span></a><span class='Parentheses'>(</span><span class='Keyword'>operator</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2696"><span class='Ref_To_Local'>eqop</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN2697"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN591"><span class='Ref_to_Macro'>DirectFunctionCall5</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2197"><span class='Ref_to_Func'>eqjoinsel</span></a><span class='Delimiter'>, 
</span>                                                    <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2691"><span class='Ref_To_Local'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                    <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2696"><span class='Ref_To_Local'>eqop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                    <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2693"><span class='Ref_To_Local'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                    <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2694"><span class='Ref_To_Local'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                    <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2695"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Use default selectivity (should we raise an error instead?) */ 
</span>        <a href="selfuncs.c.html#LN2697"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN33"><span class='Ref_to_Const'>DEFAULT_EQ_SEL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="selfuncs.c.html#LN2697"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN2697"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2697"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end neqjoinsel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      scalarltjoinsel - Join selectivity of "&LT;" and "&LT;=" for scalars 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2726"></a><span class='Declare_Function'>scalarltjoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      scalargtjoinsel - Join selectivity of "&GT;" and "&GT;=" for scalars 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2735"></a><span class='Declare_Function'>scalargtjoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * patternjoinsel       - Generic code for pattern-match join selectivity. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN2744"></a><span class='Declare_Function'>patternjoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN87"><span class='Ref_to_Typedef'>Pattern_Type</span></a> <span class='Declare_Parameter'>ptype</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>negate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* For the moment we just punt. */ 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN2744"><span class='Ref_to_Parameter'>negate</span></a> <span class='Operator'>? </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="../../../include/utils/selfuncs.h.html#LN42"><span class='Ref_to_Const'>DEFAULT_MATCH_SEL</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="../../../include/utils/selfuncs.h.html#LN42"><span class='Ref_to_Const'>DEFAULT_MATCH_SEL</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      regexeqjoinsel  - Join selectivity of regular-expression pattern match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2754"></a><span class='Declare_Function'>regexeqjoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      icregexeqjoinsel    - Join selectivity of case-insensitive regex match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2763"></a><span class='Declare_Function'>icregexeqjoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      likejoinsel         - Join selectivity of LIKE pattern match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2772"></a><span class='Declare_Function'>likejoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      iclikejoinsel           - Join selectivity of ILIKE pattern match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2781"></a><span class='Declare_Function'>iclikejoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      regexnejoinsel  - Join selectivity of regex non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2790"></a><span class='Declare_Function'>regexnejoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      icregexnejoinsel    - Join selectivity of case-insensitive regex non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2799"></a><span class='Declare_Function'>icregexnejoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      nlikejoinsel        - Join selectivity of LIKE pattern non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2808"></a><span class='Declare_Function'>nlikejoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      icnlikejoinsel      - Join selectivity of ILIKE pattern non-match. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN2817"></a><span class='Declare_Function'>icnlikejoinsel</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2743"><span class='Ref_to_Func'>patternjoinsel</span></a><span class='Parentheses'>(</span>fcinfo<span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like_IC</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * mergejoinscansel         - Scan selectivity of merge join. 
 * 
 * A merge join will stop as soon as it exhausts either input stream. 
 * Therefore, if we can estimate the ranges of both input variables, 
 * we can estimate how much of the input will actually be read.  This 
 * can have a considerable impact on the cost when using indexscans. 
 * 
 * Also, we can estimate how much of each input has to be read before the 
 * first join pair is found, which will affect the join's startup time. 
 * 
 * clause should be a clause already known to be mergejoinable.  opfamily, 
 * strategy, and nulls_first specify the sort ordering being used. 
 * 
 * The outputs are: 
 *      *leftstart is set to the fraction of the left-hand variable expected 
 *       to be scanned before the first join pair is found (0 to 1). 
 *      *leftend is set to the fraction of the left-hand variable expected 
 *       to be scanned before the join terminates (0 to 1). 
 *      *rightstart, *rightend similarly for the right-hand variable. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2844"></a><span class='Declare_Function'>mergejoinscansel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN2845"></a>                 <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opfamily</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>strategy</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>nulls_first</span><span class='Delimiter'>, 
</span><a name="LN2846"></a>                 <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leftstart</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>leftend</span><span class='Delimiter'>, 
</span><a name="LN2847"></a>                 <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rightstart</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rightend</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2849"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>left</span><span class='Delimiter'>, 
</span><a name="LN2850"></a>               <span class='Operator'>*</span><span class='Declare_Local'>right</span><span class='Delimiter'>; 
</span><a name="LN2851"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>leftvar</span><span class='Delimiter'>, 
</span><a name="LN2852"></a>                <span class='Declare_Local'>rightvar</span><span class='Delimiter'>; 
</span><a name="LN2853"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>op_strategy</span><span class='Delimiter'>; 
</span><a name="LN2854"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>op_lefttype</span><span class='Delimiter'>; 
</span><a name="LN2855"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>op_righttype</span><span class='Delimiter'>; 
</span><a name="LN2856"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opno</span><span class='Delimiter'>, 
</span><a name="LN2857"></a>                <span class='Declare_Local'>lsortop</span><span class='Delimiter'>, 
</span><a name="LN2858"></a>                <span class='Declare_Local'>rsortop</span><span class='Delimiter'>, 
</span><a name="LN2859"></a>                <span class='Declare_Local'>lstatop</span><span class='Delimiter'>, 
</span><a name="LN2860"></a>                <span class='Declare_Local'>rstatop</span><span class='Delimiter'>, 
</span><a name="LN2861"></a>                <span class='Declare_Local'>ltop</span><span class='Delimiter'>, 
</span><a name="LN2862"></a>                <span class='Declare_Local'>leop</span><span class='Delimiter'>, 
</span><a name="LN2863"></a>                <span class='Declare_Local'>revltop</span><span class='Delimiter'>, 
</span><a name="LN2864"></a>                <span class='Declare_Local'>revleop</span><span class='Delimiter'>; 
</span><a name="LN2865"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isgt</span><span class='Delimiter'>; 
</span><a name="LN2866"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>leftmin</span><span class='Delimiter'>, 
</span><a name="LN2867"></a>                <span class='Declare_Local'>leftmax</span><span class='Delimiter'>, 
</span><a name="LN2868"></a>                <span class='Declare_Local'>rightmin</span><span class='Delimiter'>, 
</span><a name="LN2869"></a>                <span class='Declare_Local'>rightmax</span><span class='Delimiter'>; 
</span><a name="LN2870"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set default results if we can't figure anything out. */ 
</span>    <span class='Comment_Multi_Line'>/* XXX should default "start" fraction be a bit more than 0? */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Deconstruct the merge clause */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>    <a href="selfuncs.c.html#LN2856"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN2849"><span class='Ref_To_Local'>left</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN32"><span class='Ref_to_Proto'>get_leftop</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN2850"><span class='Ref_To_Local'>right</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN33"><span class='Ref_to_Proto'>get_rightop</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN2850"><span class='Ref_To_Local'>right</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span> 
    <span class='Comment_Multi_Line'>/* Look for stats for the inputs */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2849"><span class='Ref_To_Local'>left</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2850"><span class='Ref_To_Local'>right</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Extract the operator's declared left/right datatypes */ 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN66"><span class='Ref_to_Proto'>get_op_opfamily_properties</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2856"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="selfuncs.c.html#LN2853"><span class='Ref_To_Local'>op_strategy</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2853"><span class='Ref_To_Local'>op_strategy</span></a> <span class='Operator'>== </span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look up the various operators we need.  If we don't find them all, it 
     * probably means the opfamily is broken, but we just fail silently. 
     * 
     * Note: we expect that pg_statistic histograms will be sorted by the '&LT;' 
     * operator, regardless of which sort direction we are considering. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>strategy</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN2865"><span class='Ref_To_Local'>isgt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a> <span class='Operator'>== </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* easy case */ 
</span>                <a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2857"><span class='Ref_To_Local'>lsortop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2858"><span class='Ref_To_Local'>rsortop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2857"><span class='Ref_To_Local'>lsortop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2860"><span class='Ref_To_Local'>rstatop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2858"><span class='Ref_To_Local'>rsortop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2863"><span class='Ref_To_Local'>revltop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2864"><span class='Ref_To_Local'>revleop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2857"><span class='Ref_To_Local'>lsortop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2858"><span class='Ref_To_Local'>rsortop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2857"><span class='Ref_To_Local'>lsortop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2860"><span class='Ref_To_Local'>rstatop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2858"><span class='Ref_To_Local'>rsortop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2863"><span class='Ref_To_Local'>revltop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2864"><span class='Ref_To_Local'>revleop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* descending-order case */ 
</span>            <a href="selfuncs.c.html#LN2865"><span class='Ref_To_Local'>isgt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a> <span class='Operator'>== </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* easy case */ 
</span>                <a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2857"><span class='Ref_To_Local'>lsortop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2858"><span class='Ref_To_Local'>rsortop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2860"><span class='Ref_To_Local'>rstatop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2863"><span class='Ref_To_Local'>revltop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2864"><span class='Ref_To_Local'>revleop</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2857"><span class='Ref_To_Local'>lsortop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2858"><span class='Ref_To_Local'>rsortop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2860"><span class='Ref_To_Local'>rstatop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2863"><span class='Ref_To_Local'>revltop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN2864"><span class='Ref_To_Local'>revleop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="selfuncs.c.html#LN3131"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* shouldn't get here */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch strategy &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2857"><span class='Ref_To_Local'>lsortop</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2858"><span class='Ref_To_Local'>rsortop</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2860"><span class='Ref_To_Local'>rstatop</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2863"><span class='Ref_To_Local'>revltop</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2864"><span class='Ref_To_Local'>revleop</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="selfuncs.c.html#LN3131"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* insufficient info in catalogs */ 
</span> 
    <span class='Comment_Multi_Line'>/* Try to get ranges of both inputs */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN2865"><span class='Ref_To_Local'>isgt</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN198"><span class='Ref_to_Proto'>get_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="selfuncs.c.html#LN2866"><span class='Ref_To_Local'>leftmin</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2867"><span class='Ref_To_Local'>leftmax</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="selfuncs.c.html#LN3131"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* no range available from stats */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN198"><span class='Ref_to_Proto'>get_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2860"><span class='Ref_To_Local'>rstatop</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="selfuncs.c.html#LN2868"><span class='Ref_To_Local'>rightmin</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2869"><span class='Ref_To_Local'>rightmax</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="selfuncs.c.html#LN3131"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* no range available from stats */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* need to swap the max and min */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN198"><span class='Ref_to_Proto'>get_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2859"><span class='Ref_To_Local'>lstatop</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="selfuncs.c.html#LN2867"><span class='Ref_To_Local'>leftmax</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2866"><span class='Ref_To_Local'>leftmin</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="selfuncs.c.html#LN3131"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* no range available from stats */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN198"><span class='Ref_to_Proto'>get_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2860"><span class='Ref_To_Local'>rstatop</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="selfuncs.c.html#LN2869"><span class='Ref_To_Local'>rightmax</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2868"><span class='Ref_To_Local'>rightmin</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="selfuncs.c.html#LN3131"><span class='Ref_to_Label'>fail</span></a><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* no range available from stats */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now, the fraction of the left variable that will be scanned is the 
     * fraction that's &LT;= the right-side maximum value.  But only believe 
     * non-default estimates, else stick with our 1.0. 
     */ 
</span>    <a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN556"><span class='Ref_to_Func'>scalarineqsel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2862"><span class='Ref_To_Local'>leop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2865"><span class='Ref_To_Local'>isgt</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Delimiter'>, 
</span>                          <a href="selfuncs.c.html#LN2869"><span class='Ref_To_Local'>rightmax</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>!= </span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And similarly for the right variable. */ 
</span>    <a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN556"><span class='Ref_to_Func'>scalarineqsel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2864"><span class='Ref_To_Local'>revleop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2865"><span class='Ref_To_Local'>isgt</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Delimiter'>, 
</span>                          <a href="selfuncs.c.html#LN2867"><span class='Ref_To_Local'>leftmax</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>!= </span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Only one of the two "end" fractions can really be less than 1.0; 
     * believe the smaller estimate and reset the other one to exactly 1.0. If 
     * we get exactly equal estimates (as can easily happen with self-joins), 
     * believe neither. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>&GT; *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>&LT; *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also, the fraction of the left variable that will be scanned before the 
     * first join pair is found is the fraction that's &LT; the right-side 
     * minimum value.  But only believe non-default estimates, else stick with 
     * our own default. 
     */ 
</span>    <a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN556"><span class='Ref_to_Func'>scalarineqsel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2861"><span class='Ref_To_Local'>ltop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2865"><span class='Ref_To_Local'>isgt</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Delimiter'>, 
</span>                          <a href="selfuncs.c.html#LN2868"><span class='Ref_To_Local'>rightmin</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2855"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>!= </span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And similarly for the right variable. */ 
</span>    <a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN556"><span class='Ref_to_Func'>scalarineqsel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2844"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2863"><span class='Ref_To_Local'>revltop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2865"><span class='Ref_To_Local'>isgt</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Delimiter'>, 
</span>                          <a href="selfuncs.c.html#LN2866"><span class='Ref_To_Local'>leftmin</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN2854"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>!= </span><a href="../../../include/utils/selfuncs.h.html#LN36"><span class='Ref_to_Const'>DEFAULT_INEQ_SEL</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN2870"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Only one of the two "start" fractions can really be more than zero; 
     * believe the larger estimate and reset the other one to exactly 0.0. If 
     * we get exactly equal estimates (as can easily happen with self-joins), 
     * believe neither. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>&LT; *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>&GT; *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the sort order is nulls-first, we're going to have to skip over any 
     * nulls too.  These would not have been counted by scalarineqsel, and we 
     * can safely add in this fraction regardless of whether we believe 
     * scalarineqsel's results or not.  But be sure to clamp the sum to 1.0! 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2845"><span class='Ref_to_Parameter'>nulls_first</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3099"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN3099"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN3099"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN3099"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN3099"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN3099"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN3099"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nulls_first &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Disbelieve start &GT;= end, just in case that can happen */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>&GT;= *</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftstart</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2846"><span class='Ref_to_Parameter'>leftend</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a> <span class='Operator'>&GT;= *</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightstart</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN2847"><span class='Ref_to_Parameter'>rightend</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
<a name="LN3131"></a><span class='Label'>fail</span><span class='Operator'>: 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2851"><span class='Ref_To_Local'>leftvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN2852"><span class='Ref_To_Local'>rightvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end mergejoinscansel &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Helper routine for estimate_num_groups: add an item to a list of 
 * GroupVarInfos, but only if it's not known equal to any of the existing 
 * entries. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN3144"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>var</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* might be an expression, not just a Var */ 
</span><a name="LN3145"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rel</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* relation it belongs to */ 
</span><a name="LN3146"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>ndistinct</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* # distinct values */ 
</span><a name="LN3147"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GroupVarInfo</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN3150"></a><span class='Declare_Function'>add_unique_group_var</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>varinfos</span><span class='Delimiter'>, 
</span><a name="LN3151"></a>                     <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>var</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3153"></a>    <a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>varinfo</span><span class='Delimiter'>; 
</span><a name="LN3154"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>ndistinct</span><span class='Delimiter'>; 
</span><a name="LN3155"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault</span><span class='Delimiter'>; 
</span><a name="LN3156"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN3154"><span class='Ref_To_Local'>ndistinct</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3151"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3155"><span class='Ref_To_Local'>isdefault</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cannot use foreach here because of possible list_delete */ 
</span>    <a href="selfuncs.c.html#LN3156"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3156"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3156"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* must advance lc before list_delete possibly pfree's it */ 
</span>        <a href="selfuncs.c.html#LN3156"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3156"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Drop exact duplicates */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3151"><span class='Ref_to_Parameter'>var</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3144"><span class='Ref_to_Member'>var</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Drop known-equal vars, but only if they belong to different 
         * relations (see comments for estimate_num_groups) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3151"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>!= </span><a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3145"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/optimizer/paths.h.html#LN148"><span class='Ref_to_Proto'>exprs_known_equal</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3151"><span class='Ref_to_Parameter'>var</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3144"><span class='Ref_to_Member'>var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3146"><span class='Ref_to_Member'>ndistinct</span></a> <span class='Operator'>&LT;= </span><a href="selfuncs.c.html#LN3154"><span class='Ref_To_Local'>ndistinct</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Keep older item, forget new one */ 
</span>                <span class='Control'>return</span> <a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Delete the older item */ 
</span>                <a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN234"><span class='Ref_to_Proto'>list_delete_ptr</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while lc &raquo; </span> 
 
    <a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3144"><span class='Ref_to_Member'>var</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3151"><span class='Ref_to_Parameter'>var</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3145"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3151"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3146"><span class='Ref_to_Member'>ndistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3154"><span class='Ref_To_Local'>ndistinct</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3153"><span class='Ref_To_Local'>varinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN3150"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end add_unique_group_var &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * estimate_num_groups      - Estimate number of groups in a grouped query 
 * 
 * Given a query having a GROUP BY clause, estimate how many groups there 
 * will be --- ie, the number of distinct combinations of the GROUP BY 
 * expressions. 
 * 
 * This routine is also used to estimate the number of rows emitted by 
 * a DISTINCT filtering step; that is an isomorphic problem.  (Note: 
 * actually, we only use it for DISTINCT when there's no grouping or 
 * aggregation ahead of the DISTINCT.) 
 * 
 * Inputs: 
 *  root - the query 
 *  groupExprs - list of expressions being grouped by 
 *  input_rows - number of rows estimated to arrive at the group/unique 
 *      filter step 
 *  pgset - NULL, or a List** pointing to a grouping set to filter the 
 *      groupExprs against 
 * 
 * Given the lack of any cross-correlation statistics in the system, it's 
 * impossible to do anything really trustworthy with GROUP BY conditions 
 * involving multiple Vars.  We should however avoid assuming the worst 
 * case (all possible cross-product terms actually appear as groups) since 
 * very often the grouped-by Vars are highly correlated.  Our current approach 
 * is as follows: 
 *  1.  Expressions yielding boolean are assumed to contribute two groups, 
 *      independently of their content, and are ignored in the subsequent 
 *      steps.  This is mainly because tests like "col IS NULL" break the 
 *      heuristic used in step 2 especially badly. 
 *  2.  Reduce the given expressions to a list of unique Vars used.  For 
 *      example, GROUP BY a, a + b is treated the same as GROUP BY a, b. 
 *      It is clearly correct not to count the same Var more than once. 
 *      It is also reasonable to treat f(x) the same as x: f() cannot 
 *      increase the number of distinct values (unless it is volatile, 
 *      which we consider unlikely for grouping), but it probably won't 
 *      reduce the number of distinct values much either. 
 *      As a special case, if a GROUP BY expression can be matched to an 
 *      expressional index for which we have statistics, then we treat the 
 *      whole expression as though it were just a Var. 
 *  3.  If the list contains Vars of different relations that are known equal 
 *      due to equivalence classes, then drop all but one of the Vars from each 
 *      known-equal set, keeping the one with smallest estimated # of values 
 *      (since the extra values of the others can't appear in joined rows). 
 *      Note the reason we only consider Vars of different relations is that 
 *      if we considered ones of the same rel, we'd be double-counting the 
 *      restriction selectivity of the equality in the next step. 
 *  4.  For Vars within a single source rel, we multiply together the numbers 
 *      of values, clamp to the number of rows in the rel (divided by 10 if 
 *      more than one Var), and then multiply by a factor based on the 
 *      selectivity of the restriction clauses for that rel.  When there's 
 *      more than one Var, the initial product is probably too high (it's the 
 *      worst case) but clamping to a fraction of the rel's rows seems to be a 
 *      helpful heuristic for not letting the estimate get out of hand.  (The 
 *      factor of 10 is derived from pre-Postgres-7.4 practice.)  The factor 
 *      we multiply by to adjust for the restriction selectivity assumes that 
 *      the restriction clauses are independent of the grouping, which may not 
 *      be a valid assumption, but it's hard to do better. 
 *  5.  If there are Vars from multiple rels, we repeat step 4 for each such 
 *      rel, and multiply the results together. 
 * Note that rels not containing grouped Vars are ignored completely, as are 
 * join clauses.  Such rels cannot increase the number of groups, and we 
 * assume such clauses do not reduce the number either (somewhat bogus, 
 * but we don't have the info to do better). 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN3268"></a><span class='Declare_Function'>estimate_num_groups</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>groupExprs</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>input_rows</span><span class='Delimiter'>, 
</span><a name="LN3269"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>pgset</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3271"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>varinfos</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3272"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numdistinct</span><span class='Delimiter'>; 
</span><a name="LN3273"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN3274"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't ever want to return an estimate of zero groups, as that tends 
     * to lead to division-by-zero and other unpleasantness.  The input_rows 
     * estimate is usually already at least 1, but clamp it just in case it 
     * isn't. 
     */ 
</span>    <a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>input_rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>input_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If no grouping columns, there's exactly one group.  (This can't happen 
     * for normal cases with GROUP BY or DISTINCT, but it is possible for 
     * corner cases with set operations.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>groupExprs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3269"><span class='Ref_to_Parameter'>pgset</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN3269"><span class='Ref_to_Parameter'>pgset</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Count groups derived from boolean grouping expressions.  For other 
     * expressions, find the unique Vars used, treating an expression as a Var 
     * if we can find stats for it.  For each one, record the statistical 
     * estimate of number of distinct values (total in its table, without 
     * regard for filtering). 
     */ 
</span>    <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN3274"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3273"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>groupExprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3304"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>groupexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3273"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3305"></a>        <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN3306"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>varshere</span><span class='Delimiter'>; 
</span><a name="LN3307"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l2</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* is expression in this grouping set? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3269"><span class='Ref_to_Parameter'>pgset</span></a> <span class='Operator'>&& !</span><a href="../../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN3269"><span class='Ref_to_Parameter'>pgset</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3274"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Short-circuit for expressions returning boolean */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3304"><span class='Ref_To_Local'>groupexpr</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If examine_variable is able to deduce anything about the GROUP BY 
         * expression, treat it as a single variable even if it's really more 
         * complicated. 
         */ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3304"><span class='Ref_To_Local'>groupexpr</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN76"><span class='Ref_to_Member'>isunique</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3149"><span class='Ref_to_Func'>add_unique_group_var</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN3304"><span class='Ref_To_Local'>groupexpr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Else pull out the component Vars.  Handle PlaceHolderVars by 
         * recursing into their arguments (effectively assuming that the 
         * PlaceHolderVar doesn't change the number of groups, which boils 
         * down to ignoring the possible addition of nulls to the result set). 
         */ 
</span>        <a href="selfuncs.c.html#LN3306"><span class='Ref_To_Local'>varshere</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3304"><span class='Ref_To_Local'>groupexpr</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../../include/optimizer/var.h.html#LN20"><span class='Ref_to_Const'>PVC_RECURSE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                   <a href="../../../include/optimizer/var.h.html#LN22"><span class='Ref_to_Const'>PVC_RECURSE_WINDOWFUNCS</span></a> <span class='Operator'>| 
</span>                                   <a href="../../../include/optimizer/var.h.html#LN25"><span class='Ref_to_Const'>PVC_RECURSE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we find any variable-free GROUP BY item, then either it is a 
         * constant (and we can ignore it) or it contains a volatile function; 
         * in the latter case we punt and assume that each input row will 
         * yield a distinct group. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3306"><span class='Ref_To_Local'>varshere</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3304"><span class='Ref_To_Local'>groupexpr</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>input_rows</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Else add variables to varinfos list 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3307"><span class='Ref_To_Local'>l2</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3306"><span class='Ref_To_Local'>varshere</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3364"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3307"><span class='Ref_To_Local'>l2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3364"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3149"><span class='Ref_to_Func'>add_unique_group_var</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3364"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3305"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If now no Vars, we must have an all-constant or all-boolean GROUP BY 
     * list. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Guard against out-of-range answers */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>input_rows</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>input_rows</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Group Vars by relation and estimate total numdistinct. 
     * 
     * For each iteration of the outer loop, we process the frontmost Var in 
     * varinfos, plus all other Vars in the same relation.  We remove these 
     * Vars from the newvarinfos list for the next iteration. This is the 
     * easiest way to group Vars of same rel together. 
     */ 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3394"></a>        <a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>varinfo1</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3395"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3394"><span class='Ref_To_Local'>varinfo1</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3145"><span class='Ref_to_Member'>rel</span></a><span class='Delimiter'>; 
</span><a name="LN3396"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>reldistinct</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN3397"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>relmaxndistinct</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a><span class='Delimiter'>; 
</span><a name="LN3398"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>relvarcount</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN3399"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newvarinfos</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3400"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>relvarinfos</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Split the list of varinfos in two - one for the current rel, one 
         * for remaining Vars on other rels. 
         */ 
</span>        <a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3394"><span class='Ref_To_Local'>varinfo1</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3273"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a><span class='Parentheses'>)))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3409"></a>            <a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>varinfo2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3273"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3409"><span class='Ref_To_Local'>varinfo2</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3145"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>== </span><a href="selfuncs.c.html#LN3394"><span class='Ref_To_Local'>varinfo1</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3145"><span class='Ref_to_Member'>rel</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* varinfos on current rel */ 
</span>                <a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3409"><span class='Ref_To_Local'>varinfo2</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* not time to process varinfo2 yet */ 
</span>                <a href="selfuncs.c.html#LN3399"><span class='Ref_To_Local'>newvarinfos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3409"><span class='Ref_To_Local'>varinfo2</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3399"><span class='Ref_To_Local'>newvarinfos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get the numdistinct estimate for the Vars of this rel.  We 
         * iteratively search for multivariate n-distinct with maximum number 
         * of vars; assuming that each var group is independent of the others, 
         * we multiply them together.  Any remaining relvarinfos after no more 
         * multivariate matches are found are assumed independent too, so 
         * their individual ndistinct estimates are multiplied also. 
         * 
         * While iterating, count how many separate numdistinct values we 
         * apply.  We apply a fudge factor below, but only if we multiplied 
         * more than one such values. 
         */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3437"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>mvndistinct</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN172"><span class='Ref_to_Proto'>estimate_multivariate_ndistinct</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>&</span><a href="selfuncs.c.html#LN3437"><span class='Ref_To_Local'>mvndistinct</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN3437"><span class='Ref_To_Local'>mvndistinct</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3397"><span class='Ref_To_Local'>relmaxndistinct</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN3437"><span class='Ref_To_Local'>mvndistinct</span></a><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN3397"><span class='Ref_To_Local'>relmaxndistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3437"><span class='Ref_To_Local'>mvndistinct</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN3398"><span class='Ref_To_Local'>relvarcount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3273"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN3451"></a>                    <a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>varinfo2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3273"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN3451"><span class='Ref_To_Local'>varinfo2</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3146"><span class='Ref_to_Member'>ndistinct</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3397"><span class='Ref_To_Local'>relmaxndistinct</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN3451"><span class='Ref_To_Local'>varinfo2</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3146"><span class='Ref_to_Member'>ndistinct</span></a><span class='Parentheses'>) 
</span>                        <a href="selfuncs.c.html#LN3397"><span class='Ref_To_Local'>relmaxndistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3451"><span class='Ref_To_Local'>varinfo2</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3146"><span class='Ref_to_Member'>ndistinct</span></a><span class='Delimiter'>; 
</span>                    <a href="selfuncs.c.html#LN3398"><span class='Ref_To_Local'>relvarcount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* we're done with this relation */ 
</span>                <a href="selfuncs.c.html#LN3400"><span class='Ref_To_Local'>relvarinfos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while relvarinfos &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Sanity check --- don't divide by zero if empty relation. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN504"><span class='Ref_to_Macro'>IS_SIMPLE_REL</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Clamp to size of rel, or size of rel / 10 if multiple Vars. The 
             * fudge factor is because the Vars are probably correlated but we 
             * don't know by how much.  We should never clamp to less than the 
             * largest ndistinct value for any of the Vars, though, since 
             * there will surely be at least that many groups. 
             */ 
</span><a name="LN3477"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>clamp</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3398"><span class='Ref_To_Local'>relvarcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN3477"><span class='Ref_To_Local'>clamp</span></a> <span class='Operator'>*= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3477"><span class='Ref_To_Local'>clamp</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN3397"><span class='Ref_To_Local'>relmaxndistinct</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="selfuncs.c.html#LN3477"><span class='Ref_To_Local'>clamp</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3397"><span class='Ref_To_Local'>relmaxndistinct</span></a><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* for sanity in case some ndistinct is too large: */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3477"><span class='Ref_To_Local'>clamp</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>                        <a href="selfuncs.c.html#LN3477"><span class='Ref_To_Local'>clamp</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN3477"><span class='Ref_To_Local'>clamp</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3477"><span class='Ref_To_Local'>clamp</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Update the estimate based on the restriction selectivity, 
             * guarding against division by zero when reldistinct is zero. 
             * Also skip this if we know that we are returning all rows. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Given a table containing N rows with n distinct values in a 
                 * uniform distribution, if we select p rows at random then 
                 * the expected number of distinct values selected is 
                 * 
                 * n * (1 - product((N-N/n-i)/(N-i), i=0..p-1)) 
                 * 
                 * = n * (1 - (N-N/n)! / (N-N/n-p)! * (N-p)! / N!) 
                 * 
                 * See "Approximating block accesses in database 
                 * organizations", S. B. Yao, Communications of the ACM, 
                 * Volume 20 Issue 4, April 1977 Pages 260-261. 
                 * 
                 * Alternatively, re-arranging the terms from the factorials, 
                 * this may be written as 
                 * 
                 * n * (1 - product((N-p-i)/(N-i), i=0..N/n-1)) 
                 * 
                 * This form of the formula is more efficient to compute in 
                 * the common case where p is larger than N/n.  Additionally, 
                 * as pointed out by Dell'Era, if i &LT;&LT; N for all terms in the 
                 * product, it can be approximated by 
                 * 
                 * n * (1 - ((N-p)/N)^(N/n)) 
                 * 
                 * See "Expected distinct values when selecting from a bag 
                 * without replacement", Alberto Dell'Era, 
                 * http://www.adellera.it/investigations/distinct_balls/. 
                 * 
                 * The condition i &LT;&LT; N is equivalent to n &GT;&GT; 1, so this is a 
                 * good approximation when the number of distinct values in 
                 * the table is large.  It turns out that this formula also 
                 * works well even when n is small. 
                 */ 
</span>                <a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a> <span class='Operator'>*= 
</span>                    <span class='Parentheses'>(</span><span class='Number'>1</span> <span class='Operator'>- </span>pow<span class='Parentheses'>((</span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>, 
</span>                             <a href="selfuncs.c.html#LN3395"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if reldistinct&GT;0&&rel-&GT;r... &raquo; </span> 
            <a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Update estimate of total distinct groups. 
             */ 
</span>            <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN3396"><span class='Ref_To_Local'>reldistinct</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rel-&GT;tuples&GT;0 &raquo; </span> 
 
        <a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3399"><span class='Ref_To_Local'>newvarinfos</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3271"><span class='Ref_To_Local'>varinfos</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Guard against out-of-range answers */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>input_rows</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3268"><span class='Ref_to_Parameter'>input_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN3272"><span class='Ref_To_Local'>numdistinct</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end estimate_num_groups &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate hash bucketsize fraction (ie, number of entries in a bucket 
 * divided by total tuples in relation) if the specified expression is used 
 * as a hash key. 
 * 
 * XXX This is really pretty bogus since we're effectively assuming that the 
 * distribution of hash keys will be the same after applying restriction 
 * clauses as it was in the underlying relation.  However, we are not nearly 
 * smart enough to figure out how the restrict clauses might change the 
 * distribution, so this will have to do for now. 
 * 
 * We are passed the number of buckets the executor will use for the given 
 * input relation.  If the data were perfectly distributed, with the same 
 * number of tuples going into each available bucket, then the bucketsize 
 * fraction would be 1/nbuckets.  But this happy state of affairs will occur 
 * only if (a) there are at least nbuckets distinct data values, and (b) 
 * we have a not-too-skewed data distribution.  Otherwise the buckets will 
 * be nonuniformly occupied.  If the other relation in the join has a key 
 * distribution similar to this one's, then the most-loaded buckets are 
 * exactly those that will be probed most often.  Therefore, the "average" 
 * bucket size for costing purposes should really be taken as something close 
 * to the "worst case" bucket size.  We try to estimate this by adjusting the 
 * fraction if there are too few distinct data values, and then scaling up 
 * by the ratio of the most common value's frequency to the average frequency. 
 * 
 * If no statistics are available, use a default estimate of 0.1.  This will 
 * discourage use of a hash rather strongly if the inner relation is large, 
 * which is what we want.  We do not want to hash unless we know that the 
 * inner rel is well-dispersed (or the alternatives seem much worse). 
 */ 
</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN3591"></a><span class='Declare_Function'>estimate_hash_bucketsize</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>hashkey</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>nbuckets</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3593"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN3594"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>estfract</span><span class='Delimiter'>, 
</span><a name="LN3595"></a>                <span class='Declare_Local'>ndistinct</span><span class='Delimiter'>, 
</span><a name="LN3596"></a>                <span class='Declare_Local'>stanullfrac</span><span class='Delimiter'>, 
</span><a name="LN3597"></a>                <span class='Declare_Local'>mcvfreq</span><span class='Delimiter'>, 
</span><a name="LN3598"></a>                <span class='Declare_Local'>avgfreq</span><span class='Delimiter'>; 
</span><a name="LN3599"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdefault</span><span class='Delimiter'>; 
</span><a name="LN3600"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3591"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3591"><span class='Ref_to_Parameter'>hashkey</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get number of distinct values */ 
</span>    <a href="selfuncs.c.html#LN3595"><span class='Ref_To_Local'>ndistinct</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN166"><span class='Ref_to_Proto'>get_variable_numdistinct</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3599"><span class='Ref_To_Local'>isdefault</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If ndistinct isn't real, punt and return 0.1, per comments above */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3599"><span class='Ref_To_Local'>isdefault</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Get fraction that are null */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3617"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN3617"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN3596"><span class='Ref_To_Local'>stanullfrac</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3617"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN3596"><span class='Ref_To_Local'>stanullfrac</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compute avg freq of all distinct data values in raw relation */ 
</span>    <a href="selfuncs.c.html#LN3598"><span class='Ref_To_Local'>avgfreq</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN3596"><span class='Ref_To_Local'>stanullfrac</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="selfuncs.c.html#LN3595"><span class='Ref_To_Local'>ndistinct</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Adjust ndistinct to account for restriction clauses.  Observe we are 
     * assuming that the data distribution is affected uniformly by the 
     * restriction clauses! 
     * 
     * XXX Possibly better way, but much more expensive: multiply by 
     * selectivity of rel's restriction clauses that mention the target Var. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN3595"><span class='Ref_To_Local'>ndistinct</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN3595"><span class='Ref_To_Local'>ndistinct</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3595"><span class='Ref_To_Local'>ndistinct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initial estimate of bucketsize fraction is 1/nbuckets as long as the 
     * number of buckets is less than the expected number of distinct values; 
     * otherwise it is 1/ndistinct. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3595"><span class='Ref_To_Local'>ndistinct</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN3591"><span class='Ref_to_Parameter'>nbuckets</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN3591"><span class='Ref_to_Parameter'>nbuckets</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN3595"><span class='Ref_To_Local'>ndistinct</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look up the frequency of the most common value, if available. 
     */ 
</span>    <a href="selfuncs.c.html#LN3597"><span class='Ref_To_Local'>mcvfreq</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3600"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The first MCV stat is for the most common value. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3600"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN3597"><span class='Ref_To_Local'>mcvfreq</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3600"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN3600"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Adjust estimated bucketsize upward to account for skewed distribution. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3598"><span class='Ref_To_Local'>avgfreq</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN3597"><span class='Ref_To_Local'>mcvfreq</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN3598"><span class='Ref_To_Local'>avgfreq</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN3597"><span class='Ref_To_Local'>mcvfreq</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN3598"><span class='Ref_To_Local'>avgfreq</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Clamp bucketsize to sane range (the above adjustment could easily 
     * produce an out-of-range result).  We set the lower bound a little above 
     * zero, since zero isn't a very sane result. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0e</span><span class='Operator'>-</span><span class='Number'>6</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0e</span><span class='Operator'>-</span><span class='Number'>6</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3593"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN3594"><span class='Ref_To_Local'>estfract</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end estimate_hash_bucketsize &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * Support routines 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Find applicable ndistinct statistics for the given list of VarInfos (which 
 * must all belong to the given rel), and update *ndistinct to the estimate of 
 * the MVNDistinctItem that best matches.  If a match it found, *varinfos is 
 * updated to remove the list of matched varinfos. 
 * 
 * Varinfos that aren't for simple Vars are ignored. 
 * 
 * Return TRUE if we're able to find a match, FALSE otherwise. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3712"></a><span class='Declare_Function'>estimate_multivariate_ndistinct</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN3713"></a>                                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>varinfos</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>ndistinct</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3715"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN3716"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>attnums</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3717"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nmatches</span><span class='Delimiter'>; 
</span><a name="LN3718"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>statOid</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN3719"></a>    <a href="../../../include/statistics/statistics.h.html#LN35"><span class='Ref_to_Struct'>MVNDistinct</span></a> <span class='Operator'>*</span><span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span><a name="LN3720"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>matched</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* bail out immediately if the table has no extended statistics */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN3712"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN562"><span class='Ref_to_Member'>statlist</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Determine the attnums we're looking for */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3715"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN3713"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3729"></a>        <a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>varinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3715"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3729"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3145"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>== </span><a href="selfuncs.c.html#LN3712"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3729"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3144"><span class='Ref_to_Member'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN3716"><span class='Ref_To_Local'>attnums</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3716"><span class='Ref_To_Local'>attnums</span></a><span class='Delimiter'>, 
</span>                                     <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN3729"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3144"><span class='Ref_to_Member'>var</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* look for the ndistinct statistics matching the most vars */ 
</span>    <a href="selfuncs.c.html#LN3717"><span class='Ref_To_Local'>nmatches</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>;</span>               <span class='Comment_Single_Line'>/* we require at least two matches */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3715"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3712"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN562"><span class='Ref_to_Member'>statlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3744"></a>        <a href="../../../include/nodes/relation.h.html#LN716"><span class='Ref_to_Struct'>StatisticExtInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>info</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN716"><span class='Ref_to_Struct'>StatisticExtInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3715"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3745"></a>        <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>shared</span><span class='Delimiter'>; 
</span><a name="LN3746"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nshared</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* skip statistics of other kinds */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3744"><span class='Ref_To_Local'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN722"><span class='Ref_to_Member'>kind</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_statistic_ext.h.html#LN76"><span class='Ref_to_Const'>STATS_EXT_NDISTINCT</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* compute attnums shared by the vars and the statistics object */ 
</span>        <a href="selfuncs.c.html#LN3745"><span class='Ref_To_Local'>shared</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN71"><span class='Ref_to_Proto'>bms_intersect</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3744"><span class='Ref_To_Local'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN723"><span class='Ref_to_Member'>keys</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3716"><span class='Ref_To_Local'>attnums</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN3746"><span class='Ref_To_Local'>nshared</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN81"><span class='Ref_to_Proto'>bms_num_members</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3745"><span class='Ref_To_Local'>shared</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Does this statistics object match more columns than the currently 
         * best object?  If so, use this one instead. 
         * 
         * XXX This should break ties using name of the object, or something 
         * like that, to make the outcome stable. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3746"><span class='Ref_To_Local'>nshared</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN3717"><span class='Ref_To_Local'>nmatches</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN3718"><span class='Ref_To_Local'>statOid</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3744"><span class='Ref_To_Local'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN720"><span class='Ref_to_Member'>statOid</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN3717"><span class='Ref_To_Local'>nmatches</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3746"><span class='Ref_To_Local'>nshared</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN3720"><span class='Ref_To_Local'>matched</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3745"><span class='Ref_To_Local'>shared</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* No match? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3718"><span class='Ref_To_Local'>statOid</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3717"><span class='Ref_To_Local'>nmatches</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN3720"><span class='Ref_To_Local'>matched</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN3719"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><a href="../../../include/statistics/statistics.h.html#LN79"><span class='Ref_to_Proto'>statext_ndistinct_load</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3718"><span class='Ref_To_Local'>statOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have a match, search it for the specific item that matches (there 
     * must be one), and construct the output values. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3719"><span class='Ref_To_Local'>stats</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3784"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN3785"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newlist</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN3786"></a>        <a href="../../../include/statistics/statistics.h.html#LN25"><span class='Ref_to_Struct'>MVNDistinctItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>item</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Find the specific item that exactly matches the combination */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3784"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN3784"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN3719"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/statistics/statistics.h.html#LN39"><span class='Ref_to_Member'>nitems</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN3784"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3791"></a>            <a href="../../../include/statistics/statistics.h.html#LN25"><span class='Ref_to_Struct'>MVNDistinctItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tmpitem</span> <span class='Operator'>= &</span><a href="selfuncs.c.html#LN3719"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/statistics/statistics.h.html#LN40"><span class='Ref_to_Member'>items</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN3784"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN74"><span class='Ref_to_Proto'>bms_subset_compare</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3791"><span class='Ref_To_Local'>tmpitem</span></a><span class='Operator'>-&GT;</span><a href="../../../include/statistics/statistics.h.html#LN28"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3720"><span class='Ref_To_Local'>matched</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/bitmapset.h.html#LN46"><span class='Ref_to_EnumConst'>BMS_EQUAL</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN3786"><span class='Ref_To_Local'>item</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3791"><span class='Ref_To_Local'>tmpitem</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* make sure we found an item */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN3786"><span class='Ref_To_Local'>item</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"corrupt MVNDistinct entry"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Form the output varinfo list, keeping only unmatched ones */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3715"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN3713"><span class='Ref_to_Parameter'>varinfos</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3807"></a>            <a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>varinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3142"><span class='Ref_to_Typedef'>GroupVarInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3715"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3808"></a>            <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attnum</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3807"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3144"><span class='Ref_to_Member'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN3785"><span class='Ref_To_Local'>newlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3785"><span class='Ref_To_Local'>newlist</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3807"><span class='Ref_To_Local'>varinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="selfuncs.c.html#LN3808"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN3807"><span class='Ref_To_Local'>varinfo</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN3144"><span class='Ref_to_Member'>var</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno<span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3808"><span class='Ref_To_Local'>attnum</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3720"><span class='Ref_To_Local'>matched</span></a><span class='Parentheses'>))</span> 
                <a href="selfuncs.c.html#LN3785"><span class='Ref_To_Local'>newlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3785"><span class='Ref_To_Local'>newlist</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3807"><span class='Ref_To_Local'>varinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Operator'>*</span><a href="selfuncs.c.html#LN3713"><span class='Ref_to_Parameter'>varinfos</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3785"><span class='Ref_To_Local'>newlist</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN3713"><span class='Ref_to_Parameter'>ndistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN3786"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/statistics/statistics.h.html#LN27"><span class='Ref_to_Member'>ndistinct</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if stats &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end estimate_multivariate_ndistinct &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * convert_to_scalar 
 *    Convert non-NULL values of the indicated types to the comparison 
 *    scale needed by scalarineqsel(). 
 *    Returns "true" if successful. 
 * 
 * XXX this routine is a hack: ideally we should look up the conversion 
 * subroutines in pg_type. 
 * 
 * All numeric datatypes are simply converted to their equivalent 
 * "double" values.  (NUMERIC values that are outside the range of "double" 
 * are clamped to +/- HUGE_VAL.) 
 * 
 * String datatypes are converted by convert_string_to_scalar(), 
 * which is explained below.  The reason why this routine deals with 
 * three values at a time, not just one, is that we need it for strings. 
 * 
 * The bytea datatype is just enough different from strings that it has 
 * to be treated separately. 
 * 
 * The several datatypes representing absolute times are all converted 
 * to Timestamp, which is actually a double, and then we just use that 
 * double value.  Note this will give correct results even for the "special" 
 * values of Timestamp, since those are chosen to compare correctly; 
 * see timestamp_cmp. 
 * 
 * The several datatypes representing relative times (intervals) are all 
 * converted to measurements expressed in seconds. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3859"></a><span class='Declare_Function'>convert_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>valuetypid</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledvalue</span><span class='Delimiter'>, 
</span><a name="LN3860"></a>                  <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>lobound</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>hibound</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>boundstypid</span><span class='Delimiter'>, 
</span><a name="LN3861"></a>                  <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledlobound</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledhibound</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Both the valuetypid and the boundstypid should exactly match the 
     * declared input type(s) of the operator we are invoked for, so we just 
     * error out if either is not recognized. 
     * 
     * XXX The histogram we are interpolating between points of could belong 
     * to a column that's only binary-compatible with the declared type. In 
     * essence we are assuming that the semantics of binary-compatible types 
     * are enough alike that we can use a histogram generated with one type's 
     * operators to estimate selectivity for the other's.  This is outright 
     * wrong in some cases --- in particular signed versus unsigned 
     * interpretation could trip us up.  But it's useful enough in the 
     * majority of cases that we do it anyway.  Should think about more 
     * rigorous ways to do it. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>valuetypid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Built-in numeric types 
             */ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN22"><span class='Ref_to_Const'>INT2OID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN21"><span class='Ref_to_Const'>INT8OID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN38"><span class='Ref_to_Const'>FLOAT4OID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN39"><span class='Ref_to_Const'>FLOAT8OID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN58"><span class='Ref_to_Const'>NUMERICOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN27"><span class='Ref_to_Const'>OIDOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN25"><span class='Ref_to_Const'>REGPROCOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN60"><span class='Ref_to_Const'>REGPROCEDUREOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN61"><span class='Ref_to_Const'>REGOPEROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN62"><span class='Ref_to_Const'>REGOPERATOROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN63"><span class='Ref_to_Const'>REGCLASSOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN64"><span class='Ref_to_Const'>REGTYPEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN73"><span class='Ref_to_Const'>REGCONFIGOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN74"><span class='Ref_to_Const'>REGDICTIONARYOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN65"><span class='Ref_to_Const'>REGROLEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN66"><span class='Ref_to_Const'>REGNAMESPACEOID</span></a><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>scaledvalue</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN177"><span class='Ref_to_Proto'>convert_numeric_to_scalar</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>valuetypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledlobound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN177"><span class='Ref_to_Proto'>convert_numeric_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>lobound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledhibound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN177"><span class='Ref_to_Proto'>convert_numeric_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Built-in string types 
             */ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN19"><span class='Ref_to_Const'>CHAROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN48"><span class='Ref_to_Const'>BPCHAROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN49"><span class='Ref_to_Const'>VARCHAROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN20"><span class='Ref_to_Const'>NAMEOID</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN3915"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>valstr</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN194"><span class='Ref_to_Proto'>convert_string_datum</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>valuetypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3916"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>lostr</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN194"><span class='Ref_to_Proto'>convert_string_datum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>lobound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3917"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>histr</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN194"><span class='Ref_to_Proto'>convert_string_datum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="selfuncs.c.html#LN178"><span class='Ref_to_Proto'>convert_string_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3915"><span class='Ref_To_Local'>valstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>scaledvalue</span></a><span class='Delimiter'>, 
</span>                                         <a href="selfuncs.c.html#LN3916"><span class='Ref_To_Local'>lostr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledlobound</span></a><span class='Delimiter'>, 
</span>                                         <a href="selfuncs.c.html#LN3917"><span class='Ref_To_Local'>histr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledhibound</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3915"><span class='Ref_To_Local'>valstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3916"><span class='Ref_To_Local'>lostr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3917"><span class='Ref_To_Local'>histr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Built-in bytea type 
             */ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN184"><span class='Ref_to_Proto'>convert_bytea_to_scalar</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>scaledvalue</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>lobound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledlobound</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledhibound</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Built-in time types 
             */ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN52"><span class='Ref_to_Const'>TIMESTAMPOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN53"><span class='Ref_to_Const'>TIMESTAMPTZOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN40"><span class='Ref_to_Const'>ABSTIMEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN50"><span class='Ref_to_Const'>DATEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN54"><span class='Ref_to_Const'>INTERVALOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN41"><span class='Ref_to_Const'>RELTIMEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN42"><span class='Ref_to_Const'>TINTERVALOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN51"><span class='Ref_to_Const'>TIMEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN55"><span class='Ref_to_Const'>TIMETZOID</span></a><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>scaledvalue</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN195"><span class='Ref_to_Proto'>convert_timevalue_to_scalar</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>valuetypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledlobound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN195"><span class='Ref_to_Proto'>convert_timevalue_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>lobound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledhibound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN195"><span class='Ref_to_Proto'>convert_timevalue_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Built-in network types 
             */ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN46"><span class='Ref_to_Const'>INETOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN47"><span class='Ref_to_Const'>CIDROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN444"><span class='Ref_to_Const'>MACADDROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN453"><span class='Ref_to_Const'>MACADDR8OID</span></a><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>scaledvalue</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN105"><span class='Ref_to_Proto'>convert_network_to_scalar</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>valuetypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledlobound</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN105"><span class='Ref_to_Proto'>convert_network_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>lobound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledhibound</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN105"><span class='Ref_to_Proto'>convert_network_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3860"><span class='Ref_to_Parameter'>boundstypid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch valuetypid &raquo; </span> 
    <span class='Comment_Multi_Line'>/* Don't know how to convert */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN3859"><span class='Ref_to_Parameter'>scaledvalue</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledlobound</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN3861"><span class='Ref_to_Parameter'>scaledhibound</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_to_scalar &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do convert_to_scalar()'s work for any numeric data type. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN3977"></a><span class='Declare_Function'>convert_numeric_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN3977"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN22"><span class='Ref_to_Const'>INT2OID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN449"><span class='Ref_to_Macro'>DatumGetInt16</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN24"><span class='Ref_to_Const'>INT4OID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN477"><span class='Ref_to_Macro'>DatumGetInt32</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN21"><span class='Ref_to_Const'>INT8OID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN610"><span class='Ref_to_Macro'>DatumGetInt64</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN38"><span class='Ref_to_Const'>FLOAT4OID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN672"><span class='Ref_to_Func'>DatumGetFloat4</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN39"><span class='Ref_to_Const'>FLOAT8OID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN58"><span class='Ref_to_Const'>NUMERICOID</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Note: out-of-range values will be clamped to +-HUGE_VAL */ 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) 
</span>                <a href="../../../include/postgres.h.html#LN720"><span class='Ref_to_Func'>DatumGetFloat8</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN583"><span class='Ref_to_Macro'>DirectFunctionCall1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/builtins.h.html#LN111"><span class='Ref_to_Proto'>numeric_float8_no_overflow</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Keyword'>value</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN27"><span class='Ref_to_Const'>OIDOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN25"><span class='Ref_to_Const'>REGPROCOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN60"><span class='Ref_to_Const'>REGPROCEDUREOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN61"><span class='Ref_to_Const'>REGOPEROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN62"><span class='Ref_to_Const'>REGOPERATOROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN63"><span class='Ref_to_Const'>REGCLASSOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN64"><span class='Ref_to_Const'>REGTYPEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN73"><span class='Ref_to_Const'>REGCONFIGOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN74"><span class='Ref_to_Const'>REGDICTIONARYOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN65"><span class='Ref_to_Const'>REGROLEOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN66"><span class='Ref_to_Const'>REGNAMESPACEOID</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* we can treat OIDs as integers... */ 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN505"><span class='Ref_to_Macro'>DatumGetObjectId</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch typid &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Can't get here unless someone tries to use scalarltsel/scalargtsel on 
     * an operator with one numeric and one non-numeric operand. 
     */ 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported type: %u"</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN3977"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_numeric_to_scalar &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do convert_to_scalar()'s work for any character-string data type. 
 * 
 * String datatypes are converted to a scale that ranges from 0 to 1, 
 * where we visualize the bytes of the string as fractional digits. 
 * 
 * We do not want the base to be 256, however, since that tends to 
 * generate inflated selectivity estimates; few databases will have 
 * occurrences of all 256 possible byte values at each position. 
 * Instead, use the smallest and largest byte values seen in the bounds 
 * as the estimated range for each byte, after some fudging to deal with 
 * the fact that we probably aren't going to see the full range that way. 
 * 
 * An additional refinement is that we discard any common prefix of the 
 * three strings before computing the scaled values.  This allows us to 
 * "zoom in" when we encounter a narrow data range.  An example is a phone 
 * number database where all the values begin with the same area code. 
 * (Actually, the bounds will be adjacent histogram-bin-boundary values, 
 * so this is more likely to happen than you might think.) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4042"></a><span class='Declare_Function'>convert_string_to_scalar</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>value</span><span class='Delimiter'>, 
</span><a name="LN4043"></a>                         <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledvalue</span><span class='Delimiter'>, 
</span><a name="LN4044"></a>                         <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>lobound</span><span class='Delimiter'>, 
</span><a name="LN4045"></a>                         <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledlobound</span><span class='Delimiter'>, 
</span><a name="LN4046"></a>                         <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>hibound</span><span class='Delimiter'>, 
</span><a name="LN4047"></a>                         <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledhibound</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4049"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>rangelo</span><span class='Delimiter'>, 
</span><a name="LN4050"></a>                <span class='Declare_Local'>rangehi</span><span class='Delimiter'>; 
</span><a name="LN4051"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>sptr</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN4046"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4044"><span class='Ref_to_Parameter'>lobound</span></a><span class='Delimiter'>; </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&GT; </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4046"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>; </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&GT; </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4051"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* If range includes any upper-case ASCII chars, make it include all */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&LT;= </span><span class='String'>'Z'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&GT;= </span><span class='String'>'A'</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&GT; </span><span class='String'>'A'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><span class='String'>'A'</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&LT; </span><span class='String'>'Z'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='String'>'Z'</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Ditto lower-case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&LT;= </span><span class='String'>'z'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&GT;= </span><span class='String'>'a'</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&GT; </span><span class='String'>'a'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><span class='String'>'a'</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&LT; </span><span class='String'>'z'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='String'>'z'</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Ditto digits */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&LT;= </span><span class='String'>'9'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&GT;= </span><span class='String'>'0'</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&GT; </span><span class='String'>'0'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><span class='String'>'0'</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>&LT; </span><span class='String'>'9'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='String'>'9'</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If range includes less than 10 chars, assume we have not got enough 
     * data, and make it include regular ASCII set. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>&LT; </span><span class='Number'>9</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><span class='String'>' '</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='Number'>127</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now strip any common prefix of the three strings. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4044"><span class='Ref_to_Parameter'>lobound</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4044"><span class='Ref_to_Parameter'>lobound</span></a> <span class='Operator'>!= *</span><a href="selfuncs.c.html#LN4046"><span class='Ref_to_Parameter'>hibound</span></a> <span class='Operator'>|| *</span><a href="selfuncs.c.html#LN4044"><span class='Ref_to_Parameter'>lobound</span></a> <span class='Operator'>!= *</span><span class='Keyword'>value</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4044"><span class='Ref_to_Parameter'>lobound</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4046"><span class='Ref_to_Parameter'>hibound</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><span class='Keyword'>value</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now we can do the conversions. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4043"><span class='Ref_to_Parameter'>scaledvalue</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN190"><span class='Ref_to_Proto'>convert_one_string_to_scalar</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4045"><span class='Ref_to_Parameter'>scaledlobound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN190"><span class='Ref_to_Proto'>convert_one_string_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4044"><span class='Ref_to_Parameter'>lobound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4047"><span class='Ref_to_Parameter'>scaledhibound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN190"><span class='Ref_to_Proto'>convert_one_string_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4046"><span class='Ref_to_Parameter'>hibound</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4049"><span class='Ref_To_Local'>rangelo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4050"><span class='Ref_To_Local'>rangehi</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_string_to_scalar &raquo; </span> 
 
<span class='Keyword'>static double 
</span><a name="LN4122"></a><span class='Declare_Function'>convert_one_string_to_scalar</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>rangelo</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>rangehi</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4124"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>slen</span> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4125"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>num</span><span class='Delimiter'>, 
</span><a name="LN4126"></a>                <span class='Declare_Local'>denom</span><span class='Delimiter'>, 
</span><a name="LN4127"></a>                <span class='Declare_Local'>base</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4124"><span class='Ref_To_Local'>slen</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* empty string has scalar value 0 */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * There seems little point in considering more than a dozen bytes from 
     * the string.  Since base is at least 10, that will give us nominal 
     * resolution of at least 12 decimal digits, which is surely far more 
     * precision than this estimation technique has got anyway (especially in 
     * non-C locales).  Also, even with the maximum possible base of 256, this 
     * ensures denom cannot grow larger than 256^13 = 2.03e31, which will not 
     * overflow on any known machine. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4124"><span class='Ref_To_Local'>slen</span></a> <span class='Operator'>&GT; </span><span class='Number'>12</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN4124"><span class='Ref_To_Local'>slen</span></a> <span class='Operator'>= </span><span class='Number'>12</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Convert initial characters to fraction */ 
</span>    <a href="selfuncs.c.html#LN4127"><span class='Ref_To_Local'>base</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4122"><span class='Ref_to_Parameter'>rangehi</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN4122"><span class='Ref_to_Parameter'>rangelo</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4125"><span class='Ref_To_Local'>num</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4126"><span class='Ref_To_Local'>denom</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4127"><span class='Ref_To_Local'>base</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4124"><span class='Ref_To_Local'>slen</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4150"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>ch</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><span class='Operator'>*</span><span class='Keyword'>value</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4150"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN4122"><span class='Ref_to_Parameter'>rangelo</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4150"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4122"><span class='Ref_to_Parameter'>rangelo</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4150"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN4122"><span class='Ref_to_Parameter'>rangehi</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4150"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4122"><span class='Ref_to_Parameter'>rangehi</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4125"><span class='Ref_To_Local'>num</span></a> <span class='Operator'>+= </span><span class='Parentheses'>((</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN4150"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN4122"><span class='Ref_to_Parameter'>rangelo</span></a><span class='Parentheses'>))</span> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN4126"><span class='Ref_To_Local'>denom</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4126"><span class='Ref_To_Local'>denom</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN4127"><span class='Ref_To_Local'>base</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN4125"><span class='Ref_To_Local'>num</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_one_string_to_scalar &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Convert a string-type Datum into a palloc'd, null-terminated string. 
 * 
 * When using a non-C locale, we must pass the string through strxfrm() 
 * before continuing, so as to generate correct locale-specific results. 
 */ 
</span><span class='Keyword'>static char </span><span class='Operator'>* 
</span><a name="LN4170"></a><span class='Declare_Function'>convert_string_datum</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4172"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>val</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4170"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN19"><span class='Ref_to_Const'>CHAROID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN414"><span class='Ref_to_Macro'>DatumGetChar</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN48"><span class='Ref_to_Const'>BPCHAROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN49"><span class='Ref_to_Const'>VARCHAROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN20"><span class='Ref_to_Const'>NAMEOID</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN4188"></a>                <a href="../../../include/c.h.html#LN492"><span class='Ref_to_Typedef'>NameData</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>nm</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN492"><span class='Ref_to_Typedef'>NameData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4188"><span class='Ref_To_Local'>nm</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Can't get here unless someone tries to use scalarltsel on an 
             * operator with one string and one non-string operand. 
             */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported type: %u"</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4170"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch typid &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/pg_locale.h.html#LN50"><span class='Ref_to_Proto'>lc_collate_is_c</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4205"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>xfrmstr</span><span class='Delimiter'>; 
</span><a name="LN4206"></a>        size_t      <span class='Declare_Local'>xfrmlen</span><span class='Delimiter'>; 
</span><a name="LN4207"></a>        size_t xfrmlen2 <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * XXX: We could guess at a suitable output buffer size and only call 
         * strxfrm twice if our guess is too small. 
         * 
         * XXX: strxfrm doesn't support UTF-8 encoding on Win32, it can return 
         * bogus data or set an error. This is not really a problem unless it 
         * crashes since it will only give an estimation error and nothing 
         * fatal. 
         */ 
</span><span class='Directive'>#if</span> _MSC_VER <span class='Operator'>== </span><span class='Number'>1400</span>            <span class='Comment_Single_Line'>/* VS.Net 2005 */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * 
         * http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx? 
         * FeedbackID=99694 */ 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4225"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>x</span><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
            <a href="selfuncs.c.html#LN4206"><span class='Ref_To_Local'>xfrmlen</span></a> <span class='Operator'>= </span>strxfrm<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4225"><span class='Ref_To_Local'>x</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span><span class='Directive'>#else</span> 
        <a href="selfuncs.c.html#LN4206"><span class='Ref_To_Local'>xfrmlen</span></a> <span class='Operator'>= </span>strxfrm<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a> 
 
        <span class='Comment_Multi_Line'>/* 
         * On Windows, strxfrm returns INT_MAX when an error occurs. Instead 
         * of trying to allocate this much memory (and fail), just return the 
         * original string unmodified as if we were in the C locale. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4206"><span class='Ref_To_Local'>xfrmlen</span></a> <span class='Operator'>== </span>INT_MAX<span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <a href="selfuncs.c.html#LN4205"><span class='Ref_To_Local'>xfrmstr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4206"><span class='Ref_To_Local'>xfrmlen</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        xfrmlen2 <span class='Operator'>= </span>strxfrm<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4205"><span class='Ref_To_Local'>xfrmstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4206"><span class='Ref_To_Local'>xfrmlen</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Some systems (e.g., glibc) can return a smaller value from the 
         * second call than the first; thus the Assert must be &LT;= not ==. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span>xfrmlen2 <span class='Operator'>&LT;= </span><a href="selfuncs.c.html#LN4206"><span class='Ref_To_Local'>xfrmlen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4205"><span class='Ref_To_Local'>xfrmstr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !lc_collate_is_c(DEFA... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN4172"><span class='Ref_To_Local'>val</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_string_datum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do convert_to_scalar()'s work for any bytea data type. 
 * 
 * Very similar to convert_string_to_scalar except we can't assume 
 * null-termination and therefore pass explicit lengths around. 
 * 
 * Also, assumptions about likely "normal" ranges of characters have been 
 * removed - a data range of 0..255 is always used, for now.  (Perhaps 
 * someday we will add information about actual byte data range to 
 * pg_statistic.) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4269"></a><span class='Declare_Function'>convert_bytea_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, 
</span><a name="LN4270"></a>                        <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledvalue</span><span class='Delimiter'>, 
</span><a name="LN4271"></a>                        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>lobound</span><span class='Delimiter'>, 
</span><a name="LN4272"></a>                        <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledlobound</span><span class='Delimiter'>, 
</span><a name="LN4273"></a>                        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>hibound</span><span class='Delimiter'>, 
</span><a name="LN4274"></a>                        <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>scaledhibound</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4276"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>rangelo</span><span class='Delimiter'>, 
</span><a name="LN4277"></a>                <span class='Declare_Local'>rangehi</span><span class='Delimiter'>, 
</span><a name="LN4278"></a>                <span class='Declare_Local'>valuelen</span> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN303"><span class='Ref_to_Macro'>VARSIZE</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>))</span> <span class='Operator'>- </span><a href="../../../include/c.h.html#LN444"><span class='Ref_to_Const'>VARHDRSZ</span></a><span class='Delimiter'>, 
</span><a name="LN4279"></a>                <span class='Declare_Local'>loboundlen</span> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN303"><span class='Ref_to_Macro'>VARSIZE</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4271"><span class='Ref_to_Parameter'>lobound</span></a><span class='Parentheses'>))</span> <span class='Operator'>- </span><a href="../../../include/c.h.html#LN444"><span class='Ref_to_Const'>VARHDRSZ</span></a><span class='Delimiter'>, 
</span><a name="LN4280"></a>                <span class='Declare_Local'>hiboundlen</span> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN303"><span class='Ref_to_Macro'>VARSIZE</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4273"><span class='Ref_to_Parameter'>hibound</span></a><span class='Parentheses'>))</span> <span class='Operator'>- </span><a href="../../../include/c.h.html#LN444"><span class='Ref_to_Const'>VARHDRSZ</span></a><span class='Delimiter'>, 
</span><a name="LN4281"></a>                <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN4282"></a>                <span class='Declare_Local'>minlen</span><span class='Delimiter'>; 
</span><a name="LN4283"></a>    <span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Declare_Local'>valstr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN302"><span class='Ref_to_Macro'>VARDATA</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span><a name="LN4284"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lostr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN302"><span class='Ref_to_Macro'>VARDATA</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4271"><span class='Ref_to_Parameter'>lobound</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span><a name="LN4285"></a>               <span class='Operator'>*</span><span class='Declare_Local'>histr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN302"><span class='Ref_to_Macro'>VARDATA</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4273"><span class='Ref_to_Parameter'>hibound</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Assume bytea data is uniformly distributed across all byte values. 
     */ 
</span>    <a href="selfuncs.c.html#LN4276"><span class='Ref_To_Local'>rangelo</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4277"><span class='Ref_To_Local'>rangehi</span></a> <span class='Operator'>= </span><span class='Number'>255</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now strip any common prefix of the three strings. 
     */ 
</span>    <a href="selfuncs.c.html#LN4282"><span class='Ref_To_Local'>minlen</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4278"><span class='Ref_To_Local'>valuelen</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4279"><span class='Ref_To_Local'>loboundlen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4280"><span class='Ref_To_Local'>hiboundlen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4281"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN4281"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN4282"><span class='Ref_To_Local'>minlen</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN4281"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4284"><span class='Ref_To_Local'>lostr</span></a> <span class='Operator'>!= *</span><a href="selfuncs.c.html#LN4285"><span class='Ref_To_Local'>histr</span></a> <span class='Operator'>|| *</span><a href="selfuncs.c.html#LN4284"><span class='Ref_To_Local'>lostr</span></a> <span class='Operator'>!= *</span><a href="selfuncs.c.html#LN4283"><span class='Ref_To_Local'>valstr</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4284"><span class='Ref_To_Local'>lostr</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4285"><span class='Ref_To_Local'>histr</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4283"><span class='Ref_To_Local'>valstr</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4279"><span class='Ref_To_Local'>loboundlen</span></a><span class='Operator'>--</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4280"><span class='Ref_To_Local'>hiboundlen</span></a><span class='Operator'>--</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4278"><span class='Ref_To_Local'>valuelen</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now we can do the conversions. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4270"><span class='Ref_to_Parameter'>scaledvalue</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN192"><span class='Ref_to_Proto'>convert_one_bytea_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4283"><span class='Ref_To_Local'>valstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4278"><span class='Ref_To_Local'>valuelen</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4276"><span class='Ref_To_Local'>rangelo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4277"><span class='Ref_To_Local'>rangehi</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4272"><span class='Ref_to_Parameter'>scaledlobound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN192"><span class='Ref_to_Proto'>convert_one_bytea_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4284"><span class='Ref_To_Local'>lostr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4279"><span class='Ref_To_Local'>loboundlen</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4276"><span class='Ref_To_Local'>rangelo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4277"><span class='Ref_To_Local'>rangehi</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4274"><span class='Ref_to_Parameter'>scaledhibound</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN192"><span class='Ref_to_Proto'>convert_one_bytea_to_scalar</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4285"><span class='Ref_To_Local'>histr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4280"><span class='Ref_To_Local'>hiboundlen</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4276"><span class='Ref_To_Local'>rangelo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4277"><span class='Ref_To_Local'>rangehi</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_bytea_to_scalar &raquo; </span> 
 
<span class='Keyword'>static double 
</span><a name="LN4314"></a><span class='Declare_Function'>convert_one_bytea_to_scalar</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>valuelen</span><span class='Delimiter'>, 
</span><a name="LN4315"></a>                            <span class='Keyword'>int </span><span class='Declare_Parameter'>rangelo</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>rangehi</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4317"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>num</span><span class='Delimiter'>, 
</span><a name="LN4318"></a>                <span class='Declare_Local'>denom</span><span class='Delimiter'>, 
</span><a name="LN4319"></a>                <span class='Declare_Local'>base</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4314"><span class='Ref_to_Parameter'>valuelen</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* empty string has scalar value 0 */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since base is 256, need not consider more than about 10 chars (even 
     * this many seems like overkill) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4314"><span class='Ref_to_Parameter'>valuelen</span></a> <span class='Operator'>&GT; </span><span class='Number'>10</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN4314"><span class='Ref_to_Parameter'>valuelen</span></a> <span class='Operator'>= </span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Convert initial characters to fraction */ 
</span>    <a href="selfuncs.c.html#LN4319"><span class='Ref_To_Local'>base</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4315"><span class='Ref_to_Parameter'>rangehi</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN4315"><span class='Ref_to_Parameter'>rangelo</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4317"><span class='Ref_To_Local'>num</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4318"><span class='Ref_To_Local'>denom</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4319"><span class='Ref_To_Local'>base</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4314"><span class='Ref_to_Parameter'>valuelen</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4337"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>ch</span> <span class='Operator'>= *</span><span class='Keyword'>value</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4337"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN4315"><span class='Ref_to_Parameter'>rangelo</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4337"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4315"><span class='Ref_to_Parameter'>rangelo</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4337"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN4315"><span class='Ref_to_Parameter'>rangehi</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN4337"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4315"><span class='Ref_to_Parameter'>rangehi</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4317"><span class='Ref_To_Local'>num</span></a> <span class='Operator'>+= </span><span class='Parentheses'>((</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN4337"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN4315"><span class='Ref_to_Parameter'>rangelo</span></a><span class='Parentheses'>))</span> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN4318"><span class='Ref_To_Local'>denom</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4318"><span class='Ref_To_Local'>denom</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN4319"><span class='Ref_To_Local'>base</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN4317"><span class='Ref_To_Local'>num</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_one_bytea_to_scalar &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do convert_to_scalar()'s work for any timevalue data type. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN4354"></a><span class='Declare_Function'>convert_timevalue_to_scalar</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>value</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4354"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN52"><span class='Ref_to_Const'>TIMESTAMPOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/utils/timestamp.h.html#LN26"><span class='Ref_to_Macro'>DatumGetTimestamp</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN53"><span class='Ref_to_Const'>TIMESTAMPTZOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/utils/timestamp.h.html#LN27"><span class='Ref_to_Macro'>DatumGetTimestampTz</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN40"><span class='Ref_to_Const'>ABSTIMEOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/utils/timestamp.h.html#LN26"><span class='Ref_to_Macro'>DatumGetTimestamp</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN583"><span class='Ref_to_Macro'>DirectFunctionCall1</span></a><span class='Parentheses'>(</span><a href="nabstime.c.html#LN465"><span class='Ref_to_Func'>abstime_timestamp</span></a><span class='Delimiter'>, 
</span>                                                         <span class='Keyword'>value</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN50"><span class='Ref_to_Const'>DATEOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/utils/date.h.html#LN70"><span class='Ref_to_Proto'>date2timestamp_no_overflow</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/date.h.html#LN51"><span class='Ref_to_Macro'>DatumGetDateADT</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN54"><span class='Ref_to_Const'>INTERVALOID</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN4369"></a>                <a href="../../../include/datatype/timestamp.h.html#LN42"><span class='Ref_to_Typedef'>Interval</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>interval</span> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN28"><span class='Ref_to_Macro'>DatumGetIntervalP</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Convert the month part of Interval to days using assumed 
                 * average month length of 365.25/12.0 days.  Not too 
                 * accurate, but plenty good enough for our purposes. 
                 */ 
</span>                <span class='Control'>return</span> <a href="selfuncs.c.html#LN4369"><span class='Ref_To_Local'>interval</span></a><span class='Operator'>-&GT;</span><a href="../../../interfaces/ecpg/include/pgtypes_interval.h.html#LN27"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN4369"><span class='Ref_To_Local'>interval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/datatype/timestamp.h.html#LN46"><span class='Ref_to_Member'>day</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/datatype/timestamp.h.html#LN90"><span class='Ref_to_Const'>USECS_PER_DAY</span></a> <span class='Operator'>+ 
</span>                    <a href="selfuncs.c.html#LN4369"><span class='Ref_To_Local'>interval</span></a><span class='Operator'>-&GT;</span><a href="../../../interfaces/ecpg/include/pgtypes_interval.h.html#LN28"><span class='Ref_to_Member'>month</span></a> <span class='Operator'>* </span><span class='Parentheses'>((</span><a href="../../../include/datatype/timestamp.h.html#LN67"><span class='Ref_to_Const'>DAYS_PER_YEAR</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="../../../include/datatype/timestamp.h.html#LN68"><span class='Ref_to_Const'>MONTHS_PER_YEAR</span></a><span class='Parentheses'>)</span> <span class='Operator'>* </span><a href="../../../include/datatype/timestamp.h.html#LN90"><span class='Ref_to_Const'>USECS_PER_DAY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN41"><span class='Ref_to_Const'>RELTIMEOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/utils/nabstime.h.html#LN50"><span class='Ref_to_Macro'>DatumGetRelativeTime</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>1000000</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN42"><span class='Ref_to_Const'>TINTERVALOID</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN4383"></a>                <a href="../../../include/utils/nabstime.h.html#LN44"><span class='Ref_to_Typedef'>TimeInterval</span></a> <span class='Declare_Local'>tinterval</span> <span class='Operator'>= </span><a href="../../../include/utils/nabstime.h.html#LN51"><span class='Ref_to_Macro'>DatumGetTimeInterval</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4383"><span class='Ref_To_Local'>tinterval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/nabstime.h.html#LN40"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Parentheses'>((</span><a href="selfuncs.c.html#LN4383"><span class='Ref_To_Local'>tinterval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/nabstime.h.html#LN41"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>- </span><a href="selfuncs.c.html#LN4383"><span class='Ref_To_Local'>tinterval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/nabstime.h.html#LN41"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>1000000</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* for lack of a better idea */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN51"><span class='Ref_to_Const'>TIMEOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/utils/date.h.html#LN52"><span class='Ref_to_Macro'>DatumGetTimeADT</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN55"><span class='Ref_to_Const'>TIMETZOID</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span><a name="LN4393"></a>                <a href="../../../include/utils/date.h.html#LN25"><span class='Ref_to_Typedef'>TimeTzADT</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>timetz</span> <span class='Operator'>= </span><a href="../../../include/utils/date.h.html#LN53"><span class='Ref_to_Macro'>DatumGetTimeTzADTP</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* use GMT-equivalent time */ 
</span>                <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN4393"><span class='Ref_To_Local'>timetz</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/date.h.html#LN27"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4393"><span class='Ref_To_Local'>timetz</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/date.h.html#LN28"><span class='Ref_to_Member'>zone</span></a> <span class='Operator'>* </span><span class='Number'>1000000</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch typid &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Can't get here unless someone tries to use scalarltsel/scalargtsel on 
     * an operator with one timevalue and one non-timevalue operand. 
     */ 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported type: %u"</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4354"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end convert_timevalue_to_scalar &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * get_restriction_variable 
 *      Examine the args of a restriction clause to see if it's of the 
 *      form (variable op pseudoconstant) or (pseudoconstant op variable), 
 *      where "variable" could be either a Var or an expression in vars of a 
 *      single relation.  If so, extract information about the variable, 
 *      and also indicate which side it was on and the other argument. 
 * 
 * Inputs: 
 *  root: the planner info 
 *  args: clause argument list 
 *  varRelid: see specs for restriction selectivity functions 
 * 
 * Outputs: (these are valid only if TRUE is returned) 
 *  *vardata: gets information about variable (see examine_variable) 
 *  *other: gets other clause argument, aggressively reduced to a constant 
 *  *varonleft: set TRUE if variable is on the left, FALSE if on the right 
 * 
 * Returns TRUE if a variable is identified, otherwise FALSE. 
 * 
 * Note: if there are Vars on both sides of the clause, we must fail, because 
 * callers are expecting that the other side will act like a pseudoconstant. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN4433"></a><span class='Declare_Function'>get_restriction_variable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>varRelid</span><span class='Delimiter'>, 
</span><a name="LN4434"></a>                         <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>other</span><span class='Delimiter'>, 
</span><a name="LN4435"></a>                         <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>varonleft</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4437"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>left</span><span class='Delimiter'>, 
</span><a name="LN4438"></a>               <span class='Operator'>*</span><span class='Declare_Local'>right</span><span class='Delimiter'>; 
</span><a name="LN4439"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>rdata</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fail if not a binary opclause (probably shouldn't happen) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN4437"><span class='Ref_To_Local'>left</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4438"><span class='Ref_To_Local'>right</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Examine both sides.  Note that when varRelid is nonzero, Vars of other 
     * relations will be treated as pseudoconstants. 
     */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4437"><span class='Ref_To_Local'>left</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4438"><span class='Ref_To_Local'>right</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN4439"><span class='Ref_To_Local'>rdata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If one side is a variable and the other not, we win. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN4439"><span class='Ref_To_Local'>rdata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4435"><span class='Ref_to_Parameter'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>other</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4439"><span class='Ref_To_Local'>rdata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Assume we need no ReleaseVariableStats(rdata) here */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="selfuncs.c.html#LN4439"><span class='Ref_To_Local'>rdata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4435"><span class='Ref_to_Parameter'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>other</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4433"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Assume we need no ReleaseVariableStats(*vardata) here */ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>vardata</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4439"><span class='Ref_To_Local'>rdata</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Oops, clause has wrong structure (probably var op var) */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN4434"><span class='Ref_to_Parameter'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4439"><span class='Ref_To_Local'>rdata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_restriction_variable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_join_variables 
 *      Apply examine_variable() to each side of a join clause. 
 *      Also, attempt to identify whether the join clause has the same 
 *      or reversed sense compared to the SpecialJoinInfo. 
 * 
 * We consider the join clause "normal" if it is "lhs_var OP rhs_var", 
 * or "reversed" if it is "rhs_var OP lhs_var".  In complicated cases 
 * where we can't tell for sure, we default to assuming it's normal. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4493"></a><span class='Declare_Function'>get_join_variables</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>args</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN4494"></a>                   <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata1</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata2</span><span class='Delimiter'>, 
</span><a name="LN4495"></a>                   <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>join_is_reversed</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4497"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>left</span><span class='Delimiter'>, 
</span><a name="LN4498"></a>               <span class='Operator'>*</span><span class='Declare_Local'>right</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4493"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"join operator should take two arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN4497"><span class='Ref_To_Local'>left</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4493"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4498"><span class='Ref_To_Local'>right</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4493"><span class='Ref_to_Parameter'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4493"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4497"><span class='Ref_To_Local'>left</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4494"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN154"><span class='Ref_to_Proto'>examine_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4493"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4498"><span class='Ref_To_Local'>right</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4494"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4494"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4494"><span class='Ref_to_Parameter'>vardata1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4493"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4495"><span class='Ref_to_Parameter'>join_is_reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* var1 is on RHS */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4494"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>&& 
</span>             <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4494"><span class='Ref_to_Parameter'>vardata2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4493"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Parentheses'>))</span> 
        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4495"><span class='Ref_to_Parameter'>join_is_reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* var2 is on LHS */ 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4495"><span class='Ref_to_Parameter'>join_is_reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_join_variables &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * examine_variable 
 *      Try to look up statistical data about an expression. 
 *      Fill in a VariableStatData struct to describe the expression. 
 * 
 * Inputs: 
 *  root: the planner info 
 *  node: the expression tree to examine 
 *  varRelid: see specs for restriction selectivity functions 
 * 
 * Outputs: *vardata is filled as follows: 
 *  var: the input expression (with any binary relabeling stripped, if 
 *      it is or contains a variable; but otherwise the type is preserved) 
 *  rel: RelOptInfo for relation containing variable; NULL if expression 
 *      contains no Vars (NOTE this could point to a RelOptInfo of a 
 *      subquery, not one in the current query). 
 *  statsTuple: the pg_statistic entry for the variable, if one exists; 
 *      otherwise NULL. 
 *  freefunc: pointer to a function to release statsTuple with. 
 *  vartype: exposed type of the expression; this should always match 
 *      the declared input type of the operator we are estimating for. 
 *  atttype, atttypmod: actual type/typmod of the "var" expression.  This is 
 *      commonly the same as the exposed type of the variable argument, 
 *      but can be different in binary-compatible-type cases. 
 *  isunique: TRUE if we were able to match the var to a unique index or a 
 *      single-column DISTINCT clause, implying its values are unique for 
 *      this query.  (Caution: this should be trusted for statistical 
 *      purposes only, since we do not check indimmediate nor verify that 
 *      the exact same definition of equality applies.) 
 *  acl_ok: TRUE if current user has permission to read the column(s) 
 *      underlying the pg_statistic entry.  This is consulted by 
 *      statistic_proc_security_check(). 
 * 
 * Caller is responsible for doing ReleaseVariableStats() before exiting. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4555"></a><span class='Declare_Function'>examine_variable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>varRelid</span><span class='Delimiter'>, 
</span><a name="LN4556"></a>                 <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4558"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>basenode</span><span class='Delimiter'>; 
</span><a name="LN4559"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>varnos</span><span class='Delimiter'>; 
</span><a name="LN4560"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>onerel</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we don't return dangling pointers in vardata */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Save the exposed type of the expression */ 
</span>    <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN73"><span class='Ref_to_Member'>vartype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Look inside any binary-compatible relabeling */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
        <a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fast path for a simple Var */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a> <span class='Operator'>== </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno<span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4580"></a>        <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Set up result fields other than the stats tuple */ 
</span>        <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* return Var without relabeling */ 
</span>        <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>= </span><a href="../../optimizer/util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4580"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN74"><span class='Ref_to_Member'>atttype</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4580"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN75"><span class='Ref_to_Member'>atttypmod</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4580"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN76"><span class='Ref_to_Member'>isunique</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/plancat.h.html#LN42"><span class='Ref_to_Proto'>has_unique_index</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4580"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Try to locate some stats */ 
</span>        <a href="selfuncs.c.html#LN196"><span class='Ref_to_Proto'>examine_simple_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4580"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Okay, it's a more complicated expression.  Determine variable 
     * membership.  Note that when varRelid isn't zero, only vars of that 
     * relation are considered "real" vars. 
     */ 
</span>    <a href="selfuncs.c.html#LN4559"><span class='Ref_To_Local'>varnos</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN4560"><span class='Ref_To_Local'>onerel</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN84"><span class='Ref_to_Proto'>bms_membership</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4559"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN55"><span class='Ref_to_EnumConst'>BMS_EMPTY_SET</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* No Vars at all ... must be pseudo-constant clause */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN56"><span class='Ref_to_EnumConst'>BMS_SINGLETON</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4559"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN4560"><span class='Ref_To_Local'>onerel</span></a> <span class='Operator'>= </span><a href="../../optimizer/util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                       <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a> <span class='Operator'>? </span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a> <span class='Operator'>: </span><a href="../../../include/nodes/bitmapset.h.html#LN79"><span class='Ref_to_Proto'>bms_singleton_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4559"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4560"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* strip any relabeling */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* else treat it as a constant */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN57"><span class='Ref_to_EnumConst'>BMS_MULTIPLE</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* treat it as a variable of a join relation */ 
</span>                <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN258"><span class='Ref_to_Proto'>find_join_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4559"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* strip any relabeling */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4559"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* ignore the vars belonging to other relations */ 
</span>                <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>= </span><a href="../../optimizer/util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>varRelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4558"><span class='Ref_To_Local'>basenode</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* strip any relabeling */ 
</span>                <span class='Comment_Multi_Line'>/* note: no point in expressional-index search here */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* else treat it as a constant */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch bms_membership(varnos... &raquo; </span> 
 
    <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4559"><span class='Ref_To_Local'>varnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN74"><span class='Ref_to_Member'>atttype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN75"><span class='Ref_to_Member'>atttypmod</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4560"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have an expression in vars of a single relation.  Try to match 
         * it to expressional index columns, in hopes of finding some 
         * statistics. 
         * 
         * XXX it's conceivable that there are multiple matches with different 
         * index opfamilies; if so, we need to pick one that matches the 
         * operator we are estimating for.  FIXME later. 
         */ 
</span><a name="LN4654"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ilist</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4654"><span class='Ref_To_Local'>ilist</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4560"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN561"><span class='Ref_to_Member'>indexlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4658"></a>            <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4654"><span class='Ref_To_Local'>ilist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4659"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>indexpr_item</span><span class='Delimiter'>; 
</span><a name="LN4660"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>pos</span><span class='Delimiter'>; 
</span> 
            <a href="selfuncs.c.html#LN4659"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN652"><span class='Ref_to_Member'>indexprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4659"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* no expressions here... */ 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4660"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN4660"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN640"><span class='Ref_to_Member'>ncolumns</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN4660"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN641"><span class='Ref_to_Member'>indexkeys</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN4660"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN4670"></a>                    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexkey</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4659"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too few entries in indexprs list"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="selfuncs.c.html#LN4670"><span class='Ref_To_Local'>indexkey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4659"><span class='Ref_To_Local'>indexpr_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4670"><span class='Ref_To_Local'>indexkey</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4670"><span class='Ref_To_Local'>indexkey</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                        <a href="selfuncs.c.html#LN4670"><span class='Ref_To_Local'>indexkey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN4670"><span class='Ref_To_Local'>indexkey</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4670"><span class='Ref_To_Local'>indexkey</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * Found a match ... is it a unique index? Tests here 
                         * should match has_unique_index(). 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN663"><span class='Ref_to_Member'>unique</span></a> <span class='Operator'>&& 
</span>                            <a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN640"><span class='Ref_to_Member'>ncolumns</span></a> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                            <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN662"><span class='Ref_to_Member'>predOK</span></a><span class='Parentheses'>))</span> 
                            <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN76"><span class='Ref_to_Member'>isunique</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * Has it got stats?  We only consider stats for 
                         * non-partial indexes, since partial indexes probably 
                         * don't reflect whole-relation statistics; the above 
                         * check for uniqueness is the only info we take from 
                         * a partial index. 
                         * 
                         * An index stats hook, however, must make its own 
                         * decisions about what to do with partial indexes. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN154"><span class='Ref_to_Global_Var'>get_index_stats_hook</span></a> <span class='Operator'>&& 
</span>                            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN154"><span class='Ref_to_Global_Var'>get_index_stats_hook</span></a><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Delimiter'>, 
</span>                                                     <a href="selfuncs.c.html#LN4660"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* 
                             * The hook took control of acquiring a stats 
                             * tuple.  If it did supply a tuple, it'd better 
                             * have supplied a freefunc. 
                             */ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                                <span class='Operator'>!</span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a><span class='Parentheses'>)</span> 
                                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no function provided to release variable stats with"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a> <span class='Operator'>= 
</span>                                <a href="../../../include/utils/syscache.h.html#LN159"><span class='Ref_to_Macro'>SearchSysCache3</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN90"><span class='Ref_to_EnumConst'>STATRELATTINH</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4660"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                            <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Delimiter'>; 
</span> 
                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
                            <span class='Delimiter'>{ 
</span>                                <span class='Comment_Multi_Line'>/* Get index's table for permission check */ 
</span><a name="LN4723"></a>                                <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
                                <a href="selfuncs.c.html#LN4723"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4658"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4555"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4723"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                                <span class='Comment_Multi_Line'>/* 
                                 * For simplicity, we insist on the whole 
                                 * table being selectable, rather than trying 
                                 * to identify which column(s) the index 
                                 * depends on. 
                                 */ 
</span>                                <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN77"><span class='Ref_to_Member'>acl_ok</span></a> <span class='Operator'>= 
</span>                                    <span class='Parentheses'>(</span><a href="../../../include/utils/acl.h.html#LN283"><span class='Ref_to_Proto'>pg_class_aclcheck</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4723"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="../init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/nodes/parsenodes.h.html#LN72"><span class='Ref_to_Const'>ACL_SELECT</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                            <span class='Control'>else</span> 
                            <span class='Delimiter'>{ 
</span>                                <span class='Comment_Multi_Line'>/* suppress leakproofness checks later */ 
</span>                                <a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN77"><span class='Ref_to_Member'>acl_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if index-&GT;indpred==NIL &raquo; </span> 
                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if equal(node,indexkey) &raquo; </span> 
                    <a href="selfuncs.c.html#LN4659"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4659"><span class='Ref_To_Local'>indexpr_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if index-&GT;indexkeys[pos]... &raquo; </span> 
            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for pos=0;pos&LT;index-&GT;ncol... &raquo; </span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4556"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if onerel &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end examine_variable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * examine_simple_variable 
 *      Handle a simple Var for examine_variable 
 * 
 * This is split out as a subroutine so that we can recurse to deal with 
 * Vars referencing subqueries. 
 * 
 * We already filled in all the fields of *vardata except for the stats tuple. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4766"></a><span class='Declare_Function'>examine_simple_variable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>var</span><span class='Delimiter'>, 
</span><a name="LN4767"></a>                        <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4769"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN153"><span class='Ref_to_Global_Var'>get_relation_stats_hook</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN153"><span class='Ref_to_Global_Var'>get_relation_stats_hook</span></a><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The hook took control of acquiring a stats tuple.  If it did supply 
         * a tuple, it'd better have supplied a freefunc. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no function provided to release variable stats with"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Plain table or parent of an inheritance appendrel, so look up the 
         * column in pg_statistic 
         */ 
</span>        <a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN159"><span class='Ref_to_Macro'>SearchSysCache3</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN90"><span class='Ref_to_EnumConst'>STATRELATTINH</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                              <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                              <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* check if user has permission to read this column */ 
</span>            <a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN77"><span class='Ref_to_Member'>acl_ok</span></a> <span class='Operator'>= 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/acl.h.html#LN283"><span class='Ref_to_Proto'>pg_class_aclcheck</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="../init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/nodes/parsenodes.h.html#LN72"><span class='Ref_to_Const'>ACL_SELECT</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/acl.h.html#LN279"><span class='Ref_to_Proto'>pg_attribute_aclcheck</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Delimiter'>, </span><a href="../init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                       <a href="../../../include/nodes/parsenodes.h.html#LN72"><span class='Ref_to_Const'>ACL_SELECT</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* suppress any possible leakproofness checks later */ 
</span>            <a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN77"><span class='Ref_to_Member'>acl_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rte-&GT;rtekind==RTE_REL... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a> <span class='Operator'>&& !</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Plain subquery (not one that was converted to an appendrel). 
         */ 
</span><a name="LN4816"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>subquery</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>; 
</span><a name="LN4817"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN4818"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ste</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Punt if it's a whole-row var rather than a plain column reference. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>== </span><a href="../../../include/access/attnum.h.html#LN22"><span class='Ref_to_Const'>InvalidAttrNumber</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Punt if subquery uses set operations or GROUP BY, as these will 
         * mash underlying columns' stats beyond recognition.  (Set ops are 
         * particularly nasty; if we forged ahead, we would return stats 
         * relevant to only the leftmost subselect...)  DISTINCT is also 
         * problematic, but we check that later because there is a possibility 
         * of learning something even with it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>|| 
</span>            <a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * OK, fetch RelOptInfo for subquery.  Note that we don't change the 
         * rel returned in vardata, since caller expects it to be a rel of the 
         * caller's query level.  Because we might already be recursing, we 
         * can't use that rel pointer either, but have to look up the Var's 
         * rel afresh. 
         */ 
</span>        <a href="selfuncs.c.html#LN4817"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../optimizer/util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If the subquery hasn't been planned yet, we have to punt */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4817"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN566"><span class='Ref_to_Member'>subroot</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4817"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN566"><span class='Ref_to_Member'>subroot</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Switch our attention to the subquery as mangled by the planner. It 
         * was okay to look at the pre-planning version for the tests above, 
         * but now we need a Var that will refer to the subroot's live 
         * RelOptInfos.  For instance, if any subquery pullup happened during 
         * planning, Vars in the targetlist might have gotten replaced, and we 
         * need to see the replacement expressions. 
         */ 
</span>        <a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4817"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN566"><span class='Ref_to_Member'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Get the subquery output expression referenced by the upper Var */ 
</span>        <a href="selfuncs.c.html#LN4818"><span class='Ref_To_Local'>ste</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parsetree.h.html#LN69"><span class='Ref_to_Proto'>get_tle_by_resno</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4818"><span class='Ref_To_Local'>ste</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="selfuncs.c.html#LN4818"><span class='Ref_To_Local'>ste</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"subquery %s does not have attribute %d"</span><span class='Delimiter'>, 
</span>                 <a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1023"><span class='Ref_to_Member'>eref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN41"><span class='Ref_to_Member'>aliasname</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN4818"><span class='Ref_To_Local'>ste</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If subquery uses DISTINCT, we can't make use of any stats for the 
         * variable ... but, if it's the only DISTINCT column, we are entitled 
         * to consider it unique.  We do the test this way so that it works 
         * for cases involving DISTINCT ON. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                <a href="../../../include/parser/parse_clause.h.html#LN51"><span class='Ref_to_Proto'>targetIsInSortList</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4818"><span class='Ref_To_Local'>ste</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4816"><span class='Ref_To_Local'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>))</span> 
                <a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN76"><span class='Ref_to_Member'>isunique</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* cannot go further */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the sub-query originated from a view with the security_barrier 
         * attribute, we must not look at the variable's statistics, though it 
         * seems all right to notice the existence of a DISTINCT clause. So 
         * stop here. 
         * 
         * This is probably a harsher restriction than necessary; it's 
         * certainly OK for the selectivity estimator (which is a C function, 
         * and therefore omnipotent anyway) to look at the statistics.  But 
         * many selectivity estimators will happily *invoke the operator 
         * function* to try to work out a good estimate - and that's not OK. 
         * So for now, don't dig down for stats. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4769"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN955"><span class='Ref_to_Member'>security_barrier</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Can only handle a simple Var of subquery's query level */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * OK, recurse into the subquery.  Note that the original setting 
             * of vardata-&GT;isunique (which will surely be false) is left 
             * unchanged in this situation.  That's what we want, since even 
             * if the underlying column is unique, the subquery may have 
             * joined to other tables in a way that creates duplicates. 
             */ 
</span>            <a href="selfuncs.c.html#LN196"><span class='Ref_to_Proto'>examine_simple_variable</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4817"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN566"><span class='Ref_to_Member'>subroot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4766"><span class='Ref_to_Parameter'>var</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN4767"><span class='Ref_to_Parameter'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rte-&GT;rtekind==RTE_SUB... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We 
         * won't see RTE_JOIN here because join alias Vars have already been 
         * flattened.)  There's not much we can do with function outputs, but 
         * maybe someday try to be smarter about VALUES and/or CTEs. 
         */ 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end examine_simple_variable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether it is permitted to call func_oid passing some of the 
 * pg_statistic data in vardata.  We allow this either if the user has SELECT 
 * privileges on the table or column underlying the pg_statistic data or if 
 * the function is marked leak-proof. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN4933"></a><span class='Declare_Function'>statistic_proc_security_check</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>func_oid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4933"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN77"><span class='Ref_to_Member'>acl_ok</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4933"><span class='Ref_to_Parameter'>func_oid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN120"><span class='Ref_to_Proto'>get_func_leakproof</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4933"><span class='Ref_to_Parameter'>func_oid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"not using statistics because function \"%s\" is not leak-proof"</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/lsyscache.h.html#LN110"><span class='Ref_to_Proto'>get_func_name</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4933"><span class='Ref_to_Parameter'>func_oid</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_variable_numdistinct 
 *    Estimate the number of distinct values of a variable. 
 * 
 * vardata: results of examine_variable 
 * *isdefault: set to TRUE if the result is a default rather than based on 
 * anything meaningful. 
 * 
 * NB: be careful to produce a positive integral result, since callers may 
 * compare the result to exact integer counts, or might divide by it. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN4962"></a><span class='Declare_Function'>get_variable_numdistinct</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isdefault</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4964"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>stadistinct</span><span class='Delimiter'>; 
</span><a name="LN4965"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>stanullfrac</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN4966"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>ntuples</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>isdefault</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the stadistinct value to use.  There are cases where we can 
     * get an estimate even without a pg_statistic entry, or can get a better 
     * value than is in pg_statistic.  Grab stanullfrac too if we can find it 
     * (otherwise, assume no nulls, for lack of any better idea). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Use the pg_statistic entry */ 
</span><a name="LN4979"></a>        <a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a> <span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN4979"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_statistic.h.html#LN128"><span class='Ref_to_Typedef'>Form_pg_statistic</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4979"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stadistinct<span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN4965"><span class='Ref_To_Local'>stanullfrac</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4979"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span>stanullfrac<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN73"><span class='Ref_to_Member'>vartype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Special-case boolean columns: presumably, two distinct values. 
         * 
         * Are there any other datatypes we should wire in special estimates 
         * for? 
         */ 
</span>        <a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We don't keep statistics for system columns, but in some cases we 
         * can infer distinctness anyway. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno<span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../../include/access/sysattr.h.html#LN21"><span class='Ref_to_Const'>ObjectIdAttributeNumber</span></a><span class='Operator'>: 
</span>                <span class='Control'>case</span> <a href="../../../include/access/sysattr.h.html#LN20"><span class='Ref_to_Const'>SelfItemPointerAttributeNumber</span></a><span class='Operator'>: 
</span>                    <a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* unique (and all non null) */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/access/sysattr.h.html#LN26"><span class='Ref_to_Const'>TableOidAttributeNumber</span></a><span class='Operator'>: 
</span>                    <a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* only 1 value */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* means "unknown" */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* means "unknown" */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * XXX consider using estimate_num_groups on expressions? 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If there is a unique index or DISTINCT clause for the variable, assume 
     * it is unique no matter what pg_statistic says; the statistics could be 
     * out of date, or we might have found a partial unique index that proves 
     * the var is unique for this query.  However, we'd better still believe 
     * the null-fraction statistic. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN76"><span class='Ref_to_Member'>isunique</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN4965"><span class='Ref_To_Local'>stanullfrac</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we had an absolute estimate, use that. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise we need to get the relation size; punt if not available. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>isdefault</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN45"><span class='Ref_to_Const'>DEFAULT_NUM_DISTINCT</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="selfuncs.c.html#LN4966"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4966"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>isdefault</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN45"><span class='Ref_to_Const'>DEFAULT_NUM_DISTINCT</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we had a relative estimate, use that. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><a href="selfuncs.c.html#LN4964"><span class='Ref_To_Local'>stadistinct</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN4966"><span class='Ref_To_Local'>ntuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * With no data, estimate ndistinct = ntuples if the table is small, else 
     * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for "small" so 
     * that the behavior isn't discontinuous. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4966"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>&LT; </span><a href="../../../include/utils/selfuncs.h.html#LN45"><span class='Ref_to_Const'>DEFAULT_NUM_DISTINCT</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN4966"><span class='Ref_To_Local'>ntuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN4962"><span class='Ref_to_Parameter'>isdefault</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN45"><span class='Ref_to_Const'>DEFAULT_NUM_DISTINCT</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_variable_numdistinct &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_variable_range 
 *      Estimate the minimum and maximum value of the specified variable. 
 *      If successful, store values in *min and *max, and return TRUE. 
 *      If no data available, return FALSE. 
 * 
 * sortop is the "&LT;" comparison operator to use.  This should generally 
 * be "&LT;" not "&GT;", as only the former is likely to be found in pg_statistic. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN5084"></a><span class='Declare_Function'>get_variable_range</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortop</span><span class='Delimiter'>, 
</span><a name="LN5085"></a>                   <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>min</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>max</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5087"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>tmin</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5088"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>tmax</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5089"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_data</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN5090"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>typLen</span><span class='Delimiter'>; 
</span><a name="LN5091"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>typByVal</span><span class='Delimiter'>; 
</span><a name="LN5092"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opfuncoid</span><span class='Delimiter'>; 
</span><a name="LN5093"></a>    <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span><a name="LN5094"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX It's very tempting to try to use the actual column min and max, if 
     * we can get them relatively-cheaply with an index probe.  However, since 
     * this function is called many times during join planning, that could 
     * have unpleasant effects on planning speed.  Need more investigation 
     * before enabling this. 
     */ 
</span><span class='Directive'>#ifdef</span> NOT_USED 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN200"><span class='Ref_to_Proto'>get_actual_variable_range</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>sortop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5085"><span class='Ref_to_Parameter'>min</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5085"><span class='Ref_to_Parameter'>max</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* no stats available, so default result */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we can't apply the sortop to the stats data, just fail.  In 
     * principle, if there's a histogram and no MCVs, we could return the 
     * histogram endpoints without ever applying the sortop ... but it's 
     * probably not worth trying, because whatever the caller wants to do with 
     * the endpoints would likely fail the security check too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/selfuncs.h.html#LN156"><span class='Ref_to_Proto'>statistic_proc_security_check</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5092"><span class='Ref_To_Local'>opfuncoid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>sortop</span></a><span class='Parentheses'>))))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN74"><span class='Ref_to_Member'>atttype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5090"><span class='Ref_To_Local'>typLen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5091"><span class='Ref_To_Local'>typByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is a histogram, grab the first and last values. 
     * 
     * If there is a histogram that is sorted with some other operator than 
     * the one we want, fail --- this suggests that there is data we can't 
     * use. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/catalog/pg_statistic.h.html#LN221"><span class='Ref_to_Const'>STATISTIC_KIND_HISTOGRAM</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>sortop</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN5087"><span class='Ref_To_Local'>tmin</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN5091"><span class='Ref_To_Local'>typByVal</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5090"><span class='Ref_To_Local'>typLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5088"><span class='Ref_To_Local'>tmax</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN5091"><span class='Ref_To_Local'>typByVal</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5090"><span class='Ref_To_Local'>typLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5089"><span class='Ref_To_Local'>have_data</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../include/catalog/pg_statistic.h.html#LN221"><span class='Ref_to_Const'>STATISTIC_KIND_HISTOGRAM</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                              <span class='Number'>0</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have most-common-values info, look for extreme MCVs.  This is 
     * needed even if we also have a histogram, since the histogram excludes 
     * the MCVs.  However, usually the MCVs will not be the extreme values, so 
     * avoid unnecessary data copying. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5084"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/catalog/pg_statistic.h.html#LN203"><span class='Ref_to_Const'>STATISTIC_KIND_MCV</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/utils/lsyscache.h.html#LN38"><span class='Ref_to_Const'>ATTSTATSSLOT_VALUES</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN5164"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>tmin_is_mcv</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN5165"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>tmax_is_mcv</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN5166"></a>        <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>opproc</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5092"><span class='Ref_To_Local'>opfuncoid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5166"><span class='Ref_To_Local'>opproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN49"><span class='Ref_to_Member'>nvalues</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN5089"><span class='Ref_To_Local'>have_data</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN5087"><span class='Ref_To_Local'>tmin</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5088"><span class='Ref_To_Local'>tmax</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>                <a href="selfuncs.c.html#LN5164"><span class='Ref_To_Local'>tmin_is_mcv</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5165"><span class='Ref_To_Local'>tmax_is_mcv</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5089"><span class='Ref_To_Local'>have_data</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5166"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN5087"><span class='Ref_To_Local'>tmin</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN5087"><span class='Ref_To_Local'>tmin</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>                <a href="selfuncs.c.html#LN5164"><span class='Ref_To_Local'>tmin_is_mcv</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5166"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN5088"><span class='Ref_To_Local'>tmax</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN5088"><span class='Ref_To_Local'>tmax</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN48"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5094"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>                <a href="selfuncs.c.html#LN5165"><span class='Ref_To_Local'>tmax_is_mcv</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;sslot.nvalues;i... &raquo; </span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5164"><span class='Ref_To_Local'>tmin_is_mcv</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN5087"><span class='Ref_To_Local'>tmin</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5087"><span class='Ref_To_Local'>tmin</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5091"><span class='Ref_To_Local'>typByVal</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5090"><span class='Ref_To_Local'>typLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5165"><span class='Ref_To_Local'>tmax_is_mcv</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN5088"><span class='Ref_To_Local'>tmax</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5088"><span class='Ref_To_Local'>tmax</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5091"><span class='Ref_To_Local'>typByVal</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5090"><span class='Ref_To_Local'>typLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5093"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if get_attstatsslot(&ssl... &raquo; </span> 
 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN5085"><span class='Ref_to_Parameter'>min</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5087"><span class='Ref_To_Local'>tmin</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN5085"><span class='Ref_to_Parameter'>max</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5088"><span class='Ref_To_Local'>tmax</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5089"><span class='Ref_To_Local'>have_data</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_variable_range &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * get_actual_variable_range 
 *      Attempt to identify the current *actual* minimum and/or maximum 
 *      of the specified variable, by looking for a suitable btree index 
 *      and fetching its low and/or high values. 
 *      If successful, store values in *min and *max, and return TRUE. 
 *      (Either pointer can be NULL if that endpoint isn't needed.) 
 *      If no data available, return FALSE. 
 * 
 * sortop is the "&LT;" comparison operator to use. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN5218"></a><span class='Declare_Function'>get_actual_variable_range</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, 
</span><a name="LN5219"></a>                          <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortop</span><span class='Delimiter'>, 
</span><a name="LN5220"></a>                          <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>min</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>max</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5222"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_data</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN5223"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5218"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN69"><span class='Ref_to_Member'>rel</span></a><span class='Delimiter'>; 
</span><a name="LN5224"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN5225"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No hope if no relation or it doesn't have indexes */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5223"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="selfuncs.c.html#LN5223"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN561"><span class='Ref_to_Member'>indexlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* If it has indexes it must be a plain relation */ 
</span>    <a href="selfuncs.c.html#LN5224"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5218"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5223"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>]; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5224"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Search through the indexes to see if any match our problem */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5225"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5223"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN561"><span class='Ref_to_Member'>indexlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5237"></a>        <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5225"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5238"></a>        <a href="../../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Local'>indexscandir</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore non-btree indexes */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN650"><span class='Ref_to_Member'>relam</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_am.h.html#LN69"><span class='Ref_to_Const'>BTREE_AM_OID</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ignore partial indexes --- we only want stats that cover the entire 
         * relation. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The index list might include hypothetical indexes inserted by a 
         * get_relation_info hook --- don't try to access them. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN665"><span class='Ref_to_Member'>hypothetical</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The first index column must match the desired variable and sort 
         * operator --- but we can use a descending-order index. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/paths.h.html#LN75"><span class='Ref_to_Proto'>match_index_to_operand</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5218"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN68"><span class='Ref_to_Member'>var</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN64"><span class='Ref_to_Proto'>get_op_opfamily_strategy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5219"><span class='Ref_to_Parameter'>sortop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN645"><span class='Ref_to_Member'>sortopfamily</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN646"><span class='Ref_to_Member'>reverse_sort</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN5238"><span class='Ref_To_Local'>indexscandir</span></a> <span class='Operator'>= </span><a href="../../../include/access/sdir.h.html#LN23"><span class='Ref_to_EnumConst'>BackwardScanDirection</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="selfuncs.c.html#LN5238"><span class='Ref_To_Local'>indexscandir</span></a> <span class='Operator'>= </span><a href="../../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN646"><span class='Ref_to_Member'>reverse_sort</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN5238"><span class='Ref_To_Local'>indexscandir</span></a> <span class='Operator'>= </span><a href="../../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="selfuncs.c.html#LN5238"><span class='Ref_To_Local'>indexscandir</span></a> <span class='Operator'>= </span><a href="../../../include/access/sdir.h.html#LN23"><span class='Ref_to_EnumConst'>BackwardScanDirection</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* index doesn't match the sortop */ 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Found a suitable index to extract data from.  We'll need an EState 
         * and a bunch of other infrastructure. 
         */ 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5288"></a>            <a href="../../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN5289"></a>            <a href="../../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN5290"></a>            <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>tmpcontext</span><span class='Delimiter'>; 
</span><a name="LN5291"></a>            <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN5292"></a>            <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>heapRel</span><span class='Delimiter'>; 
</span><a name="LN5293"></a>            <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indexRel</span><span class='Delimiter'>; 
</span><a name="LN5294"></a>            <a href="../../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>indexInfo</span><span class='Delimiter'>; 
</span><a name="LN5295"></a>            <a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN5296"></a>            <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>typLen</span><span class='Delimiter'>; 
</span><a name="LN5297"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>typByVal</span><span class='Delimiter'>; 
</span><a name="LN5298"></a>            <a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a> <span class='Declare_Local'>scankeys</span><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN5299"></a>            <a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Local'>index_scan</span><span class='Delimiter'>; 
</span><a name="LN5300"></a>            <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span><a name="LN5301"></a>            <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN5302"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN5303"></a>            <a href="../../../include/utils/snapshot.h.html#LN51"><span class='Ref_to_Struct'>SnapshotData</span></a> <span class='Declare_Local'>SnapshotDirty</span><span class='Delimiter'>; 
</span> 
            <a href="selfuncs.c.html#LN5288"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5289"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="../../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5288"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Make sure any cruft is generated in the econtext's memory */ 
</span>            <a href="selfuncs.c.html#LN5290"><span class='Ref_To_Local'>tmpcontext</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5289"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5291"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5290"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Open the table and index so we can read from them.  We should 
             * already have at least AccessShareLock on the table, but not 
             * necessarily on the index. 
             */ 
</span>            <a href="selfuncs.c.html#LN5292"><span class='Ref_To_Local'>heapRel</span></a> <span class='Operator'>= </span><a href="../../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5224"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5293"><span class='Ref_To_Local'>indexRel</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5237"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* extract index key information from the index's pg_index info */ 
</span>            <a href="selfuncs.c.html#LN5294"><span class='Ref_To_Local'>indexInfo</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/index.h.html#LN81"><span class='Ref_to_Proto'>BuildIndexInfo</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5293"><span class='Ref_To_Local'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* some other stuff */ 
</span>            <a href="selfuncs.c.html#LN5295"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../../include/executor/tuptable.h.html#LN144"><span class='Ref_to_Proto'>MakeSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5292"><span class='Ref_To_Local'>heapRel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5289"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5295"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5218"><span class='Ref_to_Parameter'>vardata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN74"><span class='Ref_to_Member'>atttype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5296"><span class='Ref_To_Local'>typLen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5297"><span class='Ref_To_Local'>typByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/tqual.h.html#LN99"><span class='Ref_to_Macro'>InitDirtySnapshot</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5303"><span class='Ref_To_Local'>SnapshotDirty</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* set up an IS NOT NULL scan key so that we ignore nulls */ 
</span>            <a href="../../access/common/scankey.c.html#LN30"><span class='Ref_to_Func'>ScanKeyEntryInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5298"><span class='Ref_To_Local'>scankeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                   <a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a> <span class='Operator'>| </span><a href="../../../include/access/skey.h.html#LN121"><span class='Ref_to_Const'>SK_SEARCHNOTNULL</span></a><span class='Delimiter'>, 
</span>                                   <span class='Number'>1</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* index col to scan */ 
</span>                                   <a href="../../../include/access/stratnum.h.html#LN23"><span class='Ref_to_Const'>InvalidStrategy</span></a><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* no strategy */ 
</span>                                   <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no strategy subtype */ 
</span>                                   <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no collation */ 
</span>                                   <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no reg proc for this */ 
</span>                                   <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* constant */ 
</span> 
            <a href="selfuncs.c.html#LN5222"><span class='Ref_To_Local'>have_data</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* If min is requested ... */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5220"><span class='Ref_to_Parameter'>min</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * In principle, we should scan the index with our current 
                 * active snapshot, which is the best approximation we've got 
                 * to what the query will see when executed.  But that won't 
                 * be exact if a new snap is taken before running the query, 
                 * and it can be very expensive if a lot of uncommitted rows 
                 * exist at the end of the index (because we'll laboriously 
                 * fetch each one and reject it).  What seems like a good 
                 * compromise is to use SnapshotDirty.  That will accept 
                 * uncommitted rows, and thus avoid fetching multiple heap 
                 * tuples in this scenario.  On the other hand, it will reject 
                 * known-dead rows, and thus not give a bogus answer when the 
                 * extreme value has been deleted; that case motivates not 
                 * using SnapshotAny here. 
                 */ 
</span>                <a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN139"><span class='Ref_to_Proto'>index_beginscan</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5292"><span class='Ref_To_Local'>heapRel</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5293"><span class='Ref_To_Local'>indexRel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5303"><span class='Ref_To_Local'>SnapshotDirty</span></a><span class='Delimiter'>, 
</span>                                             <span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5298"><span class='Ref_To_Local'>scankeys</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Fetch first tuple in sortop's direction */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="selfuncs.c.html#LN5300"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN162"><span class='Ref_to_Proto'>index_getnext</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a><span class='Delimiter'>, 
</span>                                         <a href="selfuncs.c.html#LN5238"><span class='Ref_To_Local'>indexscandir</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Extract the index column values from the heap tuple */ 
</span>                    <a href="../../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5300"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5295"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/catalog/index.h.html#LN85"><span class='Ref_to_Proto'>FormIndexDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5294"><span class='Ref_To_Local'>indexInfo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5295"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5288"><span class='Ref_To_Local'>estate</span></a><span class='Delimiter'>, 
</span>                                   <a href="selfuncs.c.html#LN5301"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5302"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Shouldn't have got a null, but be careful */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5302"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"found unexpected null value in index \"%s\""</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5293"><span class='Ref_To_Local'>indexRel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Copy the index column value out to caller's context */ 
</span>                    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5291"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="selfuncs.c.html#LN5220"><span class='Ref_to_Parameter'>min</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5301"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN5297"><span class='Ref_To_Local'>typByVal</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5296"><span class='Ref_To_Local'>typLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5290"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                    <a href="selfuncs.c.html#LN5222"><span class='Ref_To_Local'>have_data</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/access/genam.h.html#LN149"><span class='Ref_to_Proto'>index_endscan</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if min &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* If max is requested, and we didn't find the index is empty */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5220"><span class='Ref_to_Parameter'>max</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5222"><span class='Ref_To_Local'>have_data</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN139"><span class='Ref_to_Proto'>index_beginscan</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5292"><span class='Ref_To_Local'>heapRel</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5293"><span class='Ref_To_Local'>indexRel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5303"><span class='Ref_To_Local'>SnapshotDirty</span></a><span class='Delimiter'>, 
</span>                                             <span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5298"><span class='Ref_To_Local'>scankeys</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Fetch first tuple in reverse direction */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="selfuncs.c.html#LN5300"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN162"><span class='Ref_to_Proto'>index_getnext</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>-</span><a href="selfuncs.c.html#LN5238"><span class='Ref_To_Local'>indexscandir</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Extract the index column values from the heap tuple */ 
</span>                    <a href="../../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5300"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5295"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/catalog/index.h.html#LN85"><span class='Ref_to_Proto'>FormIndexDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5294"><span class='Ref_To_Local'>indexInfo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5295"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5288"><span class='Ref_To_Local'>estate</span></a><span class='Delimiter'>, 
</span>                                   <a href="selfuncs.c.html#LN5301"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5302"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Shouldn't have got a null, but be careful */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5302"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"found unexpected null value in index \"%s\""</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5293"><span class='Ref_To_Local'>indexRel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Copy the index column value out to caller's context */ 
</span>                    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5291"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="selfuncs.c.html#LN5220"><span class='Ref_to_Parameter'>max</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5301"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN5297"><span class='Ref_To_Local'>typByVal</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5296"><span class='Ref_To_Local'>typLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5290"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                    <a href="selfuncs.c.html#LN5222"><span class='Ref_To_Local'>have_data</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/access/genam.h.html#LN149"><span class='Ref_to_Proto'>index_endscan</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5299"><span class='Ref_To_Local'>index_scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if max&&have_data &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* Clean everything up */ 
</span>            <a href="../../../include/executor/tuptable.h.html#LN145"><span class='Ref_to_Proto'>ExecDropSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5295"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5293"><span class='Ref_To_Local'>indexRel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5292"><span class='Ref_To_Local'>heapRel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5291"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5288"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* And we're done */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5222"><span class='Ref_To_Local'>have_data</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_actual_variable_range &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_join_input_rel 
 *      Look up the input relation for a join. 
 * 
 * We assume that the input relation's RelOptInfo must have been constructed 
 * already. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN5444"></a><span class='Declare_Function'>find_join_input_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>relids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5446"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN84"><span class='Ref_to_Proto'>bms_membership</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5444"><span class='Ref_to_Parameter'>relids</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN55"><span class='Ref_to_EnumConst'>BMS_EMPTY_SET</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* should not happen */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN56"><span class='Ref_to_EnumConst'>BMS_SINGLETON</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN5446"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../optimizer/util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5444"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/bitmapset.h.html#LN79"><span class='Ref_to_Proto'>bms_singleton_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5444"><span class='Ref_to_Parameter'>relids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN57"><span class='Ref_to_EnumConst'>BMS_MULTIPLE</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN5446"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN258"><span class='Ref_to_Proto'>find_join_rel</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5444"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5444"><span class='Ref_to_Parameter'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5446"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find RelOptInfo for given relids"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5446"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_join_input_rel &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * Pattern analysis functions 
 * 
 * These routines support analysis of LIKE and regular-expression patterns 
 * by the planner/optimizer.  It's important that they agree with the 
 * regular-expression code in backend/regex/ and the LIKE code in 
 * backend/utils/adt/like.c.  Also, the computation of the fixed prefix 
 * must be conservative: if we report a string longer than the true fixed 
 * prefix, the query may produce actually wrong answers, rather than just 
 * getting a bad selectivity estimate! 
 * 
 * Note that the prefix-analysis functions are called from 
 * backend/optimizer/path/indxpath.c as well as from routines in this file. 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check whether char is a letter (and, hence, subject to case-folding) 
 * 
 * In multibyte character sets or with ICU, we can't use isalpha, and it does not seem 
 * worth trying to convert to wchar_t to use iswalpha.  Instead, just assume 
 * any multibyte char is potentially case-varying. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN5494"></a><span class='Declare_Function'>pattern_char_isalpha</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Declare_Parameter'>c</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>is_multibyte</span><span class='Delimiter'>, 
</span><a name="LN5495"></a>                     <a href="../../../include/utils/pg_locale.h.html#LN87"><span class='Ref_to_Typedef'>pg_locale_t</span></a> <span class='Declare_Parameter'>locale</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>locale_is_c</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5495"><span class='Ref_to_Parameter'>locale_is_c</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a> <span class='Operator'>&GT;= </span><span class='String'>'A'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a> <span class='Operator'>&LT;= </span><span class='String'>'Z'</span><span class='Parentheses'>) </span><span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a> <span class='Operator'>&GT;= </span><span class='String'>'a'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a> <span class='Operator'>&LT;= </span><span class='String'>'z'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>is_multibyte</span></a> <span class='Operator'>&& </span><a href="../../../include/c.h.html#LN972"><span class='Ref_to_Macro'>IS_HIGHBIT_SET</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5495"><span class='Ref_to_Parameter'>locale</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5495"><span class='Ref_to_Parameter'>locale</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/pg_locale.h.html#LN70"><span class='Ref_to_Member'>provider</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_collation.h.html#LN84"><span class='Ref_to_Const'>COLLPROVIDER_ICU</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/c.h.html#LN972"><span class='Ref_to_Macro'>IS_HIGHBIT_SET</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Boolean'>true </span><span class='Operator'>: </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> HAVE_LOCALE_T 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5495"><span class='Ref_to_Parameter'>locale</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5495"><span class='Ref_to_Parameter'>locale</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/pg_locale.h.html#LN70"><span class='Ref_to_Member'>provider</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_collation.h.html#LN85"><span class='Ref_to_Const'>COLLPROVIDER_LIBC</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/port/win32.h.html#LN329"><span class='Ref_to_Const'>isalpha_l</span></a><span class='Parentheses'>((</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5495"><span class='Ref_to_Parameter'>locale</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/pg_locale.h.html#LN84"><span class='Ref_to_Member'>info</span></a><span class='Operator'>.</span>lt<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
    <span class='Control'>else</span> 
        <span class='Control'>return</span> isalpha<span class='Parentheses'>((</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN5494"><span class='Ref_to_Parameter'>c</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Extract the fixed prefix, if any, for a pattern. 
 * 
 * *prefix is set to a palloc'd prefix string (in the form of a Const node), 
 *  or to NULL if no fixed prefix exists for the pattern. 
 * If rest_selec is not NULL, *rest_selec is set to an estimate of the 
 *  selectivity of the remainder of the pattern (without any fixed prefix). 
 * The prefix Const has the same type (TEXT or BYTEA) as the input pattern. 
 * 
 * The return value distinguishes no fixed prefix, a partial prefix, 
 * or an exact-match-only pattern. 
 */ 
</span> 
<span class='Keyword'>static </span><a href="../../../include/utils/selfuncs.h.html#LN93"><span class='Ref_to_Typedef'>Pattern_Prefix_Status</span></a> 
<a name="LN5525"></a><span class='Declare_Function'>like_fixed_prefix</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>patt_const</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>case_insensitive</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Delimiter'>, 
</span><a name="LN5526"></a>                  <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>prefix_const</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rest_selec</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5528"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>match</span><span class='Delimiter'>; 
</span><a name="LN5529"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>patt</span><span class='Delimiter'>; 
</span><a name="LN5530"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>pattlen</span><span class='Delimiter'>; 
</span><a name="LN5531"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typeid</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a><span class='Delimiter'>; 
</span><a name="LN5532"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>pos</span><span class='Delimiter'>, 
</span><a name="LN5533"></a>                <span class='Declare_Local'>match_pos</span><span class='Delimiter'>; 
</span><a name="LN5534"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_multibyte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/mb/pg_wchar.h.html#LN535"><span class='Ref_to_Proto'>pg_database_encoding_max_length</span></a><span class='Parentheses'>() </span><span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5535"></a>    <a href="../../../include/utils/pg_locale.h.html#LN87"><span class='Ref_to_Typedef'>pg_locale_t</span></a> <span class='Declare_Local'>locale</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5536"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>locale_is_c</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* the right-hand const is type text or bytea */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Keyword'>typeid </span><span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a> <span class='Operator'>|| </span><span class='Keyword'>typeid </span><span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>typeid </span><span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"case insensitive matching not supported on type bytea"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If case-insensitive, we need locale info */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/pg_locale.h.html#LN51"><span class='Ref_to_Proto'>lc_ctype_is_c</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>))</span> 
            <a href="selfuncs.c.html#LN5536"><span class='Ref_To_Local'>locale_is_c</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>collation</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * This typically means that the parser could not resolve a 
                 * conflict of implicit collations, so report it that way. 
                 */ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INDETERMINATE_COLLATION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not determine which collation to use for ILIKE"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Use the COLLATE clause to set the collation explicitly."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="selfuncs.c.html#LN5535"><span class='Ref_To_Local'>locale</span></a> <span class='Operator'>= </span><a href="../../../include/utils/pg_locale.h.html#LN89"><span class='Ref_to_Proto'>pg_newlocale_from_collation</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if case_insensitive &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>typeid </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN5575"></a>        <a href="../../../include/c.h.html#LN451"><span class='Ref_to_Typedef'>bytea</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>bstr</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN254"><span class='Ref_to_Macro'>DatumGetByteaPP</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN339"><span class='Ref_to_Macro'>VARSIZE_ANY_EXHDR</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5575"><span class='Ref_To_Local'>bstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN346"><span class='Ref_to_Macro'>VARDATA_ANY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5575"><span class='Ref_To_Local'>bstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN244"><span class='Ref_to_Typedef'>Pointer</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN5575"><span class='Ref_To_Local'>bstr</span></a> <span class='Operator'>== </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="selfuncs.c.html#LN5528"><span class='Ref_To_Local'>match</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN5533"><span class='Ref_To_Local'>match_pos</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* % and _ are wildcard characters in LIKE */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'%'</span> <span class='Operator'>|| 
</span>            <a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'_'</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Backslash escapes the next character */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'\\'</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Stop if case-varying character (it's sort of a wildcard) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>case_insensitive</span></a> <span class='Operator'>&& 
</span>          <a href="selfuncs.c.html#LN5493"><span class='Ref_to_Func'>pattern_char_isalpha</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN5534"><span class='Ref_To_Local'>is_multibyte</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5535"><span class='Ref_To_Local'>locale</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5536"><span class='Ref_To_Local'>locale_is_c</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN5528"><span class='Ref_To_Local'>match</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5533"><span class='Ref_To_Local'>match_pos</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for pos=0;pos&LT;pattlen;pos... &raquo; </span> 
 
    <a href="selfuncs.c.html#LN5528"><span class='Ref_To_Local'>match</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5533"><span class='Ref_To_Local'>match_pos</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>typeid </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN5526"><span class='Ref_to_Parameter'>prefix_const</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/indxpath.c.html#LN190"><span class='Ref_to_Proto'>string_to_const</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5528"><span class='Ref_To_Local'>match</span></a><span class='Delimiter'>, </span><span class='Keyword'>typeid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="selfuncs.c.html#LN5526"><span class='Ref_to_Parameter'>prefix_const</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN215"><span class='Ref_to_Proto'>string_to_bytea_const</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5528"><span class='Ref_To_Local'>match</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5533"><span class='Ref_To_Local'>match_pos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5526"><span class='Ref_to_Parameter'>rest_selec</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN5526"><span class='Ref_to_Parameter'>rest_selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN208"><span class='Ref_to_Proto'>like_selectivity</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>], </span><a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>, 
</span>                                       <a href="selfuncs.c.html#LN5525"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5529"><span class='Ref_To_Local'>patt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5528"><span class='Ref_To_Local'>match</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* in LIKE, an empty pattern is an exact match! */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5532"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>== </span><a href="selfuncs.c.html#LN5530"><span class='Ref_To_Local'>pattlen</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_Exact</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* reached end of pattern, so exact */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5533"><span class='Ref_To_Local'>match_pos</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_Partial</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_None</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end like_fixed_prefix &raquo; </span> 
 
<span class='Keyword'>static </span><a href="../../../include/utils/selfuncs.h.html#LN93"><span class='Ref_to_Typedef'>Pattern_Prefix_Status</span></a> 
<a name="LN5633"></a><span class='Declare_Function'>regex_fixed_prefix</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>patt_const</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>case_insensitive</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Delimiter'>, 
</span><a name="LN5634"></a>                   <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>prefix_const</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rest_selec</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5636"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typeid</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a><span class='Delimiter'>; 
</span><a name="LN5637"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>prefix</span><span class='Delimiter'>; 
</span><a name="LN5638"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>exact</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Should be unnecessary, there are no bytea regex operators defined. As 
     * such, it should be noted that the rest of this function has *not* been 
     * made safe for binary (possibly NULL containing) strings. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>typeid </span><span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>         <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"regular-expression matching not supported on type bytea"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Use the regexp machinery to extract the prefix, if any */ 
</span>    <a href="selfuncs.c.html#LN5637"><span class='Ref_To_Local'>prefix</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN72"><span class='Ref_to_Proto'>regexp_fixed_prefix</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN255"><span class='Ref_to_Macro'>DatumGetTextPP</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="selfuncs.c.html#LN5638"><span class='Ref_To_Local'>exact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5637"><span class='Ref_To_Local'>prefix</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN5634"><span class='Ref_to_Parameter'>prefix_const</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5634"><span class='Ref_to_Parameter'>rest_selec</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5661"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>patt</span> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Operator'>*</span><a href="selfuncs.c.html#LN5634"><span class='Ref_to_Parameter'>rest_selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN210"><span class='Ref_to_Proto'>regex_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5661"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>, </span>strlen<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5661"><span class='Ref_To_Local'>patt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Delimiter'>, 
</span>                                            <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5661"><span class='Ref_To_Local'>patt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_None</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN5634"><span class='Ref_to_Parameter'>prefix_const</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/indxpath.c.html#LN190"><span class='Ref_to_Proto'>string_to_const</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5637"><span class='Ref_To_Local'>prefix</span></a><span class='Delimiter'>, </span><span class='Keyword'>typeid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5634"><span class='Ref_to_Parameter'>rest_selec</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5638"><span class='Ref_To_Local'>exact</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Exact match, so there's no additional selectivity */ 
</span>            <span class='Operator'>*</span><a href="selfuncs.c.html#LN5634"><span class='Ref_to_Parameter'>rest_selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN5683"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>patt</span> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>patt_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Operator'>*</span><a href="selfuncs.c.html#LN5634"><span class='Ref_to_Parameter'>rest_selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN210"><span class='Ref_to_Proto'>regex_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5683"><span class='Ref_To_Local'>patt</span></a><span class='Delimiter'>, </span>strlen<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5683"><span class='Ref_To_Local'>patt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN5633"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Delimiter'>, 
</span>                                            strlen<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5637"><span class='Ref_To_Local'>prefix</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5683"><span class='Ref_To_Local'>patt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5637"><span class='Ref_To_Local'>prefix</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5638"><span class='Ref_To_Local'>exact</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_Exact</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* pattern specifies exact match */ 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_Partial</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end regex_fixed_prefix &raquo; </span> 
 
<a href="../../../include/utils/selfuncs.h.html#LN93"><span class='Ref_to_Typedef'>Pattern_Prefix_Status</span></a> 
<a name="LN5701"></a><span class='Declare_Function'>pattern_fixed_prefix</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>patt</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN87"><span class='Ref_to_Typedef'>Pattern_Type</span></a> <span class='Declare_Parameter'>ptype</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Delimiter'>, 
</span><a name="LN5702"></a>                     <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>prefix</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rest_selec</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5704"></a>    <a href="../../../include/utils/selfuncs.h.html#LN93"><span class='Ref_to_Typedef'>Pattern_Prefix_Status</span></a> <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>ptype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN5704"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5524"><span class='Ref_to_Func'>like_fixed_prefix</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>, 
</span>                                       <a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>prefix</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>rest_selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/selfuncs.h.html#LN89"><span class='Ref_to_EnumConst'>Pattern_Type_Like_IC</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN5704"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5524"><span class='Ref_to_Func'>like_fixed_prefix</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>, 
</span>                                       <a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>prefix</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>rest_selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN5704"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5632"><span class='Ref_to_Func'>regex_fixed_prefix</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>prefix</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>rest_selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/utils/selfuncs.h.html#LN90"><span class='Ref_to_EnumConst'>Pattern_Type_Regex_IC</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN5704"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5632"><span class='Ref_to_Func'>regex_fixed_prefix</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>, 
</span>                                        <a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>prefix</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5702"><span class='Ref_to_Parameter'>rest_selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized ptype: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN5701"><span class='Ref_to_Parameter'>ptype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5704"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN95"><span class='Ref_to_EnumConst'>Pattern_Prefix_None</span></a><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch ptype &raquo; </span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5704"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pattern_fixed_prefix &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate the selectivity of a fixed prefix for a pattern match. 
 * 
 * A fixed prefix "foo" is estimated as the selectivity of the expression 
 * "variable &GT;= 'foo' AND variable &LT; 'fop'" (see also indxpath.c). 
 * 
 * The selectivity estimate is with respect to the portion of the column 
 * population represented by the histogram --- the caller must fold this 
 * together with info about MCVs and NULLs. 
 * 
 * We use the &GT;= and &LT; operators from the specified btree opfamily to do the 
 * estimation.  The given variable and Const must be of the associated 
 * datatype. 
 * 
 * XXX Note: we make use of the upper bound to estimate operator selectivity 
 * even if the locale is such that we cannot rely on the upper-bound string. 
 * The selectivity only needs to be approximately right anyway, so it seems 
 * more useful to use the upper-bound code than not. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN5752"></a><span class='Declare_Function'>prefix_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vardata</span><span class='Delimiter'>, 
</span><a name="LN5753"></a>                   <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>vartype</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opfamily</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prefixcon</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5755"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>prefixsel</span><span class='Delimiter'>; 
</span><a name="LN5756"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>cmpopr</span><span class='Delimiter'>; 
</span><a name="LN5757"></a>    <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>opproc</span><span class='Delimiter'>; 
</span><a name="LN5758"></a>    <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>greaterstrcon</span><span class='Delimiter'>; 
</span><a name="LN5759"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>eq_sel</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>vartype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>vartype</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no &GT;= operator for opfamily %u"</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5757"><span class='Ref_To_Local'>opproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN5755"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN163"><span class='Ref_to_Proto'>ineq_histogram_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5752"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5752"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5757"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>prefixcon</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>prefixcon</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5755"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No histogram is present ... return a suitable default estimate */ 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/selfuncs.h.html#LN42"><span class='Ref_to_Const'>DEFAULT_MATCH_SEL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/*------- 
     * If we can create a string larger than the prefix, say 
     *  "x &LT; greaterstr". 
     *------- 
     */ 
</span>    <a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>vartype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>vartype</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no &LT; operator for opfamily %u"</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5757"><span class='Ref_To_Local'>opproc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN5758"><span class='Ref_To_Local'>greaterstrcon</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN181"><span class='Ref_to_Proto'>make_greater_string</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>prefixcon</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5757"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5758"><span class='Ref_To_Local'>greaterstrcon</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5791"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>topsel</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN5791"><span class='Ref_To_Local'>topsel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN163"><span class='Ref_to_Proto'>ineq_histogram_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5752"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5752"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN5757"><span class='Ref_To_Local'>opproc</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN5758"><span class='Ref_To_Local'>greaterstrcon</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN5758"><span class='Ref_To_Local'>greaterstrcon</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ineq_histogram_selectivity worked before, it shouldn't fail now */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5791"><span class='Ref_To_Local'>topsel</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Merge the two selectivities in the same way as for a range query 
         * (see clauselist_selectivity()).  Note that we don't need to worry 
         * about double-exclusion of nulls, since ineq_histogram_selectivity 
         * doesn't count those anyway. 
         */ 
</span>        <a href="selfuncs.c.html#LN5755"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5791"><span class='Ref_To_Local'>topsel</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN5755"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the prefix is long then the two bounding values might be too close 
     * together for the histogram to distinguish them usefully, resulting in a 
     * zero estimate (plus or minus roundoff error). To avoid returning a 
     * ridiculously small estimate, compute the estimated selectivity for 
     * "variable = 'foo'", and clamp to that. (Obviously, the resultant 
     * estimate should be at least that.) 
     * 
     * We apply this even if we couldn't make a greater string.  That case 
     * suggests that the prefix is near the maximum possible, and thus 
     * probably off the end of the histogram, and thus we probably got a very 
     * small estimate from the &GT;= condition; so we still need to clamp. 
     */ 
</span>    <a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>vartype</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>vartype</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no = operator for opfamily %u"</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>opfamily</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN5759"><span class='Ref_To_Local'>eq_sel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN157"><span class='Ref_to_Proto'>var_eq_const</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5752"><span class='Ref_to_Parameter'>vardata</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5756"><span class='Ref_To_Local'>cmpopr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5753"><span class='Ref_to_Parameter'>prefixcon</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>, 
</span>                          <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN5755"><span class='Ref_To_Local'>prefixsel</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5755"><span class='Ref_To_Local'>prefixsel</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5759"><span class='Ref_To_Local'>eq_sel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5755"><span class='Ref_To_Local'>prefixsel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end prefix_selectivity &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate the selectivity of a pattern of the specified type. 
 * Note that any fixed prefix of the pattern will have been removed already, 
 * so actually we may be looking at just a fragment of the pattern. 
 * 
 * For now, we use a very simplistic approach: fixed characters reduce the 
 * selectivity a good deal, character ranges reduce it a little, 
 * wildcards (such as % for LIKE or .* for regex) increase it. 
 */ 
</span> 
<a name="LN5845"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FIXED_CHAR_SEL</span>  <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>20</span>    <span class='Comment_Single_Line'>/* about 1/5 */ 
</span><a name="LN5846"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CHAR_RANGE_SEL</span>  <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>25</span> 
<a name="LN5847"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ANY_CHAR_SEL</span>    <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>9</span>     <span class='Comment_Single_Line'>/* not 1, since it won't match end-of-string */ 
</span><a name="LN5848"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FULL_WILDCARD_SEL</span> <span class='Number'>5</span><span class='Operator'>.</span><span class='Number'>0</span> 
<a name="LN5849"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PARTIAL_WILDCARD_SEL</span> <span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> 
 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN5852"></a><span class='Declare_Function'>like_selectivity</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>patt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>pattlen</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>case_insensitive</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5854"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>sel</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5855"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>pos</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Skip any leading wildcard; it's already factored into initial sel */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>pattlen</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='String'>'%'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='String'>'_'</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>pattlen</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* % and _ are wildcard characters in LIKE */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'%'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN5854"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5848"><span class='Ref_to_Const'>FULL_WILDCARD_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'_'</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN5854"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5847"><span class='Ref_to_Const'>ANY_CHAR_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'\\'</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Backslash quotes the next character */ 
</span>            <a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5855"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN5852"><span class='Ref_to_Parameter'>pattlen</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN5854"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5845"><span class='Ref_to_Const'>FIXED_CHAR_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN5854"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5845"><span class='Ref_to_Const'>FIXED_CHAR_SEL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Could get sel &GT; 1 if multiple wildcards */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5854"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN5854"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5854"><span class='Ref_To_Local'>sel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end like_selectivity &raquo; </span> 
 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN5889"></a><span class='Declare_Function'>regex_selectivity_sub</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>patt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>pattlen</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>case_insensitive</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5891"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>sel</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5892"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>paren_depth</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5893"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>paren_pos</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* dummy init to keep compiler quiet */ 
</span><a name="LN5894"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>pos</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>pattlen</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'('</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5893"><span class='Ref_To_Local'>paren_pos</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* remember start of parenthesized item */ 
</span>            <a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>')'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5888"><span class='Ref_to_Func'>regex_selectivity_sub</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5893"><span class='Ref_To_Local'>paren_pos</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                             <a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5893"><span class='Ref_To_Local'>paren_pos</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                             <a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'|'</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If unquoted | is present at paren level 0 in pattern, we have 
             * multiple alternatives; sum their probabilities. 
             */ 
</span>            <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN5888"><span class='Ref_to_Func'>regex_selectivity_sub</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* rest of pattern is now processed */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'['</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5925"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>negclass</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><span class='Operator'>++</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'^'</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN5925"><span class='Ref_To_Local'>negclass</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>']'</span><span class='Parentheses'>)</span>       <span class='Comment_Multi_Line'>/* ']' at start of class is not 
                                         * special */ 
</span>                <a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='String'>']'</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5925"><span class='Ref_To_Local'>negclass</span></a> <span class='Operator'>? </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="selfuncs.c.html#LN5846"><span class='Ref_to_Const'>CHAR_RANGE_SEL</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><a href="selfuncs.c.html#LN5846"><span class='Ref_to_Const'>CHAR_RANGE_SEL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'.'</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5847"><span class='Ref_to_Const'>ANY_CHAR_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'*'</span> <span class='Operator'>|| 
</span>                 <a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'?'</span> <span class='Operator'>|| 
</span>                 <a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'+'</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Ought to be smarter about quantifiers... */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5849"><span class='Ref_to_Const'>PARTIAL_WILDCARD_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'{'</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='String'>'}'</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5849"><span class='Ref_to_Const'>PARTIAL_WILDCARD_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'\\'</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* backslash quotes the next character */ 
</span>            <a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5894"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>&GT;= </span><a href="selfuncs.c.html#LN5889"><span class='Ref_to_Parameter'>pattlen</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5845"><span class='Ref_to_Const'>FIXED_CHAR_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5892"><span class='Ref_To_Local'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5845"><span class='Ref_to_Const'>FIXED_CHAR_SEL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for pos=0;pos&LT;pattlen;pos... &raquo; </span> 
    <span class='Comment_Multi_Line'>/* Could get sel &GT; 1 if multiple wildcards */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5891"><span class='Ref_To_Local'>sel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end regex_selectivity_sub &raquo; </span> 
 
<span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN5982"></a><span class='Declare_Function'>regex_selectivity</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>patt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>pattlen</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>case_insensitive</span><span class='Delimiter'>, 
</span><a name="LN5983"></a>                  <span class='Keyword'>int </span><span class='Declare_Parameter'>fixed_prefix_len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5985"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>sel</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If patt doesn't end with $, consider it to have a trailing wildcard */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'$'</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>- </span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='String'>'\\'</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* has trailing $ */ 
</span>        <a href="selfuncs.c.html#LN5985"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5888"><span class='Ref_to_Func'>regex_selectivity_sub</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>pattlen</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* no trailing $ */ 
</span>        <a href="selfuncs.c.html#LN5985"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN5888"><span class='Ref_to_Func'>regex_selectivity_sub</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>patt</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>pattlen</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5982"><span class='Ref_to_Parameter'>case_insensitive</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN5985"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN5848"><span class='Ref_to_Const'>FULL_WILDCARD_SEL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If there's a fixed prefix, discount its selectivity */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5983"><span class='Ref_to_Parameter'>fixed_prefix_len</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN5985"><span class='Ref_To_Local'>sel</span></a> <span class='Operator'>/= </span>pow<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5845"><span class='Ref_to_Const'>FIXED_CHAR_SEL</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN5983"><span class='Ref_to_Parameter'>fixed_prefix_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure result stays in range */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN5985"><span class='Ref_To_Local'>sel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN5985"><span class='Ref_To_Local'>sel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end regex_selectivity &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * For bytea, the increment function need only increment the current byte 
 * (there are no multibyte characters to worry about). 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN6016"></a><span class='Declare_Function'>byte_increment</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Declare_Parameter'>ptr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN6016"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>&GT;= </span><span class='Number'>255</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN6016"><span class='Ref_to_Parameter'>ptr</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Try to generate a string greater than the given string or any 
 * string it is a prefix of.  If successful, return a palloc'd string 
 * in the form of a Const node; else return NULL. 
 * 
 * The caller must provide the appropriate "less than" comparison function 
 * for testing the strings, along with the collation to use. 
 * 
 * The key requirement here is that given a prefix string, say "foo", 
 * we must be able to generate another string "fop" that is greater than 
 * all strings "foobar" starting with "foo".  We can test that we have 
 * generated a string greater than the prefix string, but in non-C collations 
 * that is not a bulletproof guarantee that an extension of the string might 
 * not sort after it; an example is that "foo " is less than "foo!", but it 
 * is not clear that a "dictionary" sort ordering will consider "foo!" less 
 * than "foo bar".  CAUTION: Therefore, this function should be used only for 
 * estimation purposes when working in a non-C collation. 
 * 
 * To try to catch most cases where an extended string might otherwise sort 
 * before the result value, we determine which of the strings "Z", "z", "y", 
 * and "9" is seen as largest by the collation, and append that to the given 
 * prefix before trying to find a string that compares as larger. 
 * 
 * To search for a greater string, we repeatedly "increment" the rightmost 
 * character, using an encoding-specific character incrementer function. 
 * When it's no longer possible to increment the last character, we truncate 
 * off that character and start incrementing the next-to-rightmost. 
 * For example, if "z" were the last character in the sort order, then we 
 * could produce "foo" as a string greater than "fonz". 
 * 
 * This could be rather slow in the worst case, but in most cases we 
 * won't have to try more than one or two strings before succeeding. 
 * 
 * Note that it's important for the character incrementer not to be too anal 
 * about producing every possible character code, since in some cases the only 
 * way to get a larger string is to increment a previous character position. 
 * So we don't want to spend too much time trying every possible character 
 * code at the last position.  A good rule of thumb is to be sure that we 
 * don't try more than 256*K values for a K-byte character (and definitely 
 * not 256^K, which is what an exhaustive search would approach). 
 */ 
</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>* 
</span><a name="LN6066"></a><span class='Declare_Function'>make_greater_string</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>str_const</span><span class='Delimiter'>, </span><a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ltproc</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6068"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>datatype</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a><span class='Delimiter'>; 
</span><a name="LN6069"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>workstr</span><span class='Delimiter'>; 
</span><a name="LN6070"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span><a name="LN6071"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>cmpstr</span><span class='Delimiter'>; 
</span><a name="LN6072"></a>    <a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cmptxt</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN6073"></a>    <a href="../../../include/mb/pg_wchar.h.html#LN355"><span class='Ref_to_Typedef'>mbcharacter_incrementer</span></a> <span class='Declare_Local'>charinc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get a modifiable copy of the prefix string in C-string format, and set 
     * up the string we will compare to as a Datum.  In C locale this can just 
     * be the given prefix string, otherwise we need to add a suffix.  Types 
     * NAME and BYTEA sort bytewise so they don't need a suffix either. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6068"><span class='Ref_To_Local'>datatype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN20"><span class='Ref_to_Const'>NAMEOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN571"><span class='Ref_to_Macro'>DatumGetCString</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN583"><span class='Ref_to_Macro'>DirectFunctionCall1</span></a><span class='Parentheses'>(</span><a href="name.c.html#LN67"><span class='Ref_to_Func'>nameout</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6071"><span class='Ref_To_Local'>cmpstr</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6068"><span class='Ref_To_Local'>datatype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6090"></a>        <a href="../../../include/c.h.html#LN451"><span class='Ref_to_Typedef'>bytea</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>bstr</span> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN254"><span class='Ref_to_Macro'>DatumGetByteaPP</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN339"><span class='Ref_to_Macro'>VARSIZE_ANY_EXHDR</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6090"><span class='Ref_To_Local'>bstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN346"><span class='Ref_to_Macro'>VARDATA_ANY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6090"><span class='Ref_To_Local'>bstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN244"><span class='Ref_to_Typedef'>Pointer</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6090"><span class='Ref_To_Local'>bstr</span></a> <span class='Operator'>== </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6071"><span class='Ref_To_Local'>cmpstr</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/pg_locale.h.html#LN50"><span class='Ref_to_Proto'>lc_collate_is_c</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="selfuncs.c.html#LN6071"><span class='Ref_To_Local'>cmpstr</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>str_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* If first time through, determine the suffix to use */ 
</span><a name="LN6107"></a>            <span class='Keyword'>static char </span><span class='Declare_Local'>suffixchar</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN6108"></a>            <span class='Keyword'>static </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>  <span class='Declare_Local'>suffixcollation</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN6107"><span class='Ref_To_Local'>suffixchar</span></a> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN6108"><span class='Ref_To_Local'>suffixcollation</span></a> <span class='Operator'>!= </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN6112"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>best</span><span class='Delimiter'>; 
</span> 
                <a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a> <span class='Operator'>= </span><span class='String'>"Z"</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/varlena.h.html#LN18"><span class='Ref_to_Proto'>varstr_cmp</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='String'>"z"</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a> <span class='Operator'>= </span><span class='String'>"z"</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/varlena.h.html#LN18"><span class='Ref_to_Proto'>varstr_cmp</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='String'>"y"</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a> <span class='Operator'>= </span><span class='String'>"y"</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/varlena.h.html#LN18"><span class='Ref_to_Proto'>varstr_cmp</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='String'>"9"</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a> <span class='Operator'>= </span><span class='String'>"9"</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6107"><span class='Ref_To_Local'>suffixchar</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN6112"><span class='Ref_To_Local'>best</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6108"><span class='Ref_To_Local'>suffixcollation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* And build the string to compare to */ 
</span>            <a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../../contrib/seg/segparse.y.html#LN46"><span class='Ref_to_Global_Var'>text</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN444"><span class='Ref_to_Const'>VARHDRSZ</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/postgres.h.html#LN327"><span class='Ref_to_Macro'>SET_VARSIZE</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN444"><span class='Ref_to_Const'>VARHDRSZ</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            memcpy<span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN302"><span class='Ref_to_Macro'>VARDATA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN302"><span class='Ref_to_Macro'>VARDATA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6107"><span class='Ref_To_Local'>suffixchar</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6071"><span class='Ref_To_Local'>cmpstr</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Select appropriate character-incrementer function */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6068"><span class='Ref_To_Local'>datatype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN6073"><span class='Ref_To_Local'>charinc</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6015"><span class='Ref_to_Func'>byte_increment</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN6073"><span class='Ref_To_Local'>charinc</span></a> <span class='Operator'>= </span><a href="../../../include/mb/pg_wchar.h.html#LN536"><span class='Ref_to_Proto'>pg_database_encoding_character_incrementer</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And search ... */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6143"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>charlen</span><span class='Delimiter'>; 
</span><a name="LN6144"></a>        <span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Declare_Local'>lastchar</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Identify the last character --- for bytea, just the last byte */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6068"><span class='Ref_To_Local'>datatype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN6143"><span class='Ref_To_Local'>charlen</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN6143"><span class='Ref_To_Local'>charlen</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>- </span><a href="../../../include/mb/pg_wchar.h.html#LN530"><span class='Ref_to_Proto'>pg_mbcliplen</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6144"><span class='Ref_To_Local'>lastchar</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>unsigned char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN6143"><span class='Ref_To_Local'>charlen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to generate a larger string by incrementing the last character 
         * (for BYTEA, we treat each byte as a character). 
         * 
         * Note: the incrementer function is expected to return true if it's 
         * generated a valid-per-the-encoding new character, otherwise false. 
         * The contents of the character on false return are unspecified. 
         */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6073"><span class='Ref_To_Local'>charinc</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6144"><span class='Ref_To_Local'>lastchar</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6143"><span class='Ref_To_Local'>charlen</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6163"></a>            <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>workstr_const</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6068"><span class='Ref_To_Local'>datatype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN6163"><span class='Ref_To_Local'>workstr_const</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN215"><span class='Ref_to_Proto'>string_to_bytea_const</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN6163"><span class='Ref_To_Local'>workstr_const</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/indxpath.c.html#LN190"><span class='Ref_to_Proto'>string_to_const</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6068"><span class='Ref_To_Local'>datatype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>ltproc</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN6066"><span class='Ref_to_Parameter'>collation</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN6071"><span class='Ref_To_Local'>cmpstr</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN6163"><span class='Ref_To_Local'>workstr_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Successfully made a string larger than cmpstr */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="selfuncs.c.html#LN6163"><span class='Ref_To_Local'>workstr_const</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* No good, release unusable value and try again */ 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6163"><span class='Ref_To_Local'>workstr_const</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6163"><span class='Ref_To_Local'>workstr_const</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while charinc(lastchar,char... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * No luck here, so truncate off the last character and try to 
         * increment the next one. 
         */ 
</span>        <a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>-= </span><a href="selfuncs.c.html#LN6143"><span class='Ref_To_Local'>charlen</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN6070"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while len&GT;0 &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Failed... */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6072"><span class='Ref_To_Local'>cmptxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6069"><span class='Ref_To_Local'>workstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_greater_string &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Generate a Datum of the appropriate type from a C string. 
 * Note that all of the supported types are pass-by-ref, so the 
 * returned value should be pfree'd if no longer needed. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN6209"></a><span class='Declare_Function'>string_to_datum</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datatype</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6209"><span class='Ref_to_Parameter'>str</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We cheat a little by assuming that CStringGetTextDatum() will do for 
     * bpchar and varchar constants too... 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6209"><span class='Ref_to_Parameter'>datatype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN20"><span class='Ref_to_Const'>NAMEOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/fmgr.h.html#LN583"><span class='Ref_to_Macro'>DirectFunctionCall1</span></a><span class='Parentheses'>(</span><a href="name.c.html#LN44"><span class='Ref_to_Func'>namein</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN583"><span class='Ref_to_Macro'>CStringGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6209"><span class='Ref_to_Parameter'>str</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6209"><span class='Ref_to_Parameter'>datatype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/fmgr.h.html#LN583"><span class='Ref_to_Macro'>DirectFunctionCall1</span></a><span class='Parentheses'>(</span><a href="varlena.c.html#LN253"><span class='Ref_to_Func'>byteain</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN583"><span class='Ref_to_Macro'>CStringGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6209"><span class='Ref_to_Parameter'>str</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="../../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6209"><span class='Ref_to_Parameter'>str</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Generate a Const node of the appropriate type from a C string. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>* 
</span><a name="LN6229"></a><span class='Declare_Function'>string_to_const</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datatype</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6231"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>conval</span> <span class='Operator'>= </span><a href="../../optimizer/path/indxpath.c.html#LN189"><span class='Ref_to_Proto'>string_to_datum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6229"><span class='Ref_to_Parameter'>str</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6229"><span class='Ref_to_Parameter'>datatype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6232"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>collation</span><span class='Delimiter'>; 
</span><a name="LN6233"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>constlen</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We only need to support a few datatypes here, so hard-wire properties 
     * instead of incurring the expense of catalog lookups. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6229"><span class='Ref_to_Parameter'>datatype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN49"><span class='Ref_to_Const'>VARCHAROID</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN48"><span class='Ref_to_Const'>BPCHAROID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN6232"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6233"><span class='Ref_To_Local'>constlen</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN20"><span class='Ref_to_Const'>NAMEOID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN6232"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6233"><span class='Ref_To_Local'>constlen</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Operator'>: 
</span>            <a href="selfuncs.c.html#LN6232"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6233"><span class='Ref_To_Local'>constlen</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected datatype in string_to_const: %u"</span><span class='Delimiter'>, 
</span>                 <a href="selfuncs.c.html#LN6229"><span class='Ref_to_Parameter'>datatype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch datatype &raquo; </span> 
 
    <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6229"><span class='Ref_to_Parameter'>datatype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6232"><span class='Ref_To_Local'>collation</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6233"><span class='Ref_To_Local'>constlen</span></a><span class='Delimiter'>, 
</span>                     <a href="selfuncs.c.html#LN6231"><span class='Ref_To_Local'>conval</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end string_to_const &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Generate a Const node of bytea type from a binary C string and a length. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>* 
</span><a name="LN6272"></a><span class='Declare_Function'>string_to_bytea_const</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span>size_t <span class='Declare_Parameter'>str_len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6274"></a>    <a href="../../../include/c.h.html#LN451"><span class='Ref_to_Typedef'>bytea</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>bstr</span> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN444"><span class='Ref_to_Const'>VARHDRSZ</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6272"><span class='Ref_to_Parameter'>str_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6275"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>conval</span><span class='Delimiter'>; 
</span> 
    memcpy<span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN302"><span class='Ref_to_Macro'>VARDATA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6274"><span class='Ref_To_Local'>bstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6272"><span class='Ref_to_Parameter'>str</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6272"><span class='Ref_to_Parameter'>str_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/postgres.h.html#LN327"><span class='Ref_to_Macro'>SET_VARSIZE</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6274"><span class='Ref_To_Local'>bstr</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN444"><span class='Ref_to_Const'>VARHDRSZ</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6272"><span class='Ref_to_Parameter'>str_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6275"><span class='Ref_To_Local'>conval</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6274"><span class='Ref_To_Local'>bstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN18"><span class='Ref_to_Const'>BYTEAOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6275"><span class='Ref_To_Local'>conval</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * Index cost estimation functions 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN6292"></a><span class='Declare_Function'>deconstruct_indexquals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6294"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN6295"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6292"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN6296"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcc</span><span class='Delimiter'>, 
</span><a name="LN6297"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lci</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6296"><span class='Ref_To_Local'>lcc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6292"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1032"><span class='Ref_to_Member'>indexquals</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6297"><span class='Ref_To_Local'>lci</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6292"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1033"><span class='Ref_to_Member'>indexqualcols</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6301"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6296"><span class='Ref_To_Local'>lcc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6302"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>indexcol</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6297"><span class='Ref_To_Local'>lci</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6303"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span><span class='Delimiter'>; 
</span><a name="LN6304"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftop</span><span class='Delimiter'>, 
</span><a name="LN6305"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>rightop</span><span class='Delimiter'>; 
</span><a name="LN6306"></a>        <a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>qinfo</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6301"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN105"><span class='Ref_to_Member'>rinfo</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6301"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN106"><span class='Ref_to_Member'>indexcol</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6302"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN108"><span class='Ref_to_Member'>clause_op</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6304"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN32"><span class='Ref_to_Proto'>get_leftop</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6305"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN33"><span class='Ref_to_Proto'>get_rightop</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN75"><span class='Ref_to_Proto'>match_index_to_operand</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6304"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6302"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6295"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN107"><span class='Ref_to_Member'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6305"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN75"><span class='Ref_to_Proto'>match_index_to_operand</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6305"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6302"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6295"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN107"><span class='Ref_to_Member'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6304"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6333"></a>            <a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>; 
</span> 
            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN108"><span class='Ref_to_Member'>clause_op</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN112"><span class='Ref_to_Macro'>linitial_oid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6333"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Examine only first columns to determine left/right sides */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN75"><span class='Ref_to_Proto'>match_index_to_operand</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6333"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                       <a href="selfuncs.c.html#LN6302"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6295"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN107"><span class='Ref_to_Member'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6333"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN75"><span class='Ref_to_Proto'>match_index_to_operand</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6333"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN6302"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6295"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN107"><span class='Ref_to_Member'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6333"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(clause,RowCompare... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6353"></a>            <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>; 
</span> 
            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN108"><span class='Ref_to_Member'>clause_op</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6353"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN537"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* index column is always on the left in this case */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN75"><span class='Ref_to_Proto'>match_index_to_operand</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6353"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <a href="selfuncs.c.html#LN6302"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6295"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN107"><span class='Ref_to_Member'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6353"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN108"><span class='Ref_to_Member'>clause_op</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN75"><span class='Ref_to_Proto'>match_index_to_operand</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>, 
</span>                                          <a href="selfuncs.c.html#LN6302"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6295"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN107"><span class='Ref_to_Member'>varonleft</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported indexqual type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6303"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="selfuncs.c.html#LN6294"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6294"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6306"><span class='Ref_To_Local'>qinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN6294"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end deconstruct_indexquals &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Simple function to compute the total eval cost of the "other operands" 
 * in an IndexQualInfo list.  Since we know these will be evaluated just 
 * once per scan, there's no need to distinguish startup from per-row cost. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> 
<a name="LN6387"></a><span class='Declare_Function'>other_operands_eval_cost</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qinfos</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6389"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>qual_arg_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN6390"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6390"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6387"><span class='Ref_to_Parameter'>qinfos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6394"></a>        <a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>qinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6390"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6395"></a>        <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>index_qual_cost</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6395"><span class='Ref_To_Local'>index_qual_cost</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6394"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6387"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6389"><span class='Ref_To_Local'>qual_arg_cost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6395"><span class='Ref_To_Local'>index_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6395"><span class='Ref_To_Local'>index_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN6389"><span class='Ref_To_Local'>qual_arg_cost</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get other-operand eval cost for an index orderby list. 
 * 
 * Index orderby expressions aren't represented as RestrictInfos (since they 
 * aren't boolean, usually).  So we can't apply deconstruct_indexquals to 
 * them.  However, they are much simpler to deal with since they are always 
 * OpExprs and the index column is always on the left. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> 
<a name="LN6412"></a><span class='Declare_Function'>orderby_operands_eval_cost</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6414"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>qual_arg_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN6415"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6415"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6412"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1034"><span class='Ref_to_Member'>indexorderbys</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6419"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6415"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6420"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>other_operand</span><span class='Delimiter'>; 
</span><a name="LN6421"></a>        <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>index_qual_cost</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6419"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN6420"><span class='Ref_To_Local'>other_operand</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN33"><span class='Ref_to_Proto'>get_rightop</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6419"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported indexorderby type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6419"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6420"><span class='Ref_To_Local'>other_operand</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6421"><span class='Ref_To_Local'>index_qual_cost</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6420"><span class='Ref_To_Local'>other_operand</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6412"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6414"><span class='Ref_To_Local'>qual_arg_cost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6421"><span class='Ref_To_Local'>index_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6421"><span class='Ref_To_Local'>index_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN6414"><span class='Ref_To_Local'>qual_arg_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end orderby_operands_eval_cost &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN6441"></a><span class='Declare_Function'>genericcostestimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN6442"></a>                    <a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN6443"></a>                    <span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN6444"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qinfos</span><span class='Delimiter'>, 
</span><a name="LN6445"></a>                    <a href="../../../include/utils/selfuncs.h.html#LN125"><span class='Ref_to_Typedef'>GenericCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>costs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6447"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6442"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN6448"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexQuals</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6442"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1032"><span class='Ref_to_Member'>indexquals</span></a><span class='Delimiter'>; 
</span><a name="LN6449"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexOrderBys</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6442"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1034"><span class='Ref_to_Member'>indexorderbys</span></a><span class='Delimiter'>; 
</span><a name="LN6450"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>indexStartupCost</span><span class='Delimiter'>; 
</span><a name="LN6451"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>indexTotalCost</span><span class='Delimiter'>; 
</span><a name="LN6452"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>indexSelectivity</span><span class='Delimiter'>; 
</span><a name="LN6453"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>indexCorrelation</span><span class='Delimiter'>; 
</span><a name="LN6454"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numIndexPages</span><span class='Delimiter'>; 
</span><a name="LN6455"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numIndexTuples</span><span class='Delimiter'>; 
</span><a name="LN6456"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>spc_random_page_cost</span><span class='Delimiter'>; 
</span><a name="LN6457"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>num_sa_scans</span><span class='Delimiter'>; 
</span><a name="LN6458"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>num_outer_scans</span><span class='Delimiter'>; 
</span><a name="LN6459"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>num_scans</span><span class='Delimiter'>; 
</span><a name="LN6460"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>qual_op_cost</span><span class='Delimiter'>; 
</span><a name="LN6461"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>qual_arg_cost</span><span class='Delimiter'>; 
</span><a name="LN6462"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>selectivityQuals</span><span class='Delimiter'>; 
</span><a name="LN6463"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the index is partial, AND the index predicate with the explicitly 
     * given indexquals to produce a more accurate idea of the index 
     * selectivity. 
     */ 
</span>    <a href="selfuncs.c.html#LN6462"><span class='Ref_To_Local'>selectivityQuals</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN216"><span class='Ref_to_Proto'>add_predicate_to_quals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6448"><span class='Ref_To_Local'>indexQuals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for ScalarArrayOpExpr index quals, and estimate the number of 
     * index scans that will be performed. 
     */ 
</span>    <a href="selfuncs.c.html#LN6457"><span class='Ref_To_Local'>num_sa_scans</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6463"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6448"><span class='Ref_To_Local'>indexQuals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6479"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6463"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6479"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6483"></a>            <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6479"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN6484"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>alength</span> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN195"><span class='Ref_to_Proto'>estimate_array_length</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6483"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6484"><span class='Ref_To_Local'>alength</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN6457"><span class='Ref_To_Local'>num_sa_scans</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN6484"><span class='Ref_To_Local'>alength</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Estimate the fraction of main-table tuples that will be visited */ 
</span>    <a href="selfuncs.c.html#LN6452"><span class='Ref_To_Local'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6441"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6462"><span class='Ref_To_Local'>selectivityQuals</span></a><span class='Delimiter'>, 
</span>                                              <a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                              <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If caller didn't give us an estimate, estimate the number of index 
     * tuples that will be visited.  We do it in this rather peculiar-looking 
     * way in order to get the right answer for partial indexes. 
     */ 
</span>    <a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN135"><span class='Ref_to_Member'>numIndexTuples</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6452"><span class='Ref_To_Local'>indexSelectivity</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The above calculation counts all the tuples visited across all 
         * scans induced by ScalarArrayOpExpr nodes.  We want to consider the 
         * average per-indexscan number, so adjust.  This is a handy place to 
         * round to integer, too.  (If caller supplied tuple estimate, it's 
         * responsible for handling these considerations.) 
         */ 
</span>        <a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN6457"><span class='Ref_To_Local'>num_sa_scans</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can bound the number of tuples by the index size in any case. Also, 
     * always estimate at least one tuple is touched, even when 
     * indexSelectivity estimate is tiny. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate the number of index pages that will be retrieved. 
     * 
     * We use the simplistic method of taking a pro-rata fraction of the total 
     * number of index pages.  In effect, this counts only leaf pages and not 
     * any overhead such as index metapage or upper tree levels. 
     * 
     * In practice access to upper index levels is often nearly free because 
     * those tend to stay in cache under load; moreover, the cost involved is 
     * highly dependent on index type.  We therefore ignore such costs here 
     * and leave it to the caller to add a suitable charge if needed. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN6454"><span class='Ref_To_Local'>numIndexPages</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN6454"><span class='Ref_To_Local'>numIndexPages</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch estimated page cost for tablespace containing index */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN631"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="selfuncs.c.html#LN6456"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>, 
</span>                              <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now compute the disk access costs. 
     * 
     * The above calculations are all per-index-scan.  However, if we are in a 
     * nestloop inner scan, we can expect the scan to be repeated (with 
     * different search keys) for each row of the outer relation.  Likewise, 
     * ScalarArrayOpExpr quals result in multiple index scans.  This creates 
     * the potential for cache effects to reduce the number of disk page 
     * fetches needed.  We want to estimate the average per-scan I/O cost in 
     * the presence of caching. 
     * 
     * We use the Mackert-Lohman formula (see costsize.c for details) to 
     * estimate the total number of page fetches that occur.  While this 
     * wasn't what it was designed for, it seems a reasonable model anyway. 
     * Note that we are counting pages not tuples anymore, so we take N = T = 
     * index size, as if there were one "tuple" per page. 
     */ 
</span>    <a href="selfuncs.c.html#LN6458"><span class='Ref_To_Local'>num_outer_scans</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6443"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6459"><span class='Ref_To_Local'>num_scans</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6457"><span class='Ref_To_Local'>num_sa_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6458"><span class='Ref_To_Local'>num_outer_scans</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6459"><span class='Ref_To_Local'>num_scans</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6571"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>pages_fetched</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* total page fetches ignoring cache effects */ 
</span>        <a href="selfuncs.c.html#LN6571"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6454"><span class='Ref_To_Local'>numIndexPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6459"><span class='Ref_To_Local'>num_scans</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* use Mackert and Lohman formula to adjust for cache effects */ 
</span>        <a href="selfuncs.c.html#LN6571"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6571"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6447"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <a href="selfuncs.c.html#LN6441"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now compute the total disk access cost, and then report a pro-rated 
         * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr, 
         * since that's internal to the indexscan.) 
         */ 
</span>        <a href="selfuncs.c.html#LN6451"><span class='Ref_To_Local'>indexTotalCost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6571"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6456"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>/ </span><a href="selfuncs.c.html#LN6458"><span class='Ref_To_Local'>num_outer_scans</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if num_scans&GT;1 &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For a single index scan, we just charge spc_random_page_cost per 
         * page touched. 
         */ 
</span>        <a href="selfuncs.c.html#LN6451"><span class='Ref_To_Local'>indexTotalCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6454"><span class='Ref_To_Local'>numIndexPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6456"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * CPU cost: any complex expressions in the indexquals will need to be 
     * evaluated once at the start of the scan to reduce them to runtime keys 
     * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple 
     * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per 
     * indexqual operator.  Because we have numIndexTuples as a per-scan 
     * number, we have to multiply by num_sa_scans to get the correct result 
     * for ScalarArrayOpExpr cases.  Similarly add in costs for any index 
     * ORDER BY expressions. 
     * 
     * Note: this neglects the possible costs of rechecking lossy operators. 
     * Detecting that that might be needed seems more expensive than it's 
     * worth, though, considering all the other inaccuracies here ... 
     */ 
</span>    <a href="selfuncs.c.html#LN6461"><span class='Ref_To_Local'>qual_arg_cost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6386"><span class='Ref_to_Func'>other_operands_eval_cost</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6441"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6444"><span class='Ref_to_Parameter'>qinfos</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>        <a href="selfuncs.c.html#LN6411"><span class='Ref_to_Func'>orderby_operands_eval_cost</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6441"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6442"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6460"><span class='Ref_To_Local'>qual_op_cost</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* 
</span>        <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6448"><span class='Ref_To_Local'>indexQuals</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6449"><span class='Ref_To_Local'>indexOrderBys</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN6450"><span class='Ref_To_Local'>indexStartupCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6461"><span class='Ref_To_Local'>qual_arg_cost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6451"><span class='Ref_To_Local'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6461"><span class='Ref_To_Local'>qual_arg_cost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6451"><span class='Ref_To_Local'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6457"><span class='Ref_To_Local'>num_sa_scans</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../optimizer/path/costsize.c.html#LN106"><span class='Ref_to_Global_Var'>cpu_index_tuple_cost</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN6460"><span class='Ref_To_Local'>qual_op_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generic assumption about index correlation: there isn't any. 
     */ 
</span>    <a href="selfuncs.c.html#LN6453"><span class='Ref_To_Local'>indexCorrelation</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Return everything to caller. 
     */ 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6450"><span class='Ref_To_Local'>indexStartupCost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6451"><span class='Ref_To_Local'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN130"><span class='Ref_to_Member'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6452"><span class='Ref_To_Local'>indexSelectivity</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN131"><span class='Ref_to_Member'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6453"><span class='Ref_To_Local'>indexCorrelation</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN134"><span class='Ref_to_Member'>numIndexPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6454"><span class='Ref_To_Local'>numIndexPages</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN135"><span class='Ref_to_Member'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6455"><span class='Ref_To_Local'>numIndexTuples</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN136"><span class='Ref_to_Member'>spc_random_page_cost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6456"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6445"><span class='Ref_to_Parameter'>costs</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN137"><span class='Ref_to_Member'>num_sa_scans</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6457"><span class='Ref_To_Local'>num_sa_scans</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end genericcostestimate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * If the index is partial, add its predicate to the given qual list. 
 * 
 * ANDing the index predicate with the explicitly given indexquals produces 
 * a more accurate idea of the index's selectivity.  However, we need to be 
 * careful not to insert redundant clauses, because clauselist_selectivity() 
 * is easily fooled into computing a too-low selectivity estimate.  Our 
 * approach is to add only the predicate clause(s) that cannot be proven to 
 * be implied by the given indexquals.  This successfully handles cases such 
 * as a qual "x = 42" used with a partial index "WHERE x &GT;= 40 AND x &LT; 50". 
 * There are many other cases where we won't detect redundancy, leading to a 
 * too-low selectivity estimate, which will bias the system in favor of using 
 * partial indexes where possible.  That is not necessarily bad though. 
 * 
 * Note that indexQuals contains RestrictInfo nodes while the indpred 
 * does not, so the output list will be mixed.  This is OK for both 
 * predicate_implied_by() and clauselist_selectivity(), but might be 
 * problematic if the result were passed to other things. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN6660"></a><span class='Declare_Function'>add_predicate_to_quals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>index</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexQuals</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6662"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>predExtraQuals</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN6663"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6660"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="selfuncs.c.html#LN6660"><span class='Ref_to_Parameter'>indexQuals</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6663"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6660"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6670"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>predQual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6663"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6671"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>oneQual</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6670"><span class='Ref_To_Local'>predQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/predtest.h.html#LN19"><span class='Ref_to_Proto'>predicate_implied_by</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6671"><span class='Ref_To_Local'>oneQual</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6660"><span class='Ref_to_Parameter'>indexQuals</span></a><span class='Parentheses'>))</span> 
            <a href="selfuncs.c.html#LN6662"><span class='Ref_To_Local'>predExtraQuals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6662"><span class='Ref_To_Local'>predExtraQuals</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6671"><span class='Ref_To_Local'>oneQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* list_concat avoids modifying the passed-in indexQuals list */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6662"><span class='Ref_To_Local'>predExtraQuals</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6660"><span class='Ref_to_Parameter'>indexQuals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end add_predicate_to_quals &raquo; </span> 
 
 
<span class='Keyword'>void 
</span><a name="LN6682"></a><span class='Declare_Function'>btcostestimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN6683"></a>               <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexStartupCost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexTotalCost</span><span class='Delimiter'>, 
</span><a name="LN6684"></a>               <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexSelectivity</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexCorrelation</span><span class='Delimiter'>, 
</span><a name="LN6685"></a>               <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexPages</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6687"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN6688"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qinfos</span><span class='Delimiter'>; 
</span><a name="LN6689"></a>    <a href="../../../include/utils/selfuncs.h.html#LN125"><span class='Ref_to_Typedef'>GenericCosts</span></a> <span class='Declare_Local'>costs</span><span class='Delimiter'>; 
</span><a name="LN6690"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span><span class='Delimiter'>; 
</span><a name="LN6691"></a>    <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>colnum</span><span class='Delimiter'>; 
</span><a name="LN6692"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span><a name="LN6693"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numIndexTuples</span><span class='Delimiter'>; 
</span><a name="LN6694"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>descentCost</span><span class='Delimiter'>; 
</span><a name="LN6695"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexBoundQuals</span><span class='Delimiter'>; 
</span><a name="LN6696"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>indexcol</span><span class='Delimiter'>; 
</span><a name="LN6697"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>eqQualHere</span><span class='Delimiter'>; 
</span><a name="LN6698"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found_saop</span><span class='Delimiter'>; 
</span><a name="LN6699"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found_is_null_op</span><span class='Delimiter'>; 
</span><a name="LN6700"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>num_sa_scans</span><span class='Delimiter'>; 
</span><a name="LN6701"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do preliminary analysis of indexquals */ 
</span>    <a href="selfuncs.c.html#LN6688"><span class='Ref_To_Local'>qinfos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN211"><span class='Ref_to_Proto'>deconstruct_indexquals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For a btree scan, only leading '=' quals plus inequality quals for the 
     * immediately next attribute contribute to index selectivity (these are 
     * the "boundary quals" that determine the starting and stopping points of 
     * the index scan).  Additional quals can suppress visits to the heap, so 
     * it's OK to count them in indexSelectivity, but they should not count 
     * for estimating numIndexTuples.  So we must examine the given indexquals 
     * to find out which ones count as boundary quals.  We rely on the 
     * knowledge that they are given in index column order. 
     * 
     * For a RowCompareExpr, we consider only the first column, just as 
     * rowcomparesel() does. 
     * 
     * If there's a ScalarArrayOpExpr in the quals, we'll actually perform N 
     * index scans not one, but the ScalarArrayOpExpr's operator can be 
     * considered to act the same as it normally does. 
     */ 
</span>    <a href="selfuncs.c.html#LN6695"><span class='Ref_To_Local'>indexBoundQuals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6696"><span class='Ref_To_Local'>indexcol</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6697"><span class='Ref_To_Local'>eqQualHere</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6698"><span class='Ref_To_Local'>found_saop</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6699"><span class='Ref_To_Local'>found_is_null_op</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6700"><span class='Ref_To_Local'>num_sa_scans</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6701"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6688"><span class='Ref_To_Local'>qinfos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6731"></a>        <a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>qinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6701"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6732"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6731"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN105"><span class='Ref_to_Member'>rinfo</span></a><span class='Delimiter'>; 
</span><a name="LN6733"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6732"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN6734"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>clause_op</span><span class='Delimiter'>; 
</span><a name="LN6735"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>op_strategy</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6696"><span class='Ref_To_Local'>indexcol</span></a> <span class='Operator'>!= </span><a href="selfuncs.c.html#LN6731"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN106"><span class='Ref_to_Member'>indexcol</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Beginning of a new column's quals */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN6697"><span class='Ref_To_Local'>eqQualHere</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* done if no '=' qual for indexcol */ 
</span>            <a href="selfuncs.c.html#LN6697"><span class='Ref_To_Local'>eqQualHere</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6696"><span class='Ref_To_Local'>indexcol</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6696"><span class='Ref_To_Local'>indexcol</span></a> <span class='Operator'>!= </span><a href="selfuncs.c.html#LN6731"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN106"><span class='Ref_to_Member'>indexcol</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* no quals at all for indexcol */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6733"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6750"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>alength</span> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN195"><span class='Ref_to_Proto'>estimate_array_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6731"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="selfuncs.c.html#LN6698"><span class='Ref_To_Local'>found_saop</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* count up number of SA scans induced by indexBoundQuals only */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6750"><span class='Ref_To_Local'>alength</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN6700"><span class='Ref_To_Local'>num_sa_scans</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN6750"><span class='Ref_To_Local'>alength</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6733"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6759"></a>            <a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>nt</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN6733"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6759"><span class='Ref_To_Local'>nt</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN6699"><span class='Ref_To_Local'>found_is_null_op</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* IS NULL is like = for selectivity determination purposes */ 
</span>                <a href="selfuncs.c.html#LN6697"><span class='Ref_To_Local'>eqQualHere</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We would need to commute the clause_op if not varonleft, except 
         * that we only care if it's equality or not, so that refinement is 
         * unnecessary. 
         */ 
</span>        <a href="selfuncs.c.html#LN6734"><span class='Ref_To_Local'>clause_op</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6731"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN108"><span class='Ref_to_Member'>clause_op</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* check for equality operator */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6734"><span class='Ref_To_Local'>clause_op</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN6735"><span class='Ref_To_Local'>op_strategy</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN64"><span class='Ref_to_Proto'>get_op_opfamily_strategy</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6734"><span class='Ref_To_Local'>clause_op</span></a><span class='Delimiter'>, 
</span>                                                   <a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN643"><span class='Ref_to_Member'>opfamily</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN6696"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6735"><span class='Ref_To_Local'>op_strategy</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* not a member of opfamily?? */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6735"><span class='Ref_To_Local'>op_strategy</span></a> <span class='Operator'>== </span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN6697"><span class='Ref_To_Local'>eqQualHere</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="selfuncs.c.html#LN6695"><span class='Ref_To_Local'>indexBoundQuals</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6695"><span class='Ref_To_Local'>indexBoundQuals</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6732"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If index is unique and we found an '=' clause for each column, we can 
     * just assume numIndexTuples = 1 and skip the expensive 
     * clauselist_selectivity calculations.  However, a ScalarArrayOp or 
     * NullTest invalidates that theory, even though it sets eqQualHere. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN663"><span class='Ref_to_Member'>unique</span></a> <span class='Operator'>&& 
</span>        <a href="selfuncs.c.html#LN6696"><span class='Ref_To_Local'>indexcol</span></a> <span class='Operator'>== </span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN640"><span class='Ref_to_Member'>ncolumns</span></a> <span class='Operator'>- </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>        <a href="selfuncs.c.html#LN6697"><span class='Ref_To_Local'>eqQualHere</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="selfuncs.c.html#LN6698"><span class='Ref_To_Local'>found_saop</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="selfuncs.c.html#LN6699"><span class='Ref_To_Local'>found_is_null_op</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN6693"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN6803"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>selectivityQuals</span><span class='Delimiter'>; 
</span><a name="LN6804"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>btreeSelectivity</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the index is partial, AND the index predicate with the 
         * index-bound quals to produce a more accurate idea of the number of 
         * rows covered by the bound conditions. 
         */ 
</span>        <a href="selfuncs.c.html#LN6803"><span class='Ref_To_Local'>selectivityQuals</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN216"><span class='Ref_to_Proto'>add_predicate_to_quals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6695"><span class='Ref_To_Local'>indexBoundQuals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN6804"><span class='Ref_To_Local'>btreeSelectivity</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6803"><span class='Ref_To_Local'>selectivityQuals</span></a><span class='Delimiter'>, 
</span>                                                  <a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6693"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6804"><span class='Ref_To_Local'>btreeSelectivity</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * As in genericcostestimate(), we have to adjust for any 
         * ScalarArrayOpExpr quals included in indexBoundQuals, and then round 
         * to integer. 
         */ 
</span>        <a href="selfuncs.c.html#LN6693"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6693"><span class='Ref_To_Local'>numIndexTuples</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN6700"><span class='Ref_To_Local'>num_sa_scans</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now do generic index cost estimation. 
     */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN135"><span class='Ref_to_Member'>numIndexTuples</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6693"><span class='Ref_To_Local'>numIndexTuples</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN212"><span class='Ref_to_Proto'>genericcostestimate</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6688"><span class='Ref_To_Local'>qinfos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add a CPU-cost component to represent the costs of initial btree 
     * descent.  We don't charge any I/O cost for touching upper btree levels, 
     * since they tend to stay in cache, but we still have to do about log2(N) 
     * comparisons to descend a btree of N leaf tuples.  We charge one 
     * cpu_operator_cost per comparison. 
     * 
     * If there are ScalarArrayOpExprs, charge this once per SA scan.  The 
     * ones after the first one are not startup cost so far as the overall 
     * plan is concerned, so add them only to "total" cost. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* avoid computing log(0) */ 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN6694"><span class='Ref_To_Local'>descentCost</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span>log<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span>log<span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>))</span> <span class='Operator'>* </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6694"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN137"><span class='Ref_to_Member'>num_sa_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6694"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Even though we're not charging I/O cost for touching upper btree pages, 
     * it's still reasonable to charge some CPU cost per page descended 
     * through.  Moreover, if we had no such charge at all, bloated indexes 
     * would appear to have the same search cost as unbloated ones, at least 
     * in cases where only a single leaf page is expected to be visited.  This 
     * cost is somewhat arbitrarily set at 50x cpu_operator_cost per page 
     * touched.  The number of such pages is btree tree height plus one (ie, 
     * we charge for the leaf page too).  As above, charge once per SA scan. 
     */ 
</span>    <a href="selfuncs.c.html#LN6694"><span class='Ref_To_Local'>descentCost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>50</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6694"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN137"><span class='Ref_to_Member'>num_sa_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN6694"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we can get an estimate of the first column's ordering correlation C 
     * from pg_statistic, estimate the index correlation as C for a 
     * single-column index, or C * 0.75 for multiple columns. (The idea here 
     * is that multiple columns dilute the importance of the first column's 
     * ordering, but don't negate it entirely.  Before 8.0 we divided the 
     * correlation by the number of columns, but that seems too strong.) 
     */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN641"><span class='Ref_to_Member'>indexkeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Simple variable --- look to stats for the underlying table */ 
</span><a name="LN6880"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6880"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6690"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6880"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6690"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>!= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6691"><span class='Ref_To_Local'>colnum</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN641"><span class='Ref_to_Member'>indexkeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN153"><span class='Ref_to_Global_Var'>get_relation_stats_hook</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN153"><span class='Ref_to_Global_Var'>get_relation_stats_hook</span></a><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6880"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6691"><span class='Ref_To_Local'>colnum</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The hook took control of acquiring a stats tuple.  If it did 
             * supply a tuple, it'd better have supplied a freefunc. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a><span class='Parentheses'>)</span> 
                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no function provided to release variable stats with"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN159"><span class='Ref_to_Macro'>SearchSysCache3</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN90"><span class='Ref_to_EnumConst'>STATRELATTINH</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6690"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6691"><span class='Ref_To_Local'>colnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6880"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if index-&GT;indexkeys[0]!=... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Expression --- maybe there are stats for the index itself */ 
</span>        <a href="selfuncs.c.html#LN6690"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN6691"><span class='Ref_To_Local'>colnum</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN154"><span class='Ref_to_Global_Var'>get_index_stats_hook</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN154"><span class='Ref_to_Global_Var'>get_index_stats_hook</span></a><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN6682"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6690"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6691"><span class='Ref_To_Local'>colnum</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The hook took control of acquiring a stats tuple.  If it did 
             * supply a tuple, it'd better have supplied a freefunc. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a><span class='Parentheses'>)</span> 
                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no function provided to release variable stats with"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN159"><span class='Ref_to_Macro'>SearchSysCache3</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN90"><span class='Ref_to_EnumConst'>STATRELATTINH</span></a><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6690"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6691"><span class='Ref_To_Local'>colnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN6936"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>sortop</span><span class='Delimiter'>; 
</span><a name="LN6937"></a>        <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN6936"><span class='Ref_To_Local'>sortop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN643"><span class='Ref_to_Member'>opfamily</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                     <a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN644"><span class='Ref_to_Member'>opcintype</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                     <a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN644"><span class='Ref_to_Member'>opcintype</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                     <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6936"><span class='Ref_To_Local'>sortop</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6937"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/catalog/pg_statistic.h.html#LN232"><span class='Ref_to_Const'>STATISTIC_KIND_CORRELATION</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6936"><span class='Ref_To_Local'>sortop</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6948"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>varCorrelation</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6937"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN6948"><span class='Ref_To_Local'>varCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6937"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN646"><span class='Ref_to_Member'>reverse_sort</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN6948"><span class='Ref_To_Local'>varCorrelation</span></a> <span class='Operator'>= -</span><a href="selfuncs.c.html#LN6948"><span class='Ref_To_Local'>varCorrelation</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6687"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN640"><span class='Ref_to_Member'>ncolumns</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN131"><span class='Ref_to_Member'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6948"><span class='Ref_To_Local'>varCorrelation</span></a> <span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>75</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN131"><span class='Ref_to_Member'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6948"><span class='Ref_To_Local'>varCorrelation</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6937"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(sortop)&&g... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsValid(vard... &raquo; </span> 
 
    <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6692"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6683"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6683"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6684"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN130"><span class='Ref_to_Member'>indexSelectivity</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6684"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN131"><span class='Ref_to_Member'>indexCorrelation</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6685"><span class='Ref_to_Parameter'>indexPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6689"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN134"><span class='Ref_to_Member'>numIndexPages</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btcostestimate &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN6975"></a><span class='Declare_Function'>hashcostestimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN6976"></a>                 <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexStartupCost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexTotalCost</span><span class='Delimiter'>, 
</span><a name="LN6977"></a>                 <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexSelectivity</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexCorrelation</span><span class='Delimiter'>, 
</span><a name="LN6978"></a>                 <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexPages</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6980"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qinfos</span><span class='Delimiter'>; 
</span><a name="LN6981"></a>    <a href="../../../include/utils/selfuncs.h.html#LN125"><span class='Ref_to_Typedef'>GenericCosts</span></a> <span class='Declare_Local'>costs</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do preliminary analysis of indexquals */ 
</span>    <a href="selfuncs.c.html#LN6980"><span class='Ref_To_Local'>qinfos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN211"><span class='Ref_to_Proto'>deconstruct_indexquals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6975"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN212"><span class='Ref_to_Proto'>genericcostestimate</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN6975"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6975"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6975"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN6980"><span class='Ref_To_Local'>qinfos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * A hash index has no descent costs as such, since the index AM can go 
     * directly to the target bucket after computing the hash value.  There 
     * are a couple of other hash-specific costs that we could conceivably add 
     * here, though: 
     * 
     * Ideally we'd charge spc_random_page_cost for each page in the target 
     * bucket, not just the numIndexPages pages that genericcostestimate 
     * thought we'd visit.  However in most cases we don't know which bucket 
     * that will be.  There's no point in considering the average bucket size 
     * because the hash AM makes sure that's always one page. 
     * 
     * Likewise, we could consider charging some CPU for each index tuple in 
     * the bucket, if we knew how many there were.  But the per-tuple cost is 
     * just a hash value comparison, not a general datatype-dependent 
     * comparison, so any such charge ought to be quite a bit less than 
     * cpu_operator_cost; which makes it probably not worth worrying about. 
     * 
     * A bigger issue is that chance hash-value collisions will result in 
     * wasted probes into the heap.  We don't currently attempt to model this 
     * cost on the grounds that it's rare, but maybe it's not rare enough. 
     * (Any fix for this ought to consider the generic lossy-operator problem, 
     * though; it's not entirely hash-specific.) 
     */ 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6976"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6976"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6977"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN130"><span class='Ref_to_Member'>indexSelectivity</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6977"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN131"><span class='Ref_to_Member'>indexCorrelation</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN6978"><span class='Ref_to_Parameter'>indexPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6981"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN134"><span class='Ref_to_Member'>numIndexPages</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end hashcostestimate &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN7023"></a><span class='Declare_Function'>gistcostestimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN7024"></a>                 <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexStartupCost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexTotalCost</span><span class='Delimiter'>, 
</span><a name="LN7025"></a>                 <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexSelectivity</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexCorrelation</span><span class='Delimiter'>, 
</span><a name="LN7026"></a>                 <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexPages</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7028"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7023"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN7029"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qinfos</span><span class='Delimiter'>; 
</span><a name="LN7030"></a>    <a href="../../../include/utils/selfuncs.h.html#LN125"><span class='Ref_to_Typedef'>GenericCosts</span></a> <span class='Declare_Local'>costs</span><span class='Delimiter'>; 
</span><a name="LN7031"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>descentCost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do preliminary analysis of indexquals */ 
</span>    <a href="selfuncs.c.html#LN7029"><span class='Ref_To_Local'>qinfos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN211"><span class='Ref_to_Proto'>deconstruct_indexquals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7023"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN212"><span class='Ref_to_Proto'>genericcostestimate</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7023"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7023"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7023"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7029"><span class='Ref_To_Local'>qinfos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We model index descent costs similarly to those for btree, but to do 
     * that we first need an idea of the tree height.  We somewhat arbitrarily 
     * assume that the fanout is 100, meaning the tree height is at most 
     * log100(index-&GT;pages). 
     * 
     * Although this computation isn't really expensive enough to require 
     * caching, we might as well use index-&GT;tree_height to cache it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* unknown? */ 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span>   <span class='Comment_Single_Line'>/* avoid computing log(0) */ 
</span>            <a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span>log<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span>log<span class='Parentheses'>(</span><span class='Number'>100</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add a CPU-cost component to represent the costs of initial descent. We 
     * just use log(N) here not log2(N) since the branching factor isn't 
     * necessarily two anyway.  As for btree, charge once per SA scan. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* avoid computing log(0) */ 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN7031"><span class='Ref_To_Local'>descentCost</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span>log<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>))</span> <span class='Operator'>* </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7031"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN137"><span class='Ref_to_Member'>num_sa_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7031"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Likewise add a per-page charge, calculated the same as for btrees. 
     */ 
</span>    <a href="selfuncs.c.html#LN7031"><span class='Ref_To_Local'>descentCost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7028"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>50</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7031"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN137"><span class='Ref_to_Member'>num_sa_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7031"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7024"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7024"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7025"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN130"><span class='Ref_to_Member'>indexSelectivity</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7025"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN131"><span class='Ref_to_Member'>indexCorrelation</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7026"><span class='Ref_to_Parameter'>indexPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7030"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN134"><span class='Ref_to_Member'>numIndexPages</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end gistcostestimate &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN7084"></a><span class='Declare_Function'>spgcostestimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN7085"></a>                <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexStartupCost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexTotalCost</span><span class='Delimiter'>, 
</span><a name="LN7086"></a>                <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexSelectivity</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexCorrelation</span><span class='Delimiter'>, 
</span><a name="LN7087"></a>                <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexPages</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7089"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7084"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN7090"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qinfos</span><span class='Delimiter'>; 
</span><a name="LN7091"></a>    <a href="../../../include/utils/selfuncs.h.html#LN125"><span class='Ref_to_Typedef'>GenericCosts</span></a> <span class='Declare_Local'>costs</span><span class='Delimiter'>; 
</span><a name="LN7092"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>descentCost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do preliminary analysis of indexquals */ 
</span>    <a href="selfuncs.c.html#LN7090"><span class='Ref_To_Local'>qinfos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN211"><span class='Ref_to_Proto'>deconstruct_indexquals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7084"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN212"><span class='Ref_to_Proto'>genericcostestimate</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7084"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7084"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7084"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7090"><span class='Ref_To_Local'>qinfos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We model index descent costs similarly to those for btree, but to do 
     * that we first need an idea of the tree height.  We somewhat arbitrarily 
     * assume that the fanout is 100, meaning the tree height is at most 
     * log100(index-&GT;pages). 
     * 
     * Although this computation isn't really expensive enough to require 
     * caching, we might as well use index-&GT;tree_height to cache it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* unknown? */ 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span>   <span class='Comment_Single_Line'>/* avoid computing log(0) */ 
</span>            <a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span>log<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span>log<span class='Parentheses'>(</span><span class='Number'>100</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add a CPU-cost component to represent the costs of initial descent. We 
     * just use log(N) here not log2(N) since the branching factor isn't 
     * necessarily two anyway.  As for btree, charge once per SA scan. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* avoid computing log(0) */ 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN7092"><span class='Ref_To_Local'>descentCost</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span>log<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>))</span> <span class='Operator'>* </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7092"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN137"><span class='Ref_to_Member'>num_sa_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7092"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Likewise add a per-page charge, calculated the same as for btrees. 
     */ 
</span>    <a href="selfuncs.c.html#LN7092"><span class='Ref_To_Local'>descentCost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7089"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN637"><span class='Ref_to_Member'>tree_height</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>50</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7092"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN137"><span class='Ref_to_Member'>num_sa_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7092"><span class='Ref_To_Local'>descentCost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7085"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN128"><span class='Ref_to_Member'>indexStartupCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7085"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN129"><span class='Ref_to_Member'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7086"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN130"><span class='Ref_to_Member'>indexSelectivity</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7086"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN131"><span class='Ref_to_Member'>indexCorrelation</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7087"><span class='Ref_to_Parameter'>indexPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7091"><span class='Ref_To_Local'>costs</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN134"><span class='Ref_to_Member'>numIndexPages</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end spgcostestimate &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Support routines for gincostestimate 
 */ 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN7151"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>haveFullScan</span><span class='Delimiter'>; 
</span><a name="LN7152"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>partialEntries</span><span class='Delimiter'>; 
</span><a name="LN7153"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>exactEntries</span><span class='Delimiter'>; 
</span><a name="LN7154"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>searchEntries</span><span class='Delimiter'>; 
</span><a name="LN7155"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>arrayScans</span><span class='Delimiter'>; 
</span><a name="LN7156"></a>} <span class='Declare_Typedef'>GinQualCounts</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Estimate the number of index terms that need to be searched for while 
 * testing the given GIN query, and increment the counts in *counts 
 * appropriately.  If the query is unsatisfiable, return false. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN7164"></a><span class='Declare_Function'>gincost_pattern</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>index</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>indexcol</span><span class='Delimiter'>, 
</span><a name="LN7165"></a>                <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>clause_op</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>query</span><span class='Delimiter'>, 
</span><a name="LN7166"></a>                <a href="selfuncs.c.html#LN7149"><span class='Ref_to_Typedef'>GinQualCounts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>counts</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7168"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>extractProcOid</span><span class='Delimiter'>; 
</span><a name="LN7169"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>collation</span><span class='Delimiter'>; 
</span><a name="LN7170"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>strategy_op</span><span class='Delimiter'>; 
</span><a name="LN7171"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>lefttype</span><span class='Delimiter'>, 
</span><a name="LN7172"></a>                <span class='Declare_Local'>righttype</span><span class='Delimiter'>; 
</span><a name="LN7173"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>nentries</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN7174"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>partial_matches</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN7175"></a>    <a href="../../../include/c.h.html#LN244"><span class='Ref_to_Typedef'>Pointer</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>extra_data</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN7176"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>nullFlags</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN7177"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>searchMode</span> <span class='Operator'>= </span><a href="../../../include/access/gin.h.html#LN32"><span class='Ref_to_Const'>GIN_SEARCH_MODE_DEFAULT</span></a><span class='Delimiter'>; 
</span><a name="LN7178"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get the operator's strategy number and declared input data types within 
     * the index opfamily.  (We don't need the latter, but we use 
     * get_op_opfamily_properties because it will throw error if it fails to 
     * find a matching pg_amop entry.) 
     */ 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN66"><span class='Ref_to_Proto'>get_op_opfamily_properties</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7165"><span class='Ref_to_Parameter'>clause_op</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN643"><span class='Ref_to_Member'>opfamily</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>indexcol</span></a><span class='Delimiter'>], </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="selfuncs.c.html#LN7170"><span class='Ref_To_Local'>strategy_op</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7171"><span class='Ref_To_Local'>lefttype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7172"><span class='Ref_To_Local'>righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * GIN always uses the "default" support functions, which are those with 
     * lefttype == righttype == the opclass' opcintype (see 
     * IndexSupportInitialize in relcache.c). 
     */ 
</span>    <a href="selfuncs.c.html#LN7168"><span class='Ref_To_Local'>extractProcOid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN83"><span class='Ref_to_Proto'>get_opfamily_proc</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN643"><span class='Ref_to_Member'>opfamily</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>indexcol</span></a><span class='Delimiter'>], 
</span>                                       <a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN644"><span class='Ref_to_Member'>opcintype</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>indexcol</span></a><span class='Delimiter'>], 
</span>                                       <a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN644"><span class='Ref_to_Member'>opcintype</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>indexcol</span></a><span class='Delimiter'>], 
</span>                                       <a href="../../../include/access/gin.h.html#LN23"><span class='Ref_to_Const'>GIN_EXTRACTQUERY_PROC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7168"><span class='Ref_To_Local'>extractProcOid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* should not happen; throw same error as index_getprocinfo */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"missing support function %d for attribute %d of index \"%s\""</span><span class='Delimiter'>, 
</span>             <a href="../../../include/access/gin.h.html#LN23"><span class='Ref_to_Const'>GIN_EXTRACTQUERY_PROC</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>indexcol</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>             <a href="../../../include/utils/lsyscache.h.html#LN124"><span class='Ref_to_Proto'>get_rel_name</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Choose collation to pass to extractProc (should match initGinState). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN642"><span class='Ref_to_Member'>indexcollations</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>indexcol</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
        <a href="selfuncs.c.html#LN7169"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN642"><span class='Ref_to_Member'>indexcollations</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7164"><span class='Ref_to_Parameter'>indexcol</span></a><span class='Delimiter'>]; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN7169"><span class='Ref_To_Local'>collation</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN565"><span class='Ref_to_Proto'>OidFunctionCall7Coll</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7168"><span class='Ref_To_Local'>extractProcOid</span></a><span class='Delimiter'>, 
</span>                         <a href="selfuncs.c.html#LN7169"><span class='Ref_To_Local'>collation</span></a><span class='Delimiter'>, 
</span>                         <a href="selfuncs.c.html#LN7165"><span class='Ref_to_Parameter'>query</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7173"><span class='Ref_To_Local'>nentries</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/postgres.h.html#LN470"><span class='Ref_to_Macro'>UInt16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7170"><span class='Ref_To_Local'>strategy_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7174"><span class='Ref_To_Local'>partial_matches</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7175"><span class='Ref_To_Local'>extra_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7176"><span class='Ref_To_Local'>nullFlags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7177"><span class='Ref_To_Local'>searchMode</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7173"><span class='Ref_To_Local'>nentries</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN7177"><span class='Ref_To_Local'>searchMode</span></a> <span class='Operator'>== </span><a href="../../../include/access/gin.h.html#LN32"><span class='Ref_to_Const'>GIN_SEARCH_MODE_DEFAULT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No match is possible */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7178"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN7178"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN7173"><span class='Ref_To_Local'>nentries</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN7178"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For partial match we haven't any information to estimate number of 
         * matched entries in index, so, we just estimate it as 100 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7174"><span class='Ref_To_Local'>partial_matches</span></a> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN7174"><span class='Ref_To_Local'>partial_matches</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7178"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="selfuncs.c.html#LN7166"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a> <span class='Operator'>+= </span><span class='Number'>100</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="selfuncs.c.html#LN7166"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN7166"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7177"><span class='Ref_To_Local'>searchMode</span></a> <span class='Operator'>== </span><a href="../../../include/access/gin.h.html#LN33"><span class='Ref_to_Const'>GIN_SEARCH_MODE_INCLUDE_EMPTY</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Treat "include empty" like an exact-match item */ 
</span>        <a href="selfuncs.c.html#LN7166"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7166"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7177"><span class='Ref_To_Local'>searchMode</span></a> <span class='Operator'>!= </span><a href="../../../include/access/gin.h.html#LN32"><span class='Ref_to_Const'>GIN_SEARCH_MODE_DEFAULT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* It's GIN_SEARCH_MODE_ALL */ 
</span>        <a href="selfuncs.c.html#LN7166"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7151"><span class='Ref_to_Member'>haveFullScan</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end gincost_pattern &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate the number of index terms that need to be searched for while 
 * testing the given GIN index clause, and increment the counts in *counts 
 * appropriately.  If the query is unsatisfiable, return false. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN7266"></a><span class='Declare_Function'>gincost_opexpr</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN7267"></a>               <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>index</span><span class='Delimiter'>, 
</span><a name="LN7268"></a>               <a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qinfo</span><span class='Delimiter'>, 
</span><a name="LN7269"></a>               <a href="selfuncs.c.html#LN7149"><span class='Ref_to_Typedef'>GinQualCounts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>counts</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7271"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>indexcol</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7268"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN106"><span class='Ref_to_Member'>indexcol</span></a><span class='Delimiter'>; 
</span><a name="LN7272"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>clause_op</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7268"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN108"><span class='Ref_to_Member'>clause_op</span></a><span class='Delimiter'>; 
</span><a name="LN7273"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>operand</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7268"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN7268"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN107"><span class='Ref_to_Member'>varonleft</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* must commute the operator */ 
</span>        <a href="selfuncs.c.html#LN7272"><span class='Ref_To_Local'>clause_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7272"><span class='Ref_To_Local'>clause_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* aggressively reduce to a constant, and look through relabeling */ 
</span>    <a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7266"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
        <a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's impossible to call extractQuery method for unknown operand. So 
     * unless operand is a Const we can't do much; just assume there will be 
     * one ordinary search entry from the operand at runtime. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN7269"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7269"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If Const is null, there can be no matches */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Otherwise, apply extractQuery and get the actual term counts */ 
</span>    <span class='Control'>return</span> <a href="selfuncs.c.html#LN7163"><span class='Ref_to_Func'>gincost_pattern</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7267"><span class='Ref_to_Parameter'>index</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7271"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7272"><span class='Ref_To_Local'>clause_op</span></a><span class='Delimiter'>, 
</span>                           <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7273"><span class='Ref_To_Local'>operand</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>, 
</span>                           <a href="selfuncs.c.html#LN7269"><span class='Ref_to_Parameter'>counts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end gincost_opexpr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate the number of index terms that need to be searched for while 
 * testing the given GIN index clause, and increment the counts in *counts 
 * appropriately.  If the query is unsatisfiable, return false. 
 * 
 * A ScalarArrayOpExpr will give rise to N separate indexscans at runtime, 
 * each of which involves one value from the RHS array, plus all the 
 * non-array quals (if any).  To model this, we average the counts across 
 * the RHS elements, and add the averages to the counts in *counts (which 
 * correspond to per-indexscan costs).  We also multiply counts-&GT;arrayScans 
 * by N, causing gincostestimate to scale up its estimates accordingly. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN7322"></a><span class='Declare_Function'>gincost_scalararrayopexpr</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN7323"></a>                          <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>index</span><span class='Delimiter'>, 
</span><a name="LN7324"></a>                          <a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qinfo</span><span class='Delimiter'>, 
</span><a name="LN7325"></a>                          <span class='Keyword'>double </span><span class='Declare_Parameter'>numIndexEntries</span><span class='Delimiter'>, 
</span><a name="LN7326"></a>                          <a href="selfuncs.c.html#LN7149"><span class='Ref_to_Typedef'>GinQualCounts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>counts</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7328"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>indexcol</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7324"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN106"><span class='Ref_to_Member'>indexcol</span></a><span class='Delimiter'>; 
</span><a name="LN7329"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>clause_op</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7324"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN108"><span class='Ref_to_Member'>clause_op</span></a><span class='Delimiter'>; 
</span><a name="LN7330"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rightop</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7324"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN109"><span class='Ref_to_Member'>other_operand</span></a><span class='Delimiter'>; 
</span><a name="LN7331"></a>    <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span><a name="LN7332"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>elmlen</span><span class='Delimiter'>; 
</span><a name="LN7333"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>elmbyval</span><span class='Delimiter'>; 
</span><a name="LN7334"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>elmalign</span><span class='Delimiter'>; 
</span><a name="LN7335"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numElems</span><span class='Delimiter'>; 
</span><a name="LN7336"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>elemValues</span><span class='Delimiter'>; 
</span><a name="LN7337"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>elemNulls</span><span class='Delimiter'>; 
</span><a name="LN7338"></a>    <a href="selfuncs.c.html#LN7149"><span class='Ref_to_Typedef'>GinQualCounts</span></a> <span class='Declare_Local'>arraycounts</span><span class='Delimiter'>; 
</span><a name="LN7339"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numPossible</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN7340"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7324"><span class='Ref_to_Parameter'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN105"><span class='Ref_to_Member'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>useOr<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* aggressively reduce to a constant, and look through relabeling */ 
</span>    <a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN82"><span class='Ref_to_Proto'>estimate_expression_value</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7322"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
        <a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's impossible to call extractQuery method for unknown operand. So 
     * unless operand is a Const we can't do much; just assume there will be 
     * one ordinary search entry from each array entry at runtime, and fall 
     * back on a probably-bad estimate of the number of array entries. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN7326"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7326"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7326"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a> <span class='Operator'>*= </span><a href="../../../include/utils/selfuncs.h.html#LN195"><span class='Ref_to_Proto'>estimate_array_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If Const is null, there can be no matches */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Otherwise, extract the array elements and iterate over them */ 
</span>    <a href="selfuncs.c.html#LN7331"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7330"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN136"><span class='Ref_to_Proto'>get_typlenbyvalalign</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7331"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="selfuncs.c.html#LN7332"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7333"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7334"><span class='Ref_To_Local'>elmalign</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7331"><span class='Ref_To_Local'>arrayval</span></a><span class='Delimiter'>, 
</span>                      <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7331"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <a href="selfuncs.c.html#LN7332"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7333"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7334"><span class='Ref_To_Local'>elmalign</span></a><span class='Delimiter'>, 
</span>                      <span class='Operator'>&</span><a href="selfuncs.c.html#LN7336"><span class='Ref_To_Local'>elemValues</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7337"><span class='Ref_To_Local'>elemNulls</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7335"><span class='Ref_To_Local'>numElems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7340"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN7340"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN7335"><span class='Ref_To_Local'>numElems</span></a><span class='Delimiter'>; </span><a href="selfuncs.c.html#LN7340"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN7381"></a>        <a href="selfuncs.c.html#LN7149"><span class='Ref_to_Typedef'>GinQualCounts</span></a> <span class='Declare_Local'>elemcounts</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* NULL can't match anything, so ignore, as the executor will */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7337"><span class='Ref_To_Local'>elemNulls</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7340"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Otherwise, apply extractQuery and get the actual term counts */ 
</span>        memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7163"><span class='Ref_to_Func'>gincost_pattern</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7323"><span class='Ref_to_Parameter'>index</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7328"><span class='Ref_To_Local'>indexcol</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7329"><span class='Ref_To_Local'>clause_op</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7336"><span class='Ref_To_Local'>elemValues</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7340"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                            <span class='Operator'>&</span><a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* We ignore array elements that are unsatisfiable patterns */ 
</span>            <a href="selfuncs.c.html#LN7339"><span class='Ref_To_Local'>numPossible</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7151"><span class='Ref_to_Member'>haveFullScan</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Full index scan will be required.  We treat this as if 
                 * every key in the index had been listed in the query; is 
                 * that reasonable? 
                 */ 
</span>                <a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7325"><span class='Ref_to_Parameter'>numIndexEntries</span></a><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7325"><span class='Ref_to_Parameter'>numIndexEntries</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a><span class='Delimiter'>; 
</span>            <a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7381"><span class='Ref_To_Local'>elemcounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if gincost_pattern(index... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numElems;i++ &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7339"><span class='Ref_To_Local'>numPossible</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No satisfiable patterns in the array */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now add the averages to the global counts.  This will give us an 
     * estimate of the average number of terms searched for in each indexscan, 
     * including contributions from both array and non-array quals. 
     */ 
</span>    <a href="selfuncs.c.html#LN7326"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7339"><span class='Ref_To_Local'>numPossible</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7326"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7339"><span class='Ref_To_Local'>numPossible</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7326"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7338"><span class='Ref_To_Local'>arraycounts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7339"><span class='Ref_To_Local'>numPossible</span></a><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN7326"><span class='Ref_to_Parameter'>counts</span></a><span class='Operator'>-&GT;</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN7339"><span class='Ref_To_Local'>numPossible</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end gincost_scalararrayopexpr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GIN has search behavior completely different from other index types 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN7437"></a><span class='Declare_Function'>gincostestimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN7438"></a>                <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexStartupCost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexTotalCost</span><span class='Delimiter'>, 
</span><a name="LN7439"></a>                <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexSelectivity</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexCorrelation</span><span class='Delimiter'>, 
</span><a name="LN7440"></a>                <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexPages</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7442"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN7443"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexQuals</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1032"><span class='Ref_to_Member'>indexquals</span></a><span class='Delimiter'>; 
</span><a name="LN7444"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexOrderBys</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1034"><span class='Ref_to_Member'>indexorderbys</span></a><span class='Delimiter'>; 
</span><a name="LN7445"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qinfos</span><span class='Delimiter'>; 
</span><a name="LN7446"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN7447"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>selectivityQuals</span><span class='Delimiter'>; 
</span><a name="LN7448"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numPages</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span><a name="LN7449"></a>                <span class='Declare_Local'>numTuples</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN636"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span><a name="LN7450"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numEntryPages</span><span class='Delimiter'>, 
</span><a name="LN7451"></a>                <span class='Declare_Local'>numDataPages</span><span class='Delimiter'>, 
</span><a name="LN7452"></a>                <span class='Declare_Local'>numPendingPages</span><span class='Delimiter'>, 
</span><a name="LN7453"></a>                <span class='Declare_Local'>numEntries</span><span class='Delimiter'>; 
</span><a name="LN7454"></a>    <a href="selfuncs.c.html#LN7149"><span class='Ref_to_Typedef'>GinQualCounts</span></a> <span class='Declare_Local'>counts</span><span class='Delimiter'>; 
</span><a name="LN7455"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>matchPossible</span><span class='Delimiter'>; 
</span><a name="LN7456"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>partialScale</span><span class='Delimiter'>; 
</span><a name="LN7457"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>entryPagesFetched</span><span class='Delimiter'>, 
</span><a name="LN7458"></a>                <span class='Declare_Local'>dataPagesFetched</span><span class='Delimiter'>, 
</span><a name="LN7459"></a>                <span class='Declare_Local'>dataPagesFetchedBySel</span><span class='Delimiter'>; 
</span><a name="LN7460"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>qual_op_cost</span><span class='Delimiter'>, 
</span><a name="LN7461"></a>                <span class='Declare_Local'>qual_arg_cost</span><span class='Delimiter'>, 
</span><a name="LN7462"></a>                <span class='Declare_Local'>spc_random_page_cost</span><span class='Delimiter'>, 
</span><a name="LN7463"></a>                <span class='Declare_Local'>outer_scans</span><span class='Delimiter'>; 
</span><a name="LN7464"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indexRel</span><span class='Delimiter'>; 
</span><a name="LN7465"></a>    <a href="../../../include/access/gin.h.html#LN40"><span class='Ref_to_Struct'>GinStatsData</span></a> <span class='Declare_Local'>ginStats</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do preliminary analysis of indexquals */ 
</span>    <a href="selfuncs.c.html#LN7445"><span class='Ref_To_Local'>qinfos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN211"><span class='Ref_to_Proto'>deconstruct_indexquals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Obtain statistical information from the meta page, if possible.  Else 
     * set ginStats to zeroes, and we'll cope below. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN665"><span class='Ref_to_Member'>hypothetical</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN7464"><span class='Ref_To_Local'>indexRel</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/gin.h.html#LN72"><span class='Ref_to_Proto'>ginGetStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7464"><span class='Ref_To_Local'>indexRel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7464"><span class='Ref_To_Local'>indexRel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Assuming we got valid (nonzero) stats at all, nPendingPages can be 
     * trusted, but the other fields are data as of the last VACUUM.  We can 
     * scale them up to account for growth since then, but that method only 
     * goes so far; in the worst case, the stats might be for a completely 
     * empty index, and scaling them will produce pretty bogus numbers. 
     * Somewhat arbitrarily, set the cutoff for doing scaling at 4X growth; if 
     * it's grown more than that, fall back to estimating things only from the 
     * assumed-accurate index size.  But we'll trust nPendingPages in any case 
     * so long as it's not clearly insane, ie, more than the index size. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN42"><span class='Ref_to_Member'>nPendingPages</span></a> <span class='Operator'>&LT; </span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN7452"><span class='Ref_To_Local'>numPendingPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN42"><span class='Ref_to_Member'>nPendingPages</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN7452"><span class='Ref_To_Local'>numPendingPages</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN43"><span class='Ref_to_Member'>nTotalPages</span></a> <span class='Operator'>&LT;= </span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>&& 
</span>        <a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN43"><span class='Ref_to_Member'>nTotalPages</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>/ </span><span class='Number'>4</span> <span class='Operator'>&& 
</span>        <a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN44"><span class='Ref_to_Member'>nEntryPages</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN46"><span class='Ref_to_Member'>nEntries</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * OK, the stats seem close enough to sane to be trusted.  But we 
         * still need to scale them by the ratio numPages / nTotalPages to 
         * account for growth since the last VACUUM. 
         */ 
</span><a name="LN7510"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>scale</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN43"><span class='Ref_to_Member'>nTotalPages</span></a><span class='Delimiter'>; 
</span> 
        <a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN44"><span class='Ref_to_Member'>nEntryPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7510"><span class='Ref_To_Local'>scale</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN45"><span class='Ref_to_Member'>nDataPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7510"><span class='Ref_To_Local'>scale</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7465"><span class='Ref_To_Local'>ginStats</span></a><span class='Operator'>.</span><a href="../../../include/access/gin.h.html#LN46"><span class='Ref_to_Member'>nEntries</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7510"><span class='Ref_To_Local'>scale</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ensure we didn't round up too much */ 
</span>        <a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN7452"><span class='Ref_To_Local'>numPendingPages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a><span class='Delimiter'>, 
</span>                           <a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN7452"><span class='Ref_To_Local'>numPendingPages</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We might get here because it's a hypothetical index, or an index 
         * created pre-9.1 and never vacuumed since upgrading (in which case 
         * its stats would read as zeroes), or just because it's grown too 
         * much since the last VACUUM for us to put our faith in scaling. 
         * 
         * Invent some plausible internal statistics based on the index page 
         * count (and clamp that to at least 10 pages, just in case).  We 
         * estimate that 90% of the index is entry pages, and the rest is data 
         * pages.  Estimate 100 entries per entry page; this is rather bogus 
         * since it'll depend on the size of the keys, but it's more robust 
         * than trying to predict the number of entries per heap tuple. 
         */ 
</span>        <a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a><span class='Delimiter'>, </span><span class='Number'>10</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a> <span class='Operator'>= </span>floor<span class='Parentheses'>((</span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN7452"><span class='Ref_To_Local'>numPendingPages</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>90</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7448"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN7452"><span class='Ref_To_Local'>numPendingPages</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a> <span class='Operator'>= </span>floor<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a> <span class='Operator'>* </span><span class='Number'>100</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* In an empty index, numEntries could be zero.  Avoid divide-by-zero */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Include predicate in selectivityQuals (should match 
     * genericcostestimate) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN7551"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>predExtraQuals</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7446"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN7555"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>predQual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7446"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN7556"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>oneQual</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7555"><span class='Ref_To_Local'>predQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/predtest.h.html#LN19"><span class='Ref_to_Proto'>predicate_implied_by</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7556"><span class='Ref_To_Local'>oneQual</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7443"><span class='Ref_To_Local'>indexQuals</span></a><span class='Parentheses'>))</span> 
                <a href="selfuncs.c.html#LN7551"><span class='Ref_To_Local'>predExtraQuals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7551"><span class='Ref_To_Local'>predExtraQuals</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7556"><span class='Ref_To_Local'>oneQual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* list_concat avoids modifying the passed-in indexQuals list */ 
</span>        <a href="selfuncs.c.html#LN7447"><span class='Ref_To_Local'>selectivityQuals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7551"><span class='Ref_To_Local'>predExtraQuals</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7443"><span class='Ref_To_Local'>indexQuals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN7447"><span class='Ref_To_Local'>selectivityQuals</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7443"><span class='Ref_To_Local'>indexQuals</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Estimate the fraction of main-table tuples that will be visited */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7439"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7447"><span class='Ref_To_Local'>selectivityQuals</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                               <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch estimated page cost for tablespace containing index */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN631"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="selfuncs.c.html#LN7462"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>, 
</span>                              <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generic assumption about index correlation: there isn't any. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7439"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Examine quals to estimate number of search entries & partial matches 
     */ 
</span>    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7455"><span class='Ref_To_Local'>matchPossible</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7446"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7445"><span class='Ref_To_Local'>qinfos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN7592"></a>        <a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>qinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7446"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN7593"></a>        <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7592"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN105"><span class='Ref_to_Member'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7593"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN7455"><span class='Ref_To_Local'>matchPossible</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7265"><span class='Ref_to_Func'>gincost_opexpr</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>, 
</span>                                           <a href="selfuncs.c.html#LN7592"><span class='Ref_To_Local'>qinfo</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN7455"><span class='Ref_To_Local'>matchPossible</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7593"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="selfuncs.c.html#LN7455"><span class='Ref_To_Local'>matchPossible</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7321"><span class='Ref_to_Func'>gincost_scalararrayopexpr</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN7442"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN7592"><span class='Ref_To_Local'>qinfo</span></a><span class='Delimiter'>, 
</span>                                                      <a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a><span class='Delimiter'>, 
</span>                                                      <span class='Operator'>&</span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN7455"><span class='Ref_To_Local'>matchPossible</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* shouldn't be anything else for a GIN index */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported GIN indexqual type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7593"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Fall out if there were any provably-unsatisfiable quals */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="selfuncs.c.html#LN7455"><span class='Ref_To_Local'>matchPossible</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="selfuncs.c.html#LN7439"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7151"><span class='Ref_to_Member'>haveFullScan</span></a> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN7443"><span class='Ref_To_Local'>indexQuals</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Full index scan will be required.  We treat this as if every key in 
         * the index had been listed in the query; is that reasonable? 
         */ 
</span>        <a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Will we have more than one iteration of a nestloop scan? */ 
</span>    <a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute cost to begin scan, first of all, pay attention to pending 
     * list. 
     */ 
</span>    <a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7452"><span class='Ref_To_Local'>numPendingPages</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate number of entry pages read.  We need to do 
     * counts.searchEntries searches.  Use a power function as it should be, 
     * but tuples on leaf pages usually is much greater. Here we include all 
     * searches in entry tree, including search of first entry in partial 
     * match algorithm 
     */ 
</span>    <a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a> <span class='Operator'>+= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7154"><span class='Ref_to_Member'>searchEntries</span></a> <span class='Operator'>* </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span>pow<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>15</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add an estimate of entry pages read by partial match algorithm. It's a 
     * scan over leaf pages in entry tree.  We haven't any useful stats here, 
     * so estimate it as proportion.  Because counts.partialEntries is really 
     * pretty bogus (see code above), it's possible that it is more than 
     * numEntries; clamp the proportion to ensure sanity. 
     */ 
</span>    <a href="selfuncs.c.html#LN7456"><span class='Ref_To_Local'>partialScale</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7152"><span class='Ref_to_Member'>partialEntries</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7456"><span class='Ref_To_Local'>partialScale</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7456"><span class='Ref_To_Local'>partialScale</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a> <span class='Operator'>+= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7456"><span class='Ref_To_Local'>partialScale</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Partial match algorithm reads all data pages before doing actual scan, 
     * so it's a startup cost.  Again, we haven't any useful stats here, so 
     * estimate it as proportion. 
     */ 
</span>    <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7456"><span class='Ref_To_Local'>partialScale</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate cache effects if more than one scan due to nestloops or array 
     * quals.  The result is pro-rated per nestloop scan, but the array qual 
     * factor shouldn't be pro-rated (compare genericcostestimate). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a><span class='Delimiter'>, 
</span>                                                <span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a><span class='Delimiter'>, 
</span>                                                <a href="selfuncs.c.html#LN7450"><span class='Ref_To_Local'>numEntryPages</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a> <span class='Operator'>/= </span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a><span class='Delimiter'>, 
</span>                                               <span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>/= </span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Here we use random page cost because logically-close pages could be far 
     * apart on disk. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7457"><span class='Ref_To_Local'>entryPagesFetched</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="selfuncs.c.html#LN7462"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now compute the number of data pages fetched during the scan. 
     * 
     * We assume every entry to have the same number of items, and that there 
     * is no overlap between them. (XXX: tsvector and array opclasses collect 
     * statistics on the frequency of individual keys; it would be nice to use 
     * those here.) 
     */ 
</span>    <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7153"><span class='Ref_to_Member'>exactEntries</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7453"><span class='Ref_To_Local'>numEntries</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there is a lot of overlap among the entries, in particular if one of 
     * the entries is very frequent, the above calculation can grossly 
     * under-estimate.  As a simple cross-check, calculate a lower bound based 
     * on the overall selectivity of the quals.  At a minimum, we must read 
     * one item pointer for each matching entry. 
     * 
     * The width of each item pointer varies, based on the level of 
     * compression.  We don't have statistics on that, but an average of 
     * around 3 bytes per item is fairly typical. 
     */ 
</span>    <a href="selfuncs.c.html#LN7459"><span class='Ref_To_Local'>dataPagesFetchedBySel</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN7439"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>* 
</span>                                 <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7449"><span class='Ref_To_Local'>numTuples</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span>BLCKSZ <span class='Operator'>/ </span><span class='Number'>3</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7459"><span class='Ref_To_Local'>dataPagesFetchedBySel</span></a> <span class='Operator'>&GT; </span><a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7459"><span class='Ref_To_Local'>dataPagesFetchedBySel</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Account for cache effects, the same as above */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>*= </span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7454"><span class='Ref_To_Local'>counts</span></a><span class='Operator'>.</span><a href="selfuncs.c.html#LN7155"><span class='Ref_to_Member'>arrayScans</span></a><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a><span class='Delimiter'>, 
</span>                                               <span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a><span class='Delimiter'>, 
</span>                                               <a href="selfuncs.c.html#LN7451"><span class='Ref_To_Local'>numDataPages</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>/= </span><a href="selfuncs.c.html#LN7463"><span class='Ref_To_Local'>outer_scans</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* And apply random_page_cost as the cost per page */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>+ 
</span>        <a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7462"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add on index qual eval costs, much as in genericcostestimate 
     */ 
</span>    <a href="selfuncs.c.html#LN7461"><span class='Ref_To_Local'>qual_arg_cost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6386"><span class='Ref_to_Func'>other_operands_eval_cost</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7445"><span class='Ref_To_Local'>qinfos</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>        <a href="selfuncs.c.html#LN6411"><span class='Ref_to_Func'>orderby_operands_eval_cost</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7437"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="selfuncs.c.html#LN7460"><span class='Ref_To_Local'>qual_op_cost</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* 
</span>        <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7443"><span class='Ref_To_Local'>indexQuals</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7444"><span class='Ref_To_Local'>indexOrderBys</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7461"><span class='Ref_To_Local'>qual_arg_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7461"><span class='Ref_To_Local'>qual_arg_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7438"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7449"><span class='Ref_To_Local'>numTuples</span></a> <span class='Operator'>* *</span><a href="selfuncs.c.html#LN7439"><span class='Ref_to_Parameter'>indexSelectivity</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../optimizer/path/costsize.c.html#LN106"><span class='Ref_to_Global_Var'>cpu_index_tuple_cost</span></a> <span class='Operator'>+ </span><a href="selfuncs.c.html#LN7460"><span class='Ref_To_Local'>qual_op_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7440"><span class='Ref_to_Parameter'>indexPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7458"><span class='Ref_To_Local'>dataPagesFetched</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end gincostestimate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * BRIN has search behavior completely different from other index types 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN7762"></a><span class='Declare_Function'>brincostestimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN7763"></a>                 <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexStartupCost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexTotalCost</span><span class='Delimiter'>, 
</span><a name="LN7764"></a>                 <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexSelectivity</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexCorrelation</span><span class='Delimiter'>, 
</span><a name="LN7765"></a>                 <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexPages</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7767"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN7768"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexQuals</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1032"><span class='Ref_to_Member'>indexquals</span></a><span class='Delimiter'>; 
</span><a name="LN7769"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>numPages</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>; 
</span><a name="LN7770"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>baserel</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Delimiter'>; 
</span><a name="LN7771"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7770"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN7772"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qinfos</span><span class='Delimiter'>; 
</span><a name="LN7773"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>spc_seq_page_cost</span><span class='Delimiter'>; 
</span><a name="LN7774"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>spc_random_page_cost</span><span class='Delimiter'>; 
</span><a name="LN7775"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>qual_arg_cost</span><span class='Delimiter'>; 
</span><a name="LN7776"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>qualSelectivity</span><span class='Delimiter'>; 
</span><a name="LN7777"></a>    <a href="../../../include/access/brin.h.html#LN31"><span class='Ref_to_Struct'>BrinStatsData</span></a> <span class='Declare_Local'>statsData</span><span class='Delimiter'>; 
</span><a name="LN7778"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>indexRanges</span><span class='Delimiter'>; 
</span><a name="LN7779"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>minimalRanges</span><span class='Delimiter'>; 
</span><a name="LN7780"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>estimatedRanges</span><span class='Delimiter'>; 
</span><a name="LN7781"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN7782"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indexRel</span><span class='Delimiter'>; 
</span><a name="LN7783"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN7784"></a>    <a href="../../../include/utils/selfuncs.h.html#LN66"><span class='Ref_to_Struct'>VariableStatData</span></a> <span class='Declare_Local'>vardata</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7771"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch estimated page cost for the tablespace containing the index */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN631"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="selfuncs.c.html#LN7774"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="selfuncs.c.html#LN7773"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Obtain some data from the index itself. 
     */ 
</span>    <a href="selfuncs.c.html#LN7782"><span class='Ref_To_Local'>indexRel</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/brin.h.html#LN49"><span class='Ref_to_Proto'>brinGetStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7782"><span class='Ref_To_Local'>indexRel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7777"><span class='Ref_To_Local'>statsData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7782"><span class='Ref_To_Local'>indexRel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute index correlation 
     * 
     * Because we can use all index quals equally when scanning, we can use 
     * the largest correlation (in absolute value) among columns used by the 
     * query.  Start at zero, the worst possible case.  If we cannot find any 
     * correlation statistics, we will keep it as 0. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7764"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="selfuncs.c.html#LN7772"><span class='Ref_To_Local'>qinfos</span></a> <span class='Operator'>= </span><a href="../../../include/utils/selfuncs.h.html#LN211"><span class='Ref_to_Proto'>deconstruct_indexquals</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7783"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7772"><span class='Ref_To_Local'>qinfos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN7813"></a>        <a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>qinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/selfuncs.h.html#LN103"><span class='Ref_to_Typedef'>IndexQualInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7783"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN7814"></a>        <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attnum</span> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN641"><span class='Ref_to_Member'>indexkeys</span></a><span class='Delimiter'>[</span><a href="selfuncs.c.html#LN7813"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN106"><span class='Ref_to_Member'>indexcol</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* attempt to lookup stats in relation for this index column */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7814"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Simple variable -- look to stats for the underlying table */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN153"><span class='Ref_to_Global_Var'>get_relation_stats_hook</span></a> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN153"><span class='Ref_to_Global_Var'>get_relation_stats_hook</span></a><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7771"><span class='Ref_To_Local'>rte</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7814"><span class='Ref_To_Local'>attnum</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * The hook took control of acquiring a stats tuple.  If it 
                 * did supply a tuple, it'd better have supplied a freefunc. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a><span class='Parentheses'>)</span> 
                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                      <span class='String'>"no function provided to release variable stats with"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a> <span class='Operator'>= 
</span>                    <a href="../../../include/utils/syscache.h.html#LN159"><span class='Ref_to_Macro'>SearchSysCache3</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN90"><span class='Ref_to_EnumConst'>STATRELATTINH</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7771"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7814"><span class='Ref_To_Local'>attnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if attnum!=0 &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Looks like we've found an expression column in the index. Let's 
             * see if there's any stats for it. 
             */ 
</span> 
            <span class='Comment_Multi_Line'>/* get the attnum from the 0-based index. */ 
</span>            <a href="selfuncs.c.html#LN7814"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7813"><span class='Ref_To_Local'>qinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/selfuncs.h.html#LN106"><span class='Ref_to_Member'>indexcol</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN154"><span class='Ref_to_Global_Var'>get_index_stats_hook</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN154"><span class='Ref_to_Global_Var'>get_index_stats_hook</span></a><span class='Parentheses'>) (</span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7814"><span class='Ref_To_Local'>attnum</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * The hook took control of acquiring a stats tuple.  If it 
                 * did supply a tuple, it'd better have supplied a freefunc. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                    <span class='Operator'>!</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a><span class='Parentheses'>)</span> 
                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"no function provided to release variable stats with"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN159"><span class='Ref_to_Macro'>SearchSysCache3</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN90"><span class='Ref_to_EnumConst'>STATRELATTINH</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN630"><span class='Ref_to_Member'>indexoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                     <a href="../../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7814"><span class='Ref_To_Local'>attnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                     <a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN72"><span class='Ref_to_Member'>freefunc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN7874"></a>            <a href="../../../include/utils/lsyscache.h.html#LN42"><span class='Ref_to_Struct'>AttStatsSlot</span></a> <span class='Declare_Local'>sslot</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN172"><span class='Ref_to_Proto'>get_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7874"><span class='Ref_To_Local'>sslot</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Operator'>.</span><a href="../../../include/utils/selfuncs.h.html#LN70"><span class='Ref_to_Member'>statsTuple</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/catalog/pg_statistic.h.html#LN232"><span class='Ref_to_Const'>STATISTIC_KIND_CORRELATION</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/utils/lsyscache.h.html#LN39"><span class='Ref_to_Const'>ATTSTATSSLOT_NUMBERS</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN7880"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>varCorrelation</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7874"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN52"><span class='Ref_to_Member'>nnumbers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="selfuncs.c.html#LN7880"><span class='Ref_To_Local'>varCorrelation</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN811"><span class='Ref_to_Macro'>Abs</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7874"><span class='Ref_To_Local'>sslot</span></a><span class='Operator'>.</span><a href="../../../include/utils/lsyscache.h.html#LN51"><span class='Ref_to_Member'>numbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7880"><span class='Ref_To_Local'>varCorrelation</span></a> <span class='Operator'>&GT; *</span><a href="selfuncs.c.html#LN7764"><span class='Ref_to_Parameter'>indexCorrelation</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7764"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7880"><span class='Ref_To_Local'>varCorrelation</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../../include/utils/lsyscache.h.html#LN174"><span class='Ref_to_Proto'>free_attstatsslot</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="selfuncs.c.html#LN7874"><span class='Ref_To_Local'>sslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/utils/selfuncs.h.html#LN80"><span class='Ref_to_Macro'>ReleaseVariableStats</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7784"><span class='Ref_To_Local'>vardata</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="selfuncs.c.html#LN7776"><span class='Ref_To_Local'>qualSelectivity</span></a> <span class='Operator'>= </span><a href="../../optimizer/path/clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7768"><span class='Ref_To_Local'>indexQuals</span></a><span class='Delimiter'>, 
</span>                                             <a href="selfuncs.c.html#LN7770"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* work out the actual number of ranges in the index */ 
</span>    <a href="selfuncs.c.html#LN7778"><span class='Ref_To_Local'>indexRanges</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span>ceil<span class='Parentheses'>((</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="selfuncs.c.html#LN7770"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7777"><span class='Ref_To_Local'>statsData</span></a><span class='Operator'>.</span><a href="../../../include/access/brin.h.html#LN33"><span class='Ref_to_Member'>pagesPerRange</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now calculate the minimum possible ranges we could match with if all of 
     * the rows were in the perfect order in the table's heap. 
     */ 
</span>    <a href="selfuncs.c.html#LN7779"><span class='Ref_To_Local'>minimalRanges</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7778"><span class='Ref_To_Local'>indexRanges</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7776"><span class='Ref_To_Local'>qualSelectivity</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now estimate the number of ranges that we'll touch by using the 
     * indexCorrelation from the stats. Careful not to divide by zero (note 
     * we're using the absolute value of the correlation). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="selfuncs.c.html#LN7764"><span class='Ref_to_Parameter'>indexCorrelation</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0e</span><span class='Operator'>-</span><span class='Number'>10</span><span class='Parentheses'>) 
</span>        <a href="selfuncs.c.html#LN7780"><span class='Ref_To_Local'>estimatedRanges</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7778"><span class='Ref_To_Local'>indexRanges</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="selfuncs.c.html#LN7780"><span class='Ref_To_Local'>estimatedRanges</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7779"><span class='Ref_To_Local'>minimalRanges</span></a> <span class='Operator'>/ *</span><a href="selfuncs.c.html#LN7764"><span class='Ref_to_Parameter'>indexCorrelation</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7778"><span class='Ref_To_Local'>indexRanges</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we expect to visit this portion of the table */ 
</span>    <a href="selfuncs.c.html#LN7781"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7780"><span class='Ref_To_Local'>estimatedRanges</span></a> <span class='Operator'>/ </span><a href="selfuncs.c.html#LN7778"><span class='Ref_To_Local'>indexRanges</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/selfuncs.h.html#LN56"><span class='Ref_to_Macro'>CLAMP_PROBABILITY</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7781"><span class='Ref_To_Local'>selec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7764"><span class='Ref_to_Parameter'>indexSelectivity</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7781"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute the index qual costs, much as in genericcostestimate, to add to 
     * the index costs. 
     */ 
</span>    <a href="selfuncs.c.html#LN7775"><span class='Ref_To_Local'>qual_arg_cost</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN6386"><span class='Ref_to_Func'>other_operands_eval_cost</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7772"><span class='Ref_To_Local'>qinfos</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>        <a href="selfuncs.c.html#LN6411"><span class='Ref_to_Func'>orderby_operands_eval_cost</span></a><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute the startup cost as the cost to read the whole revmap 
     * sequentially, including the cost to execute the index quals. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7763"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>= 
</span>        <a href="selfuncs.c.html#LN7773"><span class='Ref_To_Local'>spc_seq_page_cost</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7777"><span class='Ref_To_Local'>statsData</span></a><span class='Operator'>.</span><a href="../../../include/access/brin.h.html#LN34"><span class='Ref_to_Member'>revmapNumPages</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7763"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>+= </span><a href="selfuncs.c.html#LN7775"><span class='Ref_To_Local'>qual_arg_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To read a BRIN index there might be a bit of back and forth over 
     * regular pages, as revmap might point to them out of sequential order; 
     * calculate the total cost as reading the whole index in random order. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7763"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>= *</span><a href="selfuncs.c.html#LN7763"><span class='Ref_to_Parameter'>indexStartupCost</span></a> <span class='Operator'>+ 
</span>        <a href="selfuncs.c.html#LN7774"><span class='Ref_To_Local'>spc_random_page_cost</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="selfuncs.c.html#LN7769"><span class='Ref_To_Local'>numPages</span></a> <span class='Operator'>- </span><a href="selfuncs.c.html#LN7777"><span class='Ref_To_Local'>statsData</span></a><span class='Operator'>.</span><a href="../../../include/access/brin.h.html#LN34"><span class='Ref_to_Member'>revmapNumPages</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="selfuncs.c.html#LN7762"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Charge a small amount per range tuple which we expect to match to. This 
     * is meant to reflect the costs of manipulating the bitmap. The BRIN scan 
     * will set a bit for each page in the range when we find a matching 
     * range, so we must multiply the charge by the number of pages in the 
     * range. 
     */ 
</span>    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7763"><span class='Ref_to_Parameter'>indexTotalCost</span></a> <span class='Operator'>+= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>1</span> <span class='Operator'>* </span><a href="../../optimizer/path/costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="selfuncs.c.html#LN7780"><span class='Ref_To_Local'>estimatedRanges</span></a> <span class='Operator'>* 
</span>        <a href="selfuncs.c.html#LN7777"><span class='Ref_To_Local'>statsData</span></a><span class='Operator'>.</span><a href="../../../include/access/brin.h.html#LN33"><span class='Ref_to_Member'>pagesPerRange</span></a><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="selfuncs.c.html#LN7765"><span class='Ref_to_Parameter'>indexPages</span></a> <span class='Operator'>= </span><a href="selfuncs.c.html#LN7767"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end brincostestimate &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>