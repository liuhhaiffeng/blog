<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\utils\fmgr\funcapi.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\utils\fmgr\funcapi.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:56 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * funcapi.c 
 *    Utility and convenience functions for fmgr functions that return 
 *    sets and/or composite types. 
 * 
 * Copyright (c) 2002-2017, PostgreSQL Global Development Group 
 * 
 * IDENTIFICATION 
 *    src/backend/utils/fmgr/funcapi.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/namespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"funcapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/array.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/regproc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/typcache.h"</span> 
 
 
<a name="LN32"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>shutdown_MultiFuncCall</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN33"></a><span class='Keyword'>static </span><a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> <span class='Declare_Prototype'>internal_get_result_type</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, 
</span><a name="LN34"></a>                         <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>call_expr</span><span class='Delimiter'>, 
</span><a name="LN35"></a>                         <a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rsinfo</span><span class='Delimiter'>, 
</span><a name="LN36"></a>                         <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTypeId</span><span class='Delimiter'>, 
</span><a name="LN37"></a>                         <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTupleDesc</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN38"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>resolve_polymorphic_tupdesc</span><span class='Parentheses'>(</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupdesc</span><span class='Delimiter'>, 
</span><a name="LN39"></a>                            <a href="../../../include/c.h.html#LN477"><span class='Ref_to_Typedef'>oidvector</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>declared_args</span><span class='Delimiter'>, 
</span><a name="LN40"></a>                            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>call_expr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN41"></a><span class='Keyword'>static </span><a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> <span class='Declare_Prototype'>get_type_func_class</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * init_MultiFuncCall 
 * Create an empty FuncCallContext data structure 
 * and do some other basic Multi-function call setup 
 * and error checking 
 */ 
</span><a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>* 
</span><a name="LN51"></a><span class='Declare_Function'>init_MultiFuncCall</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN53"></a>    <a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>retval</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Bail if we're called in the wrong context 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>fcinfo<span class='Operator'>-&GT;</span>resultinfo <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span>fcinfo<span class='Operator'>-&GT;</span>resultinfo<span class='Delimiter'>, </span><a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"set-valued function called in context that cannot accept a set"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Operator'>-&GT;</span>fn_extra <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * First call 
         */ 
</span><a name="LN68"></a>        <a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rsi</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span>fcinfo<span class='Operator'>-&GT;</span>resultinfo<span class='Delimiter'>; 
</span><a name="LN69"></a>        <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>multi_call_ctx</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Create a suitably long-lived context to hold cross-call data 
         */ 
</span>        <a href="funcapi.c.html#LN69"><span class='Ref_To_Local'>multi_call_ctx</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span>fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Operator'>-&GT;</span>fn_mcxt<span class='Delimiter'>, 
</span>                                               <span class='String'>"SRF multi-call context"</span><span class='Delimiter'>, 
</span>                                               <a href="../../../include/utils/memutils.h.html#LN174"><span class='Ref_to_Const'>ALLOCSET_SMALL_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Allocate suitably long-lived space and zero it 
         */ 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/palloc.h.html#LN71"><span class='Ref_to_Proto'>MemoryContextAllocZero</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN69"><span class='Ref_To_Local'>multi_call_ctx</span></a><span class='Delimiter'>, 
</span>                                   <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * initialize the elements 
         */ 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN64"><span class='Ref_to_Member'>call_cntr</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN73"><span class='Ref_to_Member'>max_calls</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN81"><span class='Ref_to_Member'>slot</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN89"><span class='Ref_to_Member'>user_fctx</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN98"><span class='Ref_to_Member'>attinmeta</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN119"><span class='Ref_to_Member'>tuple_desc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN108"><span class='Ref_to_Member'>multi_call_memory_ctx</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN69"><span class='Ref_To_Local'>multi_call_ctx</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * save the pointer for cross-call use 
         */ 
</span>        fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Operator'>-&GT;</span>fn_extra <span class='Operator'>= </span><a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ensure we will get shut down cleanly if the exprcontext is not run 
         * to completion. 
         */ 
</span>        <a href="../../../include/executor/executor.h.html#LN487"><span class='Ref_to_Proto'>RegisterExprContextCallback</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN68"><span class='Ref_To_Local'>rsi</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN265"><span class='Ref_to_Member'>econtext</span></a><span class='Delimiter'>, 
</span>                                    <a href="funcapi.c.html#LN32"><span class='Ref_to_Proto'>shutdown_MultiFuncCall</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span>fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if fcinfo-&GT;flinfo-&GT;fn_ex... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* second and subsequent calls */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"init_MultiFuncCall cannot be called more than once"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* never reached, but keep compiler happy */ 
</span>        <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN53"><span class='Ref_To_Local'>retval</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end init_MultiFuncCall &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * per_MultiFuncCall 
 * 
 * Do Multi-function per-call setup 
 */ 
</span><a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>* 
</span><a name="LN127"></a><span class='Declare_Function'>per_MultiFuncCall</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN129"></a>    <a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>retval</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span>fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Operator'>-&GT;</span>fn_extra<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Clear the TupleTableSlot, if present.  This is for safety's sake: the 
     * Slot will be in a long-lived context (it better be, if the 
     * FuncCallContext is pointing to it), but in most usage patterns the 
     * tuples stored in it will be in the function's per-tuple context. So at 
     * the beginning of each call, the Slot will hold a dangling pointer to an 
     * already-recycled tuple.  We clear it out here. 
     * 
     * Note: use of retval-&GT;slot is obsolete as of 8.0, and we expect that it 
     * will always be NULL.  This is just here for backwards compatibility in 
     * case someone creates a slot anyway. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN129"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN81"><span class='Ref_to_Member'>slot</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN129"><span class='Ref_To_Local'>retval</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN81"><span class='Ref_to_Member'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN129"><span class='Ref_To_Local'>retval</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end per_MultiFuncCall &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * end_MultiFuncCall 
 * Clean up after init_MultiFuncCall 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN154"></a><span class='Declare_Function'>end_MultiFuncCall</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Delimiter'>, </span><a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>funcctx</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN156"></a>    <a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rsi</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span>fcinfo<span class='Operator'>-&GT;</span>resultinfo<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Deregister the shutdown callback */ 
</span>    <a href="../../../include/executor/executor.h.html#LN490"><span class='Ref_to_Proto'>UnregisterExprContextCallback</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN156"><span class='Ref_To_Local'>rsi</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN265"><span class='Ref_to_Member'>econtext</span></a><span class='Delimiter'>, 
</span>                                  <a href="funcapi.c.html#LN32"><span class='Ref_to_Proto'>shutdown_MultiFuncCall</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span>fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* But use it to do the real work */ 
</span>    <a href="funcapi.c.html#LN32"><span class='Ref_to_Proto'>shutdown_MultiFuncCall</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span>fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * shutdown_MultiFuncCall 
 * Shutdown function to clean up after init_MultiFuncCall 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN172"></a><span class='Declare_Function'>shutdown_MultiFuncCall</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN174"></a>    <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>flinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN172"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN175"></a>    <a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>funcctx</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="funcapi.c.html#LN174"><span class='Ref_To_Local'>flinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN63"><span class='Ref_to_Member'>fn_extra</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* unbind from flinfo */ 
</span>    <a href="funcapi.c.html#LN174"><span class='Ref_To_Local'>flinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN63"><span class='Ref_to_Member'>fn_extra</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Delete context that holds all multi-call data, including the 
     * FuncCallContext itself 
     */ 
</span>    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN175"><span class='Ref_To_Local'>funcctx</span></a><span class='Operator'>-&GT;</span><a href="../../../include/funcapi.h.html#LN108"><span class='Ref_to_Member'>multi_call_memory_ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_call_result_type 
 *      Given a function's call info record, determine the kind of datatype 
 *      it is supposed to return.  If resultTypeId isn't NULL, *resultTypeId 
 *      receives the actual datatype OID (this is mainly useful for scalar 
 *      result types).  If resultTupleDesc isn't NULL, *resultTupleDesc 
 *      receives a pointer to a TupleDesc when the result is of a composite 
 *      type, or NULL when it's a scalar result. 
 * 
 * One hard case that this handles is resolution of actual rowtypes for 
 * functions returning RECORD (from either the function's OUT parameter 
 * list, or a ReturnSetInfo context node).  TYPEFUNC_RECORD is returned 
 * only when we couldn't resolve the actual rowtype for lack of information. 
 * 
 * The other hard case that this handles is resolution of polymorphism. 
 * We will never return polymorphic pseudotypes (ANYELEMENT etc), either 
 * as a scalar result type or as a component of a rowtype. 
 * 
 * This function is relatively expensive --- in a function returning set, 
 * try to call it only the first time through. 
 */ 
</span><a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> 
<a name="LN210"></a><span class='Declare_Function'>get_call_result_type</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Parameter'>fcinfo</span><span class='Delimiter'>, 
</span><a name="LN211"></a>                     <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTypeId</span><span class='Delimiter'>, 
</span><a name="LN212"></a>                     <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTupleDesc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="funcapi.c.html#LN33"><span class='Ref_to_Proto'>internal_get_result_type</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN210"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN78"><span class='Ref_to_Member'>flinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN58"><span class='Ref_to_Member'>fn_oid</span></a><span class='Delimiter'>, 
</span>                                    <a href="funcapi.c.html#LN210"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN78"><span class='Ref_to_Member'>flinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN65"><span class='Ref_to_Member'>fn_expr</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="funcapi.c.html#LN210"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/fmgr.h.html#LN80"><span class='Ref_to_Member'>resultinfo</span></a><span class='Delimiter'>, 
</span>                                    <a href="funcapi.c.html#LN211"><span class='Ref_to_Parameter'>resultTypeId</span></a><span class='Delimiter'>, 
</span>                                    <a href="funcapi.c.html#LN212"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_expr_result_type 
 *      As above, but work from a calling expression node tree 
 */ 
</span><a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> 
<a name="LN226"></a><span class='Declare_Function'>get_expr_result_type</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, 
</span><a name="LN227"></a>                     <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTypeId</span><span class='Delimiter'>, 
</span><a name="LN228"></a>                     <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTupleDesc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN230"></a>    <a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
        <a href="funcapi.c.html#LN230"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN33"><span class='Ref_to_Proto'>internal_get_result_type</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>funcid<span class='Delimiter'>, 
</span>                                          <a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, 
</span>                                          <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                          <a href="funcapi.c.html#LN227"><span class='Ref_to_Parameter'>resultTypeId</span></a><span class='Delimiter'>, 
</span>                                          <a href="funcapi.c.html#LN228"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
        <a href="funcapi.c.html#LN230"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN33"><span class='Ref_to_Proto'>internal_get_result_type</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, 
</span>                                          <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                          <a href="funcapi.c.html#LN227"><span class='Ref_to_Parameter'>resultTypeId</span></a><span class='Delimiter'>, 
</span>                                          <a href="funcapi.c.html#LN228"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* handle as a generic expression; no chance to resolve RECORD */ 
</span><a name="LN247"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typid</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN226"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN227"><span class='Ref_to_Parameter'>resultTypeId</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="funcapi.c.html#LN227"><span class='Ref_to_Parameter'>resultTypeId</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN247"><span class='Ref_To_Local'>typid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN228"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="funcapi.c.html#LN228"><span class='Ref_to_Parameter'>resultTupleDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN230"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN41"><span class='Ref_to_Proto'>get_type_func_class</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN247"><span class='Ref_To_Local'>typid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN230"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><a href="../../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a> <span class='Operator'>&& </span><a href="funcapi.c.html#LN228"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="funcapi.c.html#LN228"><span class='Ref_to_Parameter'>resultTupleDesc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/typcache.h.html#LN156"><span class='Ref_to_Proto'>lookup_rowtype_tupdesc_copy</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN247"><span class='Ref_To_Local'>typid</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN230"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_expr_result_type &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_func_result_type 
 *      As above, but work from a function's OID only 
 * 
 * This will not be able to resolve pure-RECORD results nor polymorphism. 
 */ 
</span><a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> 
<a name="LN268"></a><span class='Declare_Function'>get_func_result_type</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>functionId</span><span class='Delimiter'>, 
</span><a name="LN269"></a>                     <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTypeId</span><span class='Delimiter'>, 
</span><a name="LN270"></a>                     <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTupleDesc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="funcapi.c.html#LN33"><span class='Ref_to_Proto'>internal_get_result_type</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN268"><span class='Ref_to_Parameter'>functionId</span></a><span class='Delimiter'>, 
</span>                                    <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                    <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                    <a href="funcapi.c.html#LN269"><span class='Ref_to_Parameter'>resultTypeId</span></a><span class='Delimiter'>, 
</span>                                    <a href="funcapi.c.html#LN270"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * internal_get_result_type -- workhorse code implementing all the above 
 * 
 * funcid must always be supplied.  call_expr and rsinfo can be NULL if not 
 * available.  We will return TYPEFUNC_RECORD, and store NULL into 
 * *resultTupleDesc, if we cannot deduce the complete result rowtype from 
 * the available information. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> 
<a name="LN288"></a><span class='Declare_Function'>internal_get_result_type</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>funcid</span><span class='Delimiter'>, 
</span><a name="LN289"></a>                         <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>call_expr</span><span class='Delimiter'>, 
</span><a name="LN290"></a>                         <a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rsinfo</span><span class='Delimiter'>, 
</span><a name="LN291"></a>                         <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTypeId</span><span class='Delimiter'>, 
</span><a name="LN292"></a>                         <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultTupleDesc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN294"></a>    <a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN295"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tp</span><span class='Delimiter'>; 
</span><a name="LN296"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>procform</span><span class='Delimiter'>; 
</span><a name="LN297"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>rettype</span><span class='Delimiter'>; 
</span><a name="LN298"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First fetch the function's pg_proc row to inspect its rettype */ 
</span>    <a href="funcapi.c.html#LN295"><span class='Ref_To_Local'>tp</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN288"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN295"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, </span><a href="funcapi.c.html#LN288"><span class='Ref_to_Parameter'>funcid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN296"><span class='Ref_To_Local'>procform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN295"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN296"><span class='Ref_To_Local'>procform</span></a><span class='Operator'>-&GT;</span>prorettype<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for OUT parameters defining a RECORD result */ 
</span>    <a href="funcapi.c.html#LN298"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../../include/funcapi.h.html#LN184"><span class='Ref_to_Proto'>build_function_result_tupdesc_t</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN295"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN298"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * It has OUT parameters, so it's basically like a regular composite 
         * type, except we have to be able to resolve any polymorphic OUT 
         * parameters. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN291"><span class='Ref_to_Parameter'>resultTypeId</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="funcapi.c.html#LN291"><span class='Ref_to_Parameter'>resultTypeId</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN38"><span class='Ref_to_Proto'>resolve_polymorphic_tupdesc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN298"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="funcapi.c.html#LN296"><span class='Ref_To_Local'>procform</span></a><span class='Operator'>-&GT;</span>proargtypes<span class='Delimiter'>, 
</span>                                        <a href="funcapi.c.html#LN289"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN298"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN76"><span class='Ref_to_Member'>tdtypeid</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a> <span class='Operator'>&& 
</span>                <a href="funcapi.c.html#LN298"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN77"><span class='Ref_to_Member'>tdtypmod</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/typcache.h.html#LN158"><span class='Ref_to_Proto'>assign_record_type_typmod</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN298"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN298"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
</span>            <a href="funcapi.c.html#LN294"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="funcapi.c.html#LN294"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/funcapi.h.html#LN153"><span class='Ref_to_EnumConst'>TYPEFUNC_RECORD</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN295"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="funcapi.c.html#LN294"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if tupdesc &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If scalar polymorphic result, try to resolve it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/catalog/pg_type.h.html#LN744"><span class='Ref_to_Macro'>IsPolymorphicType</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN348"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>newrettype</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN289"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN348"><span class='Ref_To_Local'>newrettype</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span>   <span class='Comment_Single_Line'>/* this probably should not happen */ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not determine actual result type for function \"%s\" declared to return type %s"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN296"><span class='Ref_To_Local'>procform</span></a><span class='Operator'>-&GT;</span>proname<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN348"><span class='Ref_To_Local'>newrettype</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN291"><span class='Ref_to_Parameter'>resultTypeId</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN291"><span class='Ref_to_Parameter'>resultTypeId</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* default result */ 
</span> 
    <span class='Comment_Multi_Line'>/* Classify the result type */ 
</span>    <a href="funcapi.c.html#LN294"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN41"><span class='Ref_to_Proto'>get_type_func_class</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN294"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/typcache.h.html#LN156"><span class='Ref_to_Proto'>lookup_rowtype_tupdesc_copy</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN297"><span class='Ref_To_Local'>rettype</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Named composite types can't have any polymorphic columns */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/funcapi.h.html#LN151"><span class='Ref_to_EnumConst'>TYPEFUNC_SCALAR</span></a><span class='Operator'>: 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/funcapi.h.html#LN153"><span class='Ref_to_EnumConst'>TYPEFUNC_RECORD</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* We must get the tupledesc from call context */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN290"><span class='Ref_to_Parameter'>rsinfo</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN290"><span class='Ref_to_Parameter'>rsinfo</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="funcapi.c.html#LN290"><span class='Ref_to_Parameter'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN266"><span class='Ref_to_Member'>expectedDesc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="funcapi.c.html#LN294"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a><span class='Parentheses'>) 
</span>                    <span class='Operator'>*</span><a href="funcapi.c.html#LN292"><span class='Ref_to_Parameter'>resultTupleDesc</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN290"><span class='Ref_to_Parameter'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN266"><span class='Ref_to_Member'>expectedDesc</span></a><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* Assume no polymorphic columns here, either */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch result &raquo; </span> 
 
    <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN295"><span class='Ref_To_Local'>tp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN294"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end internal_get_result_type &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given the result tuple descriptor for a function with OUT parameters, 
 * replace any polymorphic columns (ANYELEMENT etc) with correct data types 
 * deduced from the input arguments. Returns TRUE if able to deduce all types, 
 * FALSE if not. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN402"></a><span class='Declare_Function'>resolve_polymorphic_tupdesc</span><span class='Parentheses'>(</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupdesc</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN477"><span class='Ref_to_Typedef'>oidvector</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>declared_args</span><span class='Delimiter'>, 
</span><a name="LN403"></a>                            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>call_expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN405"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span> <span class='Operator'>= </span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; 
</span><a name="LN406"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargs</span> <span class='Operator'>= </span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>declared_args</span></a><span class='Operator'>-&GT;</span><a href="../../../include/c.h.html#LN483"><span class='Ref_to_Member'>dim1</span></a><span class='Delimiter'>; 
</span><a name="LN407"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyelement_result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN408"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyarray_result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN409"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyrange_result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN410"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anynonarray</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN411"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyenum</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN412"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>anyelement_type</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN413"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>anyarray_type</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN414"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>anyrange_type</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN415"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>anycollation</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN416"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* See if there are any polymorphic outputs; quick out if not */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN405"><span class='Ref_To_Local'>natts</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN407"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN408"><span class='Ref_To_Local'>have_anyarray_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN407"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="funcapi.c.html#LN410"><span class='Ref_To_Local'>have_anynonarray</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN407"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="funcapi.c.html#LN411"><span class='Ref_To_Local'>have_anyenum</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN409"><span class='Ref_To_Local'>have_anyrange_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch tupdesc-&GT;attrs[i]-&GT;at... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;natts;i++ &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN407"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>&& !</span><a href="funcapi.c.html#LN408"><span class='Ref_To_Local'>have_anyarray_result</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="funcapi.c.html#LN409"><span class='Ref_To_Local'>have_anyrange_result</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, extract actual datatype(s) from input arguments.  (We assume 
     * the parser already validated consistency of the arguments.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN403"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no hope */ 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN406"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>declared_args</span></a><span class='Operator'>-&GT;</span><a href="../../../include/c.h.html#LN485"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
                    <a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN664"><span class='Ref_to_Proto'>get_call_expr_argtype</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN403"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
                    <a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN664"><span class='Ref_to_Proto'>get_call_expr_argtype</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN403"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN414"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
                    <a href="funcapi.c.html#LN414"><span class='Ref_To_Local'>anyrange_type</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN664"><span class='Ref_to_Proto'>get_call_expr_argtype</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN403"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;nargs;i++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* If nothing found, parser messed up */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN414"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If needed, deduce one polymorphic type from others */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN407"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
            <a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_coerce.h.html#LN82"><span class='Ref_to_Proto'>resolve_generic_type</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Delimiter'>, 
</span>                                                   <a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN414"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN492"></a>            <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>subtype</span> <span class='Operator'>= </span><a href="../../../include/parser/parse_coerce.h.html#LN82"><span class='Ref_to_Proto'>resolve_generic_type</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Delimiter'>, 
</span>                                                       <a href="funcapi.c.html#LN414"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* check for inconsistent array and range results */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>!= </span><a href="funcapi.c.html#LN492"><span class='Ref_To_Local'>subtype</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN492"><span class='Ref_To_Local'>subtype</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN408"><span class='Ref_To_Local'>have_anyarray_result</span></a> <span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
        <a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_coerce.h.html#LN82"><span class='Ref_to_Proto'>resolve_generic_type</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Delimiter'>, 
</span>                                             <a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't deduce a range type from other polymorphic inputs, because 
     * there may be multiple range types for the same subtype. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN409"><span class='Ref_To_Local'>have_anyrange_result</span></a> <span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN414"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Enforce ANYNONARRAY if needed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN410"><span class='Ref_To_Local'>have_anynonarray</span></a> <span class='Operator'>&& </span><a href="../../../include/utils/lsyscache.h.html#LN179"><span class='Ref_to_Macro'>type_is_array</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Enforce ANYENUM if needed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN411"><span class='Ref_To_Local'>have_anyenum</span></a> <span class='Operator'>&& !</span><a href="../../../include/utils/lsyscache.h.html#LN151"><span class='Ref_to_Proto'>type_is_enum</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Identify the collation to use for polymorphic OUT parameters. (It'll 
     * necessarily be the same for both anyelement and anyarray.)  Note that 
     * range types are not collatable, so any possible internal collation of a 
     * range type is not considered here. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
        <a href="funcapi.c.html#LN415"><span class='Ref_To_Local'>anycollation</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN166"><span class='Ref_to_Proto'>get_typcollation</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
        <a href="funcapi.c.html#LN415"><span class='Ref_To_Local'>anycollation</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN166"><span class='Ref_to_Proto'>get_typcollation</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN415"><span class='Ref_To_Local'>anycollation</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The types are collatable, so consider whether to use a nondefault 
         * collation.  We do so if we can identify the input collation used 
         * for the function. 
         */ 
</span><a name="LN541"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputcollation</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN39"><span class='Ref_to_Proto'>exprInputCollation</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN403"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN541"><span class='Ref_To_Local'>inputcollation</span></a><span class='Parentheses'>))</span> 
            <a href="funcapi.c.html#LN415"><span class='Ref_To_Local'>anycollation</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN541"><span class='Ref_To_Local'>inputcollation</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* And finally replace the tuple column types as needed */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN405"><span class='Ref_To_Local'>natts</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Operator'>: 
</span>                <a href="../../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="funcapi.c.html#LN412"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/tupdesc.h.html#LN128"><span class='Ref_to_Proto'>TupleDescInitEntryCollation</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="funcapi.c.html#LN415"><span class='Ref_To_Local'>anycollation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Operator'>: 
</span>                <a href="../../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="funcapi.c.html#LN413"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/tupdesc.h.html#LN128"><span class='Ref_to_Proto'>TupleDescInitEntryCollation</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="funcapi.c.html#LN415"><span class='Ref_To_Local'>anycollation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Operator'>: 
</span>                <a href="../../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN402"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN416"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="funcapi.c.html#LN414"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* no collation should be attached to a range type */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch tupdesc-&GT;attrs[i]-&GT;at... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;natts;i++ &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end resolve_polymorphic_tupdesc &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given the declared argument types and modes for a function, replace any 
 * polymorphic types (ANYELEMENT etc) with correct data types deduced from the 
 * input arguments.  Returns TRUE if able to deduce all types, FALSE if not. 
 * This is the same logic as resolve_polymorphic_tupdesc, but with a different 
 * argument representation. 
 * 
 * argmodes may be NULL, in which case all arguments are assumed to be IN mode. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN596"></a><span class='Declare_Function'>resolve_polymorphic_argtypes</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>numargs</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argtypes</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>argmodes</span><span class='Delimiter'>, 
</span><a name="LN597"></a>                             <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>call_expr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN599"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyelement_result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN600"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyarray_result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN601"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_anyrange_result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN602"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>anyelement_type</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN603"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>anyarray_type</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN604"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>anyrange_type</span> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN605"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>inargno</span><span class='Delimiter'>; 
</span><a name="LN606"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First pass: resolve polymorphic inputs, check for outputs */ 
</span>    <a href="funcapi.c.html#LN605"><span class='Ref_To_Local'>inargno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>numargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN612"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>argmode</span> <span class='Operator'>= </span><a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argmodes</span></a> <span class='Operator'>? </span><a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>: </span><a href="../../../include/catalog/pg_proc.h.html#LN5500"><span class='Ref_to_Const'>PROARGMODE_IN</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5501"><span class='Ref_to_Const'>PROARGMODE_OUT</span></a> <span class='Operator'>|| </span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5504"><span class='Ref_to_Const'>PROARGMODE_TABLE</span></a><span class='Parentheses'>) 
</span>                    <a href="funcapi.c.html#LN599"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN664"><span class='Ref_to_Proto'>get_call_expr_argtype</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN597"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Delimiter'>, 
</span>                                                                <a href="funcapi.c.html#LN605"><span class='Ref_To_Local'>inargno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
                            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5501"><span class='Ref_to_Const'>PROARGMODE_OUT</span></a> <span class='Operator'>|| </span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5504"><span class='Ref_to_Const'>PROARGMODE_TABLE</span></a><span class='Parentheses'>) 
</span>                    <a href="funcapi.c.html#LN600"><span class='Ref_To_Local'>have_anyarray_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN664"><span class='Ref_to_Proto'>get_call_expr_argtype</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN597"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Delimiter'>, 
</span>                                                              <a href="funcapi.c.html#LN605"><span class='Ref_To_Local'>inargno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
                            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5501"><span class='Ref_to_Const'>PROARGMODE_OUT</span></a> <span class='Operator'>|| </span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5504"><span class='Ref_to_Const'>PROARGMODE_TABLE</span></a><span class='Parentheses'>) 
</span>                    <a href="funcapi.c.html#LN601"><span class='Ref_To_Local'>have_anyrange_result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN664"><span class='Ref_to_Proto'>get_call_expr_argtype</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN597"><span class='Ref_to_Parameter'>call_expr</span></a><span class='Delimiter'>, 
</span>                                                              <a href="funcapi.c.html#LN605"><span class='Ref_To_Local'>inargno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
                            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch argtypes[i] &raquo; </span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_proc.h.html#LN5501"><span class='Ref_to_Const'>PROARGMODE_OUT</span></a> <span class='Operator'>&& </span><a href="funcapi.c.html#LN612"><span class='Ref_To_Local'>argmode</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_proc.h.html#LN5504"><span class='Ref_to_Const'>PROARGMODE_TABLE</span></a><span class='Parentheses'>) 
</span>            <a href="funcapi.c.html#LN605"><span class='Ref_To_Local'>inargno</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numargs;i++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Done? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN599"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>&& !</span><a href="funcapi.c.html#LN600"><span class='Ref_To_Local'>have_anyarray_result</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="funcapi.c.html#LN601"><span class='Ref_To_Local'>have_anyrange_result</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If no input polymorphics, parser messed up */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If needed, deduce one polymorphic type from others */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN599"><span class='Ref_To_Local'>have_anyelement_result</span></a> <span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
            <a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_coerce.h.html#LN82"><span class='Ref_to_Proto'>resolve_generic_type</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Delimiter'>, 
</span>                                                   <a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN689"></a>            <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>subtype</span> <span class='Operator'>= </span><a href="../../../include/parser/parse_coerce.h.html#LN82"><span class='Ref_to_Proto'>resolve_generic_type</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Delimiter'>, 
</span>                                                       <a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Delimiter'>, 
</span>                                                       <a href="../../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* check for inconsistent array and range results */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>!= </span><a href="funcapi.c.html#LN689"><span class='Ref_To_Local'>subtype</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN689"><span class='Ref_To_Local'>subtype</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN600"><span class='Ref_To_Local'>have_anyarray_result</span></a> <span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Parentheses'>))</span> 
        <a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_coerce.h.html#LN82"><span class='Ref_to_Proto'>resolve_generic_type</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Delimiter'>, 
</span>                                             <a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't deduce a range type from other polymorphic inputs, because 
     * there may be multiple range types for the same subtype. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN601"><span class='Ref_To_Local'>have_anyrange_result</span></a> <span class='Operator'>&& !</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XXX do we need to enforce ANYNONARRAY or ANYENUM here?  I think not */ 
</span> 
    <span class='Comment_Multi_Line'>/* And finally replace the output column types as needed */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>numargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN703"><span class='Ref_to_Const'>ANYNONARRAYOID</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN705"><span class='Ref_to_Const'>ANYENUMOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN602"><span class='Ref_To_Local'>anyelement_type</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN603"><span class='Ref_To_Local'>anyarray_type</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN713"><span class='Ref_to_Const'>ANYRANGEOID</span></a><span class='Operator'>: 
</span>                <a href="funcapi.c.html#LN596"><span class='Ref_to_Parameter'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN606"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN604"><span class='Ref_To_Local'>anyrange_type</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end resolve_polymorphic_argtypes &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_type_func_class 
 *      Given the type OID, obtain its TYPEFUNC classification. 
 * 
 * This is intended to centralize a bunch of formerly ad-hoc code for 
 * classifying types.  The categories used here are useful for deciding 
 * how to handle functions returning the datatype. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> 
<a name="LN747"></a><span class='Declare_Function'>get_type_func_class</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN149"><span class='Ref_to_Proto'>get_typtype</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN747"><span class='Ref_to_Parameter'>typid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN720"><span class='Ref_to_Const'>TYPTYPE_COMPOSITE</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN719"><span class='Ref_to_Const'>TYPTYPE_BASE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN721"><span class='Ref_to_Const'>TYPTYPE_DOMAIN</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN722"><span class='Ref_to_Const'>TYPTYPE_ENUM</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN724"><span class='Ref_to_Const'>TYPTYPE_RANGE</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/funcapi.h.html#LN151"><span class='Ref_to_EnumConst'>TYPEFUNC_SCALAR</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/catalog/pg_type.h.html#LN723"><span class='Ref_to_Const'>TYPTYPE_PSEUDO</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN747"><span class='Ref_to_Parameter'>typid</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="../../../include/funcapi.h.html#LN153"><span class='Ref_to_EnumConst'>TYPEFUNC_RECORD</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We treat VOID and CSTRING as legitimate scalar datatypes, 
             * mostly for the convenience of the JDBC driver (which wants to 
             * be able to do "SELECT * FROM foo()" for all legitimately 
             * user-callable functions). 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN747"><span class='Ref_to_Parameter'>typid</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN689"><span class='Ref_to_Const'>VOIDOID</span></a> <span class='Operator'>|| </span><a href="funcapi.c.html#LN747"><span class='Ref_to_Parameter'>typid</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_type.h.html#LN683"><span class='Ref_to_Const'>CSTRINGOID</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="../../../include/funcapi.h.html#LN151"><span class='Ref_to_EnumConst'>TYPEFUNC_SCALAR</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="../../../include/funcapi.h.html#LN154"><span class='Ref_to_EnumConst'>TYPEFUNC_OTHER</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch get_typtype(typid) &raquo; </span> 
    <span class='Comment_Multi_Line'>/* shouldn't get here, probably */ 
</span>    <span class='Control'>return</span> <a href="../../../include/funcapi.h.html#LN154"><span class='Ref_to_EnumConst'>TYPEFUNC_OTHER</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_type_func_class &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * get_func_arg_info 
 * 
 * Fetch info about the argument types, names, and IN/OUT modes from the 
 * pg_proc tuple.  Return value is the total number of arguments. 
 * Other results are palloc'd.  *p_argtypes is always filled in, but 
 * *p_argnames and *p_argmodes will be set NULL in the default cases 
 * (no names, and all IN arguments, respectively). 
 * 
 * Note that this function simply fetches what is in the pg_proc tuple; 
 * it doesn't do any interpretation of polymorphic types. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN790"></a><span class='Declare_Function'>get_func_arg_info</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>procTup</span><span class='Delimiter'>, 
</span><a name="LN791"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>p_argtypes</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>***</span><span class='Declare_Parameter'>p_argnames</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>**</span><span class='Declare_Parameter'>p_argmodes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN793"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>procStruct</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN790"><span class='Ref_to_Parameter'>procTup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN794"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proallargtypes</span><span class='Delimiter'>; 
</span><a name="LN795"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargmodes</span><span class='Delimiter'>; 
</span><a name="LN796"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargnames</span><span class='Delimiter'>; 
</span><a name="LN797"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span><a name="LN798"></a>    <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arr</span><span class='Delimiter'>; 
</span><a name="LN799"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numargs</span><span class='Delimiter'>; 
</span><a name="LN800"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>elems</span><span class='Delimiter'>; 
</span><a name="LN801"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nelems</span><span class='Delimiter'>; 
</span><a name="LN802"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First discover the total number of parameters and get their types */ 
</span>    <a href="funcapi.c.html#LN794"><span class='Ref_To_Local'>proallargtypes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN790"><span class='Ref_to_Parameter'>procTup</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/catalog/pg_proc.h.html#LN109"><span class='Ref_to_Const'>Anum_pg_proc_proallargtypes</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="funcapi.c.html#LN797"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN797"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We expect the arrays to be 1-D arrays of the right types; verify 
         * that.  For the OID and char arrays, we don't need to use 
         * deconstruct_array() since the array data is just going to look like 
         * a C array of values. 
         */ 
</span>        <a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN794"><span class='Ref_To_Local'>proallargtypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>        <a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>            <a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN27"><span class='Ref_to_Const'>OIDOID</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proallargtypes is not a 1-D Oid array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>&GT;= </span><a href="funcapi.c.html#LN793"><span class='Ref_To_Local'>procStruct</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argtypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argtypes</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/array.h.html#LN302"><span class='Ref_to_Macro'>ARR_DATA_PTR</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !isNull &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* If no proallargtypes, use proargtypes */ 
</span>        <a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN793"><span class='Ref_To_Local'>procStruct</span></a><span class='Operator'>-&GT;</span>proargtypes<span class='Operator'>.</span>dim1<span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>== </span><a href="funcapi.c.html#LN793"><span class='Ref_To_Local'>procStruct</span></a><span class='Operator'>-&GT;</span>pronargs<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argtypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argtypes</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN793"><span class='Ref_To_Local'>procStruct</span></a><span class='Operator'>-&GT;</span>proargtypes<span class='Operator'>.</span>values<span class='Delimiter'>, 
</span>               <a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Get argument names, if available */ 
</span>    <a href="funcapi.c.html#LN796"><span class='Ref_To_Local'>proargnames</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN790"><span class='Ref_to_Parameter'>procTup</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../../include/catalog/pg_proc.h.html#LN111"><span class='Ref_to_Const'>Anum_pg_proc_proargnames</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="funcapi.c.html#LN797"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN797"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argnames</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN796"><span class='Ref_To_Local'>proargnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='String'>'i'</span><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="funcapi.c.html#LN800"><span class='Ref_To_Local'>elems</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="funcapi.c.html#LN801"><span class='Ref_To_Local'>nelems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN801"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>!= </span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a><span class='Parentheses'>)</span>  <span class='Comment_Single_Line'>/* should not happen */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargnames must have the same number of elements as the function has arguments"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argnames</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN802"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN802"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN802"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><a href="funcapi.c.html#LN802"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN800"><span class='Ref_To_Local'>elems</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN802"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Get argument modes, if available */ 
</span>    <a href="funcapi.c.html#LN795"><span class='Ref_To_Local'>proargmodes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN790"><span class='Ref_to_Parameter'>procTup</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../../include/catalog/pg_proc.h.html#LN110"><span class='Ref_to_Const'>Anum_pg_proc_proargmodes</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="funcapi.c.html#LN797"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN797"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argmodes</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN795"><span class='Ref_To_Local'>proargmodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN19"><span class='Ref_to_Const'>CHAROID</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargmodes is not a 1-D char array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argmodes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><span class='Operator'>*</span><a href="funcapi.c.html#LN791"><span class='Ref_to_Parameter'>p_argmodes</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/array.h.html#LN302"><span class='Ref_to_Macro'>ARR_DATA_PTR</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN798"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN799"><span class='Ref_To_Local'>numargs</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_func_arg_info &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_func_trftypes 
 * 
 * Returns the number of transformed types used by function. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN884"></a><span class='Declare_Function'>get_func_trftypes</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>procTup</span><span class='Delimiter'>, 
</span><a name="LN885"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>p_trftypes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN887"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>protrftypes</span><span class='Delimiter'>; 
</span><a name="LN888"></a>    <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arr</span><span class='Delimiter'>; 
</span><a name="LN889"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nelems</span><span class='Delimiter'>; 
</span><a name="LN890"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span> 
    <a href="funcapi.c.html#LN887"><span class='Ref_To_Local'>protrftypes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN884"><span class='Ref_to_Parameter'>procTup</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../../include/catalog/pg_proc.h.html#LN113"><span class='Ref_to_Const'>Anum_pg_proc_protrftypes</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="funcapi.c.html#LN890"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN890"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We expect the arrays to be 1-D arrays of the right types; verify 
         * that.  For the OID and char arrays, we don't need to use 
         * deconstruct_array() since the array data is just going to look like 
         * a C array of values. 
         */ 
</span>        <a href="funcapi.c.html#LN888"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN887"><span class='Ref_To_Local'>protrftypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>        <a href="funcapi.c.html#LN889"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN888"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN888"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>            <a href="funcapi.c.html#LN889"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN888"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN888"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN27"><span class='Ref_to_Const'>OIDOID</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"protrftypes is not a 1-D Oid array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN889"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>((</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN884"><span class='Ref_to_Parameter'>procTup</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>pronargs<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN885"><span class='Ref_to_Parameter'>p_trftypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN889"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><span class='Operator'>*</span><a href="funcapi.c.html#LN885"><span class='Ref_to_Parameter'>p_trftypes</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/array.h.html#LN302"><span class='Ref_to_Macro'>ARR_DATA_PTR</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN888"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="funcapi.c.html#LN889"><span class='Ref_To_Local'>nelems</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="funcapi.c.html#LN889"><span class='Ref_To_Local'>nelems</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !isNull &raquo; </span> 
    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_func_trftypes &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_func_input_arg_names 
 * 
 * Extract the names of input arguments only, given a function's 
 * proargnames and proargmodes entries in Datum form. 
 * 
 * Returns the number of input arguments, which is the length of the 
 * palloc'd array returned to *arg_names.  Entries for unnamed args 
 * are set to NULL.  You don't get anything if proargnames is NULL. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN932"></a><span class='Declare_Function'>get_func_input_arg_names</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>proargnames</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>proargmodes</span><span class='Delimiter'>, 
</span><a name="LN933"></a>                         <span class='Keyword'>char </span><span class='Operator'>***</span><span class='Declare_Parameter'>arg_names</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN935"></a>    <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arr</span><span class='Delimiter'>; 
</span><a name="LN936"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numargs</span><span class='Delimiter'>; 
</span><a name="LN937"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>argnames</span><span class='Delimiter'>; 
</span><a name="LN938"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>argmodes</span><span class='Delimiter'>; 
</span><a name="LN939"></a>    <span class='Keyword'>char</span>      <span class='Operator'>**</span><span class='Declare_Local'>inargnames</span><span class='Delimiter'>; 
</span><a name="LN940"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numinargs</span><span class='Delimiter'>; 
</span><a name="LN941"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do nothing if null proargnames */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN932"><span class='Ref_to_Parameter'>proargnames</span></a> <span class='Operator'>== </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN933"><span class='Ref_to_Parameter'>arg_names</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We expect the arrays to be 1-D arrays of the right types; verify that. 
     * For proargmodes, we don't need to use deconstruct_array() since the 
     * array data is just going to look like a C array of values. 
     */ 
</span>    <a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN932"><span class='Ref_to_Parameter'>proargnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>        <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargnames is not a 1-D text array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Delimiter'>, </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='String'>'i'</span><span class='Delimiter'>, 
</span>                      <span class='Operator'>&</span><a href="funcapi.c.html#LN937"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="funcapi.c.html#LN936"><span class='Ref_To_Local'>numargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN932"><span class='Ref_to_Parameter'>proargmodes</span></a> <span class='Operator'>!= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN932"><span class='Ref_to_Parameter'>proargmodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="funcapi.c.html#LN936"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN19"><span class='Ref_to_Const'>CHAROID</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargmodes is not a 1-D char array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN938"><span class='Ref_To_Local'>argmodes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/array.h.html#LN302"><span class='Ref_to_Macro'>ARR_DATA_PTR</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN935"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="funcapi.c.html#LN938"><span class='Ref_To_Local'>argmodes</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* zero elements probably shouldn't happen, but handle it gracefully */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN936"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="funcapi.c.html#LN933"><span class='Ref_to_Parameter'>arg_names</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* extract input-argument names */ 
</span>    <a href="funcapi.c.html#LN939"><span class='Ref_To_Local'>inargnames</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN936"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN940"><span class='Ref_To_Local'>numinargs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN941"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN941"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN936"><span class='Ref_To_Local'>numargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN941"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN938"><span class='Ref_To_Local'>argmodes</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>            <a href="funcapi.c.html#LN938"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5500"><span class='Ref_to_Const'>PROARGMODE_IN</span></a> <span class='Operator'>|| 
</span>            <a href="funcapi.c.html#LN938"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5502"><span class='Ref_to_Const'>PROARGMODE_INOUT</span></a> <span class='Operator'>|| 
</span>            <a href="funcapi.c.html#LN938"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5503"><span class='Ref_to_Const'>PROARGMODE_VARIADIC</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN992"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>pname</span> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN937"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN941"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN992"><span class='Ref_To_Local'>pname</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='String'>'\0'</span><span class='Parentheses'>) 
</span>                <a href="funcapi.c.html#LN939"><span class='Ref_To_Local'>inargnames</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN940"><span class='Ref_To_Local'>numinargs</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN992"><span class='Ref_To_Local'>pname</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="funcapi.c.html#LN939"><span class='Ref_To_Local'>inargnames</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN940"><span class='Ref_To_Local'>numinargs</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="funcapi.c.html#LN940"><span class='Ref_To_Local'>numinargs</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="funcapi.c.html#LN933"><span class='Ref_to_Parameter'>arg_names</span></a> <span class='Operator'>= </span><a href="funcapi.c.html#LN939"><span class='Ref_To_Local'>inargnames</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="funcapi.c.html#LN940"><span class='Ref_To_Local'>numinargs</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_func_input_arg_names &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * get_func_result_name 
 * 
 * If the function has exactly one output parameter, and that parameter 
 * is named, return the name (as a palloc'd string).  Else return NULL. 
 * 
 * This is used to determine the default output column name for functions 
 * returning scalar types. 
 */ 
</span><span class='Keyword'>char </span><span class='Operator'>* 
</span><a name="LN1017"></a><span class='Declare_Function'>get_func_result_name</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>functionId</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1019"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN1020"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>procTuple</span><span class='Delimiter'>; 
</span><a name="LN1021"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargmodes</span><span class='Delimiter'>; 
</span><a name="LN1022"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargnames</span><span class='Delimiter'>; 
</span><a name="LN1023"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>; 
</span><a name="LN1024"></a>    <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arr</span><span class='Delimiter'>; 
</span><a name="LN1025"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numargs</span><span class='Delimiter'>; 
</span><a name="LN1026"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>argmodes</span><span class='Delimiter'>; 
</span><a name="LN1027"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>argnames</span><span class='Delimiter'>; 
</span><a name="LN1028"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numoutargs</span><span class='Delimiter'>; 
</span><a name="LN1029"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargnames</span><span class='Delimiter'>; 
</span><a name="LN1030"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First fetch the function's pg_proc row */ 
</span>    <a href="funcapi.c.html#LN1020"><span class='Ref_To_Local'>procTuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1017"><span class='Ref_to_Parameter'>functionId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1020"><span class='Ref_To_Local'>procTuple</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1017"><span class='Ref_to_Parameter'>functionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If there are no named OUT parameters, return NULL */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1020"><span class='Ref_To_Local'>procTuple</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_proc.h.html#LN110"><span class='Ref_to_Const'>Anum_pg_proc_proargmodes</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1020"><span class='Ref_To_Local'>procTuple</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_proc.h.html#LN111"><span class='Ref_to_Const'>Anum_pg_proc_proargnames</span></a><span class='Parentheses'>))</span> 
        <a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Get the data out of the tuple */ 
</span>        <a href="funcapi.c.html#LN1021"><span class='Ref_To_Local'>proargmodes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1020"><span class='Ref_To_Local'>procTuple</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/catalog/pg_proc.h.html#LN110"><span class='Ref_to_Const'>Anum_pg_proc_proargmodes</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="funcapi.c.html#LN1023"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN1023"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN1022"><span class='Ref_To_Local'>proargnames</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1020"><span class='Ref_To_Local'>procTuple</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/catalog/pg_proc.h.html#LN111"><span class='Ref_to_Const'>Anum_pg_proc_proargnames</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="funcapi.c.html#LN1023"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN1023"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We expect the arrays to be 1-D arrays of the right types; verify 
         * that.  For the char array, we don't need to use deconstruct_array() 
         * since the array data is just going to look like a C array of 
         * values. 
         */ 
</span>        <a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1021"><span class='Ref_To_Local'>proargmodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>        <a href="funcapi.c.html#LN1025"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>            <a href="funcapi.c.html#LN1025"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN19"><span class='Ref_to_Const'>CHAROID</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargmodes is not a 1-D char array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN1026"><span class='Ref_To_Local'>argmodes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/array.h.html#LN302"><span class='Ref_to_Macro'>ARR_DATA_PTR</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1022"><span class='Ref_To_Local'>proargnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="funcapi.c.html#LN1025"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargnames is not a 1-D text array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1024"><span class='Ref_To_Local'>arr</span></a><span class='Delimiter'>, </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='String'>'i'</span><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="funcapi.c.html#LN1027"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="funcapi.c.html#LN1029"><span class='Ref_To_Local'>nargnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1029"><span class='Ref_To_Local'>nargnames</span></a> <span class='Operator'>== </span><a href="funcapi.c.html#LN1025"><span class='Ref_To_Local'>numargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* scan for output argument(s) */ 
</span>        <a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN1028"><span class='Ref_To_Local'>numoutargs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN1025"><span class='Ref_To_Local'>numargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1026"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5500"><span class='Ref_to_Const'>PROARGMODE_IN</span></a> <span class='Operator'>|| 
</span>                <a href="funcapi.c.html#LN1026"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5503"><span class='Ref_to_Const'>PROARGMODE_VARIADIC</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1026"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5501"><span class='Ref_to_Const'>PROARGMODE_OUT</span></a> <span class='Operator'>|| 
</span>                   <a href="funcapi.c.html#LN1026"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5502"><span class='Ref_to_Const'>PROARGMODE_INOUT</span></a> <span class='Operator'>|| 
</span>                   <a href="funcapi.c.html#LN1026"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5504"><span class='Ref_to_Const'>PROARGMODE_TABLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="funcapi.c.html#LN1028"><span class='Ref_To_Local'>numoutargs</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* multiple out args, so forget it */ 
</span>                <a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1027"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1030"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'\0'</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Parameter is not named, so forget it */ 
</span>                <a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numargs;i++ &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1020"><span class='Ref_To_Local'>procTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN1019"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_func_result_name &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * build_function_result_tupdesc_t 
 * 
 * Given a pg_proc row for a function, return a tuple descriptor for the 
 * result rowtype, or NULL if the function does not have OUT parameters. 
 * 
 * Note that this does not handle resolution of polymorphic types; 
 * that is deliberate. 
 */ 
</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> 
<a name="LN1120"></a><span class='Declare_Function'>build_function_result_tupdesc_t</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>procTuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1122"></a>    <a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a> <span class='Declare_Local'>procform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1120"><span class='Ref_to_Parameter'>procTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1123"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proallargtypes</span><span class='Delimiter'>; 
</span><a name="LN1124"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargmodes</span><span class='Delimiter'>; 
</span><a name="LN1125"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>proargnames</span><span class='Delimiter'>; 
</span><a name="LN1126"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Return NULL if the function isn't declared to return RECORD */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1122"><span class='Ref_To_Local'>procform</span></a><span class='Operator'>-&GT;</span>prorettype <span class='Operator'>!= </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If there are no OUT parameters, return NULL */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1120"><span class='Ref_to_Parameter'>procTuple</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_proc.h.html#LN109"><span class='Ref_to_Const'>Anum_pg_proc_proallargtypes</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1120"><span class='Ref_to_Parameter'>procTuple</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_proc.h.html#LN110"><span class='Ref_to_Const'>Anum_pg_proc_proargmodes</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get the data out of the tuple */ 
</span>    <a href="funcapi.c.html#LN1123"><span class='Ref_To_Local'>proallargtypes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1120"><span class='Ref_to_Parameter'>procTuple</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/catalog/pg_proc.h.html#LN109"><span class='Ref_to_Const'>Anum_pg_proc_proallargtypes</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="funcapi.c.html#LN1126"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN1126"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1124"><span class='Ref_To_Local'>proargmodes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1120"><span class='Ref_to_Parameter'>procTuple</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../../include/catalog/pg_proc.h.html#LN110"><span class='Ref_to_Const'>Anum_pg_proc_proargmodes</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="funcapi.c.html#LN1126"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="funcapi.c.html#LN1126"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1125"><span class='Ref_To_Local'>proargnames</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1120"><span class='Ref_to_Parameter'>procTuple</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../../include/catalog/pg_proc.h.html#LN111"><span class='Ref_to_Const'>Anum_pg_proc_proargnames</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="funcapi.c.html#LN1126"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1126"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>) 
</span>        <a href="funcapi.c.html#LN1125"><span class='Ref_To_Local'>proargnames</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* just to be sure */ 
</span> 
    <span class='Control'>return</span> <a href="../../../include/funcapi.h.html#LN181"><span class='Ref_to_Proto'>build_function_result_tupdesc_d</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1123"><span class='Ref_To_Local'>proallargtypes</span></a><span class='Delimiter'>, 
</span>                                           <a href="funcapi.c.html#LN1124"><span class='Ref_To_Local'>proargmodes</span></a><span class='Delimiter'>, 
</span>                                           <a href="funcapi.c.html#LN1125"><span class='Ref_To_Local'>proargnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end build_function_result_tupdesc_t &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * build_function_result_tupdesc_d 
 * 
 * Build a RECORD function's tupledesc from the pg_proc proallargtypes, 
 * proargmodes, and proargnames arrays.  This is split out for the 
 * convenience of ProcedureCreate, which needs to be able to compute the 
 * tupledesc before actually creating the function. 
 * 
 * Returns NULL if there are not at least two OUT or INOUT arguments. 
 */ 
</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> 
<a name="LN1168"></a><span class='Declare_Function'>build_function_result_tupdesc_d</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>proallargtypes</span><span class='Delimiter'>, 
</span><a name="LN1169"></a>                                <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>proargmodes</span><span class='Delimiter'>, 
</span><a name="LN1170"></a>                                <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>proargnames</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1172"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>desc</span><span class='Delimiter'>; 
</span><a name="LN1173"></a>    <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arr</span><span class='Delimiter'>; 
</span><a name="LN1174"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numargs</span><span class='Delimiter'>; 
</span><a name="LN1175"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>argtypes</span><span class='Delimiter'>; 
</span><a name="LN1176"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>argmodes</span><span class='Delimiter'>; 
</span><a name="LN1177"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>argnames</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1178"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>outargtypes</span><span class='Delimiter'>; 
</span><a name="LN1179"></a>    <span class='Keyword'>char</span>      <span class='Operator'>**</span><span class='Declare_Local'>outargnames</span><span class='Delimiter'>; 
</span><a name="LN1180"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numoutargs</span><span class='Delimiter'>; 
</span><a name="LN1181"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargnames</span><span class='Delimiter'>; 
</span><a name="LN1182"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Can't have output args if columns are null */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1168"><span class='Ref_to_Parameter'>proallargtypes</span></a> <span class='Operator'>== </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="funcapi.c.html#LN1169"><span class='Ref_to_Parameter'>proargmodes</span></a> <span class='Operator'>== </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We expect the arrays to be 1-D arrays of the right types; verify that. 
     * For the OID and char arrays, we don't need to use deconstruct_array() 
     * since the array data is just going to look like a C array of values. 
     */ 
</span>    <a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1168"><span class='Ref_to_Parameter'>proallargtypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>    <a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>        <a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>        <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN27"><span class='Ref_to_Const'>OIDOID</span></a><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proallargtypes is not a 1-D Oid array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1175"><span class='Ref_To_Local'>argtypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/array.h.html#LN302"><span class='Ref_to_Macro'>ARR_DATA_PTR</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1169"><span class='Ref_to_Parameter'>proargmodes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>        <a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>|| 
</span>        <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN19"><span class='Ref_to_Const'>CHAROID</span></a><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargmodes is not a 1-D char array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1176"><span class='Ref_To_Local'>argmodes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/array.h.html#LN302"><span class='Ref_to_Macro'>ARR_DATA_PTR</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1170"><span class='Ref_to_Parameter'>proargnames</span></a> <span class='Operator'>!= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1170"><span class='Ref_to_Parameter'>proargnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ensure not toasted */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN270"><span class='Ref_to_Macro'>ARR_NDIM</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN274"><span class='Ref_to_Macro'>ARR_DIMS</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN271"><span class='Ref_to_Macro'>ARR_HASNULL</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"proargnames is not a 1-D text array"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1173"><span class='Ref_To_Local'>arr</span></a><span class='Delimiter'>, </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='String'>'i'</span><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="funcapi.c.html#LN1177"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="funcapi.c.html#LN1181"><span class='Ref_To_Local'>nargnames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1181"><span class='Ref_To_Local'>nargnames</span></a> <span class='Operator'>== </span><a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* zero elements probably shouldn't happen, but handle it gracefully */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* extract output-argument types and names */ 
</span>    <a href="funcapi.c.html#LN1178"><span class='Ref_To_Local'>outargtypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1179"><span class='Ref_To_Local'>outargnames</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN1174"><span class='Ref_To_Local'>numargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1232"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>pname</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1176"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5500"><span class='Ref_to_Const'>PROARGMODE_IN</span></a> <span class='Operator'>|| 
</span>            <a href="funcapi.c.html#LN1176"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5503"><span class='Ref_to_Const'>PROARGMODE_VARIADIC</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1176"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5501"><span class='Ref_to_Const'>PROARGMODE_OUT</span></a> <span class='Operator'>|| 
</span>               <a href="funcapi.c.html#LN1176"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5502"><span class='Ref_to_Const'>PROARGMODE_INOUT</span></a> <span class='Operator'>|| 
</span>               <a href="funcapi.c.html#LN1176"><span class='Ref_To_Local'>argmodes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_proc.h.html#LN5504"><span class='Ref_to_Const'>PROARGMODE_TABLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN1178"><span class='Ref_To_Local'>outargtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN1175"><span class='Ref_To_Local'>argtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1177"><span class='Ref_To_Local'>argnames</span></a><span class='Parentheses'>) 
</span>            <a href="funcapi.c.html#LN1232"><span class='Ref_To_Local'>pname</span></a> <span class='Operator'>= </span><a href="../../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1177"><span class='Ref_To_Local'>argnames</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="funcapi.c.html#LN1232"><span class='Ref_To_Local'>pname</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1232"><span class='Ref_To_Local'>pname</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="funcapi.c.html#LN1232"><span class='Ref_To_Local'>pname</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'\0'</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Parameter is not named, so gin up a column name */ 
</span>            <a href="funcapi.c.html#LN1232"><span class='Ref_To_Local'>pname</span></a> <span class='Operator'>= </span><a href="../../../common/psprintf.c.html#LN44"><span class='Ref_to_Func'>psprintf</span></a><span class='Parentheses'>(</span><span class='String'>"column%d"</span><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="funcapi.c.html#LN1179"><span class='Ref_To_Local'>outargnames</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="funcapi.c.html#LN1232"><span class='Ref_To_Local'>pname</span></a><span class='Delimiter'>; 
</span>        <a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numargs;i++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If there is no output argument, or only one, the function does not 
     * return tuples. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a> <span class='Operator'>&LT; </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="funcapi.c.html#LN1172"><span class='Ref_To_Local'>desc</span></a> <span class='Operator'>= </span><a href="../../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN1180"><span class='Ref_To_Local'>numoutargs</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1172"><span class='Ref_To_Local'>desc</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                           <a href="funcapi.c.html#LN1179"><span class='Ref_To_Local'>outargnames</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                           <a href="funcapi.c.html#LN1178"><span class='Ref_To_Local'>outargtypes</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1182"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                           <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                           <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN1172"><span class='Ref_To_Local'>desc</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end build_function_result_tupdesc_d &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * RelationNameGetTupleDesc 
 * 
 * Given a (possibly qualified) relation name, build a TupleDesc. 
 * 
 * Note: while this works as advertised, it's seldom the best way to 
 * build a tupdesc for a function's result type.  It's kept around 
 * only for backwards compatibility with existing user-written code. 
 */ 
</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> 
<a name="LN1285"></a><span class='Declare_Function'>RelationNameGetTupleDesc</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>relname</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1287"></a>    <a href="../../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>relvar</span><span class='Delimiter'>; 
</span><a name="LN1288"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN1289"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN1290"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>relname_list</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Open relation and copy the tuple description */ 
</span>    <a href="funcapi.c.html#LN1290"><span class='Ref_To_Local'>relname_list</span></a> <span class='Operator'>= </span><a href="../../../include/utils/regproc.h.html#LN17"><span class='Ref_to_Proto'>stringToQualifiedNameList</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1285"><span class='Ref_to_Parameter'>relname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1287"><span class='Ref_To_Local'>relvar</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/namespace.h.html#LN119"><span class='Ref_to_Proto'>makeRangeVarFromNameList</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1290"><span class='Ref_To_Local'>relname_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1288"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../../include/access/heapam.h.html#LN86"><span class='Ref_to_Proto'>relation_openrv</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1287"><span class='Ref_To_Local'>relvar</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="funcapi.c.html#LN1289"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../../include/access/tupdesc.h.html#LN88"><span class='Ref_to_Proto'>CreateTupleDescCopy</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1288"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1288"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN1289"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TypeGetTupleDesc 
 * 
 * Given a type Oid, build a TupleDesc.  (In most cases you should be 
 * using get_call_result_type or one of its siblings instead of this 
 * routine, so that you can handle OUT parameters, RECORD result type, 
 * and polymorphic results.) 
 * 
 * If the type is composite, *and* a colaliases List is provided, *and* 
 * the List is of natts length, use the aliases instead of the relation 
 * attnames.  (NB: this usage is deprecated since it may result in 
 * creation of unnecessary transient record types.) 
 * 
 * If the type is a base type, a single item alias List is required. 
 */ 
</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> 
<a name="LN1318"></a><span class='Declare_Function'>TypeGetTupleDesc</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>typeoid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colaliases</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1320"></a>    <a href="../../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> <span class='Declare_Local'>functypclass</span> <span class='Operator'>= </span><a href="funcapi.c.html#LN41"><span class='Ref_to_Proto'>get_type_func_class</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>typeoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1321"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build a suitable tupledesc representing the output rows 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1320"><span class='Ref_To_Local'>functypclass</span></a> <span class='Operator'>== </span><a href="../../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Composite data type, e.g. a table's row type */ 
</span>        <a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/typcache.h.html#LN156"><span class='Ref_to_Proto'>lookup_rowtype_tupdesc_copy</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>typeoid</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>colaliases</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1333"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span> <span class='Operator'>= </span><a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; 
</span><a name="LN1334"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>varattno</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* does the list length match the number of attributes? */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>colaliases</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="funcapi.c.html#LN1333"><span class='Ref_To_Local'>natts</span></a><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"number of aliases does not match number of columns"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* OK, use the aliases instead */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1334"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1334"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>&LT; </span><a href="funcapi.c.html#LN1333"><span class='Ref_To_Local'>natts</span></a><span class='Delimiter'>; </span><a href="funcapi.c.html#LN1334"><span class='Ref_To_Local'>varattno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1345"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>label</span> <span class='Operator'>= </span><a href="../../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>colaliases</span></a><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1334"><span class='Ref_To_Local'>varattno</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1345"><span class='Ref_To_Local'>label</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/builtins.h.html#LN40"><span class='Ref_to_Proto'>namestrcpy</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="funcapi.c.html#LN1334"><span class='Ref_To_Local'>varattno</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="funcapi.c.html#LN1345"><span class='Ref_To_Local'>label</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* The tuple type is now an anonymous record type */ 
</span>            <a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN76"><span class='Ref_to_Member'>tdtypeid</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_type.h.html#LN679"><span class='Ref_to_Const'>RECORDOID</span></a><span class='Delimiter'>; 
</span>            <a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tupdesc.h.html#LN77"><span class='Ref_to_Member'>tdtypmod</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if colaliases!=NIL &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if functypclass==TYPEFUN... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1320"><span class='Ref_To_Local'>functypclass</span></a> <span class='Operator'>== </span><a href="../../../include/funcapi.h.html#LN151"><span class='Ref_to_EnumConst'>TYPEFUNC_SCALAR</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Base data type, i.e. scalar */ 
</span><a name="LN1359"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>attname</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* the alias list is required for base types */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>colaliases</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"no column alias was provided"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* the alias list length must be 1 */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>colaliases</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>              <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"number of aliases does not match number of columns"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* OK, get the column alias */ 
</span>        <a href="funcapi.c.html#LN1359"><span class='Ref_To_Local'>attname</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/value.h.html#LN53"><span class='Ref_to_Macro'>strVal</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>colaliases</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, 
</span>                           <span class='Parentheses'>(</span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                           <a href="funcapi.c.html#LN1359"><span class='Ref_To_Local'>attname</span></a><span class='Delimiter'>, 
</span>                           <a href="funcapi.c.html#LN1318"><span class='Ref_to_Parameter'>typeoid</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                           <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if functypclass==TYPEFUN... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="funcapi.c.html#LN1320"><span class='Ref_To_Local'>functypclass</span></a> <span class='Operator'>== </span><a href="../../../include/funcapi.h.html#LN153"><span class='Ref_to_EnumConst'>TYPEFUNC_RECORD</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* XXX can't support this because typmod wasn't passed in ... */ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not determine row description for function returning record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* crummy error message, but parser should have caught this */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"function in FROM has unsupported return type"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="funcapi.c.html#LN1321"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TypeGetTupleDesc &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>