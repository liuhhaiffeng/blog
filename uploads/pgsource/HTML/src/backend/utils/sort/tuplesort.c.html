<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\utils\sort\tuplesort.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\utils\sort\tuplesort.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:58 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * tuplesort.c 
 *    Generalized tuple sorting routines. 
 * 
 * This module handles sorting of heap tuples, index tuples, or single 
 * Datums (and could easily support other kinds of sortable objects, 
 * if necessary).  It works efficiently for both small and large amounts 
 * of data.  Small amounts are sorted in-memory using qsort().  Large 
 * amounts are sorted using temporary files and a standard external sort 
 * algorithm. 
 * 
 * See Knuth, volume 3, for more than you want to know about the external 
 * sorting algorithm.  Historically, we divided the input into sorted runs 
 * using replacement selection, in the form of a priority tree implemented 
 * as a heap (essentially his Algorithm 5.2.3H), but now we only do that 
 * for the first run, and only if the run would otherwise end up being very 
 * short.  We merge the runs using polyphase merge, Knuth's Algorithm 
 * 5.4.2D.  The logical "tapes" used by Algorithm D are implemented by 
 * logtape.c, which avoids space wastage by recycling disk space as soon 
 * as each block is read from its "tape". 
 * 
 * We do not use Knuth's recommended data structure (Algorithm 5.4.1R) for 
 * the replacement selection, because it uses a fixed number of records 
 * in memory at all times.  Since we are dealing with tuples that may vary 
 * considerably in size, we want to be able to vary the number of records 
 * kept in memory to ensure full utilization of the allowed sort memory 
 * space.  So, we keep the tuples in a variable-size heap, with the next 
 * record to go out at the top of the heap.  Like Algorithm 5.4.1R, each 
 * record is stored with the run number that it must go into, and we use 
 * (run number, key) as the ordering key for the heap.  When the run number 
 * at the top of the heap changes, we know that no more records of the prior 
 * run are left in the heap.  Note that there are in practice only ever two 
 * distinct run numbers, because since PostgreSQL 9.6, we only use 
 * replacement selection to form the first run. 
 * 
 * In PostgreSQL 9.6, a heap (based on Knuth's Algorithm H, with some small 
 * customizations) is only used with the aim of producing just one run, 
 * thereby avoiding all merging.  Only the first run can use replacement 
 * selection, which is why there are now only two possible valid run 
 * numbers, and why heapification is customized to not distinguish between 
 * tuples in the second run (those will be quicksorted).  We generally 
 * prefer a simple hybrid sort-merge strategy, where runs are sorted in much 
 * the same way as the entire input of an internal sort is sorted (using 
 * qsort()).  The replacement_sort_tuples GUC controls the limited remaining 
 * use of replacement selection for the first run. 
 * 
 * There are several reasons to favor a hybrid sort-merge strategy. 
 * Maintaining a priority tree/heap has poor CPU cache characteristics. 
 * Furthermore, the growth in main memory sizes has greatly diminished the 
 * value of having runs that are larger than available memory, even in the 
 * case where there is partially sorted input and runs can be made far 
 * larger by using a heap.  In most cases, a single-pass merge step is all 
 * that is required even when runs are no larger than available memory. 
 * Avoiding multiple merge passes was traditionally considered to be the 
 * major advantage of using replacement selection. 
 * 
 * The approximate amount of memory allowed for any one sort operation 
 * is specified in kilobytes by the caller (most pass work_mem).  Initially, 
 * we absorb tuples and simply store them in an unsorted array as long as 
 * we haven't exceeded workMem.  If we reach the end of the input without 
 * exceeding workMem, we sort the array using qsort() and subsequently return 
 * tuples just by scanning the tuple array sequentially.  If we do exceed 
 * workMem, we begin to emit tuples into sorted runs in temporary tapes. 
 * When tuples are dumped in batch after quicksorting, we begin a new run 
 * with a new output tape (selected per Algorithm D).  After the end of the 
 * input is reached, we dump out remaining tuples in memory into a final run 
 * (or two, when replacement selection is still used), then merge the runs 
 * using Algorithm D. 
 * 
 * When merging runs, we use a heap containing just the frontmost tuple from 
 * each source run; we repeatedly output the smallest tuple and replace it 
 * with the next tuple from its source tape (if any).  When the heap empties, 
 * the merge is complete.  The basic merge algorithm thus needs very little 
 * memory --- only M tuples for an M-way merge, and M is constrained to a 
 * small number.  However, we can still make good use of our full workMem 
 * allocation by pre-reading additional blocks from each source tape.  Without 
 * prereading, our access pattern to the temporary file would be very erratic; 
 * on average we'd read one block from each of M source tapes during the same 
 * time that we're writing M blocks to the output tape, so there is no 
 * sequentiality of access at all, defeating the read-ahead methods used by 
 * most Unix kernels.  Worse, the output tape gets written into a very random 
 * sequence of blocks of the temp file, ensuring that things will be even 
 * worse when it comes time to read that tape.  A straightforward merge pass 
 * thus ends up doing a lot of waiting for disk seeks.  We can improve matters 
 * by prereading from each source tape sequentially, loading about workMem/M 
 * bytes from each tape in turn, and making the sequential blocks immediately 
 * available for reuse.  This approach helps to localize both read and write 
 * accesses.  The pre-reading is handled by logtape.c, we just tell it how 
 * much memory to use for the buffers. 
 * 
 * When the caller requests random access to the sort result, we form 
 * the final sorted run on a logical tape which is then "frozen", so 
 * that we can access it randomly.  When the caller does not need random 
 * access, we return from tuplesort_performsort() as soon as we are down 
 * to one run per logical tape.  The final merge is then performed 
 * on-the-fly as the caller repeatedly calls tuplesort_getXXX; this 
 * saves one cycle of writing all the data out to disk and reading it in. 
 * 
 * Before Postgres 8.2, we always used a seven-tape polyphase merge, on the 
 * grounds that 7 is the "sweet spot" on the tapes-to-passes curve according 
 * to Knuth's figure 70 (section 5.4.2).  However, Knuth is assuming that 
 * tape drives are expensive beasts, and in particular that there will always 
 * be many more runs than tape drives.  In our implementation a "tape drive" 
 * doesn't cost much more than a few Kb of memory buffers, so we can afford 
 * to have lots of them.  In particular, if we can have as many tape drives 
 * as sorted runs, we can eliminate any repeated I/O at all.  In the current 
 * code we determine the number of tapes M on the basis of workMem: we want 
 * workMem/M to be large enough that we read a fair amount of data each time 
 * we preread from a tape, so as to maintain the locality of access described 
 * above.  Nonetheless, with large workMem we can have many tapes (but not 
 * too many -- see the comments in tuplesort_merge_order). 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/utils/sort/tuplesort.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;limits.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/nbtree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/hash.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/index.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_am.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/tablespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pg_trace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/datum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/logtape.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/pg_rusage.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/sortsupport.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tuplesort.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* sort-type codes for sort__start probes */ 
</span><a name="LN147"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HEAP_SORT</span>       <span class='Number'>0</span> 
<a name="LN148"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>INDEX_SORT</span>      <span class='Number'>1</span> 
<a name="LN149"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>DATUM_SORT</span>      <span class='Number'>2</span> 
<a name="LN150"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CLUSTER_SORT</span>    <span class='Number'>3</span> 
 
<span class='Comment_Multi_Line'>/* GUC variables */ 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
<a name="LN154"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>trace_sort</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#ifdef</span> DEBUG_BOUNDED_SORT 
<a name="LN158"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>optimize_bounded_sort</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * The objects we actually sort are SortTuple structs.  These contain 
 * a pointer to the tuple proper (might be a MinimalTuple or IndexTuple), 
 * which is a separate palloc chunk --- we assume it is just one chunk and 
 * can be freed by a simple pfree() (except during merge, when we use a 
 * simple slab allocator).  SortTuples also contain the tuple's first key 
 * column in Datum/nullflag format, and an index integer. 
 * 
 * Storing the first key column lets us save heap_getattr or index_getattr 
 * calls during tuple comparisons.  We could extract and save all the key 
 * columns not just the first, but this would increase code complexity and 
 * overhead, and wouldn't actually save any comparison cycles in the common 
 * case where the first key determines the comparison result.  Note that 
 * for a pass-by-reference datatype, datum1 points into the "tuple" storage. 
 * 
 * There is one special case: when the sort support infrastructure provides an 
 * "abbreviated key" representation, where the key is (typically) a pass by 
 * value proxy for a pass by reference type.  In this case, the abbreviated key 
 * is stored in datum1 in place of the actual first key column. 
 * 
 * When sorting single Datums, the data value is represented directly by 
 * datum1/isnull1 for pass by value types (or null values).  If the datatype is 
 * pass-by-reference and isnull1 is false, then "tuple" points to a separately 
 * palloc'd data value, otherwise "tuple" is NULL.  The value of datum1 is then 
 * either the same pointer as "tuple", or is an abbreviated key value as 
 * described above.  Accordingly, "tuple" is always used in preference to 
 * datum1 as the authoritative value for pass-by-reference cases. 
 * 
 * While building initial runs, tupindex holds the tuple's run number. 
 * Historically, the run number could meaningfully distinguish many runs, but 
 * it now only distinguishes RUN_FIRST and HEAP_RUN_NEXT, since replacement 
 * selection is always abandoned after the first run; no other run number 
 * should be represented here.  During merge passes, we re-use it to hold the 
 * input tape number that each tuple in the heap was read from.  tupindex goes 
 * unused if the sort occurs entirely in memory. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN200"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>tuple</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the tuple itself */ 
</span><a name="LN201"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>datum1</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* value of first key column */ 
</span><a name="LN202"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isnull1</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* is first key column NULL? */ 
</span><a name="LN203"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tupindex</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* see notes above */ 
</span><a name="LN204"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SortTuple</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * During merge, we use a pre-allocated set of fixed-size slots to hold 
 * tuples.  To avoid palloc/pfree overhead. 
 * 
 * Merge doesn't require a lot of memory, so we can afford to waste some, 
 * by using gratuitously-sized slots.  If a tuple is larger than 1 kB, the 
 * palloc() overhead is not significant anymore. 
 * 
 * 'nextfree' is valid when this chunk is in the free list.  When in use, the 
 * slot holds a tuple. 
 */ 
</span><a name="LN217"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SLAB_SLOT_SIZE</span> <span class='Number'>1024</span> 
 
<a name="LN219"></a><span class='Control'>typedef</span> <span class='Control'>union</span> <span class='Declare_Union'>SlabSlot</span> 
<span class='Delimiter'>{ 
</span><a name="LN221"></a>    <span class='Control'>union</span> <a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>nextfree</span><span class='Delimiter'>; 
</span><a name="LN222"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>buffer</span><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN217"><span class='Ref_to_Const'>SLAB_SLOT_SIZE</span></a><span class='Delimiter'>]; 
</span><a name="LN223"></a>} <span class='Declare_Typedef'>SlabSlot</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Possible states of a Tuplesort object.  These denote the states that 
 * persist between calls of Tuplesort routines. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN231"></a>    <span class='Declare_Enum_Const'>TSS_INITIAL</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* Loading tuples; still within memory limit */ 
</span><a name="LN232"></a>    <span class='Declare_Enum_Const'>TSS_BOUNDED</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* Loading tuples into bounded-size heap */ 
</span><a name="LN233"></a>    <span class='Declare_Enum_Const'>TSS_BUILDRUNS</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* Loading tuples; writing to tape */ 
</span><a name="LN234"></a>    <span class='Declare_Enum_Const'>TSS_SORTEDINMEM</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* Sort completed entirely in memory */ 
</span><a name="LN235"></a>    <span class='Declare_Enum_Const'>TSS_SORTEDONTAPE</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* Sort completed, final run is on tape */ 
</span><a name="LN236"></a>    <span class='Declare_Enum_Const'>TSS_FINALMERGE</span>              <span class='Comment_Single_Line'>/* Performing final merge on-the-fly */ 
</span><a name="LN237"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TupSortStatus</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Parameters for calculation of number of tapes to use --- see inittapes() 
 * and tuplesort_merge_order(). 
 * 
 * In this calculation we assume that each tape will cost us about 1 blocks 
 * worth of buffer space.  This ignores the overhead of all the other data 
 * structures needed for each tape, but it's probably close enough. 
 * 
 * MERGE_BUFFER_SIZE is how much data we'd like to read from each input 
 * tape during a preread cycle (see discussion at top of file). 
 */ 
</span><a name="LN250"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MINORDER</span>        <span class='Number'>6</span>       <span class='Comment_Single_Line'>/* minimum merge order */ 
</span><a name="LN251"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MAXORDER</span>        <span class='Number'>500</span>     <span class='Comment_Single_Line'>/* maximum merge order */ 
</span><a name="LN252"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>TAPE_BUFFER_OVERHEAD</span>        BLCKSZ 
<a name="LN253"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MERGE_BUFFER_SIZE</span>           <span class='Parentheses'>(</span>BLCKSZ <span class='Operator'>* </span><span class='Number'>32</span><span class='Parentheses'>) 
</span> 
 <span class='Comment_Multi_Line'>/* 
  * Run numbers, used during external sort operations. 
  * 
  * HEAP_RUN_NEXT is only used for SortTuple.tupindex, never state.currentRun. 
  */ 
</span><a name="LN260"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RUN_FIRST</span>       <span class='Number'>0</span> 
<a name="LN261"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HEAP_RUN_NEXT</span>   INT_MAX 
<a name="LN262"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RUN_SECOND</span>      <span class='Number'>1</span> 
 
<a name="LN264"></a><span class='Control'>typedef</span> <span class='Keyword'>int </span><span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Typedef'>SortTupleComparator</span><span class='Parentheses'>) (</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span>a<span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span>b<span class='Delimiter'>, 
</span>                                                <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Private state of a Tuplesort operation. 
 */ 
</span><a name="LN270"></a><span class='Control'>struct</span> <span class='Declare_Struct'>Tuplesortstate</span> 
<span class='Delimiter'>{ 
</span><a name="LN272"></a>    <a href="tuplesort.c.html#LN229"><span class='Ref_to_Typedef'>TupSortStatus</span></a> <span class='Declare_Member'>status</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* enumerated value as shown above */ 
</span><a name="LN273"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nKeys</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* number of columns in sort key */ 
</span><a name="LN274"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>randomAccess</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* did caller request random access? */ 
</span><a name="LN275"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>bounded</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* did caller specify a maximum number of 
                                 * tuples to return? */ 
</span><a name="LN277"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>boundUsed</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* true if we made use of a bounded heap */ 
</span><a name="LN278"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>bound</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* if bounded, the maximum number of tuples */ 
</span><a name="LN279"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>tuples</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Can SortTuple.tuple ever be set? */ 
</span><a name="LN280"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>availMem</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* remaining memory available, in bytes */ 
</span><a name="LN281"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>allowedMem</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* total memory allowed, in bytes */ 
</span><a name="LN282"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>maxTapes</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* number of tapes (Knuth's T) */ 
</span><a name="LN283"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tapeRange</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* maxTapes-1 (Knuth's P) */ 
</span><a name="LN284"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>sortcontext</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* memory context holding most sort data */ 
</span><a name="LN285"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tuplecontext</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* sub-context of sortcontext for tuple data */ 
</span><a name="LN286"></a>    <a href="logtape.c.html#LN151"><span class='Ref_to_Struct'>LogicalTapeSet</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tapeset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* logtape.c object for tapes in a temp file */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These function pointers decouple the routines that must know what kind 
     * of tuple we are sorting from the routines that don't need to know it. 
     * They are set up by the tuplesort_begin_xxx routines. 
     * 
     * Function to compare two tuples; result is per qsort() convention, ie: 
     * &LT;0, 0, &GT;0 according as a&LT;b, a=b, a&GT;b.  The API must match 
     * qsort_arg_comparator. 
     */ 
</span><a name="LN297"></a>    <a href="tuplesort.c.html#LN264"><span class='Ref_to_Typedef'>SortTupleComparator</span></a> <span class='Declare_Member'>comparetup</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Function to copy a supplied input tuple into palloc'd space and set up 
     * its SortTuple representation (ie, set tuple/datum1/isnull1).  Also, 
     * state-&GT;availMem must be decreased by the amount of space used for the 
     * tuple copy (note the SortTuple struct itself is not counted). 
     */ 
</span><a name="LN305"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>copytup</span><span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span>stup<span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span>tup<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Function to write a stored tuple onto tape.  The representation of the 
     * tuple on tape need not be the same as it is in memory; requirements on 
     * the tape representation are given below.  Unless the slab allocator is 
     * used, after writing the tuple, pfree() the out-of-line data (not the 
     * SortTuple struct!), and increase state-&GT;availMem by the amount of 
     * memory space thereby released. 
     */ 
</span><a name="LN315"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>writetup</span><span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Delimiter'>, </span><span class='Keyword'>int </span>tapenum<span class='Delimiter'>, 
</span>                                         <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span>stup<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Function to read a stored tuple from tape back into memory. 'len' is 
     * the already-read length of the stored tuple.  The tuple is allocated 
     * from the slab memory arena, or is palloc'd, see readtup_alloc(). 
     */ 
</span><a name="LN323"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>readtup</span><span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span>stup<span class='Delimiter'>, 
</span>                                        <span class='Keyword'>int </span>tapenum<span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><a href="../../replication/repl_scanner.l.html#LN155"><span class='Ref_to_Global_Var'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This array holds the tuples now in sort memory.  If we are in state 
     * INITIAL, the tuples are in no particular order; if we are in state 
     * SORTEDINMEM, the tuples are in final sorted order; in states BUILDRUNS 
     * and FINALMERGE, the tuples are organized in "heap" order per Algorithm 
     * H.  In state SORTEDONTAPE, the array is not used. 
     */ 
</span><a name="LN333"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>memtuples</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* array of SortTuple structs */ 
</span><a name="LN334"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>memtupcount</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of tuples currently present */ 
</span><a name="LN335"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>memtupsize</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* allocated length of memtuples array */ 
</span><a name="LN336"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>growmemtuples</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* memtuples' growth still underway? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Memory for tuples is sometimes allocated using a simple slab allocator, 
     * rather than with palloc().  Currently, we switch to slab allocation 
     * when we start merging.  Merging only needs to keep a small, fixed 
     * number of tuples in memory at any time, so we can avoid the 
     * palloc/pfree overhead by recycling a fixed number of fixed-size slots 
     * to hold the tuples. 
     * 
     * For the slab, we use one large allocation, divided into SLAB_SLOT_SIZE 
     * slots.  The allocation is sized to have one slot per tape, plus one 
     * additional slot.  We need that many slots to hold all the tuples kept 
     * in the heap during merge, plus the one we have last returned from the 
     * sort, with tuplesort_gettuple. 
     * 
     * Initially, all the slots are kept in a linked list of free slots.  When 
     * a tuple is read from a tape, it is put to the next available slot, if 
     * it fits.  If the tuple is larger than SLAB_SLOT_SIZE, it is palloc'd 
     * instead. 
     * 
     * When we're done processing a tuple, we return the slot back to the free 
     * list, or pfree() if it was palloc'd.  We know that a tuple was 
     * allocated from the slab, if its pointer value is between 
     * slabMemoryBegin and -End. 
     * 
     * When the slab allocator is used, the USEMEM/LACKMEM mechanism of 
     * tracking memory usage is not used. 
     */ 
</span><a name="LN365"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>slabAllocatorUsed</span><span class='Delimiter'>; 
</span> 
<a name="LN367"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>slabMemoryBegin</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* beginning of slab memory arena */ 
</span><a name="LN368"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>slabMemoryEnd</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* end of slab memory arena */ 
</span><a name="LN369"></a>    <a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>slabFreeHead</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* head of free list */ 
</span> 
    <span class='Comment_Multi_Line'>/* Buffer size to use for reading input tapes, during merge. */ 
</span><a name="LN372"></a>    size_t      <span class='Declare_Member'>read_buffer_size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When we return a tuple to the caller in tuplesort_gettuple_XXX, that 
     * came from a tape (that is, in TSS_SORTEDONTAPE or TSS_FINALMERGE 
     * modes), we remember the tuple in 'lastReturnedTuple', so that we can 
     * recycle the memory on next gettuple call. 
     */ 
</span><a name="LN380"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>lastReturnedTuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * While building initial runs, this indicates if the replacement 
     * selection strategy is in use.  When it isn't, then a simple hybrid 
     * sort-merge strategy is in use instead (runs are quicksorted). 
     */ 
</span><a name="LN387"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>replaceActive</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * While building initial runs, this is the current output run number 
     * (starting at RUN_FIRST).  Afterwards, it is the number of initial runs 
     * we made. 
     */ 
</span><a name="LN394"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>currentRun</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Unless otherwise noted, all pointer variables below are pointers to 
     * arrays of length maxTapes, holding per-tape data. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This variable is only used during merge passes.  mergeactive[i] is true 
     * if we are reading an input run from (actual) tape number i and have not 
     * yet exhausted that run. 
     */ 
</span><a name="LN406"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>mergeactive</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* active input run source? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Variables for Algorithm D.  Note that destTape is a "logical" tape 
     * number, ie, an index into the tp_xxx[] arrays.  Be careful to keep 
     * "logical" and "actual" tape numbers straight! 
     */ 
</span><a name="LN413"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>Level</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* Knuth's l */ 
</span><a name="LN414"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>destTape</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* current output tape (Knuth's j, less 1) */ 
</span><a name="LN415"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>tp_fib</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Target Fibonacci run counts (A[]) */ 
</span><a name="LN416"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>tp_runs</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* # of real runs on each tape */ 
</span><a name="LN417"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>tp_dummy</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* # of dummy runs for each tape (D[]) */ 
</span><a name="LN418"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>tp_tapenum</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* Actual tape numbers (TAPE[]) */ 
</span><a name="LN419"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>activeTapes</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* # of active input tapes in merge pass */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These variables are used after completion of sorting to keep track of 
     * the next tuple to return.  (In the tape case, the tape's current read 
     * position is also critical state.) 
     */ 
</span><a name="LN426"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>result_tape</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* actual tape number of finished output */ 
</span><a name="LN427"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>current</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* array index (only used if SORTEDINMEM) */ 
</span><a name="LN428"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>eof_reached</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* reached EOF (needed for cursors) */ 
</span> 
    <span class='Comment_Multi_Line'>/* markpos_xxx holds marked position for mark and restore */ 
</span><a name="LN431"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>markpos_block</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* tape block# (only used if SORTEDONTAPE) */ 
</span><a name="LN432"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>markpos_offset</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* saved "current", or offset in tape block */ 
</span><a name="LN433"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>markpos_eof</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* saved "eof_reached" */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The sortKeys variable is used by every case other than the hash index 
     * case; it is set by tuplesort_begin_xxx.  tupDesc is only used by the 
     * MinimalTuple and CLUSTER routines, though. 
     */ 
</span><a name="LN440"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>tupDesc</span><span class='Delimiter'>; 
</span><a name="LN441"></a>    <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Member'>sortKeys</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* array of length nKeys */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This variable is shared by the single-key MinimalTuple case and the 
     * Datum case (which both use qsort_ssup()).  Otherwise it's NULL. 
     */ 
</span><a name="LN447"></a>    <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Member'>onlyKey</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Additional state for managing "abbreviated key" sortsupport routines 
     * (which currently may be used by all cases except the hash index case). 
     * Tracks the intervals at which the optimization's effectiveness is 
     * tested. 
     */ 
</span><a name="LN455"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>abbrevNext</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* Tuple # at which to next check 
                                 * applicability */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These variables are specific to the CLUSTER case; they are set by 
     * tuplesort_begin_cluster. 
     */ 
</span><a name="LN462"></a>    <a href="../../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>indexInfo</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* info about index being used for reference */ 
</span><a name="LN463"></a>    <a href="../../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>estate</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* for evaluating index expressions */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These variables are specific to the IndexTuple case; they are set by 
     * tuplesort_begin_index_xxx and used only by the IndexTuple routines. 
     */ 
</span><a name="LN469"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>heapRel</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* table the index is being built on */ 
</span><a name="LN470"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>indexRel</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* index being built */ 
</span> 
    <span class='Comment_Multi_Line'>/* These are specific to the index_btree subcase: */ 
</span><a name="LN473"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>enforceUnique</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* complain if we find duplicate tuples */ 
</span> 
    <span class='Comment_Multi_Line'>/* These are specific to the index_hash subcase: */ 
</span><a name="LN476"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>high_mask</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* masks for sortable part of hash code */ 
</span><a name="LN477"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>low_mask</span><span class='Delimiter'>; 
</span><a name="LN478"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>max_buckets</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These variables are specific to the Datum case; they are set by 
     * tuplesort_begin_datum and used only by the DatumTuple routines. 
     */ 
</span><a name="LN484"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>datumType</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* we need typelen in order to know how to copy the Datums. */ 
</span><a name="LN486"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>datumTypeLen</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Resource snapshot for time of sort start. 
     */ 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
<a name="LN492"></a>    <a href="../../../include/utils/pg_rusage.h.html#LN26"><span class='Ref_to_Struct'>PGRUsage</span></a>    <span class='Declare_Member'>ru_start</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end Tuplesortstate &raquo; </span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Is the given tuple allocated from the slab memory arena? 
 */ 
</span><a name="LN499"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_SLAB_SLOT</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>tuple</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN499"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN499"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>slabMemoryBegin <span class='Operator'>&& \ 
</span>     <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN499"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN499"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>slabMemoryEnd<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the given tuple to the slab memory free list, or free it 
 * if it was palloc'd. 
 */ 
</span><a name="LN507"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>RELEASE_SLAB_SLOT</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>tuple</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a> <span class='Operator'>*</span><a href="../../../bin/pg_test_fsync/pg_test_fsync.c.html#LN66"><span class='Ref_to_Global_Var'>buf</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN507"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Operator'>\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN499"><span class='Ref_to_Macro'>IS_SLAB_SLOT</span></a><span class='Parentheses'>((</span><a href="tuplesort.c.html#LN507"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../bin/pg_test_fsync/pg_test_fsync.c.html#LN66"><span class='Ref_to_Global_Var'>buf</span></a><span class='Parentheses'>))</span> <span class='Operator'>\ 
</span>        <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>            <a href="../../../bin/pg_test_fsync/pg_test_fsync.c.html#LN66"><span class='Ref_to_Global_Var'>buf</span></a><span class='Operator'>-&GT;</span>nextfree <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN507"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>slabFreeHead<span class='Delimiter'>; </span><span class='Operator'>\ 
</span>            <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN507"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>slabFreeHead <span class='Operator'>= </span><a href="../../../bin/pg_test_fsync/pg_test_fsync.c.html#LN66"><span class='Ref_to_Global_Var'>buf</span></a><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Delimiter'>} </span><span class='Control'>else</span> <span class='Operator'>\ 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_test_fsync/pg_test_fsync.c.html#LN66"><span class='Ref_to_Global_Var'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<a name="LN519"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>COMPARETUP</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>b</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN519"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>comparetup<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN519"><span class='Ref_to_Parameter'>a</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN519"><span class='Ref_to_Parameter'>b</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN519"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
<a name="LN520"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>COPYTUP</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) ((</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN520"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>copytup<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN520"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN520"><span class='Ref_to_Parameter'>stup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN520"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>))</span> 
<a name="LN521"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>WRITETUP</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>tape</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN521"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>writetup<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN521"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN521"><span class='Ref_to_Parameter'>tape</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN521"><span class='Ref_to_Parameter'>stup</span></a><span class='Parentheses'>))</span> 
<a name="LN522"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>READTUP</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>tape</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) ((</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN522"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>readtup<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN522"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN522"><span class='Ref_to_Parameter'>stup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN522"><span class='Ref_to_Parameter'>tape</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN522"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>))</span> 
<a name="LN523"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LACKMEM</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span>      <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN523"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>availMem <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>&& !</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN523"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>slabAllocatorUsed<span class='Parentheses'>)</span> 
<a name="LN524"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>USEMEM</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>amt</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN524"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>availMem <span class='Operator'>-= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN524"><span class='Ref_to_Parameter'>amt</span></a><span class='Parentheses'>))</span> 
<a name="LN525"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>FREEMEM</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>amt</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN525"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>availMem <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN525"><span class='Ref_to_Parameter'>amt</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * NOTES about on-tape representation of tuples: 
 * 
 * We require the first "unsigned int" of a stored tuple to be the total size 
 * on-tape of the tuple, including itself (so it is never zero; an all-zero 
 * unsigned int is used to delimit runs).  The remainder of the stored tuple 
 * may or may not match the in-memory representation of the tuple --- 
 * any conversion needed is the job of the writetup and readtup routines. 
 * 
 * If state-&GT;randomAccess is true, then the stored representation of the 
 * tuple must be followed by another "unsigned int" that is a copy of the 
 * length --- so the total tape space used is actually sizeof(unsigned int) 
 * more than the stored length value.  This allows read-backwards.  When 
 * randomAccess is not true, the write/read routines may omit the extra 
 * length word. 
 * 
 * writetup is expected to write both length words as well as the tuple 
 * data.  When readtup is called, the tape is positioned just after the 
 * front length word; readtup must read the tuple data and advance past 
 * the back length word (if present). 
 * 
 * The write/read routines can make use of the tuple description data 
 * stored in the Tuplesortstate record, if needed.  They are also expected 
 * to adjust state-&GT;availMem by the amount of memory space (not tape space!) 
 * released or consumed.  There is no error return from either writetup 
 * or readtup; they should ereport() on failure. 
 * 
 * 
 * NOTES about memory consumption calculations: 
 * 
 * We count space allocated for tuples against the workMem limit, plus 
 * the space used by the variable-size memtuples array.  Fixed-size space 
 * is not counted; it's small enough to not be interesting. 
 * 
 * Note that we count actual space used (as shown by GetMemoryChunkSpace) 
 * rather than the originally-requested size.  This is important since 
 * palloc can add substantial overhead.  It's not a complete answer since 
 * we won't count any wasted space in palloc allocation blocks, but it's 
 * a lot better than what we were doing before 7.3.  As of 9.6, a 
 * separate memory context is used for caller passed tuples.  Resetting 
 * it at certain key increments significantly ameliorates fragmentation. 
 * Note that this places a responsibility on readtup and copytup routines 
 * to use the right memory context for these tuples (and to not use the 
 * reset context for anything whose lifetime needs to span multiple 
 * external sort runs). 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* When using this macro, beware of double evaluation of len */ 
</span><a name="LN575"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LogicalTapeReadExact</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>tapeset</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>ptr</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/logtape.h.html#LN29"><span class='Ref_to_Proto'>LogicalTapeRead</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN575"><span class='Ref_to_Parameter'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN575"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN575"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN575"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Parentheses'>(</span>size_t<span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN575"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>))</span> <span class='Operator'>\ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected end of data"</span><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
 
<a name="LN582"></a><span class='Keyword'>static </span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>tuplesort_begin_common</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>workMem</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN583"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>puttuple_common</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN584"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>consider_abort_common</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN585"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>useselection</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN586"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>inittapes</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN587"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>selectnewtape</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN588"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>init_slab_allocator</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numSlots</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN589"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>mergeruns</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN590"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>mergeonerun</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN591"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>beginmerge</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN592"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>mergereadnext</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>srcTape</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN593"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>dumptuples</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>alltuples</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN594"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>dumpbatch</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>alltuples</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN595"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>make_bounded_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN596"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>sort_bounded_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN597"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>tuplesort_sort_memtuples</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN598"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>tuplesort_heap_insert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN599"></a>                      <span class='Keyword'>bool </span><span class='Declare_Parameter'>checkIndex</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN600"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>tuplesort_heap_replace_top</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN601"></a>                           <span class='Keyword'>bool </span><span class='Declare_Parameter'>checkIndex</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN602"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>tuplesort_heap_delete_top</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>checkIndex</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN603"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>reversedirection</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN604"></a><span class='Keyword'>static unsigned int </span><span class='Declare_Prototype'>getlen</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>eofOK</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN605"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>markrunend</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN606"></a><span class='Keyword'>static void </span><span class='Operator'>*</span><span class='Declare_Prototype'>readtup_alloc</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>tuplen</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN607"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>comparetup_heap</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN608"></a>                <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN609"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>copytup_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN610"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>writetup_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, 
</span><a name="LN611"></a>              <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN612"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>readtup_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN613"></a>             <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN614"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>comparetup_cluster</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN615"></a>                   <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN616"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>copytup_cluster</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN617"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>writetup_cluster</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, 
</span><a name="LN618"></a>                 <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN619"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>readtup_cluster</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN620"></a>                <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN621"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>comparetup_index_btree</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN622"></a>                       <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN623"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>comparetup_index_hash</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN624"></a>                      <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN625"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>copytup_index</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN626"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>writetup_index</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, 
</span><a name="LN627"></a>               <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN628"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>readtup_index</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN629"></a>              <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN630"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>comparetup_datum</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN631"></a>                 <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN632"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>copytup_datum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN633"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>writetup_datum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, 
</span><a name="LN634"></a>               <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN635"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>readtup_datum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN636"></a>              <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN637"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>free_sort_tuple</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Special versions of qsort just for SortTuple objects.  qsort_tuple() sorts 
 * any variant of SortTuples, using the appropriate comparetup function. 
 * qsort_ssup() is specialized for the case where the comparetup function 
 * reduces to ApplySortComparator(), that is single-key MinimalTuple sorts 
 * and Datum sorts. 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"qsort_tuple.c"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *      tuplesort_begin_xxx 
 * 
 * Initialize for a tuple sort operation. 
 * 
 * After calling tuplesort_begin, the caller should call tuplesort_putXXX 
 * zero or more times, then call tuplesort_performsort when all the tuples 
 * have been supplied.  After performsort, retrieve the tuples in sorted 
 * order by calling tuplesort_getXXX until it returns false/NULL.  (If random 
 * access was requested, rescan, markpos, and restorepos can also be called.) 
 * Call tuplesort_end to terminate the operation and release memory/disk space. 
 * 
 * Each variant of tuplesort_begin has a workMem parameter specifying the 
 * maximum number of kilobytes of RAM to use before spilling data to disk. 
 * (The normal value of this parameter is work_mem, but some callers use 
 * other values.)  Each variant also has a randomAccess parameter specifying 
 * whether the caller needs non-sequential access to the sort result. 
 */ 
</span> 
<span class='Keyword'>static </span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>* 
</span><a name="LN669"></a><span class='Declare_Function'>tuplesort_begin_common</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>workMem</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN671"></a>    <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN672"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>sortcontext</span><span class='Delimiter'>; 
</span><a name="LN673"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>tuplecontext</span><span class='Delimiter'>; 
</span><a name="LN674"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create a working memory context for this sort operation. All data 
     * needed by the sort will live inside this context. 
     */ 
</span>    <a href="tuplesort.c.html#LN672"><span class='Ref_To_Local'>sortcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                                        <span class='String'>"TupleSort main"</span><span class='Delimiter'>, 
</span>                                        <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Caller tuple (e.g. IndexTuple) memory context. 
     * 
     * A dedicated child context used exclusively for caller passed tuples 
     * eases memory management.  Resetting at key points reduces 
     * fragmentation. Note that the memtuples array of SortTuples is allocated 
     * in the parent context, not this context, because there is no need to 
     * free memtuples early. 
     */ 
</span>    <a href="tuplesort.c.html#LN673"><span class='Ref_To_Local'>tuplecontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN672"><span class='Ref_To_Local'>sortcontext</span></a><span class='Delimiter'>, 
</span>                                         <span class='String'>"Caller tuples"</span><span class='Delimiter'>, 
</span>                                         <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make the Tuplesortstate within the per-sort context.  This way, we 
     * don't need a separate pfree() operation for it at shutdown. 
     */ 
</span>    <a href="tuplesort.c.html#LN674"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN672"><span class='Ref_To_Local'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../misc/pg_rusage.c.html#LN25"><span class='Ref_to_Func'>pg_rusage_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN231"><span class='Ref_to_EnumConst'>TSS_INITIAL</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN669"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN279"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN277"><span class='Ref_to_Member'>boundUsed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN669"><span class='Ref_to_Parameter'>workMem</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) </span><span class='Number'>1024</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN672"><span class='Ref_To_Local'>sortcontext</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN673"><span class='Ref_To_Local'>tuplecontext</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD; 
     * see comments in grow_memtuples(). 
     */ 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><span class='Number'>1024</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/utils/memutils.h.html#LN191"><span class='Ref_to_Const'>ALLOCSET_SEPARATE_THRESHOLD</span></a> <span class='Operator'>/ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN336"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* workMem must be large enough for the minimal memtuples array */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Macro'>LACKMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"insufficient memory allowed for sort"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * maxTapes, tapeRange, and Algorithm D variables will be initialized by 
     * inittapes(), if needed 
     */ 
</span> 
    <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* flag that result tape has not been formed */ 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN674"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN671"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_begin_common &raquo; </span> 
 
<a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>* 
</span><a name="LN755"></a><span class='Declare_Function'>tuplesort_begin_heap</span><span class='Parentheses'>(</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupDesc</span><span class='Delimiter'>, 
</span><a name="LN756"></a>                     <span class='Keyword'>int </span><span class='Declare_Parameter'>nkeys</span><span class='Delimiter'>, </span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>attNums</span><span class='Delimiter'>, 
</span><a name="LN757"></a>                     <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortOperators</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sortCollations</span><span class='Delimiter'>, 
</span><a name="LN758"></a>                     <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>nullsFirstFlags</span><span class='Delimiter'>, 
</span><a name="LN759"></a>                     <span class='Keyword'>int </span><span class='Declare_Parameter'>workMem</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN761"></a>    <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN582"><span class='Ref_to_Proto'>tuplesort_begin_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN759"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN759"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN762"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN763"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN762"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN676"><span class='Ref_to_Macro'>AssertArg</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>nkeys</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>             <span class='String'>"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>nkeys</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN759"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN759"><span class='Ref_to_Parameter'>randomAccess</span></a> <span class='Operator'>? </span><span class='String'>'t'</span> <span class='Operator'>: </span><span class='String'>'f'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>nkeys</span></a><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_SORT_START<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN147"><span class='Ref_to_Const'>HEAP_SORT</span></a><span class='Delimiter'>, 
</span>                                <span class='Boolean'>false</span><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no unique check */ 
</span>                                <a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>nkeys</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN759"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN759"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN297"><span class='Ref_to_Member'>comparetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN607"><span class='Ref_to_Proto'>comparetup_heap</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN305"><span class='Ref_to_Member'>copytup</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN241"><span class='Ref_to_Proto'>copytup_heap</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN315"><span class='Ref_to_Member'>writetup</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN242"><span class='Ref_to_Proto'>writetup_heap</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN323"><span class='Ref_to_Member'>readtup</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN243"><span class='Ref_to_Proto'>readtup_heap</span></a><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN755"><span class='Ref_to_Parameter'>tupDesc</span></a><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* assume we need not copy tupDesc */ 
</span>    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN455"><span class='Ref_to_Member'>abbrevNext</span></a> <span class='Operator'>= </span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare SortSupport data for each column */ 
</span>    <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>nkeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN59"><span class='Ref_to_Struct'>SortSupportData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>nkeys</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN797"></a>        <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>sortKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/c.h.html#LN676"><span class='Ref_to_Macro'>AssertArg</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>attNums</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/c.h.html#LN676"><span class='Ref_to_Macro'>AssertArg</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN757"><span class='Ref_to_Parameter'>sortOperators</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN797"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN65"><span class='Ref_to_Member'>ssup_cxt</span></a> <span class='Operator'>= </span><a href="../mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN797"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN66"><span class='Ref_to_Member'>ssup_collation</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN757"><span class='Ref_to_Parameter'>sortCollations</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <a href="tuplesort.c.html#LN797"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN74"><span class='Ref_to_Member'>ssup_nulls_first</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN758"><span class='Ref_to_Parameter'>nullsFirstFlags</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <a href="tuplesort.c.html#LN797"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>attNums</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Comment_Multi_Line'>/* Convey if abbreviation optimization is applicable in principle */ 
</span>        <a href="tuplesort.c.html#LN797"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN155"><span class='Ref_to_Member'>abbreviate</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="sortsupport.c.html#LN131"><span class='Ref_to_Func'>PrepareSortSupportFromOrderingOp</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN757"><span class='Ref_to_Parameter'>sortOperators</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN763"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="tuplesort.c.html#LN797"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The "onlyKey" optimization cannot be used with abbreviated keys, since 
     * tie-breaker comparisons may be required.  Typically, the optimization 
     * is only of value to pass-by-value types anyway, whereas abbreviated 
     * keys are typically only of value to pass-by-reference types. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN756"><span class='Ref_to_Parameter'>nkeys</span></a> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& !</span><a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN447"><span class='Ref_to_Member'>onlyKey</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN762"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN761"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_begin_heap &raquo; </span> 
 
<a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>* 
</span><a name="LN827"></a><span class='Declare_Function'>tuplesort_begin_cluster</span><span class='Parentheses'>(</span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupDesc</span><span class='Delimiter'>, 
</span><a name="LN828"></a>                        <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRel</span><span class='Delimiter'>, 
</span><a name="LN829"></a>                        <span class='Keyword'>int </span><span class='Declare_Parameter'>workMem</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN831"></a>    <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN582"><span class='Ref_to_Proto'>tuplesort_begin_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN829"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN829"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN832"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>indexScanKey</span><span class='Delimiter'>; 
</span><a name="LN833"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN834"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN828"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relam <span class='Operator'>== </span><a href="../../../include/catalog/pg_am.h.html#LN69"><span class='Ref_to_Const'>BTREE_AM_OID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN833"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>             <span class='String'>"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c"</span><span class='Delimiter'>, 
</span>             <a href="../../../include/utils/rel.h.html#LN422"><span class='Ref_to_Macro'>RelationGetNumberOfAttributes</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN828"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN829"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN829"><span class='Ref_to_Parameter'>randomAccess</span></a> <span class='Operator'>? </span><span class='String'>'t'</span> <span class='Operator'>: </span><span class='String'>'f'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN422"><span class='Ref_to_Macro'>RelationGetNumberOfAttributes</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN828"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_SORT_START<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN150"><span class='Ref_to_Const'>CLUSTER_SORT</span></a><span class='Delimiter'>, 
</span>                                <span class='Boolean'>false</span><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no unique check */ 
</span>                                <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN829"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN829"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN297"><span class='Ref_to_Member'>comparetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN614"><span class='Ref_to_Proto'>comparetup_cluster</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN305"><span class='Ref_to_Member'>copytup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN616"><span class='Ref_to_Proto'>copytup_cluster</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN315"><span class='Ref_to_Member'>writetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN617"><span class='Ref_to_Proto'>writetup_cluster</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN323"><span class='Ref_to_Member'>readtup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN619"><span class='Ref_to_Proto'>readtup_cluster</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN455"><span class='Ref_to_Member'>abbrevNext</span></a> <span class='Operator'>= </span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/index.h.html#LN81"><span class='Ref_to_Proto'>BuildIndexInfo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN828"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN827"><span class='Ref_to_Parameter'>tupDesc</span></a><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* assume we need not copy tupDesc */ 
</span> 
    <a href="tuplesort.c.html#LN832"><span class='Ref_To_Local'>indexScanKey</span></a> <span class='Operator'>= </span><a href="../../access/nbtree/nbtutils.c.html#LN113"><span class='Ref_to_Func'>_bt_mkscankey_nodata</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN828"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN870"></a>        <a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN871"></a>        <a href="../../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We will need to use FormIndexDatum to evaluate the index 
         * expressions.  To do that, we need an EState, as well as a 
         * TupleTableSlot to put the table tuples into.  The econtext's 
         * scantuple has to point to that slot, too. 
         */ 
</span>        <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a> <span class='Operator'>= </span><a href="../../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN870"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../../include/executor/tuptable.h.html#LN144"><span class='Ref_to_Proto'>MakeSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN827"><span class='Ref_to_Parameter'>tupDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN871"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="../../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN871"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN870"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare SortSupport data for each column */ 
</span>    <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>* 
</span>                                            <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN59"><span class='Ref_to_Struct'>SortSupportData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN834"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN834"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN834"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN891"></a>        <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>sortKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN834"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span><a name="LN892"></a>        <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>scanKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN832"><span class='Ref_To_Local'>indexScanKey</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN834"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span><a name="LN893"></a>        <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>strategy</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN891"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN65"><span class='Ref_to_Member'>ssup_cxt</span></a> <span class='Operator'>= </span><a href="../mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN891"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN66"><span class='Ref_to_Member'>ssup_collation</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN892"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN891"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN74"><span class='Ref_to_Member'>ssup_nulls_first</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN892"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN427"><span class='Ref_to_Const'>SK_BT_NULLS_FIRST</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN891"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN892"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Convey if abbreviation optimization is applicable in principle */ 
</span>        <a href="tuplesort.c.html#LN891"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN155"><span class='Ref_to_Member'>abbreviate</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN834"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/c.h.html#LN677"><span class='Ref_to_Macro'>AssertState</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN891"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN893"><span class='Ref_To_Local'>strategy</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN892"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>? 
</span>            <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a> <span class='Operator'>: </span><a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Delimiter'>; 
</span> 
        <a href="sortsupport.c.html#LN158"><span class='Ref_to_Func'>PrepareSortSupportFromIndexRel</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN828"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN893"><span class='Ref_To_Local'>strategy</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN891"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;state-&GT;nKeys;i+... &raquo; </span> 
 
    <a href="../../access/nbtree/nbtutils.c.html#LN153"><span class='Ref_to_Func'>_bt_freeskey</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN832"><span class='Ref_To_Local'>indexScanKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN833"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN831"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_begin_cluster &raquo; </span> 
 
<a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>* 
</span><a name="LN919"></a><span class='Declare_Function'>tuplesort_begin_index_btree</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRel</span><span class='Delimiter'>, 
</span><a name="LN920"></a>                            <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRel</span><span class='Delimiter'>, 
</span><a name="LN921"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>enforceUnique</span><span class='Delimiter'>, 
</span><a name="LN922"></a>                            <span class='Keyword'>int </span><span class='Declare_Parameter'>workMem</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN924"></a>    <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN582"><span class='Ref_to_Proto'>tuplesort_begin_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN922"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN922"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN925"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>indexScanKey</span><span class='Delimiter'>; 
</span><a name="LN926"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN927"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN926"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>             <span class='String'>"begin index sort: unique = %c, workMem = %d, randomAccess = %c"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN921"><span class='Ref_to_Parameter'>enforceUnique</span></a> <span class='Operator'>? </span><span class='String'>'t'</span> <span class='Operator'>: </span><span class='String'>'f'</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN922"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN922"><span class='Ref_to_Parameter'>randomAccess</span></a> <span class='Operator'>? </span><span class='String'>'t'</span> <span class='Operator'>: </span><span class='String'>'f'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN422"><span class='Ref_to_Macro'>RelationGetNumberOfAttributes</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN920"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_SORT_START<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN148"><span class='Ref_to_Const'>INDEX_SORT</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN921"><span class='Ref_to_Parameter'>enforceUnique</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN922"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN922"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN297"><span class='Ref_to_Member'>comparetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN621"><span class='Ref_to_Proto'>comparetup_index_btree</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN305"><span class='Ref_to_Member'>copytup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN625"><span class='Ref_to_Proto'>copytup_index</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN315"><span class='Ref_to_Member'>writetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN626"><span class='Ref_to_Proto'>writetup_index</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN323"><span class='Ref_to_Member'>readtup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN628"><span class='Ref_to_Proto'>readtup_index</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN455"><span class='Ref_to_Member'>abbrevNext</span></a> <span class='Operator'>= </span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN469"><span class='Ref_to_Member'>heapRel</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN919"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN920"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN473"><span class='Ref_to_Member'>enforceUnique</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN921"><span class='Ref_to_Parameter'>enforceUnique</span></a><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN925"><span class='Ref_To_Local'>indexScanKey</span></a> <span class='Operator'>= </span><a href="../../access/nbtree/nbtutils.c.html#LN113"><span class='Ref_to_Func'>_bt_mkscankey_nodata</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN920"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN422"><span class='Ref_to_Macro'>RelationGetNumberOfAttributes</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN920"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare SortSupport data for each column */ 
</span>    <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>* 
</span>                                            <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN59"><span class='Ref_to_Struct'>SortSupportData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN927"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN927"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN927"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN966"></a>        <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>sortKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN927"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span><a name="LN967"></a>        <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>scanKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN925"><span class='Ref_To_Local'>indexScanKey</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN927"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span><a name="LN968"></a>        <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>strategy</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN966"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN65"><span class='Ref_to_Member'>ssup_cxt</span></a> <span class='Operator'>= </span><a href="../mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN966"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN66"><span class='Ref_to_Member'>ssup_collation</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN967"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN966"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN74"><span class='Ref_to_Member'>ssup_nulls_first</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN967"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN427"><span class='Ref_to_Const'>SK_BT_NULLS_FIRST</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN966"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN967"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Convey if abbreviation optimization is applicable in principle */ 
</span>        <a href="tuplesort.c.html#LN966"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN155"><span class='Ref_to_Member'>abbreviate</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN927"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/c.h.html#LN677"><span class='Ref_to_Macro'>AssertState</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN966"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN968"><span class='Ref_To_Local'>strategy</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN967"><span class='Ref_To_Local'>scanKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>? 
</span>            <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a> <span class='Operator'>: </span><a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Delimiter'>; 
</span> 
        <a href="sortsupport.c.html#LN158"><span class='Ref_to_Func'>PrepareSortSupportFromIndexRel</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN920"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN968"><span class='Ref_To_Local'>strategy</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN966"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;state-&GT;nKeys;i+... &raquo; </span> 
 
    <a href="../../access/nbtree/nbtutils.c.html#LN153"><span class='Ref_to_Func'>_bt_freeskey</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN925"><span class='Ref_To_Local'>indexScanKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN926"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN924"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_begin_index_btree &raquo; </span> 
 
<a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>* 
</span><a name="LN994"></a><span class='Declare_Function'>tuplesort_begin_index_hash</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRel</span><span class='Delimiter'>, 
</span><a name="LN995"></a>                           <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRel</span><span class='Delimiter'>, 
</span><a name="LN996"></a>                           <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>high_mask</span><span class='Delimiter'>, 
</span><a name="LN997"></a>                           <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>low_mask</span><span class='Delimiter'>, 
</span><a name="LN998"></a>                           <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>max_buckets</span><span class='Delimiter'>, 
</span><a name="LN999"></a>                           <span class='Keyword'>int </span><span class='Declare_Parameter'>workMem</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1001"></a>    <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN582"><span class='Ref_to_Proto'>tuplesort_begin_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN999"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN999"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1002"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1002"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>             <span class='String'>"begin index sort: high_mask = 0x%x, low_mask = 0x%x, "</span> 
             <span class='String'>"max_buckets = 0x%x, workMem = %d, randomAccess = %c"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN996"><span class='Ref_to_Parameter'>high_mask</span></a><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN997"><span class='Ref_to_Parameter'>low_mask</span></a><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN998"><span class='Ref_to_Parameter'>max_buckets</span></a><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN999"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN999"><span class='Ref_to_Parameter'>randomAccess</span></a> <span class='Operator'>? </span><span class='String'>'t'</span> <span class='Operator'>: </span><span class='String'>'f'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* Only one sort column, the hash code */ 
</span> 
    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN297"><span class='Ref_to_Member'>comparetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN623"><span class='Ref_to_Proto'>comparetup_index_hash</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN305"><span class='Ref_to_Member'>copytup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN625"><span class='Ref_to_Proto'>copytup_index</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN315"><span class='Ref_to_Member'>writetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN626"><span class='Ref_to_Proto'>writetup_index</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN323"><span class='Ref_to_Member'>readtup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN628"><span class='Ref_to_Proto'>readtup_index</span></a><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN469"><span class='Ref_to_Member'>heapRel</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN994"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN995"><span class='Ref_to_Parameter'>indexRel</span></a><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN476"><span class='Ref_to_Member'>high_mask</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN996"><span class='Ref_to_Parameter'>high_mask</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN477"><span class='Ref_to_Member'>low_mask</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN997"><span class='Ref_to_Parameter'>low_mask</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN478"><span class='Ref_to_Member'>max_buckets</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN998"><span class='Ref_to_Parameter'>max_buckets</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1002"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN1001"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_begin_index_hash &raquo; </span> 
 
<a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>* 
</span><a name="LN1037"></a><span class='Declare_Function'>tuplesort_begin_datum</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datumType</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortOperator</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortCollation</span><span class='Delimiter'>, 
</span><a name="LN1038"></a>                      <span class='Keyword'>bool </span><span class='Declare_Parameter'>nullsFirstFlag</span><span class='Delimiter'>, 
</span><a name="LN1039"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>workMem</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1041"></a>    <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN582"><span class='Ref_to_Proto'>tuplesort_begin_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1039"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1039"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1042"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN1043"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>typlen</span><span class='Delimiter'>; 
</span><a name="LN1044"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>typbyval</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1042"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>             <span class='String'>"begin datum sort: workMem = %d, randomAccess = %c"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN1039"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1039"><span class='Ref_to_Parameter'>randomAccess</span></a> <span class='Operator'>? </span><span class='String'>'t'</span> <span class='Operator'>: </span><span class='String'>'f'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* always a one-column sort */ 
</span> 
    TRACE_POSTGRESQL_SORT_START<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN149"><span class='Ref_to_Const'>DATUM_SORT</span></a><span class='Delimiter'>, 
</span>                                <span class='Boolean'>false</span><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no unique check */ 
</span>                                <span class='Number'>1</span><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN1039"><span class='Ref_to_Parameter'>workMem</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN1039"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN297"><span class='Ref_to_Member'>comparetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN630"><span class='Ref_to_Proto'>comparetup_datum</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN305"><span class='Ref_to_Member'>copytup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN632"><span class='Ref_to_Proto'>copytup_datum</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN315"><span class='Ref_to_Member'>writetup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN633"><span class='Ref_to_Proto'>writetup_datum</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN323"><span class='Ref_to_Member'>readtup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN635"><span class='Ref_to_Proto'>readtup_datum</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN455"><span class='Ref_to_Member'>abbrevNext</span></a> <span class='Operator'>= </span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN484"><span class='Ref_to_Member'>datumType</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1037"><span class='Ref_to_Parameter'>datumType</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* lookup necessary attributes of the datum type */ 
</span>    <a href="../../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1037"><span class='Ref_to_Parameter'>datumType</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1043"><span class='Ref_To_Local'>typlen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1044"><span class='Ref_To_Local'>typbyval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN486"><span class='Ref_to_Member'>datumTypeLen</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1043"><span class='Ref_To_Local'>typlen</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN279"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= !</span><a href="tuplesort.c.html#LN1044"><span class='Ref_To_Local'>typbyval</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare SortSupport data */ 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/utils/sortsupport.h.html#LN59"><span class='Ref_to_Struct'>SortSupportData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN65"><span class='Ref_to_Member'>ssup_cxt</span></a> <span class='Operator'>= </span><a href="../mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN66"><span class='Ref_to_Member'>ssup_collation</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1037"><span class='Ref_to_Parameter'>sortCollation</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN74"><span class='Ref_to_Member'>ssup_nulls_first</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1038"><span class='Ref_to_Parameter'>nullsFirstFlag</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Abbreviation is possible here only for by-reference types.  In theory, 
     * a pass-by-value datatype could have an abbreviated form that is cheaper 
     * to compare.  In a tuple sort, we could support that, because we can 
     * always extract the original datum from the tuple is needed.  Here, we 
     * can't, because a datum sort only stores a single copy of the datum; the 
     * "tuple" field of each sortTuple is NULL. 
     */ 
</span>    <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN155"><span class='Ref_to_Member'>abbreviate</span></a> <span class='Operator'>= !</span><a href="tuplesort.c.html#LN1044"><span class='Ref_To_Local'>typbyval</span></a><span class='Delimiter'>; 
</span> 
    <a href="sortsupport.c.html#LN131"><span class='Ref_to_Func'>PrepareSortSupportFromOrderingOp</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1037"><span class='Ref_to_Parameter'>sortOperator</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The "onlyKey" optimization cannot be used with abbreviated keys, since 
     * tie-breaker comparisons may be required.  Typically, the optimization 
     * is only of value to pass-by-value types anyway, whereas abbreviated 
     * keys are typically only of value to pass-by-reference types. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN447"><span class='Ref_to_Member'>onlyKey</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1042"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN1041"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_begin_datum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplesort_set_bound 
 * 
 *  Advise tuplesort that at most the first N result tuples are required. 
 * 
 * Must be called before inserting any tuples.  (Actually, we could allow it 
 * as long as the sort hasn't spilled to disk, but there seems no need for 
 * delayed calls at the moment.) 
 * 
 * This is a hint only. The tuplesort may still return more tuples than 
 * requested. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1122"></a><span class='Declare_Function'>tuplesort_set_bound</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Declare_Parameter'>bound</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Assert we're called before loading any tuples */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN231"><span class='Ref_to_EnumConst'>TSS_INITIAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> DEBUG_BOUNDED_SORT 
    <span class='Comment_Multi_Line'>/* Honor GUC setting that disables the feature (for easy testing) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN158"><span class='Ref_to_Global_Var'>optimize_bounded_sort</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* We want to be able to compute bound * 2, so limit the setting */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>bound</span></a> <span class='Operator'>&GT; </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) (</span>INT_MAX <span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>bound</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Bounded sorts are not an effective target for abbreviated key 
     * optimization.  Disable by setting state to be consistent with no 
     * abbreviation support. 
     */ 
</span>    <a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN106"><span class='Ref_to_Member'>comparator</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Not strictly necessary, but be tidy */ 
</span>    <a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN182"><span class='Ref_to_Member'>abbrev_abort</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1122"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_set_bound &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplesort_end 
 * 
 *  Release resources and clean up. 
 * 
 * NOTE: after calling this, any pointers returned by tuplesort_getXXX are 
 * pointing to garbage.  Be careful not to attempt to use or free such 
 * pointers afterwards! 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1166"></a><span class='Declare_Function'>tuplesort_end</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* context swap probably not needed, but let's be safe */ 
</span><a name="LN1169"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
<a name="LN1172"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>spaceUsed</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN1172"><span class='Ref_To_Local'>spaceUsed</span></a> <span class='Operator'>= </span><a href="../../../include/utils/logtape.h.html#LN43"><span class='Ref_to_Proto'>LogicalTapeSetBlocks</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="tuplesort.c.html#LN1172"><span class='Ref_To_Local'>spaceUsed</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>- </span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a> <span class='Operator'>+ </span><span class='Number'>1023</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>1024</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Delete temporary "tape" files, if any. 
     * 
     * Note: want to include this in reported total cost of sort, hence need 
     * for two #ifdef TRACE_SORT sections. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/logtape.h.html#LN27"><span class='Ref_to_Proto'>LogicalTapeSetClose</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"external sort ended, %ld disk blocks used: %s"</span><span class='Delimiter'>, 
</span>                 <a href="tuplesort.c.html#LN1172"><span class='Ref_To_Local'>spaceUsed</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"internal sort ended, %ld KB used: %s"</span><span class='Delimiter'>, 
</span>                 <a href="tuplesort.c.html#LN1172"><span class='Ref_To_Local'>spaceUsed</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    TRACE_POSTGRESQL_SORT_DONE<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1172"><span class='Ref_To_Local'>spaceUsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#else</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If you disabled TRACE_SORT, you can still probe sort__done, but you 
     * ain't getting space-used stats. 
     */ 
</span>    TRACE_POSTGRESQL_SORT_DONE<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0L</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* Free any execution state created for CLUSTER case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1213"></a>        <a href="../../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span> <span class='Operator'>= </span><a href="../../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/executor/tuptable.h.html#LN145"><span class='Ref_to_Proto'>ExecDropSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1213"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1169"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Free the per-sort memory context, thereby releasing all working memory, 
     * including the Tuplesortstate struct itself. 
     */ 
</span>    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1166"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_end &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Grow the memtuples[] array, if possible within our memory constraint.  We 
 * must not exceed INT_MAX tuples in memory or the caller-provided memory 
 * limit.  Return TRUE if we were able to enlarge the array, FALSE if not. 
 * 
 * Normally, at each increment we double the size of the array.  When doing 
 * that would exceed a limit, we attempt one last, smaller increase (and then 
 * clear the growmemtuples flag so we don't try any more).  That allows us to 
 * use memory as fully as permitted; sticking to the pure doubling rule could 
 * result in almost half going unused.  Because availMem moves around with 
 * tuple addition/removal, we need some rule to prevent making repeated small 
 * increases in memtupsize, which would just be useless thrashing.  The 
 * growmemtuples flag accomplishes that and also prevents useless 
 * recalculations in this function. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1244"></a><span class='Declare_Function'>grow_memtuples</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1246"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>newmemtupsize</span><span class='Delimiter'>; 
</span><a name="LN1247"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>memtupsize</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a><span class='Delimiter'>; 
</span><a name="LN1248"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>memNowUsed</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>- </span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Forget it if we've already maxed out memtuples, per comment above */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN336"><span class='Ref_to_Member'>growmemtuples</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Select new value of memtupsize */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1248"><span class='Ref_To_Local'>memNowUsed</span></a> <span class='Operator'>&LT;= </span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We've used no more than half of allowedMem; double our usage, 
         * clamping at INT_MAX tuples. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1247"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>&LT; </span>INT_MAX <span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>            <a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1247"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>* </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span>INT_MAX<span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN336"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * This will be the last increment of memtupsize.  Abandon doubling 
         * strategy and instead increase as much as we safely can. 
         * 
         * To stay within allowedMem, we can't increase memtupsize by more 
         * than availMem / sizeof(SortTuple) elements.  In practice, we want 
         * to increase it by considerably less, because we need to leave some 
         * space for the tuples to which the new array slots will refer.  We 
         * assume the new tuples will be about the same size as the tuples 
         * we've already seen, and thus we can extrapolate from the space 
         * consumption so far to estimate an appropriate new size for the 
         * memtuples array.  The optimal value might be higher or lower than 
         * this estimate, but it's hard to know that in advance.  We again 
         * clamp at INT_MAX tuples. 
         * 
         * This calculation is safe against enlarging the array so much that 
         * LACKMEM becomes true, because the memory currently used includes 
         * the present array; thus, there would be enough allowedMem for the 
         * new array elements even if no other memory were currently used. 
         * 
         * We do the arithmetic in float8, because otherwise the product of 
         * memtupsize and allowedMem could overflow.  Any inaccuracy in the 
         * result should be insignificant; but even if we computed a 
         * completely insane result, the checks below will prevent anything 
         * really bad from happening. 
         */ 
</span><a name="LN1297"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>grow_ratio</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN1297"><span class='Ref_To_Local'>grow_ratio</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN1248"><span class='Ref_To_Local'>memNowUsed</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1247"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>* </span><a href="tuplesort.c.html#LN1297"><span class='Ref_To_Local'>grow_ratio</span></a> <span class='Operator'>&LT; </span>INT_MAX<span class='Parentheses'>) 
</span>            <a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN1247"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>* </span><a href="tuplesort.c.html#LN1297"><span class='Ref_To_Local'>grow_ratio</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span>INT_MAX<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* We won't make any further enlargement attempts */ 
</span>        <a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN336"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Must enlarge array by at least one element, else report failure */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>&LT;= </span><a href="tuplesort.c.html#LN1247"><span class='Ref_To_Local'>memtupsize</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="tuplesort.c.html#LN1351"><span class='Ref_to_Label'>noalloc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp 
     * to ensure our request won't be rejected.  Note that we can easily 
     * exhaust address space before facing this outcome.  (This is presently 
     * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but 
     * don't rely on that at this distance.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/utils/memutils.h.html#LN43"><span class='Ref_to_Const'>MaxAllocHugeSize</span></a> <span class='Operator'>/ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="../../../include/utils/memutils.h.html#LN43"><span class='Ref_to_Const'>MaxAllocHugeSize</span></a> <span class='Operator'>/ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN336"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* can't grow any more */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need to be sure that we do not cause LACKMEM to become true, else 
     * the space management algorithm will go nuts.  The code above should 
     * never generate a dangerous request, but to be safe, check explicitly 
     * that the array growth fits within availMem.  (We could still cause 
     * LACKMEM if the memory chunk overhead associated with the memtuples 
     * array were to increase.  That shouldn't happen because we chose the 
     * initial array size large enough to ensure that palloc will be treating 
     * both old and new arrays as separate chunks.  But we'll check LACKMEM 
     * explicitly below just in case.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>- </span><a href="tuplesort.c.html#LN1247"><span class='Ref_To_Local'>memtupsize</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a><span class='Parentheses'>)))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="tuplesort.c.html#LN1351"><span class='Ref_to_Label'>noalloc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* OK, do it */ 
</span>    <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1246"><span class='Ref_To_Local'>newmemtupsize</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/palloc.h.html#LN97"><span class='Ref_to_Proto'>repalloc_huge</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>, 
</span>                      <a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Macro'>LACKMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected out-of-memory situation in tuplesort"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
<a name="LN1351"></a><span class='Label'>noalloc</span><span class='Operator'>: 
</span>    <span class='Comment_Multi_Line'>/* If for any reason we didn't realloc, shut off future attempts */ 
</span>    <a href="tuplesort.c.html#LN1244"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN336"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end grow_memtuples &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Accept one tuple while collecting input data for sort. 
 * 
 * Note that the input data is always copied; the caller need not save it. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1363"></a><span class='Declare_Function'>tuplesort_puttupleslot</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1365"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1363"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1366"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy the given tuple into memory we control, and decrease availMem. 
     * Then call the common code. 
     */ 
</span>    <a href="tuplestore.c.html#LN182"><span class='Ref_to_Macro'>COPYTUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1363"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1366"><span class='Ref_To_Local'>stup</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN1363"><span class='Ref_to_Parameter'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN583"><span class='Ref_to_Proto'>puttuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1363"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1366"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1365"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Accept one tuple while collecting input data for sort. 
 * 
 * Note that the input data is always copied; the caller need not save it. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1385"></a><span class='Declare_Function'>tuplesort_putheaptuple</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1387"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1385"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1388"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy the given tuple into memory we control, and decrease availMem. 
     * Then call the common code. 
     */ 
</span>    <a href="tuplestore.c.html#LN182"><span class='Ref_to_Macro'>COPYTUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1385"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1388"><span class='Ref_To_Local'>stup</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN1385"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN583"><span class='Ref_to_Proto'>puttuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1385"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1388"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1387"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Collect one index tuple while collecting input data for sort, building 
 * it from caller-supplied values. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1406"></a><span class='Declare_Function'>tuplesort_putindextuplevalues</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN1407"></a>                              <a href="../../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>self</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, 
</span><a name="LN1408"></a>                              <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1410"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1411"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span><a name="LN1412"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>original</span><span class='Delimiter'>; 
</span><a name="LN1413"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><a href="../../access/common/indextuple.c.html#LN35"><span class='Ref_to_Func'>index_form_tuple</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1407"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1408"><span class='Ref_to_Parameter'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1413"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN1413"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a> <span class='Operator'>= *</span><a href="tuplesort.c.html#LN1407"><span class='Ref_to_Parameter'>self</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* set up first-column key value */ 
</span>    <a href="tuplesort.c.html#LN1412"><span class='Ref_To_Local'>original</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1413"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                             <span class='Number'>1</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>|| !</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Store ordinary Datum representation, or NULL value.  If there is a 
         * converter it won't expect NULL values, and cost model is not 
         * required to account for NULL, so in that case we avoid calling 
         * converter and just set datum1 to zeroed representation (to be 
         * consistent, and to support cheap inequality tests for NULL 
         * abbreviated keys). 
         */ 
</span>        <a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1412"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN584"><span class='Ref_to_Proto'>consider_abort_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Store abbreviated key representation */ 
</span>        <a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1412"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>, 
</span>                                                        <a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Abort abbreviation */ 
</span><a name="LN1448"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1412"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set state to be consistent with never trying abbreviation. 
         * 
         * Alter datum1 representation in already-copied tuples, so as to 
         * ensure a consistent representation (current tuple was just 
         * handled).  It does not matter if some dumped tuples are already 
         * sorted on tape, since serialized tuples lack abbreviated keys 
         * (TSS_BUILDRUNS state prevents control reaching here in any case). 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1448"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN1448"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN1448"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1463"></a>            <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>mtup</span> <span class='Operator'>= &</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN1448"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="tuplesort.c.html#LN1413"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1463"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1463"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1413"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                                         <span class='Number'>1</span><span class='Delimiter'>, 
</span>                                         <a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="tuplesort.c.html#LN1463"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="tuplesort.c.html#LN583"><span class='Ref_to_Proto'>puttuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1406"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1411"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1410"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_putindextuplevalues &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Accept one Datum while collecting input data for sort. 
 * 
 * If the Datum is pass-by-ref type, the value will be copied. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1484"></a><span class='Declare_Function'>tuplesort_putdatum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>val</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isNull</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1486"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1487"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Pass-by-value types or null values are just stored directly in 
     * stup.datum1 (and stup.tuple is not used and set to NULL). 
     * 
     * Non-null pass-by-reference values need to be copied into memory we 
     * control, and possibly abbreviated. The copied value is pointed to by 
     * stup.tuple and is treated as the canonical copy (e.g. to return via 
     * tuplesort_getdatum or when writing to tape); stup.datum1 gets the 
     * abbreviated value if abbreviation is happening, otherwise it's 
     * identical to stup.tuple. 
     */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>|| !</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN279"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Set datum1 to zeroed representation for NULLs (to be consistent, 
         * and to support cheap inequality tests for NULL abbreviated keys). 
         */ 
</span>        <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= !</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>? </span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>val</span></a> <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>isNull</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* no separate storage */ 
</span>        <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1514"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>original</span> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>val</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN486"><span class='Ref_to_Member'>datumTypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1514"><span class='Ref_To_Local'>original</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1514"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN584"><span class='Ref_to_Proto'>consider_abort_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Store abbreviated key representation */ 
</span>            <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1514"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>, 
</span>                                                            <a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Abort abbreviation */ 
</span><a name="LN1534"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
            <a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1514"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Set state to be consistent with never trying abbreviation. 
             * 
             * Alter datum1 representation in already-copied tuples, so as to 
             * ensure a consistent representation (current tuple was just 
             * handled).  It does not matter if some dumped tuples are already 
             * sorted on tape, since serialized tuples lack abbreviated keys 
             * (TSS_BUILDRUNS state prevents control reaching here in any 
             * case). 
             */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1534"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN1534"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN1534"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1550"></a>                <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>mtup</span> <span class='Operator'>= &</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN1534"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
                <a href="tuplesort.c.html#LN1550"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1550"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="tuplesort.c.html#LN583"><span class='Ref_to_Proto'>puttuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1484"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1487"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1486"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_putdatum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Shared code for tuple and datum cases. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1566"></a><span class='Declare_Function'>puttuple_common</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN231"><span class='Ref_to_EnumConst'>TSS_INITIAL</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Save the tuple into the unsorted array.  First, grow the array 
             * as needed.  Note that we try to grow the array when there is 
             * still one free slot remaining --- if we fail, there'll still be 
             * room to store the incoming tuple, and then we'll switch to 
             * tape-based operation. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN576"><span class='Ref_to_Func'>grow_memtuples</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= *</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check if it's time to switch over to a bounded heapsort. We do 
             * so if the input tuple count exceeds twice the desired tuple 
             * count (this is a heuristic for where heapsort becomes cheaper 
             * than a quicksort), or if we've just filled workMem and have 
             * enough tuples to meet the bound. 
             * 
             * Note that once we enter TSS_BOUNDED state we will always try to 
             * complete the sort that way.  In the worst case, if later input 
             * tuples are larger than earlier ones, this might cause us to 
             * exceed workMem significantly. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a> <span class='Operator'>* </span><span class='Number'>2</span> <span class='Operator'>|| 
</span>                 <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Macro'>LACKMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))))</span> 
            <span class='Delimiter'>{ 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"switching to bounded heapsort at %d tuples: %s"</span><span class='Delimiter'>, 
</span>                         <a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
                <a href="tuplesort.c.html#LN595"><span class='Ref_to_Proto'>make_bounded_heap</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Done if we still fit in available memory and have array slots. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>&& !</span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Macro'>LACKMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Nope; time to switch to tape-based operation. 
             */ 
</span>            <a href="tuplesort.c.html#LN586"><span class='Ref_to_Proto'>inittapes</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Dump tuples until we are back under the limit. 
             */ 
</span>            <a href="tuplestore.c.html#LN239"><span class='Ref_to_Proto'>dumptuples</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplesort.c.html#LN232"><span class='Ref_to_EnumConst'>TSS_BOUNDED</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We don't want to grow the array here, so check whether the new 
             * tuple can be discarded before putting it in.  This should be a 
             * good speed optimization, too, since when there are many more 
             * input tuples than the bound, most input tuples can be discarded 
             * with just this one comparison.  Note that because we currently 
             * have the sort direction reversed, we must check for &LT;= not &GT;=. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN519"><span class='Ref_to_Macro'>COMPARETUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* new tuple &LT;= top of the heap, so we can discard it */ 
</span>                <a href="tuplesort.c.html#LN637"><span class='Ref_to_Proto'>free_sort_tuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* discard top of heap, replacing it with the new tuple */ 
</span>                <a href="tuplesort.c.html#LN637"><span class='Ref_to_Proto'>free_sort_tuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* not used */ 
</span>                <a href="tuplesort.c.html#LN600"><span class='Ref_to_Proto'>tuplesort_heap_replace_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplesort.c.html#LN233"><span class='Ref_to_EnumConst'>TSS_BUILDRUNS</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Insert the tuple into the heap, with run number currentRun if 
             * it can go into the current run, else HEAP_RUN_NEXT.  The tuple 
             * can go into the current run if it is &GT;= the first 
             * not-yet-output tuple.  (Actually, it could go into the current 
             * run if it is &GT;= the most recently output tuple ... but that 
             * would require keeping around the tuple we last output, and it's 
             * simplest to let writetup free each tuple as soon as it's 
             * written.) 
             * 
             * Note that this only applies when: 
             * 
             * - currentRun is RUN_FIRST 
             * 
             * - Replacement selection is in use (typically it is never used). 
             * 
             * When these two conditions are not both true, all tuples are 
             * appended indifferently, much like the TSS_INITIAL case. 
             * 
             * There should always be room to store the incoming tuple. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN387"><span class='Ref_to_Member'>replaceActive</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN387"><span class='Ref_to_Member'>replaceActive</span></a> <span class='Operator'>&& 
</span>                <a href="tuplesort.c.html#LN519"><span class='Ref_to_Macro'>COMPARETUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Insert tuple into first, fully heapified run. 
                 * 
                 * Unlike classic replacement selection, which this module was 
                 * previously based on, only RUN_FIRST tuples are fully 
                 * heapified.  Any second/next run tuples are appended 
                 * indifferently.  While HEAP_RUN_NEXT tuples may be sifted 
                 * out of the way of first run tuples, COMPARETUP() will never 
                 * be called for the run's tuples during sifting (only our 
                 * initial COMPARETUP() call is required for the tuple, to 
                 * determine that the tuple does not belong in RUN_FIRST). 
                 */ 
</span>                <a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN598"><span class='Ref_to_Proto'>tuplesort_heap_insert</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;replaceActive&... &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Tuple was determined to not belong to heapified RUN_FIRST, 
                 * or replacement selection not in play.  Append the tuple to 
                 * memtuples indifferently. 
                 * 
                 * dumptuples() does not trust that the next run's tuples are 
                 * heapified.  Anything past the first run will always be 
                 * quicksorted even when replacement selection is initially 
                 * used.  (When it's never used, every tuple still takes this 
                 * path.) 
                 */ 
</span>                <a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN261"><span class='Ref_to_Const'>HEAP_RUN_NEXT</span></a><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= *</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we are over the memory limit, dump tuples till we're under. 
             */ 
</span>            <a href="tuplestore.c.html#LN239"><span class='Ref_to_Proto'>dumptuples</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1566"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplesort state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end puttuple_common &raquo; </span> 
 
<span class='Keyword'>static bool 
</span><a name="LN1728"></a><span class='Declare_Function'>consider_abort_common</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN182"><span class='Ref_to_Member'>abbrev_abort</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check effectiveness of abbreviation optimization.  Consider aborting 
     * when still within memory limit. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN231"><span class='Ref_to_EnumConst'>TSS_INITIAL</span></a> <span class='Operator'>&& 
</span>        <a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN455"><span class='Ref_to_Member'>abbrevNext</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN455"><span class='Ref_to_Member'>abbrevNext</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check opclass-supplied abbreviation abort routine.  It may indicate 
         * that abbreviation should not proceed. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN182"><span class='Ref_to_Member'>abbrev_abort</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>, 
</span>                                           <a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Finally, restore authoritative comparator, and indicate that 
         * abbreviation is not in play by setting abbrev_converter to NULL 
         */ 
</span>        <a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN106"><span class='Ref_to_Member'>comparator</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Not strictly necessary, but be tidy */ 
</span>        <a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN182"><span class='Ref_to_Member'>abbrev_abort</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN1728"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Give up - expect original pass-by-value representation */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;status==TSS_IN... &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end consider_abort_common &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * All tuples have been provided; finish the sort. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1772"></a><span class='Declare_Function'>tuplesort_performsort</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1774"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"performsort starting: %s"</span><span class='Delimiter'>, 
</span>             <a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN231"><span class='Ref_to_EnumConst'>TSS_INITIAL</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We were able to accumulate all the tuples within the allowed 
             * amount of memory.  Just qsort 'em and we're done. 
             */ 
</span>            <a href="tuplesort.c.html#LN597"><span class='Ref_to_Proto'>tuplesort_sort_memtuples</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplesort.c.html#LN232"><span class='Ref_to_EnumConst'>TSS_BOUNDED</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We were able to accumulate all the tuples required for output 
             * in memory, using a heap to eliminate excess tuples.  Now we 
             * have to transform the heap to a properly-sorted array. 
             */ 
</span>            <a href="tuplesort.c.html#LN596"><span class='Ref_to_Proto'>sort_bounded_heap</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplesort.c.html#LN233"><span class='Ref_to_EnumConst'>TSS_BUILDRUNS</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Finish tape-based sort.  First, flush all tuples remaining in 
             * memory out to tape; then merge until we have a single remaining 
             * run (or, if !randomAccess, one run per tape). Note that 
             * mergeruns sets the correct state-&GT;status. 
             */ 
</span>            <a href="tuplestore.c.html#LN239"><span class='Ref_to_Proto'>dumptuples</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN589"><span class='Ref_to_Proto'>mergeruns</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN431"><span class='Ref_to_Member'>markpos_block</span></a> <span class='Operator'>= </span><span class='Number'>0L</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplesort state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN236"><span class='Ref_to_EnumConst'>TSS_FINALMERGE</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"performsort done (except %d-way final merge): %s"</span><span class='Delimiter'>, 
</span>                 <a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN419"><span class='Ref_to_Member'>activeTapes</span></a><span class='Delimiter'>, 
</span>                 <a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"performsort done: %s"</span><span class='Delimiter'>, 
</span>                 <a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN1772"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1774"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_performsort &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Internal routine to fetch the next tuple in either forward or back 
 * direction into *stup.  Returns FALSE if no more tuples. 
 * Returned tuple belongs to tuplesort memory context, and must not be freed 
 * by caller.  Note that fetched tuple is stored in memory that may be 
 * recycled by any future fetch. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1858"></a><span class='Declare_Function'>tuplesort_gettuple_common</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Delimiter'>, 
</span><a name="LN1859"></a>                          <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1861"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span><span class='Delimiter'>; 
</span><a name="LN1862"></a>    size_t      <span class='Declare_Local'>nmoved</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>forward</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Operator'>*</span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span>                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Complain if caller tries to retrieve more tuples than 
                 * originally asked for in a bounded sort.  This is because 
                 * returning EOF here might be the wrong thing. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a> <span class='Operator'>&& </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a><span class='Parentheses'>) 
</span>                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"retrieved too many tuples in a bounded sort"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * if all tuples are fetched already then we return last 
                 * tuple, else - tuple before last returned. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                    <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a><span class='Operator'>--</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* last returned tuple */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Operator'>*</span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>forward</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The slot that held the tuple that we returned in previous 
             * gettuple call can now be reused. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="tuplesort.c.html#LN507"><span class='Ref_to_Macro'>RELEASE_SLAB_SLOT</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN240"><span class='Ref_to_Proto'>getlen</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN184"><span class='Ref_to_Macro'>READTUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Remember the tuple we return, so that we can recycle 
                     * its memory on next call.  (This can be NULL, in the 
                     * !state-&GT;tuples case). 
                     */ 
</span>                    <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if forward &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Backward. 
             * 
             * if all tuples are fetched already then we return last tuple, 
             * else - tuple before last returned. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Seek position is pointing just past the zero tuplen at the 
                 * end of file; back up to fetch last tuple's ending length 
                 * word.  If seek fails we must have a completely empty file. 
                 */ 
</span>                <a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/logtape.h.html#LN37"><span class='Ref_to_Proto'>LogicalTapeBackspace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, 
</span>                                              <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, 
</span>                                              <span class='Number'>2</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>!= </span><span class='Number'>2</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span> 
                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected tape position"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Back up and fetch previously-returned tuple's ending length 
                 * word.  If seek fails, assume we are at start of file. 
                 */ 
</span>                <a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/logtape.h.html#LN37"><span class='Ref_to_Proto'>LogicalTapeBackspace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, 
</span>                                              <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, 
</span>                                              <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span> 
                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected tape position"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN240"><span class='Ref_to_Proto'>getlen</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Back up to get ending length word of tuple before it. 
                 */ 
</span>                <a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/logtape.h.html#LN37"><span class='Ref_to_Proto'>LogicalTapeBackspace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, 
</span>                                              <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, 
</span>                                          <a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>+ </span><span class='Number'>2</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * We backed up over the previous tuple, but there was no 
                     * ending length word before it.  That means that the prev 
                     * tuple is the first tuple in the file.  It is now the 
                     * next to read in forward direction (not obviously right, 
                     * but that is what in-memory case does). 
                     */ 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>+ </span><span class='Number'>2</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span> 
                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bogus tuple length in backward scan"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
            <a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN240"><span class='Ref_to_Proto'>getlen</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Now we have the length of the prior tuple, back up and read it. 
             * Note: READTUP expects we are positioned after the initial 
             * length word of the tuple, so back up to that point. 
             */ 
</span>            <a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/logtape.h.html#LN37"><span class='Ref_to_Proto'>LogicalTapeBackspace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, 
</span>                                          <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, 
</span>                                          <a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1862"><span class='Ref_To_Local'>nmoved</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>) 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bogus tuple length in backward scan"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN184"><span class='Ref_to_Macro'>READTUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1861"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Remember the tuple we return, so that we can recycle its memory 
             * on next call. (This can be NULL, in the Datum case). 
             */ 
</span>            <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplesort.c.html#LN236"><span class='Ref_to_EnumConst'>TSS_FINALMERGE</span></a><span class='Operator'>: 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* We are managing memory ourselves, with the slab allocator. */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The slab slot holding the tuple that we returned in previous 
             * gettuple call can now be reused. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="tuplesort.c.html#LN507"><span class='Ref_to_Macro'>RELEASE_SLAB_SLOT</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * This code should match the inner loop of mergeonerun(). 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2049"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>srcTape</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a><span class='Delimiter'>; 
</span><a name="LN2050"></a>                <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>newtup</span><span class='Delimiter'>; 
</span> 
                <span class='Operator'>*</span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Remember the tuple we return, so that we can recycle its 
                 * memory on next call. (This can be NULL, in the Datum case). 
                 */ 
</span>                <a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN380"><span class='Ref_to_Member'>lastReturnedTuple</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN1859"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Pull next tuple from tape, and replace the returned tuple 
                 * at top of the heap with it. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN592"><span class='Ref_to_Proto'>mergereadnext</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2049"><span class='Ref_To_Local'>srcTape</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2050"><span class='Ref_To_Local'>newtup</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * If no more data, we've reached end of run on this tape. 
                     * Remove the top node from the heap. 
                     */ 
</span>                    <a href="tuplesort.c.html#LN602"><span class='Ref_to_Proto'>tuplesort_heap_delete_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Rewind to free the read buffer.  It'd go away at the 
                     * end of the sort anyway, but better to release the 
                     * memory early. 
                     */ 
</span>                    <a href="../../../include/utils/logtape.h.html#LN35"><span class='Ref_to_Proto'>LogicalTapeRewindForWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2049"><span class='Ref_To_Local'>srcTape</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="tuplesort.c.html#LN2050"><span class='Ref_To_Local'>newtup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2049"><span class='Ref_To_Local'>srcTape</span></a><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN600"><span class='Ref_to_Proto'>tuplesort_heap_replace_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN1858"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2050"><span class='Ref_To_Local'>newtup</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;memtupcount&GT;0 &raquo; </span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplesort state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tuplesort_gettuple_common &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Fetch the next tuple in either forward or back direction. 
 * If successful, put tuple in slot and return TRUE; else, clear the slot 
 * and return FALSE. 
 * 
 * Caller may optionally be passed back abbreviated value (on TRUE return 
 * value) when abbreviation was used, which can be used to cheaply avoid 
 * equality checks that might otherwise be required.  Caller can safely make a 
 * determination of "non-equal tuple" based on simple binary inequality.  A 
 * NULL value in leading attribute will set abbreviated value to zeroed 
 * representation, which caller may rely on in abbreviated inequality check. 
 * 
 * If copy is true, the slot receives a copied tuple that will stay valid 
 * regardless of future manipulations of the tuplesort's state.  Memory is 
 * owned by the caller.  If copy is false, the slot will just receive a 
 * pointer to a tuple held within the tuplesort, which is more efficient, but 
 * only safe for callers that are prepared to have any subsequent manipulation 
 * of the tuplesort's state invalidate slot contents. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2112"></a><span class='Declare_Function'>tuplesort_gettupleslot</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>copy</span><span class='Delimiter'>, 
</span><a name="LN2113"></a>                       <a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>abbrev</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2115"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2112"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2116"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1857"><span class='Ref_to_Func'>tuplesort_gettuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2112"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2112"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2116"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>))</span> 
        <a href="tuplesort.c.html#LN2116"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2115"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2116"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Record abbreviated key for caller */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2112"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>&& </span><a href="tuplesort.c.html#LN2113"><span class='Ref_to_Parameter'>abbrev</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="tuplesort.c.html#LN2113"><span class='Ref_to_Parameter'>abbrev</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2116"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2112"><span class='Ref_to_Parameter'>copy</span></a><span class='Parentheses'>) 
</span>            <a href="tuplesort.c.html#LN2116"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN819"><span class='Ref_to_Proto'>heap_copy_minimal_tuple</span></a><span class='Parentheses'>((</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN2116"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/executor/tuptable.h.html#LN151"><span class='Ref_to_Proto'>ExecStoreMinimalTuple</span></a><span class='Parentheses'>((</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN2116"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2113"><span class='Ref_to_Parameter'>slot</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2112"><span class='Ref_to_Parameter'>copy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2113"><span class='Ref_to_Parameter'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_gettupleslot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Fetch the next tuple in either forward or back direction. 
 * Returns NULL if no more tuples.  Returned tuple belongs to tuplesort memory 
 * context, and must not be freed by caller.  Caller may not rely on tuple 
 * remaining valid after any further manipulation of tuplesort. 
 */ 
</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> 
<a name="LN2149"></a><span class='Declare_Function'>tuplesort_getheaptuple</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2151"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2149"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2152"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1857"><span class='Ref_to_Func'>tuplesort_gettuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2149"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2149"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2152"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>))</span> 
        <a href="tuplesort.c.html#LN2152"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2151"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN2152"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Fetch the next index tuple in either forward or back direction. 
 * Returns NULL if no more tuples.  Returned tuple belongs to tuplesort memory 
 * context, and must not be freed by caller.  Caller may not rely on tuple 
 * remaining valid after any further manipulation of tuplesort. 
 */ 
</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a> 
<a name="LN2169"></a><span class='Declare_Function'>tuplesort_getindextuple</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2171"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2169"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2172"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1857"><span class='Ref_to_Func'>tuplesort_gettuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2169"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2169"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2172"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>))</span> 
        <a href="tuplesort.c.html#LN2172"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2171"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN2172"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Fetch the next Datum in either forward or back direction. 
 * Returns FALSE if no more datums. 
 * 
 * If the Datum is pass-by-ref type, the returned value is freshly palloc'd 
 * and is now owned by the caller (this differs from similar routines for 
 * other types of tuplesorts). 
 * 
 * Caller may optionally be passed back abbreviated value (on TRUE return 
 * value) when abbreviation was used, which can be used to cheaply avoid 
 * equality checks that might otherwise be required.  Caller can safely make a 
 * determination of "non-equal tuple" based on simple binary inequality.  A 
 * NULL value will have a zeroed abbreviated value representation, which caller 
 * may rely on in abbreviated inequality check. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2198"></a><span class='Declare_Function'>tuplesort_getdatum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Delimiter'>, 
</span><a name="LN2199"></a>                   <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>val</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isNull</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>abbrev</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2201"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2198"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2202"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1857"><span class='Ref_to_Func'>tuplesort_gettuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2198"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2198"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2202"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2201"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Record abbreviated key for caller */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2198"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>&& </span><a href="tuplesort.c.html#LN2199"><span class='Ref_to_Parameter'>abbrev</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN2199"><span class='Ref_to_Parameter'>abbrev</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2202"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2202"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a> <span class='Operator'>|| !</span><a href="tuplesort.c.html#LN2198"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN279"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN2199"><span class='Ref_to_Parameter'>val</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2202"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN2199"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2202"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* use stup.tuple because stup.datum1 may be an abbreviation */ 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN2199"><span class='Ref_to_Parameter'>val</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2202"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2198"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN486"><span class='Ref_to_Member'>datumTypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN2199"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2201"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_getdatum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Advance over N tuples in either forward or back direction, 
 * without returning any data.  N==0 is a no-op. 
 * Returns TRUE if successful, FALSE if ran out of tuples. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2237"></a><span class='Declare_Function'>tuplesort_skiptuples</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Declare_Parameter'>ntuples</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2239"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't actually support backwards skip yet, because no callers need 
     * it.  The API is designed to allow for that later, though. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>ntuples</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>- </span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>+= </span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Complain if caller tries to retrieve more tuples than 
             * originally asked for in a bounded sort.  This is because 
             * returning EOF here might be the wrong thing. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a> <span class='Operator'>&& </span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a><span class='Parentheses'>) 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"retrieved too many tuples in a bounded sort"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN236"><span class='Ref_to_EnumConst'>TSS_FINALMERGE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We could probably optimize these cases better, but for now it's 
             * not worth the trouble. 
             */ 
</span>            <a href="tuplesort.c.html#LN2239"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2279"></a>                <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN1857"><span class='Ref_to_Func'>tuplesort_gettuple_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2237"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2279"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2239"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2239"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplesort state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tuplesort_skiptuples &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplesort_merge_order - report merge order we'll use for given memory 
 * (note: "merge order" just means the number of input tapes in the merge). 
 * 
 * This is exported for use by the planner.  allowedMem is in bytes. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN2304"></a><span class='Declare_Function'>tuplesort_merge_order</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Declare_Parameter'>allowedMem</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2306"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>mOrder</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need one tape for each merge input, plus another one for the output, 
     * and each of these tapes needs buffer space.  In addition we want 
     * MERGE_BUFFER_SIZE workspace per input tape (but the output tape doesn't 
     * count). 
     * 
     * Note: you might be thinking we need to account for the memtuples[] 
     * array in this calculation, but we effectively treat that as part of the 
     * MERGE_BUFFER_SIZE workspace. 
     */ 
</span>    <a href="tuplesort.c.html#LN2306"><span class='Ref_To_Local'>mOrder</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2304"><span class='Ref_to_Parameter'>allowedMem</span></a> <span class='Operator'>- </span><a href="tuplesort.c.html#LN252"><span class='Ref_to_Const'>TAPE_BUFFER_OVERHEAD</span></a><span class='Parentheses'>) </span><span class='Operator'>/ 
</span>        <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN253"><span class='Ref_to_Const'>MERGE_BUFFER_SIZE</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN252"><span class='Ref_to_Const'>TAPE_BUFFER_OVERHEAD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Even in minimum memory, use at least a MINORDER merge.  On the other 
     * hand, even when we have lots of memory, do not use more than a MAXORDER 
     * merge.  Tapes are pretty cheap, but they're not entirely free.  Each 
     * additional tape reduces the amount of memory available to build runs, 
     * which in turn can cause the same sort to need more runs, which makes 
     * merging slower even if it can still be done in a single pass.  Also, 
     * high order merges are quite slow due to CPU cache effects; it can be 
     * faster to pay the I/O cost of a polyphase merge than to perform a 
     * single merge pass across many hundreds of tapes. 
     */ 
</span>    <a href="tuplesort.c.html#LN2306"><span class='Ref_To_Local'>mOrder</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2306"><span class='Ref_To_Local'>mOrder</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN250"><span class='Ref_to_Const'>MINORDER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2306"><span class='Ref_To_Local'>mOrder</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2306"><span class='Ref_To_Local'>mOrder</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN251"><span class='Ref_to_Const'>MAXORDER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN2306"><span class='Ref_To_Local'>mOrder</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_merge_order &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * useselection - determine algorithm to use to sort first run. 
 * 
 * It can sometimes be useful to use the replacement selection algorithm if it 
 * results in one large run, and there is little available workMem.  See 
 * remarks on RUN_SECOND optimization within dumptuples(). 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2346"></a><span class='Declare_Function'>useselection</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * memtupsize might be noticeably higher than memtupcount here in atypical 
     * cases.  It seems slightly preferable to not allow recent outliers to 
     * impact this determination.  Note that caller's trace_sort output 
     * reports memtupcount instead. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2346"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>&LT;= </span><a href="../init/globals.c.html#LN114"><span class='Ref_to_Global_Var'>replacement_sort_tuples</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * inittapes - initialize for tape sorting. 
 * 
 * This is called only if we have found we don't have room to sort in memory. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2366"></a><span class='Declare_Function'>inittapes</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2368"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>maxTapes</span><span class='Delimiter'>, 
</span><a name="LN2369"></a>                <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN2370"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>tapeSpace</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compute number of tapes to use: merge order plus 1 */ 
</span>    <a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/tuplesort.h.html#LN113"><span class='Ref_to_Proto'>tuplesort_merge_order</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN282"><span class='Ref_to_Member'>maxTapes</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"switching to external sort with %d tapes: %s"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Decrease availMem to reflect the space needed for tape buffers, when 
     * writing the initial runs; but don't decrease it to the point that we 
     * have no room for tuples.  (That case is only likely to occur if sorting 
     * pass-by-value Datums; in all other scenarios the memtuples[] array is 
     * unlikely to occupy more than half of allowedMem.  In the pass-by-value 
     * case it's not important to account for tuple space, so we don't care if 
     * LACKMEM becomes inaccurate.) 
     */ 
</span>    <a href="tuplesort.c.html#LN2370"><span class='Ref_To_Local'>tapeSpace</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>*</span><a href="tuplesort.c.html#LN252"><span class='Ref_to_Const'>TAPE_BUFFER_OVERHEAD</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2370"><span class='Ref_To_Local'>tapeSpace</span></a> <span class='Operator'>+ </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a><span class='Parentheses'>)</span> 
        <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2370"><span class='Ref_To_Local'>tapeSpace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make sure that the temp file(s) underlying the tape set are created in 
     * suitable temp tablespaces. 
     */ 
</span>    <a href="../../../include/commands/tablespace.h.html#LN53"><span class='Ref_to_Proto'>PrepareTempTablespaces</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create the tape set and allocate the per-tape data arrays. 
     */ 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a> <span class='Operator'>= </span><a href="../../../include/utils/logtape.h.html#LN26"><span class='Ref_to_Proto'>LogicalTapeSetCreate</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN406"><span class='Ref_to_Member'>mergeactive</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Give replacement selection a try based on user setting.  There will be 
     * a switch to a simple hybrid sort-merge strategy after the first run 
     * (iff we could not output one long run). 
     */ 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN387"><span class='Ref_to_Member'>replaceActive</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN585"><span class='Ref_to_Proto'>useselection</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN387"><span class='Ref_to_Member'>replaceActive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Convert the unsorted contents of memtuples[] into a heap. Each 
         * tuple is marked as belonging to run number zero. 
         * 
         * NOTE: we pass false for checkIndex since there's no point in 
         * comparing indexes in this step, even though we do intend the 
         * indexes to be part of the sort key... 
         */ 
</span><a name="LN2432"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>ntuples</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"replacement selection will sort %d first run tuples"</span><span class='Delimiter'>, 
</span>                 <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* make the heap empty */ 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2432"><span class='Ref_To_Local'>ntuples</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Must copy source tuple to avoid possible overwrite */ 
</span><a name="LN2444"></a>            <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span> 
            <a href="tuplesort.c.html#LN2444"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN598"><span class='Ref_to_Proto'>tuplesort_heap_insert</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2444"><span class='Ref_To_Local'>stup</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN2432"><span class='Ref_To_Local'>ntuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;replaceActive &raquo; </span> 
 
    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize variables of Algorithm D (step D1). 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2368"><span class='Ref_To_Local'>maxTapes</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2369"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN413"><span class='Ref_to_Member'>Level</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN2366"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN233"><span class='Ref_to_EnumConst'>TSS_BUILDRUNS</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end inittapes &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * selectnewtape -- select new tape for new initial run. 
 * 
 * This is called after finishing a run when we know another run 
 * must be started.  This implements steps D3, D4 of Algorithm D. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2480"></a><span class='Declare_Function'>selectnewtape</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2482"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN2483"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>a</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Step D3: advance j (destTape) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>] </span><span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Step D4: increase level */ 
</span>    <a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN413"><span class='Ref_to_Member'>Level</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2483"><span class='Ref_To_Local'>a</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2483"><span class='Ref_To_Local'>a</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>- </span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span>        <a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2483"><span class='Ref_To_Local'>a</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN415"><span class='Ref_to_Member'>tp_fib</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2482"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplesort.c.html#LN2480"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end selectnewtape &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Initialize the slab allocation arena, for the given number of slots. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2512"></a><span class='Declare_Function'>init_slab_allocator</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numSlots</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>numSlots</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2516"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span><a name="LN2517"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN367"><span class='Ref_to_Member'>slabMemoryBegin</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>numSlots</span></a> <span class='Operator'>* </span><a href="tuplesort.c.html#LN217"><span class='Ref_to_Const'>SLAB_SLOT_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN368"><span class='Ref_to_Member'>slabMemoryEnd</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN367"><span class='Ref_to_Member'>slabMemoryBegin</span></a> <span class='Operator'>+ 
</span>            <a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>numSlots</span></a> <span class='Operator'>* </span><a href="tuplesort.c.html#LN217"><span class='Ref_to_Const'>SLAB_SLOT_SIZE</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN369"><span class='Ref_to_Member'>slabFreeHead</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN367"><span class='Ref_to_Member'>slabMemoryBegin</span></a><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>numSlots</span></a> <span class='Operator'>* </span><a href="tuplesort.c.html#LN217"><span class='Ref_to_Const'>SLAB_SLOT_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN2516"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN367"><span class='Ref_to_Member'>slabMemoryBegin</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2517"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2517"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>numSlots</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2517"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN2516"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>nextfree <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a> <span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="tuplesort.c.html#LN2516"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>+ </span><a href="tuplesort.c.html#LN217"><span class='Ref_to_Const'>SLAB_SLOT_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2516"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>+= </span><a href="tuplesort.c.html#LN217"><span class='Ref_to_Const'>SLAB_SLOT_SIZE</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN2516"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>nextfree <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN367"><span class='Ref_to_Member'>slabMemoryBegin</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN368"><span class='Ref_to_Member'>slabMemoryEnd</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN369"><span class='Ref_to_Member'>slabFreeHead</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplesort.c.html#LN2512"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end init_slab_allocator &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * mergeruns -- merge all the completed initial runs. 
 * 
 * This implements steps D5, D6 of Algorithm D.  All input data has 
 * already been written to initial runs on tape (see dumptuples). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2548"></a><span class='Declare_Function'>mergeruns</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2550"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tapenum</span><span class='Delimiter'>, 
</span><a name="LN2551"></a>                <span class='Declare_Local'>svTape</span><span class='Delimiter'>, 
</span><a name="LN2552"></a>                <span class='Declare_Local'>svRuns</span><span class='Delimiter'>, 
</span><a name="LN2553"></a>                <span class='Declare_Local'>svDummy</span><span class='Delimiter'>; 
</span><a name="LN2554"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numTapes</span><span class='Delimiter'>; 
</span><a name="LN2555"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numInputTapes</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN233"><span class='Ref_to_EnumConst'>TSS_BUILDRUNS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If there are multiple runs to be merged, when we go to read back 
         * tuples from disk, abbreviated keys will not have been stored, and 
         * we don't care to regenerate them.  Disable abbreviation from this 
         * point on. 
         */ 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN106"><span class='Ref_to_Member'>comparator</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Not strictly necessary, but be tidy */ 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN182"><span class='Ref_to_Member'>abbrev_abort</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN191"><span class='Ref_to_Member'>abbrev_full_comparator</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset tuple memory.  We've freed all the tuples that we previously 
     * allocated.  We will use the slab allocator from now on. 
     */ 
</span>    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We no longer need a large memtuples array.  (We will allocate a smaller 
     * one for the heap later.) 
     */ 
</span>    <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we had fewer runs than tapes, refund the memory that we imagined we 
     * would need for the tape buffers of the unused tapes. 
     * 
     * numTapes and numInputTapes reflect the actual number of tapes we will 
     * use.  Note that the output tape's tape number is maxTapes - 1, so the 
     * tape numbers of the used tapes are not consecutive, and you cannot just 
     * loop from 0 to numTapes to visit all used tapes! 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN413"><span class='Ref_to_Member'>Level</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2554"><span class='Ref_To_Local'>numTapes</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN282"><span class='Ref_to_Member'>maxTapes</span></a> <span class='Operator'>- </span><a href="tuplesort.c.html#LN2554"><span class='Ref_To_Local'>numTapes</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="tuplesort.c.html#LN252"><span class='Ref_to_Const'>TAPE_BUFFER_OVERHEAD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2554"><span class='Ref_To_Local'>numTapes</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN282"><span class='Ref_to_Member'>maxTapes</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize the slab allocator.  We need one slab slot per input tape, 
     * for the tuples in the heap, plus one to hold the tuple last returned 
     * from tuplesort_gettuple.  (If we're sorting pass-by-val Datums, 
     * however, we don't need to do allocate anything.) 
     * 
     * From this point on, we no longer use the USEMEM()/LACKMEM() mechanism 
     * to track memory usage of individual tuples. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN279"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN588"><span class='Ref_to_Proto'>init_slab_allocator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="tuplesort.c.html#LN588"><span class='Ref_to_Proto'>init_slab_allocator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we produced only one initial run (quite likely if the total data 
     * volume is between 1X and 2X workMem when replacement selection is used, 
     * but something we particular count on when input is presorted), we can 
     * just use that tape as the finished output, rather than doing a useless 
     * merge.  (This obvious optimization is not in Knuth's algorithm.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN262"><span class='Ref_to_Const'>RUN_SECOND</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>]; 
</span>        <span class='Comment_Multi_Line'>/* must freeze and rewind the finished output tape */ 
</span>        <a href="../../../include/utils/logtape.h.html#LN36"><span class='Ref_to_Proto'>LogicalTapeFreeze</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate a new 'memtuples' array, for the heap.  It will hold one tuple 
     * from each input tape. 
     */ 
</span>    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Use all the remaining memory we have available for read buffers among 
     * the input tapes. 
     * 
     * We do this only after checking for the case that we produced only one 
     * initial run, because there is no need to use a large read buffer when 
     * we're reading from a single tape.  With one tape, the I/O pattern will 
     * be the same regardless of the buffer size. 
     * 
     * We don't try to "rebalance" the memory among tapes, when we start a new 
     * merge phase, even if some tapes are inactive in the new phase.  That 
     * would be hard, because logtape.c doesn't know where one run ends and 
     * another begins.  When a new merge phase begins, and a tape doesn't 
     * participate in it, its buffer nevertheless already contains tuples from 
     * the next run on same tape, so we cannot release the buffer.  That's OK 
     * in practice, merge performance isn't that sensitive to the amount of 
     * buffers used, and most merge phases use all or almost all tapes, 
     * anyway. 
     */ 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"using "</span> <a href="../../../include/c.h.html#LN314"><span class='Ref_to_Const'>INT64_FORMAT</span></a> <span class='String'>" KB of memory for read buffers among %d input tapes"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>1024</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN372"><span class='Ref_to_Member'>read_buffer_size</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a> <span class='Operator'>/ </span><a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN372"><span class='Ref_to_Member'>read_buffer_size</span></a> <span class='Operator'>* </span><a href="tuplesort.c.html#LN2555"><span class='Ref_To_Local'>numInputTapes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* End of step D2: rewind all output tapes to prepare for merging */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/logtape.h.html#LN33"><span class='Ref_to_Proto'>LogicalTapeRewindForRead</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN372"><span class='Ref_to_Member'>read_buffer_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * At this point we know that tape[T] is empty.  If there's just one 
         * (real or dummy) run left on each input tape, then only one merge 
         * pass remains.  If we don't have to produce a materialized sorted 
         * tape, we can stop at this point and do the final merge on-the-fly. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2692"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>allOneRun</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>+ </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplesort.c.html#LN2692"><span class='Ref_To_Local'>allOneRun</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2692"><span class='Ref_To_Local'>allOneRun</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Tell logtape.c we won't be writing anymore */ 
</span>                <a href="../../../include/utils/logtape.h.html#LN28"><span class='Ref_to_Proto'>LogicalTapeSetForgetFreeSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* Initialize for the final merge pass */ 
</span>                <a href="tuplesort.c.html#LN591"><span class='Ref_to_Proto'>beginmerge</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN236"><span class='Ref_to_EnumConst'>TSS_FINALMERGE</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !state-&GT;randomAccess &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Step D5: merge runs onto tape[T] until tape[P] is empty */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>|| 
</span>               <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2718"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>allDummy</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplesort.c.html#LN2718"><span class='Ref_To_Local'>allDummy</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2718"><span class='Ref_To_Local'>allDummy</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>]</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>]</span><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="tuplesort.c.html#LN590"><span class='Ref_to_Proto'>mergeonerun</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while state-&GT;tp_runs[state-... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Step D6: decrease level */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN413"><span class='Ref_to_Member'>Level</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* rewind output tape T to use as new input */ 
</span>        <a href="../../../include/utils/logtape.h.html#LN33"><span class='Ref_to_Proto'>LogicalTapeRewindForRead</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>], 
</span>                                 <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN372"><span class='Ref_to_Member'>read_buffer_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* rewind used-up input tape P, and prepare it for write pass */ 
</span>        <a href="../../../include/utils/logtape.h.html#LN35"><span class='Ref_to_Proto'>LogicalTapeRewindForWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * reassign tape units per step D6; note we no longer care about A[] 
         */ 
</span>        <a href="tuplesort.c.html#LN2551"><span class='Ref_To_Local'>svTape</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>]; 
</span>        <a href="tuplesort.c.html#LN2553"><span class='Ref_To_Local'>svDummy</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>]; 
</span>        <a href="tuplesort.c.html#LN2552"><span class='Ref_To_Local'>svRuns</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2551"><span class='Ref_To_Local'>svTape</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2553"><span class='Ref_To_Local'>svDummy</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN2552"><span class='Ref_To_Local'>svRuns</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Done.  Knuth says that the result is on TAPE[1], but since we exited 
     * the loop without performing the last iteration of step D6, we have not 
     * rearranged the tape unit assignment, and therefore the result is on 
     * TAPE[T].  We need to do it this way so that we can freeze the final 
     * output tape while rewinding it.  The last iteration of step D6 would be 
     * a waste of cycles anyway... 
     */ 
</span>    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>]; 
</span>    <a href="../../../include/utils/logtape.h.html#LN36"><span class='Ref_to_Proto'>LogicalTapeFreeze</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release the read buffers of all the other tapes, by rewinding them. */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN282"><span class='Ref_to_Member'>maxTapes</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/logtape.h.html#LN35"><span class='Ref_to_Proto'>LogicalTapeRewindForWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2548"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2550"><span class='Ref_To_Local'>tapenum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end mergeruns &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Merge one run from each input tape, except ones with dummy runs. 
 * 
 * This is the inner loop of Algorithm D step D5.  We know that the 
 * output tape is TAPE[T]. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2793"></a><span class='Declare_Function'>mergeonerun</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2795"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>destTape</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>]; 
</span><a name="LN2796"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>srcTape</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Start the merge by loading one tuple from each active source tape into 
     * the heap.  We can also decrease the input run/dummy run counts. 
     */ 
</span>    <a href="tuplesort.c.html#LN591"><span class='Ref_to_Proto'>beginmerge</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Execute merge by repeatedly extracting lowest tuple in heap, writing it 
     * out, and replacing it with next tuple from same tape (if there is 
     * another one). 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2811"></a>        <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* write the tuple to destTape */ 
</span>        <a href="tuplesort.c.html#LN2796"><span class='Ref_To_Local'>srcTape</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN183"><span class='Ref_to_Macro'>WRITETUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2795"><span class='Ref_To_Local'>destTape</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* recycle the slot of the tuple we just wrote out, for the next read */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>) 
</span>            <a href="tuplesort.c.html#LN507"><span class='Ref_to_Macro'>RELEASE_SLAB_SLOT</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * pull next tuple from the tape, and replace the written-out tuple in 
         * the heap with it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN592"><span class='Ref_to_Proto'>mergereadnext</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2796"><span class='Ref_To_Local'>srcTape</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2811"><span class='Ref_To_Local'>stup</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN2811"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2796"><span class='Ref_To_Local'>srcTape</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN600"><span class='Ref_to_Proto'>tuplesort_heap_replace_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2811"><span class='Ref_To_Local'>stup</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="tuplesort.c.html#LN602"><span class='Ref_to_Proto'>tuplesort_heap_delete_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while state-&GT;memtupcount&GT;0 &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * When the heap empties, we're done.  Write an end-of-run marker on the 
     * output tape, and increment its count of real runs. 
     */ 
</span>    <a href="tuplesort.c.html#LN605"><span class='Ref_to_Proto'>markrunend</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2795"><span class='Ref_To_Local'>destTape</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>]</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"finished %d-way merge step: %s"</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN419"><span class='Ref_to_Member'>activeTapes</span></a><span class='Delimiter'>, 
</span>             <a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2793"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end mergeonerun &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * beginmerge - initialize for a merge pass 
 * 
 * We decrease the counts of real and dummy runs for each tape, and mark 
 * which tapes contain active input runs in mergeactive[].  Then, fill the 
 * merge heap with the first tuple from each active tape. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2857"></a><span class='Declare_Function'>beginmerge</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2859"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>activeTapes</span><span class='Delimiter'>; 
</span><a name="LN2860"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tapenum</span><span class='Delimiter'>; 
</span><a name="LN2861"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>srcTape</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Heap should be empty here */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Adjust run counts and mark the active tapes */ 
</span>    memset<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN406"><span class='Ref_to_Member'>mergeactive</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>           <a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN282"><span class='Ref_to_Member'>maxTapes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN406"><span class='Ref_to_Member'>mergeactive</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2859"><span class='Ref_To_Local'>activeTapes</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN283"><span class='Ref_to_Member'>tapeRange</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>]</span><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>]</span><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2861"><span class='Ref_To_Local'>srcTape</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2860"><span class='Ref_To_Local'>tapenum</span></a><span class='Delimiter'>]; 
</span>            <a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN406"><span class='Ref_to_Member'>mergeactive</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2861"><span class='Ref_To_Local'>srcTape</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2859"><span class='Ref_To_Local'>activeTapes</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2859"><span class='Ref_To_Local'>activeTapes</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN419"><span class='Ref_to_Member'>activeTapes</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2859"><span class='Ref_To_Local'>activeTapes</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Load the merge heap with the first tuple from each input tape */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2861"><span class='Ref_To_Local'>srcTape</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2861"><span class='Ref_To_Local'>srcTape</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN282"><span class='Ref_to_Member'>maxTapes</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN2861"><span class='Ref_To_Local'>srcTape</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2889"></a>        <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN592"><span class='Ref_to_Proto'>mergereadnext</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2861"><span class='Ref_To_Local'>srcTape</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2889"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN2889"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN2861"><span class='Ref_To_Local'>srcTape</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN598"><span class='Ref_to_Proto'>tuplesort_heap_insert</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2857"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2889"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end beginmerge &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * mergereadnext - read next tuple from one merge input tape 
 * 
 * Returns false on EOF. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2905"></a><span class='Declare_Function'>mergereadnext</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>srcTape</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2907"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN406"><span class='Ref_to_Member'>mergeactive</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>srcTape</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* tape's run is already exhausted */ 
</span> 
    <span class='Comment_Multi_Line'>/* read next tuple, if any */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN2907"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN240"><span class='Ref_to_Proto'>getlen</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>srcTape</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN406"><span class='Ref_to_Member'>mergeactive</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>srcTape</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplestore.c.html#LN184"><span class='Ref_to_Macro'>READTUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>stup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2905"><span class='Ref_to_Parameter'>srcTape</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2907"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * dumptuples - remove tuples from memtuples and write to tape 
 * 
 * This is used during initial-run building, but not during merging. 
 * 
 * When alltuples = false and replacement selection is still active, dump 
 * only enough tuples to get under the availMem limit (and leave at least 
 * one tuple in memtuples, since puttuple will then assume it is a heap that 
 * has a tuple to compare to).  We always insist there be at least one free 
 * slot in the memtuples[] array. 
 * 
 * When alltuples = true, dump everything currently in memory.  (This 
 * case is only used at end of input data, although in practice only the 
 * first run could fail to dump all tuples when we LACKMEM(), and only 
 * when replacement selection is active.) 
 * 
 * If, when replacement selection is active, we see that the tuple run 
 * number at the top of the heap has changed, start a new run.  This must be 
 * the first run, because replacement selection is always abandoned for all 
 * further runs. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2945"></a><span class='Declare_Function'>dumptuples</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>alltuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>alltuples</span></a> <span class='Operator'>|| 
</span>           <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Macro'>LACKMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>           <a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN387"><span class='Ref_to_Member'>replaceActive</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Still holding out for a case favorable to replacement 
             * selection. Still incrementally spilling using heap. 
             * 
             * Dump the heap's frontmost entry, and remove it from the heap. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN183"><span class='Ref_to_Macro'>WRITETUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>], 
</span>                     <span class='Operator'>&</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN602"><span class='Ref_to_Proto'>tuplesort_heap_delete_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Once committed to quicksorting runs, never incrementally spill 
             */ 
</span>            <a href="tuplesort.c.html#LN594"><span class='Ref_to_Proto'>dumpbatch</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>alltuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If top run number has changed, we've finished the current run (this 
         * can only be the first run), and will no longer spill incrementally. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>            <a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN261"><span class='Ref_to_Const'>HEAP_RUN_NEXT</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN605"><span class='Ref_to_Proto'>markrunend</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>]</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>]</span><span class='Operator'>--</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* per Alg D step D2 */ 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"finished incrementally writing %s run %d to tape %d: %s"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>"only"</span> <span class='Operator'>: </span><span class='String'>"first"</span><span class='Delimiter'>, 
</span>                     <a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>, 
</span>                     <a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Done if heap is empty, which is possible when there is only one 
             * long run. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN262"><span class='Ref_to_Const'>RUN_SECOND</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Replacement selection best case; no final merge required, 
                 * because there was only one initial run (second run has no 
                 * tuples).  See RUN_SECOND case in mergeruns(). 
                 */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Abandon replacement selection for second run (as well as any 
             * subsequent runs). 
             */ 
</span>            <a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN387"><span class='Ref_to_Member'>replaceActive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * First tuple of next run should not be heapified, and so will 
             * bear placeholder run number.  In practice this must actually be 
             * the second run, which just became the currentRun, so we're 
             * clear to quicksort and dump the tuples in batch next time 
             * memtuples becomes full. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN261"><span class='Ref_to_Const'>HEAP_RUN_NEXT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN587"><span class='Ref_to_Proto'>selectnewtape</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN2945"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;memtupcount==0... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while alltuples||(LACKMEM(s... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end dumptuples &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * dumpbatch - sort and dump all memtuples, forming one run on tape 
 * 
 * Second or subsequent runs are never heapified by this module (although 
 * heapification still respects run number differences between the first and 
 * second runs), and a heap (replacement selection priority queue) is often 
 * avoided in the first place. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3037"></a><span class='Declare_Function'>dumpbatch</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>alltuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3039"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>memtupwrite</span><span class='Delimiter'>; 
</span><a name="LN3040"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Final call might require no sorting, in rare cases where we just so 
     * happen to have previously LACKMEM()'d at the point where exactly all 
     * remaining tuples are loaded into memory, just before input was 
     * exhausted. 
     * 
     * In general, short final runs are quite possible.  Rather than allowing 
     * a special case where there was a superfluous selectnewtape() call (i.e. 
     * a call with no subsequent run actually written to destTape), we prefer 
     * to write out a 0 tuple run. 
     * 
     * mergereadnext() is prepared for 0 tuple runs, and will reliably mark 
     * the tape inactive for the merge when called from beginmerge().  This 
     * case is therefore similar to the case where mergeonerun() finds a dummy 
     * run for the tape, and so doesn't need to merge a run from the tape (or 
     * conceptually "merges" the dummy run, if you prefer).  According to 
     * Knuth, Algorithm D "isn't strictly optimal" in its method of 
     * distribution and dummy run assignment; this edge case seems very 
     * unlikely to make that appreciably worse. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN233"><span class='Ref_to_EnumConst'>TSS_BUILDRUNS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It seems unlikely that this limit will ever be exceeded, but take no 
     * chances 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>== </span>INT_MAX<span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROGRAM_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot have more than %d runs for an external sort"</span><span class='Delimiter'>, 
</span>                        INT_MAX<span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"starting quicksort of run %d: %s"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Sort all tuples accumulated within the allowed amount of memory for 
     * this run using quicksort 
     */ 
</span>    <a href="tuplesort.c.html#LN597"><span class='Ref_to_Proto'>tuplesort_sort_memtuples</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"finished quicksort of run %d: %s"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="tuplesort.c.html#LN3039"><span class='Ref_To_Local'>memtupwrite</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3040"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3040"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3039"><span class='Ref_To_Local'>memtupwrite</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3040"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN183"><span class='Ref_to_Macro'>WRITETUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>], 
</span>                 <span class='Operator'>&</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3040"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset tuple memory.  We've freed all of the tuples that we previously 
     * allocated.  It's important to avoid fragmentation when there is a stark 
     * change in the sizes of incoming tuples.  Fragmentation due to 
     * AllocSetFree's bucketing by size class might be particularly bad if 
     * this step wasn't taken. 
     */ 
</span>    <a href="../../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN605"><span class='Ref_to_Proto'>markrunend</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN418"><span class='Ref_to_Member'>tp_tapenum</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN416"><span class='Ref_to_Member'>tp_runs</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>]</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN417"><span class='Ref_to_Member'>tp_dummy</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>]</span><span class='Operator'>--</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* per Alg D step D2 */ 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/pg_config_manual.h.html#LN314"><span class='Ref_to_Const'>TRACE_SORT</span></a> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN154"><span class='Ref_to_Global_Var'>trace_sort</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"finished writing run %d to tape %d: %s"</span><span class='Delimiter'>, 
</span>             <a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN414"><span class='Ref_to_Member'>destTape</span></a><span class='Delimiter'>, 
</span>             <a href="../../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN492"><span class='Ref_to_Member'>ru_start</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>alltuples</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN587"><span class='Ref_to_Proto'>selectnewtape</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3037"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end dumpbatch &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplesort_rescan     - rewind and replay the scan 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3130"></a><span class='Declare_Function'>tuplesort_rescan</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3132"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Operator'>: 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Operator'>: 
</span>            <a href="../../../include/utils/logtape.h.html#LN33"><span class='Ref_to_Proto'>LogicalTapeRewindForRead</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, 
</span>                                     <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, 
</span>                                     <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN431"><span class='Ref_to_Member'>markpos_block</span></a> <span class='Operator'>= </span><span class='Number'>0L</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3130"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplesort state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3132"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_rescan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplesort_markpos    - saves current position in the merged sort file 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3165"></a><span class='Declare_Function'>tuplesort_markpos</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3167"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Operator'>: 
</span>            <a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Operator'>: 
</span>            <a href="../../../include/utils/logtape.h.html#LN41"><span class='Ref_to_Proto'>LogicalTapeTell</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN431"><span class='Ref_to_Member'>markpos_block</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3165"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplesort state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3167"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_markpos &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplesort_restorepos - restores current position in merged sort file to 
 *                        last saved position 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3197"></a><span class='Declare_Function'>tuplesort_restorepos</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3199"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Operator'>: 
</span>            <a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN427"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Operator'>: 
</span>            <a href="../../../include/utils/logtape.h.html#LN39"><span class='Ref_to_Proto'>LogicalTapeSeek</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN426"><span class='Ref_to_Member'>result_tape</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN431"><span class='Ref_to_Member'>markpos_block</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN432"><span class='Ref_to_Member'>markpos_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN428"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3197"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN433"><span class='Ref_to_Member'>markpos_eof</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplesort state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3199"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_restorepos &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplesort_get_stats - extract summary statistics 
 * 
 * This can be called after tuplesort_performsort() finishes to obtain 
 * printable summary information about how the sort was performed. 
 * spaceUsed is measured in kilobytes. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3232"></a><span class='Declare_Function'>tuplesort_get_stats</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, 
</span><a name="LN3233"></a>                    <span class='Keyword'>const char </span><span class='Operator'>**</span><span class='Declare_Parameter'>sortMethod</span><span class='Delimiter'>, 
</span><a name="LN3234"></a>                    <span class='Keyword'>const char </span><span class='Operator'>**</span><span class='Declare_Parameter'>spaceType</span><span class='Delimiter'>, 
</span><a name="LN3235"></a>                    <span class='Keyword'>long </span><span class='Operator'>*</span><span class='Declare_Parameter'>spaceUsed</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Note: it might seem we should provide both memory and disk usage for a 
     * disk-based sort.  However, the current code doesn't track memory space 
     * accurately once we have begun to return tuples to the caller (since we 
     * don't account for pfree's the caller is expected to do), so we cannot 
     * rely on availMem in a disk sort.  This does not seem worth the overhead 
     * to fix.  Is it worth creating an API for the memory context code to 
     * tell us how much is actually used in sortcontext? 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN3234"><span class='Ref_to_Parameter'>spaceType</span></a> <span class='Operator'>= </span><span class='String'>"Disk"</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN3235"><span class='Ref_to_Parameter'>spaceUsed</span></a> <span class='Operator'>= </span><a href="../../../include/utils/logtape.h.html#LN43"><span class='Ref_to_Proto'>LogicalTapeSetBlocks</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Parentheses'>(</span>BLCKSZ <span class='Operator'>/ </span><span class='Number'>1024</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN3234"><span class='Ref_to_Parameter'>spaceType</span></a> <span class='Operator'>= </span><span class='String'>"Memory"</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="tuplesort.c.html#LN3235"><span class='Ref_to_Parameter'>spaceUsed</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN281"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>- </span><a href="tuplesort.c.html#LN3232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN280"><span class='Ref_to_Member'>availMem</span></a> <span class='Operator'>+ </span><span class='Number'>1023</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>1024</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN277"><span class='Ref_to_Member'>boundUsed</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="tuplesort.c.html#LN3233"><span class='Ref_to_Parameter'>sortMethod</span></a> <span class='Operator'>= </span><span class='String'>"top-N heapsort"</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <span class='Operator'>*</span><a href="tuplesort.c.html#LN3233"><span class='Ref_to_Parameter'>sortMethod</span></a> <span class='Operator'>= </span><span class='String'>"quicksort"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN235"><span class='Ref_to_EnumConst'>TSS_SORTEDONTAPE</span></a><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="tuplesort.c.html#LN3233"><span class='Ref_to_Parameter'>sortMethod</span></a> <span class='Operator'>= </span><span class='String'>"external sort"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplesort.c.html#LN236"><span class='Ref_to_EnumConst'>TSS_FINALMERGE</span></a><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="tuplesort.c.html#LN3233"><span class='Ref_to_Parameter'>sortMethod</span></a> <span class='Operator'>= </span><span class='String'>"external merge"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="tuplesort.c.html#LN3233"><span class='Ref_to_Parameter'>sortMethod</span></a> <span class='Operator'>= </span><span class='String'>"still in progress"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_get_stats &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Heap manipulation routines, per Knuth's Algorithm 5.2.3H. 
 * 
 * Compare two SortTuples.  If checkIndex is true, use the tuple index 
 * as the front of the sort key; otherwise, no. 
 * 
 * Note that for checkIndex callers, the heap invariant is never 
 * maintained beyond the first run, and so there are no COMPARETUP() 
 * calls needed to distinguish tuples in HEAP_RUN_NEXT. 
 */ 
</span> 
<a name="LN3289"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>HEAPCOMPARE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>tup1</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>tup2</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span>checkIndex <span class='Operator'>&& </span><span class='Parentheses'>((</span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Parameter'>tup1</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>tupindex <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Parameter'>tup2</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>tupindex <span class='Operator'>|| \ 
</span>                    <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Parameter'>tup1</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>tupindex <span class='Operator'>== </span><a href="tuplesort.c.html#LN261"><span class='Ref_to_Const'>HEAP_RUN_NEXT</span></a><span class='Parentheses'>)</span> <span class='Operator'>? \ 
</span>     <span class='Parentheses'>((</span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Parameter'>tup1</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>tupindex<span class='Parentheses'>)</span> <span class='Operator'>- </span><span class='Parentheses'>((</span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Parameter'>tup2</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>tupindex<span class='Parentheses'>)</span> <span class='Operator'>: \ 
</span>     <a href="tuplesort.c.html#LN519"><span class='Ref_to_Macro'>COMPARETUP</span></a><span class='Parentheses'>(</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Parameter'>tup1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Parameter'>tup2</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Convert the existing unordered array of SortTuples to a bounded heap, 
 * discarding all but the smallest "state-&GT;bound" tuples. 
 * 
 * When working with a bounded heap, we want to keep the largest entry 
 * at the root (array entry zero), instead of the smallest as in the normal 
 * sort case.  This allows us to discard the largest entry cheaply. 
 * Therefore, we temporarily reverse the sort direction. 
 * 
 * We assume that all entries in a bounded heap will always have tupindex 
 * zero; it therefore doesn't matter that HEAPCOMPARE() doesn't reverse 
 * the direction of comparison for tupindexes. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3309"></a><span class='Declare_Function'>make_bounded_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3311"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tupcount</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span><a name="LN3312"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN231"><span class='Ref_to_EnumConst'>TSS_INITIAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3311"><span class='Ref_To_Local'>tupcount</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Reverse sort direction so largest entry will be at root */ 
</span>    <a href="tuplesort.c.html#LN603"><span class='Ref_to_Proto'>reversedirection</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* make the heap empty */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3312"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3312"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3311"><span class='Ref_To_Local'>tupcount</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3312"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Insert next tuple into heap */ 
</span>            <span class='Comment_Multi_Line'>/* Must copy source tuple to avoid possible overwrite */ 
</span><a name="LN3328"></a>            <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3312"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="tuplesort.c.html#LN3328"><span class='Ref_To_Local'>stup</span></a><span class='Operator'>.</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* not used */ 
</span>            <a href="tuplesort.c.html#LN598"><span class='Ref_to_Proto'>tuplesort_heap_insert</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3328"><span class='Ref_To_Local'>stup</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The heap is full.  Replace the largest entry with the new 
             * tuple, or just discard it, if it's larger than anything already 
             * in the heap. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN519"><span class='Ref_to_Macro'>COMPARETUP</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3312"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="tuplesort.c.html#LN637"><span class='Ref_to_Proto'>free_sort_tuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3312"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="tuplesort.c.html#LN600"><span class='Ref_to_Proto'>tuplesort_heap_replace_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3312"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;tupcount;i++ &raquo; </span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3309"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN232"><span class='Ref_to_EnumConst'>TSS_BOUNDED</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_bounded_heap &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Convert the bounded heap to a properly-sorted array 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3358"></a><span class='Declare_Function'>sort_bounded_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3360"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tupcount</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN232"><span class='Ref_to_EnumConst'>TSS_BOUNDED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN275"><span class='Ref_to_Member'>bounded</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3360"><span class='Ref_To_Local'>tupcount</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN278"><span class='Ref_to_Member'>bound</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can unheapify in place because each delete-top call will remove the 
     * largest entry, which we can promptly store in the newly freed slot at 
     * the end.  Once we're down to a single-entry heap, we're done. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3373"></a>        <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>   <span class='Declare_Local'>stup</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* this sifts-up the next-largest entry and decreases memtupcount */ 
</span>        <a href="tuplesort.c.html#LN602"><span class='Ref_to_Proto'>tuplesort_heap_delete_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN3373"><span class='Ref_To_Local'>stup</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3360"><span class='Ref_To_Local'>tupcount</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reverse sort direction back to the original state.  This is not 
     * actually necessary but seems like a good idea for tidiness. 
     */ 
</span>    <a href="tuplesort.c.html#LN603"><span class='Ref_to_Proto'>reversedirection</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN272"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN234"><span class='Ref_to_EnumConst'>TSS_SORTEDINMEM</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN277"><span class='Ref_to_Member'>boundUsed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end sort_bounded_heap &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Sort all memtuples using specialized qsort() routines. 
 * 
 * Quicksort is used for small in-memory sorts.  Quicksort is also generally 
 * preferred to replacement selection for generating runs during external sort 
 * operations, although replacement selection is sometimes used for the first 
 * run. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3400"></a><span class='Declare_Function'>tuplesort_sort_memtuples</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Can we use the single-key sort function? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN447"><span class='Ref_to_Member'>onlyKey</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            qsort_ssup<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>, 
</span>                       <a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN447"><span class='Ref_to_Member'>onlyKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            qsort_tuple<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>, 
</span>                        <a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>, 
</span>                        <a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN297"><span class='Ref_to_Member'>comparetup</span></a><span class='Delimiter'>, 
</span>                        <a href="tuplesort.c.html#LN3400"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert a new tuple into an empty or existing heap, maintaining the 
 * heap invariant.  Caller is responsible for ensuring there's room. 
 * 
 * Note: For some callers, tuple points to a memtuples[] entry above the 
 * end of the heap.  This is safe as long as it's not immediately adjacent 
 * to the end of the heap (ie, in the [memtupcount] array entry) --- if it 
 * is, it might get overwritten before being moved into the heap! 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3426"></a><span class='Declare_Function'>tuplesort_heap_insert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN3427"></a>                      <span class='Keyword'>bool </span><span class='Declare_Parameter'>checkIndex</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3429"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>memtuples</span><span class='Delimiter'>; 
</span><a name="LN3430"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN3429"><span class='Ref_To_Local'>memtuples</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3426"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3426"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3426"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN335"><span class='Ref_to_Member'>memtupsize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3427"><span class='Ref_to_Parameter'>checkIndex</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN3426"><span class='Ref_to_Parameter'>tuple</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN203"><span class='Ref_to_Member'>tupindex</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is 
     * using 1-based array indexes, not 0-based. 
     */ 
</span>    <a href="tuplesort.c.html#LN3430"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3426"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3430"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3445"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3430"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>&GT;&GT; </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Macro'>HEAPCOMPARE</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3426"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3429"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3445"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3429"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3430"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN3429"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3445"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <a href="tuplesort.c.html#LN3430"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3445"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplesort.c.html#LN3429"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3430"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= *</span><a href="tuplesort.c.html#LN3426"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_heap_insert &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove the tuple at state-&GT;memtuples[0] from the heap.  Decrement 
 * memtupcount, and sift up to maintain the heap invariant. 
 * 
 * The caller has already free'd the tuple the top node points to, 
 * if necessary. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3463"></a><span class='Declare_Function'>tuplesort_heap_delete_top</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>checkIndex</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3465"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>memtuples</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3463"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>; 
</span><a name="LN3466"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3463"><span class='Ref_to_Parameter'>checkIndex</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN3463"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><a href="tuplesort.c.html#LN3463"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove the last tuple in the heap, and re-insert it, by replacing the 
     * current top node with it. 
     */ 
</span>    <a href="tuplesort.c.html#LN3466"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= &</span><a href="tuplesort.c.html#LN3465"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3463"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>]; 
</span>    <a href="tuplesort.c.html#LN600"><span class='Ref_to_Proto'>tuplesort_heap_replace_top</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3463"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3466"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3463"><span class='Ref_to_Parameter'>checkIndex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Replace the tuple at state-&GT;memtuples[0] with a new tuple.  Sift up to 
 * maintain the heap invariant. 
 * 
 * This corresponds to Knuth's "sift-up" algorithm (Algorithm 5.2.3H, 
 * Heapsort, steps H3-H8). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3488"></a><span class='Declare_Function'>tuplesort_heap_replace_top</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN3489"></a>                           <span class='Keyword'>bool </span><span class='Declare_Parameter'>checkIndex</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3491"></a>    <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>memtuples</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3488"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>; 
</span><a name="LN3492"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN3493"></a>                <span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3489"><span class='Ref_to_Parameter'>checkIndex</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN3488"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN394"><span class='Ref_to_Member'>currentRun</span></a> <span class='Operator'>== </span><a href="tuplesort.c.html#LN260"><span class='Ref_to_Const'>RUN_FIRST</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3488"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN3493"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3488"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3492"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>                      <span class='Comment_Single_Line'>/* i is where the "hole" is */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3504"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span> <span class='Operator'>= </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="tuplesort.c.html#LN3492"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT;= </span><a href="tuplesort.c.html#LN3493"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3493"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>&& 
</span>            <a href="tuplesort.c.html#LN3289"><span class='Ref_to_Macro'>HEAPCOMPARE</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3491"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>], </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3491"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3289"><span class='Ref_to_Macro'>HEAPCOMPARE</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3488"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3491"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3491"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3492"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplesort.c.html#LN3491"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span>        <a href="tuplesort.c.html#LN3492"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3504"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplesort.c.html#LN3491"><span class='Ref_To_Local'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3492"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= *</span><a href="tuplesort.c.html#LN3488"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplesort_heap_replace_top &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Function to reverse the sort direction from its current state 
 * 
 * It is not safe to call this when performing hash tuplesorts 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3525"></a><span class='Declare_Function'>reversedirection</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3527"></a>    <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>sortKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3525"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>; 
</span><a name="LN3528"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nkey</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3528"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3528"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3525"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3528"><span class='Ref_To_Local'>nkey</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3527"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN3527"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN73"><span class='Ref_to_Member'>ssup_reverse</span></a> <span class='Operator'>= !</span><a href="tuplesort.c.html#LN3527"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN73"><span class='Ref_to_Member'>ssup_reverse</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3527"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN74"><span class='Ref_to_Member'>ssup_nulls_first</span></a> <span class='Operator'>= !</span><a href="tuplesort.c.html#LN3527"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN74"><span class='Ref_to_Member'>ssup_nulls_first</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Tape interface routines 
 */ 
</span> 
<span class='Keyword'>static unsigned int 
</span><a name="LN3543"></a><span class='Declare_Function'>getlen</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>eofOK</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3545"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/logtape.h.html#LN29"><span class='Ref_to_Proto'>LogicalTapeRead</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3543"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3543"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="tuplesort.c.html#LN3545"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3545"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3545"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected end of tape"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3545"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="tuplesort.c.html#LN3543"><span class='Ref_to_Parameter'>eofOK</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected end of data"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="tuplesort.c.html#LN3545"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN3556"></a><span class='Declare_Function'>markrunend</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3558"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>len</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3556"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3556"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3558"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3558"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get memory for tuple from within READTUP() routine. 
 * 
 * We use next free slot from the slab allocator, or palloc() if the tuple 
 * is too large for that. 
 */ 
</span><span class='Keyword'>static void </span><span class='Operator'>* 
</span><a name="LN3570"></a><span class='Declare_Function'>readtup_alloc</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>tuplen</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3572"></a>    <a href="tuplesort.c.html#LN219"><span class='Ref_to_Union'>SlabSlot</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We pre-allocate enough slots in the slab arena that we should never run 
     * out. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3570"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN369"><span class='Ref_to_Member'>slabFreeHead</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3570"><span class='Ref_to_Parameter'>tuplen</span></a> <span class='Operator'>&GT; </span><a href="tuplesort.c.html#LN217"><span class='Ref_to_Const'>SLAB_SLOT_SIZE</span></a> <span class='Operator'>|| !</span><a href="tuplesort.c.html#LN3570"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN369"><span class='Ref_to_Member'>slabFreeHead</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../../include/utils/palloc.h.html#LN70"><span class='Ref_to_Proto'>MemoryContextAlloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3570"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN284"><span class='Ref_to_Member'>sortcontext</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3570"><span class='Ref_to_Parameter'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN3572"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3570"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN369"><span class='Ref_to_Member'>slabFreeHead</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Reuse this slot */ 
</span>        <a href="tuplesort.c.html#LN3570"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN369"><span class='Ref_to_Member'>slabFreeHead</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3572"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN221"><span class='Ref_to_Member'>nextfree</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="tuplesort.c.html#LN3572"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end readtup_alloc &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Routines specialized for HeapTuple (actually MinimalTuple) case 
 */ 
</span> 
<span class='Keyword'>static int 
</span><a name="LN3598"></a><span class='Declare_Function'>comparetup_heap</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3600"></a>    <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>sortKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>; 
</span><a name="LN3601"></a>    <a href="../../../include/access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Local'>ltup</span><span class='Delimiter'>; 
</span><a name="LN3602"></a>    <a href="../../../include/access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Local'>rtup</span><span class='Delimiter'>; 
</span><a name="LN3603"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupDesc</span><span class='Delimiter'>; 
</span><a name="LN3604"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nkey</span><span class='Delimiter'>; 
</span><a name="LN3605"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>compare</span><span class='Delimiter'>; 
</span><a name="LN3606"></a>    <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attno</span><span class='Delimiter'>; 
</span><a name="LN3607"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>datum1</span><span class='Delimiter'>, 
</span><a name="LN3608"></a>                <span class='Declare_Local'>datum2</span><span class='Delimiter'>; 
</span><a name="LN3609"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull1</span><span class='Delimiter'>, 
</span><a name="LN3610"></a>                <span class='Declare_Local'>isnull2</span><span class='Delimiter'>; 
</span> 
 
    <span class='Comment_Multi_Line'>/* Compare the leading sort key */ 
</span>    <a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                  <a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                  <a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compare additional sort keys */ 
</span>    <a href="tuplesort.c.html#LN3601"><span class='Ref_To_Local'>ltup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>t_len <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3601"><span class='Ref_To_Local'>ltup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>- </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3602"><span class='Ref_To_Local'>rtup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>t_len <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3602"><span class='Ref_To_Local'>rtup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>- </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3603"><span class='Ref_To_Local'>tupDesc</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN3606"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN3607"><span class='Ref_To_Local'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3601"><span class='Ref_To_Local'>ltup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3606"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3603"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3609"><span class='Ref_To_Local'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3608"><span class='Ref_To_Local'>datum2</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3602"><span class='Ref_To_Local'>rtup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3606"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3603"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3610"><span class='Ref_To_Local'>isnull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN237"><span class='Ref_to_Func'>ApplySortAbbrevFullComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3607"><span class='Ref_To_Local'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3609"><span class='Ref_To_Local'>isnull1</span></a><span class='Delimiter'>, 
</span>                                                <a href="tuplesort.c.html#LN3608"><span class='Ref_To_Local'>datum2</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3610"><span class='Ref_To_Local'>isnull2</span></a><span class='Delimiter'>, 
</span>                                                <a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3604"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3604"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3598"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3604"><span class='Ref_To_Local'>nkey</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN3606"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN3607"><span class='Ref_To_Local'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3601"><span class='Ref_To_Local'>ltup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3606"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3603"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3609"><span class='Ref_To_Local'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3608"><span class='Ref_To_Local'>datum2</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3602"><span class='Ref_To_Local'>rtup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3606"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3603"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3610"><span class='Ref_To_Local'>isnull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3607"><span class='Ref_To_Local'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3609"><span class='Ref_To_Local'>isnull1</span></a><span class='Delimiter'>, 
</span>                                      <a href="tuplesort.c.html#LN3608"><span class='Ref_To_Local'>datum2</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3610"><span class='Ref_To_Local'>isnull2</span></a><span class='Delimiter'>, 
</span>                                      <a href="tuplesort.c.html#LN3600"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tuplesort.c.html#LN3605"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end comparetup_heap &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN3660"></a><span class='Declare_Function'>copytup_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We expect the passed "tup" to be a TupleTableSlot, and form a 
     * MinimalTuple using the exported interface for that. 
     */ 
</span><a name="LN3666"></a>    <a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>tup</span></a><span class='Delimiter'>; 
</span><a name="LN3667"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>original</span><span class='Delimiter'>; 
</span><a name="LN3668"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN3669"></a>    <a href="../../../include/access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Local'>htup</span><span class='Delimiter'>; 
</span><a name="LN3670"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* copy the tuple into sort storage */ 
</span>    <a href="tuplesort.c.html#LN3668"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/executor/tuptable.h.html#LN158"><span class='Ref_to_Proto'>ExecCopySlotMinimalTuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3666"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3668"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3668"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* set up first-column key value */ 
</span>    <a href="tuplesort.c.html#LN3669"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3668"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN628"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3669"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3668"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>- </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3667"><span class='Ref_To_Local'>original</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3669"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3670"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Store ordinary Datum representation, or NULL value.  If there is a 
         * converter it won't expect NULL values, and cost model is not 
         * required to account for NULL, so in that case we avoid calling 
         * converter and just set datum1 to zeroed representation (to be 
         * consistent, and to support cheap inequality tests for NULL 
         * abbreviated keys). 
         */ 
</span>        <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3667"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN584"><span class='Ref_to_Proto'>consider_abort_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Store abbreviated key representation */ 
</span>        <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3667"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>, 
</span>                                                         <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Abort abbreviation */ 
</span><a name="LN3707"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3667"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set state to be consistent with never trying abbreviation. 
         * 
         * Alter datum1 representation in already-copied tuples, so as to 
         * ensure a consistent representation (current tuple was just 
         * handled).  It does not matter if some dumped tuples are already 
         * sorted on tape, since serialized tuples lack abbreviated keys 
         * (TSS_BUILDRUNS state prevents control reaching here in any case). 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3707"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3707"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3707"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3722"></a>            <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>mtup</span> <span class='Operator'>= &</span><a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3707"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="tuplesort.c.html#LN3669"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3722"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>t_len <span class='Operator'>+ 
</span>                <a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3669"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3722"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>- 
</span>                                             <a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="tuplesort.c.html#LN3722"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3669"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>, 
</span>                                        <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a><span class='Delimiter'>, 
</span>                                        <a href="tuplesort.c.html#LN3660"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="tuplesort.c.html#LN3722"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end copytup_heap &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN3738"></a><span class='Declare_Function'>writetup_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3740"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* the part of the MinimalTuple we'll write: */ 
</span><a name="LN3743"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>tupbody</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3740"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span><a name="LN3744"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tupbodylen</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3740"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN628"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>- </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* total on-disk footprint: */ 
</span><a name="LN3747"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3744"><span class='Ref_To_Local'>tupbodylen</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3747"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3747"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3743"><span class='Ref_To_Local'>tupbody</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3744"><span class='Ref_To_Local'>tupbodylen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3747"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3747"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3738"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3740"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/htup_details.h.html#LN818"><span class='Ref_to_Proto'>heap_free_minimal_tuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3740"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end writetup_heap &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN3765"></a><span class='Declare_Function'>readtup_heap</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN3766"></a>             <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3768"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tupbodylen</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3766"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3769"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3768"><span class='Ref_To_Local'>tupbodylen</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span><a name="LN3770"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN606"><span class='Ref_to_Proto'>readtup_alloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3769"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3771"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>tupbody</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3770"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span><a name="LN3772"></a>    <a href="../../../include/access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Local'>htup</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* read in the tuple proper */ 
</span>    <a href="tuplesort.c.html#LN3770"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN628"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3769"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3766"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <a href="tuplesort.c.html#LN3771"><span class='Ref_To_Local'>tupbody</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3768"><span class='Ref_To_Local'>tupbodylen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3766"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="tuplesort.c.html#LN3769"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3769"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3770"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* set up first-column key value */ 
</span>    <a href="tuplesort.c.html#LN3772"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3770"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN628"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3772"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3770"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>- </span><a href="../../../include/access/htup_details.h.html#LN619"><span class='Ref_to_Const'>MINIMAL_TUPLE_OFFSET</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3772"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="tuplesort.c.html#LN3765"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end readtup_heap &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Routines specialized for the CLUSTER case (HeapTuple data, with 
 * comparisons per a btree index definition) 
 */ 
</span> 
<span class='Keyword'>static int 
</span><a name="LN3797"></a><span class='Declare_Function'>comparetup_cluster</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN3798"></a>                   <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3800"></a>    <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>sortKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>; 
</span><a name="LN3801"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>ltup</span><span class='Delimiter'>; 
</span><a name="LN3802"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>rtup</span><span class='Delimiter'>; 
</span><a name="LN3803"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupDesc</span><span class='Delimiter'>; 
</span><a name="LN3804"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nkey</span><span class='Delimiter'>; 
</span><a name="LN3805"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>compare</span><span class='Delimiter'>; 
</span><a name="LN3806"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>datum1</span><span class='Delimiter'>, 
</span><a name="LN3807"></a>                <span class='Declare_Local'>datum2</span><span class='Delimiter'>; 
</span><a name="LN3808"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull1</span><span class='Delimiter'>, 
</span><a name="LN3809"></a>                <span class='Declare_Local'>isnull2</span><span class='Delimiter'>; 
</span><a name="LN3810"></a>    <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>leading</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* Be prepared to compare additional sort keys */ 
</span>    <a href="tuplesort.c.html#LN3801"><span class='Ref_To_Local'>ltup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3797"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3802"><span class='Ref_To_Local'>rtup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3797"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3803"><span class='Ref_To_Local'>tupDesc</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compare the leading sort key, if it's simple */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3810"><span class='Ref_To_Local'>leading</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3797"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3797"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                      <a href="tuplesort.c.html#LN3797"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3797"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                      <a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN3806"><span class='Ref_To_Local'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3801"><span class='Ref_To_Local'>ltup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3810"><span class='Ref_To_Local'>leading</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3803"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3808"><span class='Ref_To_Local'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3807"><span class='Ref_To_Local'>datum2</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3802"><span class='Ref_To_Local'>rtup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3810"><span class='Ref_To_Local'>leading</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3803"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3809"><span class='Ref_To_Local'>isnull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN237"><span class='Ref_to_Func'>ApplySortAbbrevFullComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3806"><span class='Ref_To_Local'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3808"><span class='Ref_To_Local'>isnull1</span></a><span class='Delimiter'>, 
</span>                                                    <a href="tuplesort.c.html#LN3807"><span class='Ref_To_Local'>datum2</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3809"><span class='Ref_To_Local'>isnull2</span></a><span class='Delimiter'>, 
</span>                                                    <a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Compare additional columns the hard way */ 
</span>        <a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if leading!=0 &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Must compare all keys the hard way */ 
</span>        <a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* If not expression index, just compare the proper heap attrs */ 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3853"></a>            <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attno</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a><span class='Delimiter'>]; 
</span> 
            <a href="tuplesort.c.html#LN3806"><span class='Ref_To_Local'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3801"><span class='Ref_To_Local'>ltup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3853"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3803"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3808"><span class='Ref_To_Local'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3807"><span class='Ref_To_Local'>datum2</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3802"><span class='Ref_To_Local'>rtup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3853"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3803"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN3809"><span class='Ref_To_Local'>isnull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3806"><span class='Ref_To_Local'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3808"><span class='Ref_To_Local'>isnull1</span></a><span class='Delimiter'>, 
</span>                                          <a href="tuplesort.c.html#LN3807"><span class='Ref_To_Local'>datum2</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3809"><span class='Ref_To_Local'>isnull2</span></a><span class='Delimiter'>, 
</span>                                          <a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * In the expression index case, compute the whole index tuple and 
         * then compare values.  It would perhaps be faster to compute only as 
         * many columns as we need to compare, but that would require 
         * duplicating all the logic in FormIndexDatum. 
         */ 
</span><a name="LN3873"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>l_index_values</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN3874"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>l_index_isnull</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN3875"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>r_index_values</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN3876"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>r_index_isnull</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN3877"></a>        <a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ecxt_scantuple</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Reset context each time to prevent memory leakage */ 
</span>        <a href="../../../include/executor/executor.h.html#LN464"><span class='Ref_to_Macro'>ResetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN3877"><span class='Ref_To_Local'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="../../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ecxt_scantuple<span class='Delimiter'>; 
</span> 
        <a href="../../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3801"><span class='Ref_To_Local'>ltup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3877"><span class='Ref_To_Local'>ecxt_scantuple</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/catalog/index.h.html#LN85"><span class='Ref_to_Proto'>FormIndexDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3877"><span class='Ref_To_Local'>ecxt_scantuple</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a><span class='Delimiter'>, 
</span>                       <a href="tuplesort.c.html#LN3873"><span class='Ref_To_Local'>l_index_values</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3874"><span class='Ref_To_Local'>l_index_isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3802"><span class='Ref_To_Local'>rtup</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3877"><span class='Ref_To_Local'>ecxt_scantuple</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/catalog/index.h.html#LN85"><span class='Ref_to_Proto'>FormIndexDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3877"><span class='Ref_To_Local'>ecxt_scantuple</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN463"><span class='Ref_to_Member'>estate</span></a><span class='Delimiter'>, 
</span>                       <a href="tuplesort.c.html#LN3875"><span class='Ref_To_Local'>r_index_values</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3876"><span class='Ref_To_Local'>r_index_isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3873"><span class='Ref_To_Local'>l_index_values</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a><span class='Delimiter'>], 
</span>                                          <a href="tuplesort.c.html#LN3874"><span class='Ref_To_Local'>l_index_isnull</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a><span class='Delimiter'>], 
</span>                                          <a href="tuplesort.c.html#LN3875"><span class='Ref_To_Local'>r_index_values</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a><span class='Delimiter'>], 
</span>                                          <a href="tuplesort.c.html#LN3876"><span class='Ref_To_Local'>r_index_isnull</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3804"><span class='Ref_To_Local'>nkey</span></a><span class='Delimiter'>], 
</span>                                          <a href="tuplesort.c.html#LN3800"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="tuplesort.c.html#LN3805"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end comparetup_cluster &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN3908"></a><span class='Declare_Function'>copytup_cluster</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3910"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>tup</span></a><span class='Delimiter'>; 
</span><a name="LN3911"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>original</span><span class='Delimiter'>; 
</span><a name="LN3912"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* copy the tuple into sort storage */ 
</span>    <a href="tuplesort.c.html#LN3910"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../access/common/heaptuple.c.html#LN606"><span class='Ref_to_Func'>heap_copytuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3910"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3910"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3910"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3912"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * set up first-column key value, and potentially abbreviate, if it's a 
     * simple column 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN3911"><span class='Ref_To_Local'>original</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3910"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                            <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Store ordinary Datum representation, or NULL value.  If there is a 
         * converter it won't expect NULL values, and cost model is not 
         * required to account for NULL, so in that case we avoid calling 
         * converter and just set datum1 to zeroed representation (to be 
         * consistent, and to support cheap inequality tests for NULL 
         * abbreviated keys). 
         */ 
</span>        <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3911"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN584"><span class='Ref_to_Proto'>consider_abort_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Store abbreviated key representation */ 
</span>        <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3911"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>, 
</span>                                                         <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Abort abbreviation */ 
</span><a name="LN3954"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3911"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set state to be consistent with never trying abbreviation. 
         * 
         * Alter datum1 representation in already-copied tuples, so as to 
         * ensure a consistent representation (current tuple was just 
         * handled).  It does not matter if some dumped tuples are already 
         * sorted on tape, since serialized tuples lack abbreviated keys 
         * (TSS_BUILDRUNS state prevents control reaching here in any case). 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3954"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3954"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN3954"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3969"></a>            <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>mtup</span> <span class='Operator'>= &</span><a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN3954"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="tuplesort.c.html#LN3910"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3969"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN3969"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3910"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                                      <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                        <a href="tuplesort.c.html#LN3908"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="tuplesort.c.html#LN3969"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end copytup_cluster &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN3981"></a><span class='Declare_Function'>writetup_cluster</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3983"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span><a name="LN3984"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN3983"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We need to store t_self, but not other fields of HeapTupleData */ 
</span>    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="tuplesort.c.html#LN3984"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3984"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="tuplesort.c.html#LN3983"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <a href="tuplesort.c.html#LN3983"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3983"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="tuplesort.c.html#LN3984"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3984"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3981"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3983"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN3983"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end writetup_cluster &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN4005"></a><span class='Declare_Function'>readtup_cluster</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN4006"></a>                <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>tuplen</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4008"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>t_len</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4006"><span class='Ref_to_Parameter'>tuplen</span></a> <span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4009"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN606"><span class='Ref_to_Proto'>readtup_alloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, 
</span>                                                  <a href="tuplesort.c.html#LN4008"><span class='Ref_To_Local'>t_len</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup.h.html#LN71"><span class='Ref_to_Const'>HEAPTUPLESIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Reconstruct the HeapTupleData header */ 
</span>    <a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup.h.html#LN71"><span class='Ref_to_Const'>HEAPTUPLESIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4008"><span class='Ref_To_Local'>t_len</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4006"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* We don't currently bother to reconstruct t_tableOid */ 
</span>    <a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN65"><span class='Ref_to_Member'>t_tableOid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Read in the tuple body */ 
</span>    <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4006"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4006"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="tuplesort.c.html#LN4006"><span class='Ref_to_Parameter'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4006"><span class='Ref_to_Parameter'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* set up first-column key value, if it's a simple column */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN768"><span class='Ref_to_Macro'>heap_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4009"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                                    <a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN462"><span class='Ref_to_Member'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                    <a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN440"><span class='Ref_to_Member'>tupDesc</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><a href="tuplesort.c.html#LN4005"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end readtup_cluster &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Routines specialized for IndexTuple case 
 * 
 * The btree and hash cases require separate comparison functions, but the 
 * IndexTuple representation is the same so the copy/write/read support 
 * functions can be shared. 
 */ 
</span> 
<span class='Keyword'>static int 
</span><a name="LN4043"></a><span class='Declare_Function'>comparetup_index_btree</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN4044"></a>                       <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * This is similar to comparetup_heap(), but expects index tuples.  There 
     * is also special handling for enforcing uniqueness, and special 
     * treatment for equal keys at the end. 
     */ 
</span><a name="LN4051"></a>    <a href="../../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>sortKey</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Delimiter'>; 
</span><a name="LN4052"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple1</span><span class='Delimiter'>; 
</span><a name="LN4053"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple2</span><span class='Delimiter'>; 
</span><a name="LN4054"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>keysz</span><span class='Delimiter'>; 
</span><a name="LN4055"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupDes</span><span class='Delimiter'>; 
</span><a name="LN4056"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>equal_hasnull</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN4057"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nkey</span><span class='Delimiter'>; 
</span><a name="LN4058"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>compare</span><span class='Delimiter'>; 
</span><a name="LN4059"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>datum1</span><span class='Delimiter'>, 
</span><a name="LN4060"></a>                <span class='Declare_Local'>datum2</span><span class='Delimiter'>; 
</span><a name="LN4061"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull1</span><span class='Delimiter'>, 
</span><a name="LN4062"></a>                <span class='Declare_Local'>isnull2</span><span class='Delimiter'>; 
</span> 
 
    <span class='Comment_Multi_Line'>/* Compare the leading sort key */ 
</span>    <a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4043"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4043"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                  <a href="tuplesort.c.html#LN4043"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4043"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                  <a href="tuplesort.c.html#LN4051"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compare additional sort keys */ 
</span>    <a href="tuplesort.c.html#LN4052"><span class='Ref_To_Local'>tuple1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4043"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4053"><span class='Ref_To_Local'>tuple2</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4043"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4054"><span class='Ref_To_Local'>keysz</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN273"><span class='Ref_to_Member'>nKeys</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4055"><span class='Ref_To_Local'>tupDes</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4051"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN4059"><span class='Ref_To_Local'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4052"><span class='Ref_To_Local'>tuple1</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4055"><span class='Ref_To_Local'>tupDes</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4061"><span class='Ref_To_Local'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4060"><span class='Ref_To_Local'>datum2</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4053"><span class='Ref_To_Local'>tuple2</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4055"><span class='Ref_To_Local'>tupDes</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4062"><span class='Ref_To_Local'>isnull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN237"><span class='Ref_to_Func'>ApplySortAbbrevFullComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4059"><span class='Ref_To_Local'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4061"><span class='Ref_To_Local'>isnull1</span></a><span class='Delimiter'>, 
</span>                                                <a href="tuplesort.c.html#LN4060"><span class='Ref_To_Local'>datum2</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4062"><span class='Ref_To_Local'>isnull2</span></a><span class='Delimiter'>, 
</span>                                                <a href="tuplesort.c.html#LN4051"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* they are equal, so we only need to examine one null flag */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4043"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN4056"><span class='Ref_To_Local'>equal_hasnull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN4051"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4057"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN4057"><span class='Ref_To_Local'>nkey</span></a> <span class='Operator'>&LT;= </span><a href="tuplesort.c.html#LN4054"><span class='Ref_To_Local'>keysz</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN4057"><span class='Ref_To_Local'>nkey</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4051"><span class='Ref_To_Local'>sortKey</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN4059"><span class='Ref_To_Local'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4052"><span class='Ref_To_Local'>tuple1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4057"><span class='Ref_To_Local'>nkey</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4055"><span class='Ref_To_Local'>tupDes</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4061"><span class='Ref_To_Local'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4060"><span class='Ref_To_Local'>datum2</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4053"><span class='Ref_To_Local'>tuple2</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4057"><span class='Ref_To_Local'>nkey</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4055"><span class='Ref_To_Local'>tupDes</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4062"><span class='Ref_To_Local'>isnull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4059"><span class='Ref_To_Local'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4061"><span class='Ref_To_Local'>isnull1</span></a><span class='Delimiter'>, 
</span>                                      <a href="tuplesort.c.html#LN4060"><span class='Ref_To_Local'>datum2</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4062"><span class='Ref_To_Local'>isnull2</span></a><span class='Delimiter'>, 
</span>                                      <a href="tuplesort.c.html#LN4051"><span class='Ref_To_Local'>sortKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="tuplesort.c.html#LN4058"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* done when we find unequal attributes */ 
</span> 
        <span class='Comment_Multi_Line'>/* they are equal, so we only need to examine one null flag */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4061"><span class='Ref_To_Local'>isnull1</span></a><span class='Parentheses'>) 
</span>            <a href="tuplesort.c.html#LN4056"><span class='Ref_To_Local'>equal_hasnull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If btree has asked us to enforce uniqueness, complain if two equal 
     * tuples are detected (unless there was at least one NULL field). 
     * 
     * It is sufficient to make the test here, because if two tuples are equal 
     * they *must* get compared at some stage of the sort --- otherwise the 
     * sort algorithm wouldn't have checked whether one must appear before the 
     * other. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN473"><span class='Ref_to_Member'>enforceUnique</span></a> <span class='Operator'>&& !</span><a href="tuplesort.c.html#LN4056"><span class='Ref_To_Local'>equal_hasnull</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4122"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN4123"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN4124"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>key_desc</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Some rather brain-dead implementations of qsort (such as the one in 
         * QNX 4) will sometimes call the comparison routine to compare a 
         * value to itself, but we always use our own implementation, which 
         * does not. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4052"><span class='Ref_To_Local'>tuple1</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN4053"><span class='Ref_To_Local'>tuple2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/itup.h.html#LN146"><span class='Ref_to_Proto'>index_deform_tuple</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4052"><span class='Ref_To_Local'>tuple1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4055"><span class='Ref_To_Local'>tupDes</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4122"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4123"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN4124"><span class='Ref_To_Local'>key_desc</span></a> <span class='Operator'>= </span><a href="../../access/index/genam.c.html#LN175"><span class='Ref_to_Func'>BuildIndexValueDescription</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4122"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4123"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNIQUE_VIOLATION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create unique index \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="tuplesort.c.html#LN4124"><span class='Ref_To_Local'>key_desc</span></a> <span class='Operator'>? </span><a href="../error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Key %s is duplicated."</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4124"><span class='Ref_To_Local'>key_desc</span></a><span class='Parentheses'>)</span> <span class='Operator'>: 
</span>                 <a href="../error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Duplicate keys exist."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../../include/utils/relcache.h.html#LN79"><span class='Ref_to_Proto'>errtableconstraint</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN469"><span class='Ref_to_Member'>heapRel</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4044"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;enforceUnique&... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If key values are equal, we sort on ItemPointer.  This does not affect 
     * validity of the finished index, but it may be useful to have index 
     * scans in physical order. 
     */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4154"></a>        <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>blk1</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4052"><span class='Ref_To_Local'>tuple1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4155"></a>        <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>blk2</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4053"><span class='Ref_To_Local'>tuple2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4154"><span class='Ref_To_Local'>blk1</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN4155"><span class='Ref_To_Local'>blk2</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4154"><span class='Ref_To_Local'>blk1</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN4155"><span class='Ref_To_Local'>blk2</span></a><span class='Parentheses'>) </span><span class='Operator'>? -</span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4161"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>pos1</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4052"><span class='Ref_To_Local'>tuple1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4162"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>pos2</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4053"><span class='Ref_To_Local'>tuple2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4161"><span class='Ref_To_Local'>pos1</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN4162"><span class='Ref_To_Local'>pos2</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4161"><span class='Ref_To_Local'>pos1</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN4162"><span class='Ref_To_Local'>pos2</span></a><span class='Parentheses'>) </span><span class='Operator'>? -</span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end comparetup_index_btree &raquo; </span> 
 
<span class='Keyword'>static int 
</span><a name="LN4172"></a><span class='Declare_Function'>comparetup_index_hash</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN4173"></a>                      <a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4175"></a>    <a href="../../../include/access/hash.h.html#LN33"><span class='Ref_to_Typedef'>Bucket</span></a>      <span class='Declare_Local'>bucket1</span><span class='Delimiter'>; 
</span><a name="LN4176"></a>    <a href="../../../include/access/hash.h.html#LN33"><span class='Ref_to_Typedef'>Bucket</span></a>      <span class='Declare_Local'>bucket2</span><span class='Delimiter'>; 
</span><a name="LN4177"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple1</span><span class='Delimiter'>; 
</span><a name="LN4178"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple2</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fetch hash keys and mask off bits we don't want to sort by. We know 
     * that the first column of the index tuple is the hash key. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN4172"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4175"><span class='Ref_To_Local'>bucket1</span></a> <span class='Operator'>= </span><a href="../../access/hash/hashutil.c.html#LN123"><span class='Ref_to_Func'>_hash_hashkey2bucket</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN491"><span class='Ref_to_Macro'>DatumGetUInt32</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4172"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="tuplesort.c.html#LN4173"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN478"><span class='Ref_to_Member'>max_buckets</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4173"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN476"><span class='Ref_to_Member'>high_mask</span></a><span class='Delimiter'>, 
</span>                                   <a href="tuplesort.c.html#LN4173"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN477"><span class='Ref_to_Member'>low_mask</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN4172"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4176"><span class='Ref_To_Local'>bucket2</span></a> <span class='Operator'>= </span><a href="../../access/hash/hashutil.c.html#LN123"><span class='Ref_to_Func'>_hash_hashkey2bucket</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN491"><span class='Ref_to_Macro'>DatumGetUInt32</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4172"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="tuplesort.c.html#LN4173"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN478"><span class='Ref_to_Member'>max_buckets</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4173"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN476"><span class='Ref_to_Member'>high_mask</span></a><span class='Delimiter'>, 
</span>                                   <a href="tuplesort.c.html#LN4173"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN477"><span class='Ref_to_Member'>low_mask</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4175"><span class='Ref_To_Local'>bucket1</span></a> <span class='Operator'>&GT; </span><a href="tuplesort.c.html#LN4176"><span class='Ref_To_Local'>bucket2</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4175"><span class='Ref_To_Local'>bucket1</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN4176"><span class='Ref_To_Local'>bucket2</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If hash values are equal, we sort on ItemPointer.  This does not affect 
     * validity of the finished index, but it may be useful to have index 
     * scans in physical order. 
     */ 
</span>    <a href="tuplesort.c.html#LN4177"><span class='Ref_To_Local'>tuple1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4172"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4178"><span class='Ref_To_Local'>tuple2</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4172"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4206"></a>        <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>blk1</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4177"><span class='Ref_To_Local'>tuple1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4207"></a>        <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>blk2</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4178"><span class='Ref_To_Local'>tuple2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4206"><span class='Ref_To_Local'>blk1</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN4207"><span class='Ref_To_Local'>blk2</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4206"><span class='Ref_To_Local'>blk1</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN4207"><span class='Ref_To_Local'>blk2</span></a><span class='Parentheses'>) </span><span class='Operator'>? -</span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4213"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>pos1</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4177"><span class='Ref_To_Local'>tuple1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4214"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>pos2</span> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4178"><span class='Ref_To_Local'>tuple2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4213"><span class='Ref_To_Local'>pos1</span></a> <span class='Operator'>!= </span><a href="tuplesort.c.html#LN4214"><span class='Ref_To_Local'>pos2</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4213"><span class='Ref_To_Local'>pos1</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN4214"><span class='Ref_To_Local'>pos2</span></a><span class='Parentheses'>) </span><span class='Operator'>? -</span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end comparetup_index_hash &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN4224"></a><span class='Declare_Function'>copytup_index</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4226"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>tup</span></a><span class='Delimiter'>; 
</span><a name="LN4227"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN69"><span class='Ref_to_Macro'>IndexTupleSize</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4226"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4228"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>newtuple</span><span class='Delimiter'>; 
</span><a name="LN4229"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>original</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* copy the tuple into sort storage */ 
</span>    <a href="tuplesort.c.html#LN4228"><span class='Ref_To_Local'>newtuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="../../../include/utils/palloc.h.html#LN70"><span class='Ref_to_Proto'>MemoryContextAlloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN285"><span class='Ref_to_Member'>tuplecontext</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4227"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4228"><span class='Ref_To_Local'>newtuple</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4226"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4227"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4228"><span class='Ref_To_Local'>newtuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4228"><span class='Ref_To_Local'>newtuple</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* set up first-column key value */ 
</span>    <a href="tuplesort.c.html#LN4229"><span class='Ref_To_Local'>original</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4228"><span class='Ref_To_Local'>newtuple</span></a><span class='Delimiter'>, 
</span>                             <span class='Number'>1</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a> <span class='Operator'>|| </span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Store ordinary Datum representation, or NULL value.  If there is a 
         * converter it won't expect NULL values, and cost model is not 
         * required to account for NULL, so in that case we avoid calling 
         * converter and just set datum1 to zeroed representation (to be 
         * consistent, and to support cheap inequality tests for NULL 
         * abbreviated keys). 
         */ 
</span>        <a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4229"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN584"><span class='Ref_to_Proto'>consider_abort_common</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Store abbreviated key representation */ 
</span>        <a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4229"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>, 
</span>                                                         <a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Abort abbreviation */ 
</span><a name="LN4263"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4229"><span class='Ref_To_Local'>original</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set state to be consistent with never trying abbreviation. 
         * 
         * Alter datum1 representation in already-copied tuples, so as to 
         * ensure a consistent representation (current tuple was just 
         * handled).  It does not matter if some dumped tuples are already 
         * sorted on tape, since serialized tuples lack abbreviated keys 
         * (TSS_BUILDRUNS state prevents control reaching here in any case). 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4263"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN4263"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN334"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; </span><a href="tuplesort.c.html#LN4263"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4278"></a>            <a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>mtup</span> <span class='Operator'>= &</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN333"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplesort.c.html#LN4263"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="tuplesort.c.html#LN4226"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4278"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>            <a href="tuplesort.c.html#LN4278"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4226"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                                         <span class='Number'>1</span><span class='Delimiter'>, 
</span>                                         <a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4224"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="tuplesort.c.html#LN4278"><span class='Ref_To_Local'>mtup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end copytup_index &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN4290"></a><span class='Declare_Function'>writetup_index</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4292"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span><a name="LN4293"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN4293"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN69"><span class='Ref_to_Macro'>IndexTupleSize</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4292"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4293"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4293"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4293"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4292"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="../../../include/access/itup.h.html#LN69"><span class='Ref_to_Macro'>IndexTupleSize</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4292"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4293"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4293"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4290"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4292"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4292"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end writetup_index &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN4312"></a><span class='Declare_Function'>readtup_index</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN4313"></a>              <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4315"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4313"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4316"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN606"><span class='Ref_to_Proto'>readtup_alloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4315"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4313"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <a href="tuplesort.c.html#LN4316"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4315"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4313"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="tuplesort.c.html#LN4315"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4315"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplesort.c.html#LN4316"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* set up first-column key value */ 
</span>    <a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4316"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                                 <span class='Number'>1</span><span class='Delimiter'>, 
</span>                                 <a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN470"><span class='Ref_to_Member'>indexRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="tuplesort.c.html#LN4312"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Routines specialized for DatumTuple case 
 */ 
</span> 
<span class='Keyword'>static int 
</span><a name="LN4336"></a><span class='Declare_Function'>comparetup_datum</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4338"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>compare</span><span class='Delimiter'>; 
</span> 
    <a href="tuplesort.c.html#LN4338"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN199"><span class='Ref_to_Func'>ApplySortComparator</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                  <a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                  <a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4338"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="tuplesort.c.html#LN4338"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* if we have abbreviations, then "tuple" has the original value */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/sortsupport.h.html#LN172"><span class='Ref_to_Member'>abbrev_converter</span></a><span class='Parentheses'>) 
</span>        <a href="tuplesort.c.html#LN4338"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/utils/sortsupport.h.html#LN237"><span class='Ref_to_Func'>ApplySortAbbrevFullComparator</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>b</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Delimiter'>, 
</span>                                                <a href="tuplesort.c.html#LN4336"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN441"><span class='Ref_to_Member'>sortKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplesort.c.html#LN4338"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end comparetup_datum &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN4357"></a><span class='Declare_Function'>copytup_datum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Not currently needed */ 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"copytup_datum() should not be called"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN4364"></a><span class='Declare_Function'>writetup_datum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4366"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Local'>waddr</span><span class='Delimiter'>; 
</span><a name="LN4367"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span><span class='Delimiter'>; 
</span><a name="LN4368"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>writtenlen</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN4366"><span class='Ref_To_Local'>waddr</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4367"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN279"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN4366"><span class='Ref_To_Local'>waddr</span></a> <span class='Operator'>= &</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4367"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tuplesort.c.html#LN4366"><span class='Ref_To_Local'>waddr</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4367"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="../../../include/utils/datum.h.html#LN23"><span class='Ref_to_Proto'>datumGetSize</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN486"><span class='Ref_to_Member'>datumTypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4367"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="tuplesort.c.html#LN4368"><span class='Ref_To_Local'>writtenlen</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4367"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4368"><span class='Ref_To_Local'>writtenlen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4368"><span class='Ref_To_Local'>writtenlen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                     <a href="tuplesort.c.html#LN4366"><span class='Ref_To_Local'>waddr</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4367"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="../../../include/utils/logtape.h.html#LN31"><span class='Ref_to_Proto'>LogicalTapeWrite</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplesort.c.html#LN4368"><span class='Ref_To_Local'>writtenlen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4368"><span class='Ref_To_Local'>writtenlen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN365"><span class='Ref_to_Member'>slabAllocatorUsed</span></a> <span class='Operator'>&& </span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4364"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end writetup_datum &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN4405"></a><span class='Declare_Function'>readtup_datum</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Delimiter'>, 
</span><a name="LN4406"></a>              <span class='Keyword'>int </span><span class='Declare_Parameter'>tapenum</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4408"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4406"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4408"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* it's NULL */ 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN279"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4408"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>== </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4406"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4408"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4427"></a>        <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Local'>raddr</span> <span class='Operator'>= </span><a href="tuplesort.c.html#LN606"><span class='Ref_to_Proto'>readtup_alloc</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4408"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4406"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                             <a href="tuplesort.c.html#LN4427"><span class='Ref_To_Local'>raddr</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4408"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN201"><span class='Ref_to_Member'>datum1</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4427"><span class='Ref_To_Local'>raddr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN202"><span class='Ref_to_Member'>isnull1</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><a href="tuplesort.c.html#LN4427"><span class='Ref_To_Local'>raddr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN274"><span class='Ref_to_Member'>randomAccess</span></a><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <a href="tuplesort.c.html#LN575"><span class='Ref_to_Macro'>LogicalTapeReadExact</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4405"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN286"><span class='Ref_to_Member'>tapeset</span></a><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN4406"><span class='Ref_to_Parameter'>tapenum</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="tuplesort.c.html#LN4408"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4408"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end readtup_datum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Convenience routine to free a tuple previously loaded into sort memory 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4445"></a><span class='Declare_Function'>free_sort_tuple</span><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="tuplesort.c.html#LN198"><span class='Ref_to_Typedef'>SortTuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4445"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4445"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplesort.c.html#LN4445"><span class='Ref_to_Parameter'>stup</span></a><span class='Operator'>-&GT;</span><a href="tuplesort.c.html#LN200"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>