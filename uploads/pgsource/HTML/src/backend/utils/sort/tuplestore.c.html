<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\utils\sort\tuplestore.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\utils\sort\tuplestore.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:59 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * tuplestore.c 
 *    Generalized routines for temporary tuple storage. 
 * 
 * This module handles temporary storage of tuples for purposes such 
 * as Materialize nodes, hashjoin batch files, etc.  It is essentially 
 * a dumbed-down version of tuplesort.c; it does no sorting of tuples 
 * but can only store and regurgitate a sequence of tuples.  However, 
 * because no sort is required, it is allowed to start reading the sequence 
 * before it has all been written.  This is particularly useful for cursors, 
 * because it allows random access within the already-scanned portion of 
 * a query without having to process the underlying scan to completion. 
 * Also, it is possible to support multiple independent read pointers. 
 * 
 * A temporary file is used to handle the data if it exceeds the 
 * space limit specified by the caller. 
 * 
 * The (approximate) amount of memory allowed to the tuplestore is specified 
 * in kilobytes by the caller.  We absorb tuples and simply store them in an 
 * in-memory array as long as we haven't exceeded maxKBytes.  If we do exceed 
 * maxKBytes, we dump all the tuples into a temp file and then read from that 
 * when needed. 
 * 
 * Upon creation, a tuplestore supports a single read pointer, numbered 0. 
 * Additional read pointers can be created using tuplestore_alloc_read_pointer. 
 * Mark/restore behavior is supported by copying read pointers. 
 * 
 * When the caller requests backward-scan capability, we write the temp file 
 * in a format that allows either forward or backward scan.  Otherwise, only 
 * forward scan is allowed.  A request for backward scan must be made before 
 * putting any tuples into the tuplestore.  Rewind is normally allowed but 
 * can be turned off via tuplestore_set_eflags; turning off rewind for all 
 * read pointers enables truncation of the tuplestore at the oldest read point 
 * for minimal memory usage.  (The caller must explicitly call tuplestore_trim 
 * at appropriate times for truncation to actually happen.) 
 * 
 * Note: in TSS_WRITEFILE state, the temp file's seek position is the 
 * current write position, and the write-position variables in the tuplestore 
 * aren't kept up to date.  Similarly, in TSS_READFILE state the temp file's 
 * seek position is the active read pointer's position, and that read pointer 
 * isn't kept up to date.  We update the appropriate variables using ftell() 
 * before switching to the other state or activating a different read pointer. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/utils/sort/tuplestore.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;limits.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/tablespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/buffile.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/resowner.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Possible states of a Tuplestore object.  These denote the states that 
 * persist between calls of Tuplestore routines. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN73"></a>    <span class='Declare_Enum_Const'>TSS_INMEM</span><span class='Delimiter'>,</span>                  <span class='Comment_Single_Line'>/* Tuples still fit in memory */ 
</span><a name="LN74"></a>    <span class='Declare_Enum_Const'>TSS_WRITEFILE</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* Writing to temp file */ 
</span><a name="LN75"></a>    <span class='Declare_Enum_Const'>TSS_READFILE</span>                <span class='Comment_Single_Line'>/* Reading from temp file */ 
</span><a name="LN76"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TupStoreStatus</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * State for a single read pointer.  If we are in state INMEM then all the 
 * read pointers' "current" fields denote the read positions.  In state 
 * WRITEFILE, the file/offset fields denote the read positions.  In state 
 * READFILE, inactive read pointers have valid file/offset, but the active 
 * read pointer implicitly has position equal to the temp file's seek position. 
 * 
 * Special case: if eof_reached is true, then the pointer's read position is 
 * implicitly equal to the write position, and current/file/offset aren't 
 * maintained.  This way we need not update all the read pointers each time 
 * we write. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN92"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>eflags</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* capability flags */ 
</span><a name="LN93"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>eof_reached</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* read has reached EOF */ 
</span><a name="LN94"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>current</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* next array index to read */ 
</span><a name="LN95"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>file</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* temp file# */ 
</span><a name="LN96"></a>    off_t       <span class='Declare_Member'>offset</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* byte offset in file */ 
</span><a name="LN97"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TSReadPointer</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Private state of a Tuplestore operation. 
 */ 
</span><a name="LN102"></a><span class='Control'>struct</span> <span class='Declare_Struct'>Tuplestorestate</span> 
<span class='Delimiter'>{ 
</span><a name="LN104"></a>    <a href="tuplestore.c.html#LN71"><span class='Ref_to_Typedef'>TupStoreStatus</span></a> <span class='Declare_Member'>status</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* enumerated value as shown above */ 
</span><a name="LN105"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>eflags</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* capability flags (OR of pointers' flags) */ 
</span><a name="LN106"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>backward</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* store extra length words in file? */ 
</span><a name="LN107"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>interXact</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* keep open through transactions? */ 
</span><a name="LN108"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>truncated</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* tuplestore_trim has removed tuples? */ 
</span><a name="LN109"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>availMem</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* remaining memory available, in bytes */ 
</span><a name="LN110"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>allowedMem</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* total memory allowed, in bytes */ 
</span><a name="LN111"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>tuples</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* number of tuples added */ 
</span><a name="LN112"></a>    <a href="../../storage/file/buffile.c.html#LN58"><span class='Ref_to_Struct'>BufFile</span></a>    <span class='Operator'>*</span><span class='Declare_Member'>myfile</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* underlying file, or NULL if none */ 
</span><a name="LN113"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>context</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* memory context for holding tuples */ 
</span><a name="LN114"></a>    <a href="../../../include/utils/resowner.h.html#LN26"><span class='Ref_to_Typedef'>ResourceOwner</span></a> <span class='Declare_Member'>resowner</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* resowner for holding temp files */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These function pointers decouple the routines that must know what kind 
     * of tuple we are handling from the routines that don't need to know it. 
     * They are set up by the tuplestore_begin_xxx routines. 
     * 
     * (Although tuplestore.c currently only supports heap tuples, I've copied 
     * this part of tuplesort.c so that extension to other kinds of objects 
     * will be easy if it's ever needed.) 
     * 
     * Function to copy a supplied input tuple into palloc'd space. (NB: we 
     * assume that a single pfree() is enough to release the tuple later, so 
     * the representation must be "flat" in one palloc chunk.) state-&GT;availMem 
     * must be decreased by the amount of space used. 
     */ 
</span>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Parentheses'>(</span><span class='Operator'>*</span>copytup<span class='Parentheses'>) (</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span>tup<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Function to write a stored tuple onto tape.  The representation of the 
     * tuple on tape need not be the same as it is in memory; requirements on 
     * the tape representation are given below.  After writing the tuple, 
     * pfree() it, and increase state-&GT;availMem by the amount of memory space 
     * thereby released. 
     */ 
</span><a name="LN139"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>writetup</span><span class='Parentheses'>) (</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span>tup<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Function to read a stored tuple from tape back into memory. 'len' is 
     * the already-read length of the stored tuple.  Create and return a 
     * palloc'd copy, and decrease state-&GT;availMem by the amount of memory 
     * space consumed. 
     */ 
</span>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Parentheses'>(</span><span class='Operator'>*</span>readtup<span class='Parentheses'>) (</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><a href="../../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><a href="../../replication/repl_scanner.l.html#LN155"><span class='Ref_to_Global_Var'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This array holds pointers to tuples in memory if we are in state INMEM. 
     * In states WRITEFILE and READFILE it's not used. 
     * 
     * When memtupdeleted &GT; 0, the first memtupdeleted pointers are already 
     * released due to a tuplestore_trim() operation, but we haven't expended 
     * the effort to slide the remaining pointers down.  These unused pointers 
     * are set to NULL to catch any invalid accesses.  Note that memtupcount 
     * includes the deleted pointers. 
     */ 
</span><a name="LN159"></a>    <span class='Keyword'>void</span>      <span class='Operator'>**</span><span class='Declare_Member'>memtuples</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* array of pointers to palloc'd tuples */ 
</span><a name="LN160"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>memtupdeleted</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* the first N slots are currently unused */ 
</span><a name="LN161"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>memtupcount</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of tuples currently present */ 
</span><a name="LN162"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>memtupsize</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* allocated length of memtuples array */ 
</span><a name="LN163"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>growmemtuples</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* memtuples' growth still underway? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These variables are used to keep track of the current positions. 
     * 
     * In state WRITEFILE, the current file seek position is the write point; 
     * in state READFILE, the write position is remembered in writepos_xxx. 
     * (The write position is the same as EOF, but since BufFileSeek doesn't 
     * currently implement SEEK_END, we have to remember it explicitly.) 
     */ 
</span><a name="LN173"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Member'>readptrs</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of read pointers */ 
</span><a name="LN174"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>activeptr</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* index of the active read pointer */ 
</span><a name="LN175"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>readptrcount</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* number of pointers currently valid */ 
</span><a name="LN176"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>readptrsize</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* allocated length of readptrs array */ 
</span> 
<a name="LN178"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>writepos_file</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* file# (valid if READFILE state) */ 
</span><a name="LN179"></a>    off_t       <span class='Declare_Member'>writepos_offset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* offset (valid if READFILE state) */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end Tuplestorestate &raquo; </span><span class='Delimiter'>; 
</span> 
<a name="LN182"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>COPYTUP</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN182"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>copytup<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN182"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN182"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>))</span> 
<a name="LN183"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>WRITETUP</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) ((</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN183"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>writetup<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN183"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN183"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>))</span> 
<a name="LN184"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>READTUP</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>len</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><span class='Operator'>*</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN184"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>readtup<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN184"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN184"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>))</span> 
<a name="LN185"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LACKMEM</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span>      <span class='Parentheses'>((</span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>availMem <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN186"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>USEMEM</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>amt</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><a href="tuplestore.c.html#LN186"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>availMem <span class='Operator'>-= </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN186"><span class='Ref_to_Parameter'>amt</span></a><span class='Parentheses'>))</span> 
<a name="LN187"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>FREEMEM</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>amt</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><a href="tuplestore.c.html#LN187"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>availMem <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN187"><span class='Ref_to_Parameter'>amt</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/*-------------------- 
 * 
 * NOTES about on-tape representation of tuples: 
 * 
 * We require the first "unsigned int" of a stored tuple to be the total size 
 * on-tape of the tuple, including itself (so it is never zero). 
 * The remainder of the stored tuple 
 * may or may not match the in-memory representation of the tuple --- 
 * any conversion needed is the job of the writetup and readtup routines. 
 * 
 * If state-&GT;backward is true, then the stored representation of 
 * the tuple must be followed by another "unsigned int" that is a copy of the 
 * length --- so the total tape space used is actually sizeof(unsigned int) 
 * more than the stored length value.  This allows read-backwards.  When 
 * state-&GT;backward is not set, the write/read routines may omit the extra 
 * length word. 
 * 
 * writetup is expected to write both length words as well as the tuple 
 * data.  When readtup is called, the tape is positioned just after the 
 * front length word; readtup must read the tuple data and advance past 
 * the back length word (if present). 
 * 
 * The write/read routines can make use of the tuple description data 
 * stored in the Tuplestorestate record, if needed. They are also expected 
 * to adjust state-&GT;availMem by the amount of memory space (not tape space!) 
 * released or consumed.  There is no error return from either writetup 
 * or readtup; they should ereport() on failure. 
 * 
 * 
 * NOTES about memory consumption calculations: 
 * 
 * We count space allocated for tuples against the maxKBytes limit, 
 * plus the space used by the variable-size array memtuples. 
 * Fixed-size space (primarily the BufFile I/O buffer) is not counted. 
 * We don't worry about the size of the read pointer array, either. 
 * 
 * Note that we count actual space used (as shown by GetMemoryChunkSpace) 
 * rather than the originally-requested size.  This is important since 
 * palloc can add substantial overhead.  It's not a complete answer since 
 * we won't count any wasted space in palloc allocation blocks, but it's 
 * a lot better than what we were doing before 7.3. 
 * 
 *-------------------- 
 */ 
</span> 
 
<a name="LN235"></a><span class='Keyword'>static </span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>tuplestore_begin_common</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Delimiter'>, 
</span><a name="LN236"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>interXact</span><span class='Delimiter'>, 
</span><a name="LN237"></a>                        <span class='Keyword'>int </span><span class='Declare_Parameter'>maxKBytes</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN238"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>tuplestore_puttuple_common</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN239"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>dumptuples</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN240"></a><span class='Keyword'>static unsigned int </span><span class='Declare_Prototype'>getlen</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>eofOK</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN241"></a><span class='Keyword'>static void </span><span class='Operator'>*</span><span class='Declare_Prototype'>copytup_heap</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN242"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>writetup_heap</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN243"></a><span class='Keyword'>static void </span><span class='Operator'>*</span><span class='Declare_Prototype'>readtup_heap</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *      tuplestore_begin_xxx 
 * 
 * Initialize for a tuple store operation. 
 */ 
</span><span class='Keyword'>static </span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>* 
</span><a name="LN252"></a><span class='Declare_Function'>tuplestore_begin_common</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>interXact</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>maxKBytes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN254"></a>    <a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN252"><span class='Ref_to_Parameter'>eflags</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN107"><span class='Ref_to_Member'>interXact</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN252"><span class='Ref_to_Parameter'>interXact</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN110"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN252"><span class='Ref_to_Parameter'>maxKBytes</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN109"><span class='Ref_to_Member'>availMem</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN110"><span class='Ref_to_Member'>allowedMem</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN113"><span class='Ref_to_Member'>context</span></a> <span class='Operator'>= </span><a href="../mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN114"><span class='Ref_to_Member'>resowner</span></a> <span class='Operator'>= </span><a href="../resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN111"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD; 
     * see comments in grow_memtuples(). 
     */ 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><span class='Number'>16384</span> <span class='Operator'>/ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/utils/memutils.h.html#LN191"><span class='Ref_to_Const'>ALLOCSET_SEPARATE_THRESHOLD</span></a> <span class='Operator'>/ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN163"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN176"><span class='Ref_to_Member'>readptrsize</span></a> <span class='Operator'>= </span><span class='Number'>8</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* arbitrary */ 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN176"><span class='Ref_to_Member'>readptrsize</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN252"><span class='Ref_to_Parameter'>eflags</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplestore.c.html#LN254"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplestore_begin_common &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_begin_heap 
 * 
 * Create a new tuplestore; other types of tuple stores (other than 
 * "heap" tuple stores, for heap tuples) are possible, but not presently 
 * implemented. 
 * 
 * randomAccess: if true, both forward and backward accesses to the 
 * tuple store are allowed. 
 * 
 * interXact: if true, the files used for on-disk storage persist beyond the 
 * end of the current transaction.  NOTE: It's the caller's responsibility to 
 * create such a tuplestore in a memory context and resource owner that will 
 * also survive transaction boundaries, and to ensure the tuplestore is closed 
 * when it's no longer wanted. 
 * 
 * maxKBytes: how much data to store in memory (any data beyond this 
 * amount is paged to disk).  When in doubt, use work_mem. 
 */ 
</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>* 
</span><a name="LN317"></a><span class='Declare_Function'>tuplestore_begin_heap</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>interXact</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>maxKBytes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN319"></a>    <a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN320"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>eflags</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This interpretation of the meaning of randomAccess is compatible with 
     * the pre-8.3 behavior of tuplestores. 
     */ 
</span>    <a href="tuplestore.c.html#LN320"><span class='Ref_To_Local'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN317"><span class='Ref_to_Parameter'>randomAccess</span></a> <span class='Operator'>? 
</span>        <span class='Parentheses'>(</span><a href="../../../include/executor/executor.h.html#LN59"><span class='Ref_to_Const'>EXEC_FLAG_BACKWARD</span></a> <span class='Operator'>| </span><a href="../../../include/executor/executor.h.html#LN58"><span class='Ref_to_Const'>EXEC_FLAG_REWIND</span></a><span class='Parentheses'>) </span><span class='Operator'>: 
</span>        <span class='Parentheses'>(</span><a href="../../../include/executor/executor.h.html#LN58"><span class='Ref_to_Const'>EXEC_FLAG_REWIND</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN319"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN235"><span class='Ref_to_Proto'>tuplestore_begin_common</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN320"><span class='Ref_To_Local'>eflags</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN317"><span class='Ref_to_Parameter'>interXact</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN317"><span class='Ref_to_Parameter'>maxKBytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN319"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span>copytup <span class='Operator'>= </span><a href="tuplestore.c.html#LN241"><span class='Ref_to_Proto'>copytup_heap</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN319"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN139"><span class='Ref_to_Member'>writetup</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN242"><span class='Ref_to_Proto'>writetup_heap</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN319"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span>readtup <span class='Operator'>= </span><a href="tuplestore.c.html#LN243"><span class='Ref_to_Proto'>readtup_heap</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplestore.c.html#LN319"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplestore_begin_heap &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_set_eflags 
 * 
 * Set the capability flags for read pointer 0 at a finer grain than is 
 * allowed by tuplestore_begin_xxx.  This must be called before inserting 
 * any data into the tuplestore. 
 * 
 * eflags is a bitmask following the meanings used for executor node 
 * startup flags (see executor.h).  tuplestore pays attention to these bits: 
 *      EXEC_FLAG_REWIND        need rewind to start 
 *      EXEC_FLAG_BACKWARD      need backward fetch 
 * If tuplestore_set_eflags is not called, REWIND is allowed, and BACKWARD 
 * is set per "randomAccess" in the tuplestore_begin_xxx call. 
 * 
 * NOTE: setting BACKWARD without REWIND means the pointer can read backwards, 
 * but not further than the truncation point (the furthest-back read pointer 
 * position at the time of the last tuplestore_trim call). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN358"></a><span class='Declare_Function'>tuplestore_set_eflags</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN360"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>!= </span><a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a> <span class='Operator'>|| </span><a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too late to call tuplestore_set_eflags"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>eflags</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN360"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN360"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN360"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>eflags</span></a> <span class='Operator'>|= </span><a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN360"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN358"><span class='Ref_to_Parameter'>eflags</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_alloc_read_pointer - allocate another read pointer. 
 * 
 * Returns the pointer's index. 
 * 
 * The new pointer initially copies the position of read pointer 0. 
 * It can have its own eflags, but if any data has been inserted into 
 * the tuplestore, these eflags must not represent an increase in 
 * requirements. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN382"></a><span class='Declare_Function'>tuplestore_alloc_read_pointer</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Check for possible increase of requirements */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>!= </span><a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a> <span class='Operator'>|| </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>| </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>eflags</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too late to require new tuplestore eflags"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Make room for another read pointer if needed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a> <span class='Operator'>&GT;= </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN176"><span class='Ref_to_Member'>readptrsize</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN394"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>newcnt</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN176"><span class='Ref_to_Member'>readptrsize</span></a> <span class='Operator'>* </span><span class='Number'>2</span><span class='Delimiter'>; 
</span> 
        <a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN394"><span class='Ref_To_Local'>newcnt</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN176"><span class='Ref_to_Member'>readptrsize</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN394"><span class='Ref_To_Local'>newcnt</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* And set it up */ 
</span>    <a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>    <a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>eflags</span></a><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>|= </span><a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>eflags</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="tuplestore.c.html#LN382"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplestore_alloc_read_pointer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_clear 
 * 
 *  Delete all the contents of a tuplestore, and reset its read pointers 
 *  to the start. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN417"></a><span class='Declare_Function'>tuplestore_clear</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN419"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN420"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>readptr</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/buffile.h.html#LN37"><span class='Ref_to_Proto'>BufFileClose</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN111"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN420"><span class='Ref_To_Local'>readptr</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN420"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN419"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN420"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN420"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end tuplestore_clear &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_end 
 * 
 *  Release resources and clean up. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN452"></a><span class='Declare_Function'>tuplestore_end</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN454"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/buffile.h.html#LN37"><span class='Ref_to_Proto'>BufFileClose</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN454"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN454"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN454"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN454"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN452"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_select_read_pointer - make the specified read pointer active 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN472"></a><span class='Declare_Function'>tuplestore_select_read_pointer</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>ptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN474"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>readptr</span><span class='Delimiter'>; 
</span><a name="LN475"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>oldptr</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No work if already active */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>== </span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN474"><span class='Ref_To_Local'>readptr</span></a> <span class='Operator'>= &</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>]; 
</span>    <a href="tuplestore.c.html#LN475"><span class='Ref_To_Local'>oldptr</span></a> <span class='Operator'>= &</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN74"><span class='Ref_to_EnumConst'>TSS_WRITEFILE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* no work */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN75"><span class='Ref_to_EnumConst'>TSS_READFILE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * First, save the current read position in the pointer about to 
             * become inactive. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN475"><span class='Ref_To_Local'>oldptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/buffile.h.html#LN41"><span class='Ref_to_Proto'>BufFileTell</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplestore.c.html#LN475"><span class='Ref_To_Local'>oldptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplestore.c.html#LN475"><span class='Ref_To_Local'>oldptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We have to make the temp file's seek position equal to the 
             * logical position of the new read pointer.  In eof_reached 
             * state, that's the EOF, which we have available from the saved 
             * write position. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN474"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN178"><span class='Ref_to_Member'>writepos_file</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN179"><span class='Ref_to_Member'>writepos_offset</span></a><span class='Delimiter'>, 
</span>                                SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplestore.c.html#LN474"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplestore.c.html#LN474"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Delimiter'>, 
</span>                                SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplestore state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
 
    <a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN472"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tuplestore_select_read_pointer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_tuple_count 
 * 
 * Returns the number of tuples added since creation or the last 
 * tuplestore_clear(). 
 */ 
</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> 
<a name="LN545"></a><span class='Declare_Function'>tuplestore_tuple_count</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="tuplestore.c.html#LN545"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN111"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_ateof 
 * 
 * Returns the active read pointer's eof_reached state. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN556"></a><span class='Declare_Function'>tuplestore_ateof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="tuplestore.c.html#LN556"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN556"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Grow the memtuples[] array, if possible within our memory constraint.  We 
 * must not exceed INT_MAX tuples in memory or the caller-provided memory 
 * limit.  Return TRUE if we were able to enlarge the array, FALSE if not. 
 * 
 * Normally, at each increment we double the size of the array.  When doing 
 * that would exceed a limit, we attempt one last, smaller increase (and then 
 * clear the growmemtuples flag so we don't try any more).  That allows us to 
 * use memory as fully as permitted; sticking to the pure doubling rule could 
 * result in almost half going unused.  Because availMem moves around with 
 * tuple addition/removal, we need some rule to prevent making repeated small 
 * increases in memtupsize, which would just be useless thrashing.  The 
 * growmemtuples flag accomplishes that and also prevents useless 
 * recalculations in this function. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN577"></a><span class='Declare_Function'>grow_memtuples</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN579"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>newmemtupsize</span><span class='Delimiter'>; 
</span><a name="LN580"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>memtupsize</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a><span class='Delimiter'>; 
</span><a name="LN581"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>memNowUsed</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN110"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>- </span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN109"><span class='Ref_to_Member'>availMem</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Forget it if we've already maxed out memtuples, per comment above */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN163"><span class='Ref_to_Member'>growmemtuples</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Select new value of memtupsize */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN581"><span class='Ref_To_Local'>memNowUsed</span></a> <span class='Operator'>&LT;= </span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN109"><span class='Ref_to_Member'>availMem</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We've used no more than half of allowedMem; double our usage, 
         * clamping at INT_MAX tuples. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN580"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>&LT; </span>INT_MAX <span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>            <a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN580"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>* </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span>INT_MAX<span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN163"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * This will be the last increment of memtupsize.  Abandon doubling 
         * strategy and instead increase as much as we safely can. 
         * 
         * To stay within allowedMem, we can't increase memtupsize by more 
         * than availMem / sizeof(void *) elements. In practice, we want to 
         * increase it by considerably less, because we need to leave some 
         * space for the tuples to which the new array slots will refer.  We 
         * assume the new tuples will be about the same size as the tuples 
         * we've already seen, and thus we can extrapolate from the space 
         * consumption so far to estimate an appropriate new size for the 
         * memtuples array.  The optimal value might be higher or lower than 
         * this estimate, but it's hard to know that in advance.  We again 
         * clamp at INT_MAX tuples. 
         * 
         * This calculation is safe against enlarging the array so much that 
         * LACKMEM becomes true, because the memory currently used includes 
         * the present array; thus, there would be enough allowedMem for the 
         * new array elements even if no other memory were currently used. 
         * 
         * We do the arithmetic in float8, because otherwise the product of 
         * memtupsize and allowedMem could overflow.  Any inaccuracy in the 
         * result should be insignificant; but even if we computed a 
         * completely insane result, the checks below will prevent anything 
         * really bad from happening. 
         */ 
</span><a name="LN630"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>grow_ratio</span><span class='Delimiter'>; 
</span> 
        <a href="tuplestore.c.html#LN630"><span class='Ref_To_Local'>grow_ratio</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN110"><span class='Ref_to_Member'>allowedMem</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN581"><span class='Ref_To_Local'>memNowUsed</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN580"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>* </span><a href="tuplestore.c.html#LN630"><span class='Ref_To_Local'>grow_ratio</span></a> <span class='Operator'>&LT; </span>INT_MAX<span class='Parentheses'>) 
</span>            <a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="tuplestore.c.html#LN580"><span class='Ref_To_Local'>memtupsize</span></a> <span class='Operator'>* </span><a href="tuplestore.c.html#LN630"><span class='Ref_To_Local'>grow_ratio</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span>INT_MAX<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* We won't make any further enlargement attempts */ 
</span>        <a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN163"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Must enlarge array by at least one element, else report failure */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>&LT;= </span><a href="tuplestore.c.html#LN580"><span class='Ref_To_Local'>memtupsize</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="tuplestore.c.html#LN684"><span class='Ref_to_Label'>noalloc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp 
     * to ensure our request won't be rejected.  Note that we can easily 
     * exhaust address space before facing this outcome.  (This is presently 
     * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but 
     * don't rely on that at this distance.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/utils/memutils.h.html#LN43"><span class='Ref_to_Const'>MaxAllocHugeSize</span></a> <span class='Operator'>/ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="../../../include/utils/memutils.h.html#LN43"><span class='Ref_to_Const'>MaxAllocHugeSize</span></a> <span class='Operator'>/ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN163"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* can't grow any more */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need to be sure that we do not cause LACKMEM to become true, else 
     * the space management algorithm will go nuts.  The code above should 
     * never generate a dangerous request, but to be safe, check explicitly 
     * that the array growth fits within availMem.  (We could still cause 
     * LACKMEM if the memory chunk overhead associated with the memtuples 
     * array were to increase.  That shouldn't happen because we chose the 
     * initial array size large enough to ensure that palloc will be treating 
     * both old and new arrays as separate chunks.  But we'll check LACKMEM 
     * explicitly below just in case.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN109"><span class='Ref_to_Member'>availMem</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a> <span class='Operator'>- </span><a href="tuplestore.c.html#LN580"><span class='Ref_To_Local'>memtupsize</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>)))</span> 
        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="tuplestore.c.html#LN684"><span class='Ref_to_Label'>noalloc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* OK, do it */ 
</span>    <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN579"><span class='Ref_To_Local'>newmemtupsize</span></a><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>**</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/palloc.h.html#LN97"><span class='Ref_to_Proto'>repalloc_huge</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>, 
</span>                      <a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Macro'>LACKMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected out-of-memory situation in tuplestore"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
<a name="LN684"></a><span class='Label'>noalloc</span><span class='Operator'>: 
</span>    <span class='Comment_Multi_Line'>/* If for any reason we didn't realloc, shut off future attempts */ 
</span>    <a href="tuplestore.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN163"><span class='Ref_to_Member'>growmemtuples</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end grow_memtuples &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Accept one tuple and append it to the tuplestore. 
 * 
 * Note that the input tuple is always copied; the caller need not save it. 
 * 
 * If the active read pointer is currently "at EOF", it remains so (the read 
 * pointer implicitly advances along with the write pointer); otherwise the 
 * read pointer is unchanged.  Non-active read pointers do not move, which 
 * means they are certain to not be "at EOF" immediately after puttuple. 
 * This curious-seeming behavior is for the convenience of nodeMaterial.c and 
 * nodeCtescan.c, which would otherwise need to do extra pointer repositioning 
 * steps. 
 * 
 * tuplestore_puttupleslot() is a convenience routine to collect data from 
 * a TupleTableSlot without an extra copy operation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN707"></a><span class='Declare_Function'>tuplestore_puttupleslot</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, 
</span><a name="LN708"></a>                        <a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN710"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN711"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcxt</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN707"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN113"><span class='Ref_to_Member'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Form a MinimalTuple in working memory 
     */ 
</span>    <a href="tuplestore.c.html#LN710"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/executor/tuptable.h.html#LN158"><span class='Ref_to_Proto'>ExecCopySlotMinimalTuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN708"><span class='Ref_to_Parameter'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN707"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN710"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN238"><span class='Ref_to_Proto'>tuplestore_puttuple_common</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN707"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN710"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN711"><span class='Ref_To_Local'>oldcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * "Standard" case to copy from a HeapTuple.  This is actually now somewhat 
 * deprecated, but not worth getting rid of in view of the number of callers. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN729"></a><span class='Declare_Function'>tuplestore_puttuple</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN731"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcxt</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN729"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN113"><span class='Ref_to_Member'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy the tuple.  (Must do this even in WRITEFILE case.  Note that 
     * COPYTUP includes USEMEM, so we needn't do that here.) 
     */ 
</span>    <a href="tuplestore.c.html#LN729"><span class='Ref_to_Parameter'>tuple</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN182"><span class='Ref_to_Macro'>COPYTUP</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN729"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN729"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN238"><span class='Ref_to_Proto'>tuplestore_puttuple_common</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN729"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN729"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN731"><span class='Ref_To_Local'>oldcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Similar to tuplestore_puttuple(), but work from values + nulls arrays. 
 * This avoids an extra tuple-construction operation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN749"></a><span class='Declare_Function'>tuplestore_putvalues</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tdesc</span><span class='Delimiter'>, 
</span><a name="LN750"></a>                     <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN752"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN753"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcxt</span> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN749"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN113"><span class='Ref_to_Member'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN752"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN816"><span class='Ref_to_Proto'>heap_form_minimal_tuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN749"><span class='Ref_to_Parameter'>tdesc</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN750"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN750"><span class='Ref_to_Parameter'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN749"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN752"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN238"><span class='Ref_to_Proto'>tuplestore_puttuple_common</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN749"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN752"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN753"><span class='Ref_To_Local'>oldcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN764"></a><span class='Declare_Function'>tuplestore_puttuple_common</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN766"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>readptr</span><span class='Delimiter'>; 
</span><a name="LN767"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN768"></a>    <a href="../../../include/utils/resowner.h.html#LN26"><span class='Ref_to_Typedef'>ResourceOwner</span></a> <span class='Declare_Local'>oldowner</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN111"><span class='Ref_to_Member'>tuples</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Update read pointers as needed; see API spec above. 
             */ 
</span>            <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>!= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Grow the array as needed.  Note that we try to grow the array 
             * when there is still one free slot remaining --- if we fail, 
             * there'll still be room to store the incoming tuple, and then 
             * we'll switch to tape-based operation. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&GT;= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN576"><span class='Ref_to_Func'>grow_memtuples</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Stash the tuple in the in-memory array */ 
</span>            <a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Done if we still fit in available memory and have array slots. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN162"><span class='Ref_to_Member'>memtupsize</span></a> <span class='Operator'>&& !</span><a href="tuplestore.c.html#LN185"><span class='Ref_to_Macro'>LACKMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Nope; time to switch to tape-based operation.  Make sure that 
             * the temp file(s) are created in suitable temp tablespaces. 
             */ 
</span>            <a href="../../../include/commands/tablespace.h.html#LN53"><span class='Ref_to_Proto'>PrepareTempTablespaces</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* associate the file with the store's resource owner */ 
</span>            <a href="tuplestore.c.html#LN768"><span class='Ref_To_Local'>oldowner</span></a> <span class='Operator'>= </span><a href="../resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a><span class='Delimiter'>; 
</span>            <a href="../resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN114"><span class='Ref_to_Member'>resowner</span></a><span class='Delimiter'>; 
</span> 
            <a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buffile.h.html#LN36"><span class='Ref_to_Proto'>BufFileCreateTemp</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN107"><span class='Ref_to_Member'>interXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../resowner/resowner.c.html#LN137"><span class='Ref_to_Global_Var'>CurrentResourceOwner</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN768"><span class='Ref_To_Local'>oldowner</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Freeze the decision about whether trailing length words will be 
             * used.  We can't change this choice once data is on tape, even 
             * though callers might drop the requirement. 
             */ 
</span>            <a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN106"><span class='Ref_to_Member'>backward</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>& </span><a href="../../../include/executor/executor.h.html#LN59"><span class='Ref_to_Const'>EXEC_FLAG_BACKWARD</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN74"><span class='Ref_to_EnumConst'>TSS_WRITEFILE</span></a><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN239"><span class='Ref_to_Proto'>dumptuples</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN74"><span class='Ref_to_EnumConst'>TSS_WRITEFILE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Update read pointers as needed; see API spec above. Note: 
             * BufFileTell is quite cheap, so not worth trying to avoid 
             * multiple calls. 
             */ 
</span>            <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>!= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/storage/buffile.h.html#LN41"><span class='Ref_to_Proto'>BufFileTell</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="tuplestore.c.html#LN183"><span class='Ref_to_Macro'>WRITETUP</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN75"><span class='Ref_to_EnumConst'>TSS_READFILE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Switch from reading to writing. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/buffile.h.html#LN41"><span class='Ref_to_Proto'>BufFileTell</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                            <a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN178"><span class='Ref_to_Member'>writepos_file</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN179"><span class='Ref_to_Member'>writepos_offset</span></a><span class='Delimiter'>, 
</span>                            SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN74"><span class='Ref_to_EnumConst'>TSS_WRITEFILE</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Update read pointers as needed; see API spec above. 
             */ 
</span>            <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN767"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>!= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN178"><span class='Ref_to_Member'>writepos_file</span></a><span class='Delimiter'>; 
</span>                    <a href="tuplestore.c.html#LN766"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN179"><span class='Ref_to_Member'>writepos_offset</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="tuplestore.c.html#LN183"><span class='Ref_to_Macro'>WRITETUP</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN764"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplestore state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tuplestore_puttuple_common &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Fetch the next tuple in either forward or back direction. 
 * Returns NULL if no more tuples.  If should_free is set, the 
 * caller must pfree the returned tuple when done with it. 
 * 
 * Backward scan is only allowed if randomAccess was set true or 
 * EXEC_FLAG_BACKWARD was specified to tuplestore_set_eflags(). 
 */ 
</span><span class='Keyword'>static void </span><span class='Operator'>* 
</span><a name="LN902"></a><span class='Declare_Function'>tuplestore_gettuple</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Delimiter'>, 
</span><a name="LN903"></a>                    <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>should_free</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN905"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>readptr</span> <span class='Operator'>= &</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]; 
</span><a name="LN906"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span><span class='Delimiter'>; 
</span><a name="LN907"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>forward</span></a> <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>& </span><a href="../../../include/executor/executor.h.html#LN59"><span class='Ref_to_Const'>EXEC_FLAG_BACKWARD</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="tuplestore.c.html#LN903"><span class='Ref_to_Parameter'>should_free</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* We have another tuple, so return it */ 
</span>                    <span class='Control'>return</span> <a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span>                <span class='Delimiter'>} 
</span>                <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * if all tuples are fetched already then we return last 
                 * tuple, else tuple before last returned. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>                    <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&LT;= </span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a><span class='Operator'>--</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* last returned tuple */ 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&LT;= </span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>return</span> <a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="tuplestore.c.html#LN74"><span class='Ref_to_EnumConst'>TSS_WRITEFILE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Skip state change if we'll just return NULL */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Switch from writing to reading. 
             */ 
</span>            <a href="../../../include/storage/buffile.h.html#LN41"><span class='Ref_to_Proto'>BufFileTell</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN178"><span class='Ref_to_Member'>writepos_file</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN179"><span class='Ref_to_Member'>writepos_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                                <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Delimiter'>, 
</span>                                SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN75"><span class='Ref_to_EnumConst'>TSS_READFILE</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* FALL THRU into READFILE case */ 
</span> 
        <span class='Control'>case</span> <a href="tuplestore.c.html#LN75"><span class='Ref_to_EnumConst'>TSS_READFILE</span></a><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="tuplestore.c.html#LN903"><span class='Ref_to_Parameter'>should_free</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN240"><span class='Ref_to_Proto'>getlen</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN907"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN184"><span class='Ref_to_Macro'>READTUP</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="tuplestore.c.html#LN907"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Backward. 
             * 
             * if all tuples are fetched already then we return last tuple, 
             * else tuple before last returned. 
             * 
             * Back up to fetch previously-returned tuple's ending length 
             * word. If seek fails, assume we are at start of file. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>) </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            SEEK_CUR<span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* even a failed backwards fetch gets you out of eof state */ 
</span>                <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN240"><span class='Ref_to_Proto'>getlen</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="tuplestore.c.html#LN905"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* We will return the tuple returned before returning NULL */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Back up to get ending length word of tuple before it. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                <span class='Operator'>-</span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>+ </span><span class='Number'>2</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                                SEEK_CUR<span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * If that fails, presumably the prev tuple is the first 
                     * in the file.  Back up so that it becomes next to read 
                     * in forward direction (not obviously right, but that is 
                     * what in-memory case does). 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                    <span class='Operator'>-</span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>unsigned int</span><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                                    SEEK_CUR<span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN240"><span class='Ref_to_Proto'>getlen</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Now we have the length of the prior tuple, back up and read it. 
             * Note: READTUP expects we are positioned after the initial 
             * length word of the tuple, so back up to that point. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                            <span class='Operator'>-</span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, 
</span>                            SEEK_CUR<span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN907"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN184"><span class='Ref_to_Macro'>READTUP</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN902"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN906"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="tuplestore.c.html#LN907"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplestore state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tuplestore_gettuple &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_gettupleslot - exported function to fetch a MinimalTuple 
 * 
 * If successful, put tuple in slot and return TRUE; else, clear the slot 
 * and return FALSE. 
 * 
 * If copy is TRUE, the slot receives a copied tuple (allocated in current 
 * memory context) that will stay valid regardless of future manipulations of 
 * the tuplestore's state.  If copy is FALSE, the slot may just receive a 
 * pointer to a tuple held within the tuplestore.  The latter is more 
 * efficient but the slot contents may be corrupted if additional writes to 
 * the tuplestore occur.  (If using tuplestore_trim, see comments therein.) 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1077"></a><span class='Declare_Function'>tuplestore_gettupleslot</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Delimiter'>, 
</span><a name="LN1078"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>copy</span><span class='Delimiter'>, </span><a href="../../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1080"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN1081"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>should_free</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN1080"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN901"><span class='Ref_to_Func'>tuplestore_gettuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1077"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1077"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1081"><span class='Ref_To_Local'>should_free</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1080"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1078"><span class='Ref_to_Parameter'>copy</span></a> <span class='Operator'>&& !</span><a href="tuplestore.c.html#LN1081"><span class='Ref_To_Local'>should_free</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="tuplestore.c.html#LN1080"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN819"><span class='Ref_to_Proto'>heap_copy_minimal_tuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1080"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN1081"><span class='Ref_To_Local'>should_free</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/executor/tuptable.h.html#LN151"><span class='Ref_to_Proto'>ExecStoreMinimalTuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1080"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1078"><span class='Ref_to_Parameter'>slot</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1081"><span class='Ref_To_Local'>should_free</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1078"><span class='Ref_to_Parameter'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end tuplestore_gettupleslot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_advance - exported function to adjust position without fetching 
 * 
 * We could optimize this case to avoid palloc/pfree overhead, but for the 
 * moment it doesn't seem worthwhile. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1109"></a><span class='Declare_Function'>tuplestore_advance</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1111"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN1112"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>should_free</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN1111"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN901"><span class='Ref_to_Func'>tuplestore_gettuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1109"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1109"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1112"><span class='Ref_To_Local'>should_free</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1111"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1112"><span class='Ref_To_Local'>should_free</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1111"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Advance over N tuples in either forward or back direction, 
 * without returning any data.  N&LT;=0 is a no-op. 
 * Returns TRUE if successful, FALSE if ran out of tuples. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1134"></a><span class='Declare_Function'>tuplestore_skiptuples</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Declare_Parameter'>ntuples</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>forward</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1136"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>readptr</span> <span class='Operator'>= &</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>forward</span></a> <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>& </span><a href="../../../include/executor/executor.h.html#LN59"><span class='Ref_to_Const'>EXEC_FLAG_BACKWARD</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>ntuples</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>forward</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>- </span><a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&GT;= </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>+= </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>                <a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>                    <a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>- </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a> <span class='Operator'>&GT; </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>-= </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="tuplestore.c.html#LN1136"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* We don't currently try hard to optimize other cases */ 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>ntuples</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1182"></a>                <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN1183"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>should_free</span><span class='Delimiter'>; 
</span> 
                <a href="tuplestore.c.html#LN1182"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN901"><span class='Ref_to_Func'>tuplestore_gettuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1134"><span class='Ref_to_Parameter'>forward</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1183"><span class='Ref_To_Local'>should_free</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1182"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1183"><span class='Ref_To_Local'>should_free</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1182"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tuplestore_skiptuples &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * dumptuples - remove tuples from memory and write to tape 
 * 
 * As a side effect, we must convert each read pointer's position from 
 * "current" to file/offset format.  But eof_reached pointers don't 
 * need to change state. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1205"></a><span class='Declare_Function'>dumptuples</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1207"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1207"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Delimiter'>;; </span><a href="tuplestore.c.html#LN1207"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1211"></a>        <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>readptr</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>; 
</span><a name="LN1212"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1212"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1212"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1211"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1212"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1207"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><a href="tuplestore.c.html#LN1211"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>&& !</span><a href="tuplestore.c.html#LN1211"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/storage/buffile.h.html#LN41"><span class='Ref_to_Proto'>BufFileTell</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="tuplestore.c.html#LN1211"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1211"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1207"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN183"><span class='Ref_to_Macro'>WRITETUP</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1207"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN1205"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end dumptuples &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_rescan        - rewind the active read pointer to start 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1232"></a><span class='Declare_Function'>tuplestore_rescan</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1234"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>readptr</span> <span class='Operator'>= &</span><a href="tuplestore.c.html#LN1232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1234"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>& </span><a href="../../../include/executor/executor.h.html#LN58"><span class='Ref_to_Const'>EXEC_FLAG_REWIND</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN1232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Operator'>: 
</span>            <a href="tuplestore.c.html#LN1234"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN1234"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN74"><span class='Ref_to_EnumConst'>TSS_WRITEFILE</span></a><span class='Operator'>: 
</span>            <a href="tuplestore.c.html#LN1234"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN1234"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="tuplestore.c.html#LN1234"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>= </span><span class='Number'>0L</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN75"><span class='Ref_to_EnumConst'>TSS_READFILE</span></a><span class='Operator'>: 
</span>            <a href="tuplestore.c.html#LN1234"><span class='Ref_To_Local'>readptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1232"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0L</span><span class='Delimiter'>, </span>SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplestore state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tuplestore_rescan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_copy_read_pointer - copy a read pointer's state to another 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1267"></a><span class='Declare_Function'>tuplestore_copy_read_pointer</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, 
</span><a name="LN1268"></a>                             <span class='Keyword'>int </span><span class='Declare_Parameter'>srcptr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>destptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1270"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sptr</span> <span class='Operator'>= &</span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>srcptr</span></a><span class='Delimiter'>]; 
</span><a name="LN1271"></a>    <a href="tuplestore.c.html#LN90"><span class='Ref_to_Typedef'>TSReadPointer</span></a> <span class='Operator'>*</span><span class='Declare_Local'>dptr</span> <span class='Operator'>= &</span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>destptr</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>srcptr</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>srcptr</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>destptr</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>destptr</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Assigning to self is a no-op */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>srcptr</span></a> <span class='Operator'>== </span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>destptr</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>!= </span><a href="tuplestore.c.html#LN1270"><span class='Ref_To_Local'>sptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Possible change of overall eflags, so copy and then recompute */ 
</span><a name="LN1283"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>eflags</span><span class='Delimiter'>; 
</span><a name="LN1284"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a> <span class='Operator'>= *</span><a href="tuplestore.c.html#LN1270"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN1283"><span class='Ref_To_Local'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1284"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1284"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1284"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="tuplestore.c.html#LN1283"><span class='Ref_To_Local'>eflags</span></a> <span class='Operator'>|= </span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1284"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN92"><span class='Ref_to_Member'>eflags</span></a><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1283"><span class='Ref_To_Local'>eflags</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a> <span class='Operator'>= *</span><a href="tuplestore.c.html#LN1270"><span class='Ref_To_Local'>sptr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN74"><span class='Ref_to_EnumConst'>TSS_WRITEFILE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* no work */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="tuplestore.c.html#LN75"><span class='Ref_to_EnumConst'>TSS_READFILE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * This case is a bit tricky since the active read pointer's 
             * position corresponds to the seek point, not what is in its 
             * variables.  Assigning to the active requires a seek, and 
             * assigning from the active requires a tell, except when 
             * eof_reached. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>destptr</span></a> <span class='Operator'>== </span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                                    <a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN178"><span class='Ref_to_Member'>writepos_file</span></a><span class='Delimiter'>, 
</span>                                    <a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN179"><span class='Ref_to_Member'>writepos_offset</span></a><span class='Delimiter'>, 
</span>                                    SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN40"><span class='Ref_to_Proto'>BufFileSeek</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                                    <a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Delimiter'>, 
</span>                                    SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if destptr==state-&GT;activ... &raquo; </span> 
            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1268"><span class='Ref_to_Parameter'>srcptr</span></a> <span class='Operator'>== </span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN174"><span class='Ref_to_Member'>activeptr</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/storage/buffile.h.html#LN41"><span class='Ref_to_Proto'>BufFileTell</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1267"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN95"><span class='Ref_to_Member'>file</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="tuplestore.c.html#LN1271"><span class='Ref_To_Local'>dptr</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN96"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid tuplestore state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;status &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tuplestore_copy_read_pointer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_trim  - remove all no-longer-needed tuples 
 * 
 * Calling this function authorizes the tuplestore to delete all tuples 
 * before the oldest read pointer, if no read pointer is marked as requiring 
 * REWIND capability. 
 * 
 * Note: this is obviously safe if no pointer has BACKWARD capability either. 
 * If a pointer is marked as BACKWARD but not REWIND capable, it means that 
 * the pointer can be moved backward but not before the oldest other read 
 * pointer. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1359"></a><span class='Declare_Function'>tuplestore_trim</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1361"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>oldest</span><span class='Delimiter'>; 
</span><a name="LN1362"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nremove</span><span class='Delimiter'>; 
</span><a name="LN1363"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Truncation is disallowed if any read pointer requires rewind 
     * capability. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN105"><span class='Ref_to_Member'>eflags</span></a> <span class='Operator'>& </span><a href="../../../include/executor/executor.h.html#LN58"><span class='Ref_to_Const'>EXEC_FLAG_REWIND</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't bother trimming temp files since it usually would mean more 
     * work than just letting them sit in kernel buffers until they age out. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>!= </span><a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Find the oldest read pointer */ 
</span>    <a href="tuplestore.c.html#LN1361"><span class='Ref_To_Local'>oldest</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>            <a href="tuplestore.c.html#LN1361"><span class='Ref_To_Local'>oldest</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1361"><span class='Ref_To_Local'>oldest</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: you might think we could remove all the tuples before the oldest 
     * "current", since that one is the next to be returned.  However, since 
     * tuplestore_gettuple returns a direct pointer to our internal copy of 
     * the tuple, it's likely that the caller has still got the tuple just 
     * before "current" referenced in a slot. So we keep one extra tuple 
     * before the oldest "current".  (Strictly speaking, we could require such 
     * callers to use the "copy" flag to tuplestore_gettupleslot, but for 
     * efficiency we allow this one case to not use "copy".) 
     */ 
</span>    <a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1361"><span class='Ref_To_Local'>oldest</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* nothing to do */ 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a> <span class='Operator'>&GT;= </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a> <span class='Operator'>&LT;= </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release no-longer-needed tuples */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* mark tuplestore as truncated (used for Assert crosschecks only) */ 
</span>    <a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN108"><span class='Ref_to_Member'>truncated</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If nremove is less than 1/8th memtupcount, just stop here, leaving the 
     * "deleted" slots as NULL.  This prevents us from expending O(N^2) time 
     * repeatedly memmove-ing a large pointer array.  The worst case space 
     * wastage is pretty small, since it's just pointers and not whole tuples. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>/ </span><span class='Number'>8</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Slide the array down and readjust pointers. 
     * 
     * In mergejoin's current usage, it's demonstrable that there will always 
     * be exactly one non-removed tuple; so optimize that case. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a> <span class='Operator'>+ </span><span class='Number'>1</span> <span class='Operator'>== </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a><span class='Parentheses'>) 
</span>        <a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a><span class='Delimiter'>]; 
</span>    <span class='Control'>else</span> 
        <a href="../../../include/c.h.html#LN1057"><span class='Ref_to_Macro'>memmove</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a><span class='Delimiter'>, </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN159"><span class='Ref_to_Member'>memtuples</span></a> <span class='Operator'>+ </span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>- </span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN160"><span class='Ref_to_Member'>memtupdeleted</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN161"><span class='Ref_to_Member'>memtupcount</span></a> <span class='Operator'>-= </span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN175"><span class='Ref_to_Member'>readptrcount</span></a><span class='Delimiter'>; </span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN93"><span class='Ref_to_Member'>eof_reached</span></a><span class='Parentheses'>) 
</span>            <a href="tuplestore.c.html#LN1359"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN173"><span class='Ref_to_Member'>readptrs</span></a><span class='Delimiter'>[</span><a href="tuplestore.c.html#LN1363"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="tuplestore.c.html#LN94"><span class='Ref_to_Member'>current</span></a> <span class='Operator'>-= </span><a href="tuplestore.c.html#LN1362"><span class='Ref_To_Local'>nremove</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end tuplestore_trim &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * tuplestore_in_memory 
 * 
 * Returns true if the tuplestore has not spilled to disk. 
 * 
 * XXX exposing this is a violation of modularity ... should get rid of it. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1454"></a><span class='Declare_Function'>tuplestore_in_memory</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1454"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN104"><span class='Ref_to_Member'>status</span></a> <span class='Operator'>== </span><a href="tuplestore.c.html#LN73"><span class='Ref_to_EnumConst'>TSS_INMEM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Tape interface routines 
 */ 
</span> 
<span class='Keyword'>static unsigned int 
</span><a name="LN1465"></a><span class='Declare_Function'>getlen</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>eofOK</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1467"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span><a name="LN1468"></a>    size_t      <span class='Declare_Local'>nbytes</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN1468"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>= </span><a href="../../../include/storage/buffile.h.html#LN38"><span class='Ref_to_Proto'>BufFileRead</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1465"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1467"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1467"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1468"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>== </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1467"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="tuplestore.c.html#LN1467"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1468"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| !</span><a href="tuplestore.c.html#LN1465"><span class='Ref_to_Parameter'>eofOK</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>               <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read from tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Routines specialized for HeapTuple case 
 * 
 * The stored form is actually a MinimalTuple, but for largely historical 
 * reasons we allow COPYTUP to work from a HeapTuple. 
 * 
 * Since MinimalTuple already has length in its first word, we don't need 
 * to write that separately. 
 */ 
</span> 
<span class='Keyword'>static void </span><span class='Operator'>* 
</span><a name="LN1492"></a><span class='Declare_Function'>copytup_heap</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1494"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN1494"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN821"><span class='Ref_to_Proto'>minimal_tuple_from_heap_tuple</span></a><span class='Parentheses'>((</span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1492"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1492"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1494"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1494"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN1502"></a><span class='Declare_Function'>writetup_heap</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1504"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1502"><span class='Ref_to_Parameter'>tup</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* the part of the MinimalTuple we'll write: */ 
</span><a name="LN1507"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>tupbody</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1504"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span><a name="LN1508"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tupbodylen</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1504"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN628"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>- </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* total on-disk footprint: */ 
</span><a name="LN1511"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1508"><span class='Ref_To_Local'>tupbodylen</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN39"><span class='Ref_to_Proto'>BufFileWrite</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1502"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1511"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, 
</span>                     <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1511"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1511"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN39"><span class='Ref_to_Proto'>BufFileWrite</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1502"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1507"><span class='Ref_To_Local'>tupbody</span></a><span class='Delimiter'>, 
</span>                     <a href="tuplestore.c.html#LN1508"><span class='Ref_To_Local'>tupbodylen</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Parentheses'>(</span>size_t<span class='Parentheses'>)</span> <a href="tuplestore.c.html#LN1508"><span class='Ref_To_Local'>tupbodylen</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1502"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN106"><span class='Ref_to_Member'>backward</span></a><span class='Parentheses'>)</span>        <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN39"><span class='Ref_to_Proto'>BufFileWrite</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1502"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1511"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, 
</span>                         <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1511"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1511"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN187"><span class='Ref_to_Macro'>FREEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1502"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1504"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/htup_details.h.html#LN818"><span class='Ref_to_Proto'>heap_free_minimal_tuple</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1504"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end writetup_heap &raquo; </span> 
 
<span class='Keyword'>static void </span><span class='Operator'>* 
</span><a name="LN1535"></a><span class='Declare_Function'>readtup_heap</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>unsigned int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1537"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tupbodylen</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1535"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>- </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1538"></a>    <span class='Keyword'>unsigned int </span><span class='Declare_Local'>tuplen</span> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1537"><span class='Ref_To_Local'>tupbodylen</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span><a name="LN1539"></a>    <a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>tuple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1538"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1540"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>tupbody</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1539"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>+ </span><a href="../../../include/access/htup_details.h.html#LN623"><span class='Ref_to_Const'>MINIMAL_TUPLE_DATA_OFFSET</span></a><span class='Delimiter'>; 
</span> 
    <a href="tuplestore.c.html#LN186"><span class='Ref_to_Macro'>USEMEM</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1535"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/memutils.h.html#LN80"><span class='Ref_to_Proto'>GetMemoryChunkSpace</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1539"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* read in the tuple proper */ 
</span>    <a href="tuplestore.c.html#LN1539"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN628"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="tuplestore.c.html#LN1538"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN38"><span class='Ref_to_Proto'>BufFileRead</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1535"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1540"><span class='Ref_To_Local'>tupbody</span></a><span class='Delimiter'>, 
</span>                    <a href="tuplestore.c.html#LN1537"><span class='Ref_To_Local'>tupbodylen</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Parentheses'>(</span>size_t<span class='Parentheses'>)</span> <a href="tuplestore.c.html#LN1537"><span class='Ref_To_Local'>tupbodylen</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>               <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read from tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1535"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN106"><span class='Ref_to_Member'>backward</span></a><span class='Parentheses'>)</span>        <span class='Comment_Single_Line'>/* need trailing length word? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/buffile.h.html#LN38"><span class='Ref_to_Proto'>BufFileRead</span></a><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1535"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="tuplestore.c.html#LN112"><span class='Ref_to_Member'>myfile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="tuplestore.c.html#LN1538"><span class='Ref_To_Local'>tuplen</span></a><span class='Delimiter'>, 
</span>                        <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1538"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tuplestore.c.html#LN1538"><span class='Ref_To_Local'>tuplen</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>               <a href="../error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read from tuplestore temporary file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="tuplestore.c.html#LN1539"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end readtup_heap &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>