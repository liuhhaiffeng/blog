<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\utils\time\combocid.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\utils\time\combocid.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:59 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * combocid.c 
 *    Combo command ID support routines 
 * 
 * Before version 8.3, HeapTupleHeaderData had separate fields for cmin 
 * and cmax.  To reduce the header size, cmin and cmax are now overlayed 
 * in the same field in the header.  That usually works because you rarely 
 * insert and delete a tuple in the same transaction, and we don't need 
 * either field to remain valid after the originating transaction exits. 
 * To make it work when the inserting transaction does delete the tuple, 
 * we create a "combo" command ID and store that in the tuple header 
 * instead of cmin and cmax. The combo command ID can be mapped to the 
 * real cmin and cmax using a backend-private array, which is managed by 
 * this module. 
 * 
 * To allow reusing existing combo cids, we also keep a hash table that 
 * maps cmin,cmax pairs to combo cids.  This keeps the data structure size 
 * reasonable in most cases, since the number of unique pairs used by any 
 * one transaction is likely to be small. 
 * 
 * With a 32-bit combo command id we can represent 2^32 distinct cmin,cmax 
 * combinations. In the most perverse case where each command deletes a tuple 
 * generated by every previous command, the number of combo command ids 
 * required for N commands is N*(N+1)/2.  That means that in the worst case, 
 * that's enough for 92682 commands.  In practice, you'll run out of memory 
 * and/or disk space way before you reach that limit. 
 * 
 * The array and hash table are kept in TopTransactionContext, and are 
 * destroyed at the end of each transaction. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/utils/time/combocid.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/shmem.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/combocid.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/hsearch.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Hash table to lookup combo cids by cmin and cmax */ 
</span><a name="LN53"></a><span class='Keyword'>static </span><a href="../hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>comboHash</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Key and entry structures for the hash table */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN58"></a>    <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Member'>cmin</span><span class='Delimiter'>; 
</span><a name="LN59"></a>    <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Member'>cmax</span><span class='Delimiter'>; 
</span><a name="LN60"></a>} <span class='Declare_Typedef'>ComboCidKeyData</span><span class='Delimiter'>; 
</span> 
<a name="LN62"></a><span class='Control'>typedef</span> <a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>ComboCidKey</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN66"></a>    <a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a> <span class='Declare_Member'>key</span><span class='Delimiter'>; 
</span><a name="LN67"></a>    <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Member'>combocid</span><span class='Delimiter'>; 
</span><a name="LN68"></a>} <span class='Declare_Typedef'>ComboCidEntryData</span><span class='Delimiter'>; 
</span> 
<a name="LN70"></a><span class='Control'>typedef</span> <a href="combocid.c.html#LN64"><span class='Ref_to_Typedef'>ComboCidEntryData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>ComboCidEntry</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Initial size of the hash table */ 
</span><a name="LN73"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CCID_HASH_SIZE</span>          <span class='Number'>100</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * An array of cmin,cmax pairs, indexed by combo command id. 
 * To convert a combo cid to cmin and cmax, you do a simple array lookup. 
 */ 
</span><a name="LN80"></a><span class='Keyword'>static </span><a href="combocid.c.html#LN62"><span class='Ref_to_Typedef'>ComboCidKey</span></a> <span class='Declare_Var'>comboCids</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN81"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>usedComboCids</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* number of elements in comboCids */ 
</span><a name="LN82"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>sizeComboCids</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* allocated size of array */ 
</span> 
<span class='Comment_Multi_Line'>/* Initial size of the array */ 
</span><a name="LN85"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CCID_ARRAY_SIZE</span>         <span class='Number'>100</span> 
 
 
<span class='Comment_Multi_Line'>/* prototypes for internal functions */ 
</span><a name="LN89"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Prototype'>GetComboCommandId</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>cmin</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>cmax</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN90"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Prototype'>GetRealCmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>combocid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN91"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Prototype'>GetRealCmax</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>combocid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/**** External API ****/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetCmin and GetCmax assert that they are only called in situations where 
 * they make sense, that is, can deliver a useful answer.  If you have 
 * reason to examine a tuple's t_cid field from a transaction other than 
 * the originating one, use HeapTupleHeaderGetRawCommandId() directly. 
 */ 
</span> 
<a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> 
<a name="LN104"></a><span class='Declare_Function'>HeapTupleHeaderGetCmin</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN106"></a>    <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Local'>cid</span> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN384"><span class='Ref_to_Macro'>HeapTupleHeaderGetRawCommandId</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN104"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN104"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>& </span><a href="../../../include/access/htup_details.h.html#LN201"><span class='Ref_to_Const'>HEAP_MOVED</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN104"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN104"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>& </span><a href="../../../include/access/htup_details.h.html#LN179"><span class='Ref_to_Const'>HEAP_COMBOCID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="combocid.c.html#LN90"><span class='Ref_to_Proto'>GetRealCmin</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN106"><span class='Ref_To_Local'>cid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="combocid.c.html#LN106"><span class='Ref_To_Local'>cid</span></a><span class='Delimiter'>; 
} 
</span> 
<a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> 
<a name="LN118"></a><span class='Declare_Function'>HeapTupleHeaderGetCmax</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN120"></a>    <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Local'>cid</span> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN384"><span class='Ref_to_Macro'>HeapTupleHeaderGetRawCommandId</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN118"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN118"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>& </span><a href="../../../include/access/htup_details.h.html#LN201"><span class='Ref_to_Const'>HEAP_MOVED</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Because GetUpdateXid() performs memory allocations if xmax is a 
     * multixact we can't Assert() if we're inside a critical section. This 
     * weakens the check, but not using GetCmax() inside one would complicate 
     * things too much. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../init/globals.c.html#LN36"><span class='Ref_to_Global_Var'>CritSectionCount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>      <a href="../../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN118"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN118"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>& </span><a href="../../../include/access/htup_details.h.html#LN179"><span class='Ref_to_Const'>HEAP_COMBOCID</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="combocid.c.html#LN91"><span class='Ref_to_Proto'>GetRealCmax</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN120"><span class='Ref_To_Local'>cid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="combocid.c.html#LN120"><span class='Ref_To_Local'>cid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end HeapTupleHeaderGetCmax &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given a tuple we are about to delete, determine the correct value to store 
 * into its t_cid field. 
 * 
 * If we don't need a combo CID, *cmax is unchanged and *iscombo is set to 
 * FALSE.  If we do need one, *cmax is replaced by a combo CID and *iscombo 
 * is set to TRUE. 
 * 
 * The reason this is separate from the actual HeapTupleHeaderSetCmax() 
 * operation is that this could fail due to out-of-memory conditions.  Hence 
 * we need to do this before entering the critical section that actually 
 * changes the tuple in shared buffers. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN153"></a><span class='Declare_Function'>HeapTupleHeaderAdjustCmax</span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Parameter'>tup</span><span class='Delimiter'>, 
</span><a name="LN154"></a>                          <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cmax</span><span class='Delimiter'>, 
</span><a name="LN155"></a>                          <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>iscombo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * If we're marking a tuple deleted that was inserted by (any 
     * subtransaction of) our transaction, we need to use a combo command id. 
     * Test for HeapTupleHeaderXminCommitted() first, because it's cheaper 
     * than a TransactionIdIsCurrentTransactionId call. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup_details.h.html#LN317"><span class='Ref_to_Macro'>HeapTupleHeaderXminCommitted</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN153"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <a href="../../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN301"><span class='Ref_to_Macro'>HeapTupleHeaderGetRawXmin</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN153"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN166"></a>        <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Local'>cmin</span> <span class='Operator'>= </span><a href="../../../include/access/htup.h.html#LN79"><span class='Ref_to_Proto'>HeapTupleHeaderGetCmin</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN153"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="combocid.c.html#LN154"><span class='Ref_to_Parameter'>cmax</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN89"><span class='Ref_to_Proto'>GetComboCommandId</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN166"><span class='Ref_To_Local'>cmin</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="combocid.c.html#LN154"><span class='Ref_to_Parameter'>cmax</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="combocid.c.html#LN155"><span class='Ref_to_Parameter'>iscombo</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="combocid.c.html#LN155"><span class='Ref_to_Parameter'>iscombo</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end HeapTupleHeaderAdjustCmax &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Combo command ids are only interesting to the inserting and deleting 
 * transaction, so we can forget about them at the end of transaction. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN182"></a><span class='Declare_Function'>AtEOXact_ComboCid</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Don't bother to pfree. These are allocated in TopTransactionContext, so 
     * they're going to go away at the end of transaction anyway. 
     */ 
</span>    <a href="combocid.c.html#LN53"><span class='Ref_to_Global_Var'>comboHash</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="combocid.c.html#LN82"><span class='Ref_to_Global_Var'>sizeComboCids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/**** Internal routines ****/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get a combo command id that maps to cmin and cmax. 
 * 
 * We try to reuse old combo command ids when possible. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> 
<a name="LN204"></a><span class='Declare_Function'>GetComboCommandId</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>cmin</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>cmax</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN206"></a>    <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Local'>combocid</span><span class='Delimiter'>; 
</span><a name="LN207"></a>    <a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span><a name="LN208"></a>    <a href="combocid.c.html#LN70"><span class='Ref_to_Typedef'>ComboCidEntry</span></a> <span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN209"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create the hash table and array the first time we need to use combo 
     * cids in the transaction. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN53"><span class='Ref_to_Global_Var'>comboHash</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN217"></a>        <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>hash_ctl</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Make array first; existence of hash table asserts array exists */ 
</span>        <a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/palloc.h.html#LN70"><span class='Ref_to_Proto'>MemoryContextAlloc</span></a><span class='Parentheses'>(</span><a href="../mmgr/mcxt.c.html#LN47"><span class='Ref_to_Global_Var'>TopTransactionContext</span></a><span class='Delimiter'>, 
</span>                               <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="combocid.c.html#LN85"><span class='Ref_to_Const'>CCID_ARRAY_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="combocid.c.html#LN82"><span class='Ref_to_Global_Var'>sizeComboCids</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN85"><span class='Ref_to_Const'>CCID_ARRAY_SIZE</span></a><span class='Delimiter'>; 
</span>        <a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="combocid.c.html#LN217"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN217"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="combocid.c.html#LN217"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="combocid.c.html#LN217"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN64"><span class='Ref_to_Typedef'>ComboCidEntryData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="combocid.c.html#LN217"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN77"><span class='Ref_to_Member'>hcxt</span></a> <span class='Operator'>= </span><a href="../mmgr/mcxt.c.html#LN47"><span class='Ref_to_Global_Var'>TopTransactionContext</span></a><span class='Delimiter'>; 
</span> 
        <a href="combocid.c.html#LN53"><span class='Ref_to_Global_Var'>comboHash</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Combo CIDs"</span><span class='Delimiter'>, 
</span>                                <a href="combocid.c.html#LN73"><span class='Ref_to_Const'>CCID_HASH_SIZE</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>&</span><a href="combocid.c.html#LN217"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                                <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN92"><span class='Ref_to_Const'>HASH_CONTEXT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if comboHash==NULL &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Grow the array if there's not at least one free slot.  We must do this 
     * before possibly entering a new hashtable entry, else failure to 
     * repalloc would leave a corrupt hashtable entry behind. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a> <span class='Operator'>&GT;= </span><a href="combocid.c.html#LN82"><span class='Ref_to_Global_Var'>sizeComboCids</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN244"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>newsize</span> <span class='Operator'>= </span><a href="combocid.c.html#LN82"><span class='Ref_to_Global_Var'>sizeComboCids</span></a> <span class='Operator'>* </span><span class='Number'>2</span><span class='Delimiter'>; 
</span> 
        <a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="combocid.c.html#LN244"><span class='Ref_To_Local'>newsize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="combocid.c.html#LN82"><span class='Ref_to_Global_Var'>sizeComboCids</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN244"><span class='Ref_To_Local'>newsize</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Lookup or create a hash entry with the desired cmin/cmax */ 
</span> 
    <span class='Comment_Multi_Line'>/* We assume there is no struct padding in ComboCidKeyData! */ 
</span>    <a href="combocid.c.html#LN207"><span class='Ref_To_Local'>key</span></a><span class='Operator'>.</span><a href="combocid.c.html#LN58"><span class='Ref_to_Member'>cmin</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN204"><span class='Ref_to_Parameter'>cmin</span></a><span class='Delimiter'>; 
</span>    <a href="combocid.c.html#LN207"><span class='Ref_To_Local'>key</span></a><span class='Operator'>.</span><a href="combocid.c.html#LN59"><span class='Ref_to_Member'>cmax</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN204"><span class='Ref_to_Parameter'>cmax</span></a><span class='Delimiter'>; 
</span>    <a href="combocid.c.html#LN208"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="combocid.c.html#LN70"><span class='Ref_to_Typedef'>ComboCidEntry</span></a><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN53"><span class='Ref_to_Global_Var'>comboHash</span></a><span class='Delimiter'>, 
</span>                                        <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="combocid.c.html#LN207"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="combocid.c.html#LN209"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN209"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Reuse an existing combo cid */ 
</span>        <span class='Control'>return</span> <a href="combocid.c.html#LN208"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="combocid.c.html#LN67"><span class='Ref_to_Member'>combocid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* We have to create a new combo cid; we already made room in the array */ 
</span>    <a href="combocid.c.html#LN206"><span class='Ref_To_Local'>combocid</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Delimiter'>; 
</span> 
    <a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a><span class='Delimiter'>[</span><a href="combocid.c.html#LN206"><span class='Ref_To_Local'>combocid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="combocid.c.html#LN58"><span class='Ref_to_Member'>cmin</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN204"><span class='Ref_to_Parameter'>cmin</span></a><span class='Delimiter'>; 
</span>    <a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a><span class='Delimiter'>[</span><a href="combocid.c.html#LN206"><span class='Ref_To_Local'>combocid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="combocid.c.html#LN59"><span class='Ref_to_Member'>cmax</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN204"><span class='Ref_to_Parameter'>cmax</span></a><span class='Delimiter'>; 
</span>    <a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <a href="combocid.c.html#LN208"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="combocid.c.html#LN67"><span class='Ref_to_Member'>combocid</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN206"><span class='Ref_To_Local'>combocid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="combocid.c.html#LN206"><span class='Ref_To_Local'>combocid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetComboCommandId &raquo; </span> 
 
<span class='Keyword'>static </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> 
<a name="LN280"></a><span class='Declare_Function'>GetRealCmin</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>combocid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN280"><span class='Ref_to_Parameter'>combocid</span></a> <span class='Operator'>&LT; </span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a><span class='Delimiter'>[</span><a href="combocid.c.html#LN280"><span class='Ref_to_Parameter'>combocid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="combocid.c.html#LN58"><span class='Ref_to_Member'>cmin</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static </span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> 
<a name="LN287"></a><span class='Declare_Function'>GetRealCmax</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a> <span class='Declare_Parameter'>combocid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN287"><span class='Ref_to_Parameter'>combocid</span></a> <span class='Operator'>&LT; </span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a><span class='Delimiter'>[</span><a href="combocid.c.html#LN287"><span class='Ref_to_Parameter'>combocid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="combocid.c.html#LN59"><span class='Ref_to_Member'>cmax</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Estimate the amount of space required to serialize the current ComboCID 
 * state. 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN298"></a><span class='Declare_Function'>EstimateComboCIDStateSpace</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN300"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add space required for saving usedComboCids */ 
</span>    <a href="combocid.c.html#LN300"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add space required for saving the combocids key */ 
</span>    <a href="combocid.c.html#LN300"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN300"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="combocid.c.html#LN300"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Serialize the ComboCID state into the memory, beginning at start_address. 
 * maxsize should be at least as large as the value returned by 
 * EstimateComboCIDStateSpace. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN317"></a><span class='Declare_Function'>SerializeComboCIDState</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>maxsize</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>start_address</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN319"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>endptr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First, we store the number of currently-existing ComboCIDs. */ 
</span>    <span class='Operator'>*</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="combocid.c.html#LN317"><span class='Ref_to_Parameter'>start_address</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If maxsize is too small, throw an error. */ 
</span>    <a href="combocid.c.html#LN319"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN317"><span class='Ref_to_Parameter'>start_address</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN319"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>&LT; </span><a href="combocid.c.html#LN317"><span class='Ref_to_Parameter'>start_address</span></a> <span class='Operator'>|| </span><a href="combocid.c.html#LN319"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>&GT; </span><a href="combocid.c.html#LN317"><span class='Ref_to_Parameter'>start_address</span></a> <span class='Operator'>+ </span><a href="combocid.c.html#LN317"><span class='Ref_to_Parameter'>maxsize</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"not enough space to serialize ComboCID state"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now, copy the actual cmin/cmax pairs. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        memcpy<span class='Parentheses'>(</span><a href="combocid.c.html#LN317"><span class='Ref_to_Parameter'>start_address</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a><span class='Delimiter'>, 
</span>               <span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="combocid.c.html#LN81"><span class='Ref_to_Global_Var'>usedComboCids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Read the ComboCID state at the specified address and initialize this 
 * backend with the same ComboCIDs.  This is only valid in a backend that 
 * currently has no ComboCIDs (and only makes sense if the transaction state 
 * is serialized and restored as well). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN343"></a><span class='Declare_Function'>RestoreComboCIDState</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>comboCIDstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN345"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_elements</span><span class='Delimiter'>; 
</span><a name="LN346"></a>    <a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>keydata</span><span class='Delimiter'>; 
</span><a name="LN347"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN348"></a>    <a href="../../../include/c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Local'>cid</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="combocid.c.html#LN80"><span class='Ref_to_Global_Var'>comboCids</span></a> <span class='Operator'>&& !</span><a href="combocid.c.html#LN53"><span class='Ref_to_Global_Var'>comboHash</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First, we retrieve the number of ComboCIDs that were serialized. */ 
</span>    <a href="combocid.c.html#LN345"><span class='Ref_To_Local'>num_elements</span></a> <span class='Operator'>= *</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="combocid.c.html#LN343"><span class='Ref_to_Parameter'>comboCIDstate</span></a><span class='Delimiter'>; 
</span>    <a href="combocid.c.html#LN346"><span class='Ref_To_Local'>keydata</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="combocid.c.html#LN56"><span class='Ref_to_Typedef'>ComboCidKeyData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="combocid.c.html#LN343"><span class='Ref_to_Parameter'>comboCIDstate</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Use GetComboCommandId to restore each ComboCID. */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN347"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="combocid.c.html#LN347"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="combocid.c.html#LN345"><span class='Ref_To_Local'>num_elements</span></a><span class='Delimiter'>; </span><a href="combocid.c.html#LN347"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="combocid.c.html#LN348"><span class='Ref_To_Local'>cid</span></a> <span class='Operator'>= </span><a href="combocid.c.html#LN89"><span class='Ref_to_Proto'>GetComboCommandId</span></a><span class='Parentheses'>(</span><a href="combocid.c.html#LN346"><span class='Ref_To_Local'>keydata</span></a><span class='Delimiter'>[</span><a href="combocid.c.html#LN347"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="combocid.c.html#LN58"><span class='Ref_to_Member'>cmin</span></a><span class='Delimiter'>, </span><a href="combocid.c.html#LN346"><span class='Ref_To_Local'>keydata</span></a><span class='Delimiter'>[</span><a href="combocid.c.html#LN347"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="combocid.c.html#LN59"><span class='Ref_to_Member'>cmax</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Verify that we got the expected answer. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="combocid.c.html#LN348"><span class='Ref_To_Local'>cid</span></a> <span class='Operator'>!= </span><a href="combocid.c.html#LN347"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected command ID while restoring combo CIDs"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end RestoreComboCIDState &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>