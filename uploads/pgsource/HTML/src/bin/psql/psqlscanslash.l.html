<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\bin\psql\psqlscanslash.l</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\bin\psql\psqlscanslash.l</b></p></td>
<td align='right'>
Wed Jun 14 08:26:02 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Operator'>%</span>top<span class='Delimiter'>{ 
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * psqlscanslash.l 
 *    lexical scanner for psql backslash commands 
 * 
 * XXX Avoid creating backtracking cases --- see the backend lexer for info. 
 * 
 * See fe_utils/psqlscan_int.h for additional commentary. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/bin/psql/psqlscanslash.l 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres_fe.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"psqlscanslash.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"conditional.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"libpq-fe.h"</span> 
<span class='Delimiter'>} 
</span> 
<span class='Operator'>%</span><span class='Delimiter'>{ 
</span><span class='Keyword'>#include </span><span class='String'>"fe_utils/psqlscan_int.h"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * We must have a typedef YYSTYPE for yylex's first argument, but this lexer 
 * doesn't presently make use of that argument, so just declare it as int. 
 */ 
</span><a name="LN33"></a><span class='Control'>typedef</span> <span class='Keyword'>int </span><span class='Declare_Typedef'>YYSTYPE</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Set the type of yyextra; we use it as a pointer back to the containing 
 * PsqlScanState. 
 */ 
</span><a name="LN39"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>YY_EXTRA_TYPE</span> <a href="../../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> 
 
<span class='Comment_Multi_Line'>/* 
 * These variables do not need to be saved across calls.  Yeah, it's a bit 
 * of a hack, but putting them into PsqlScanStateData would be klugy too. 
 */ 
</span><a name="LN45"></a><span class='Keyword'>static </span><span class='Control'>enum</span> <a href="psqlscanslash.h.html#LN14"><span class='Ref_to_Enum'>slash_option_type</span></a> <span class='Declare_Var'>option_type</span><span class='Delimiter'>; 
</span><a name="LN46"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>option_quote</span><span class='Delimiter'>; 
</span><a name="LN47"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>unquoted_option_chars</span><span class='Delimiter'>; 
</span><a name="LN48"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>backtick_start_offset</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* Return values from yylex() */ 
</span><a name="LN52"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LEXRES_EOL</span>          <span class='Number'>0</span>   <span class='Comment_Single_Line'>/* end of input */ 
</span><a name="LN53"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LEXRES_OK</span>           <span class='Number'>1</span>   <span class='Comment_Single_Line'>/* OK completion of backslash argument */ 
</span> 
 
<a name="LN56"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>evaluate_backtick</span><span class='Parentheses'>(</span><a href="../../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN58"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ECHO</span> <a href="../pgbench/exprscan.l.html#LN97"><span class='Ref_to_Proto'>psqlscan_emit</span></a><span class='Parentheses'>(</span><a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, </span>yytext<span class='Delimiter'>, </span>yyleng<span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Work around a bug in flex 2.5.35: it emits a couple of functions that 
 * it forgets to emit declarations for.  Since we use -Wmissing-prototypes, 
 * this would cause warnings.  Providing our own declarations should be 
 * harmless even when the bug gets fixed. 
 */ 
</span><a name="LN66"></a><span class='Keyword'>extern int</span>  <span class='Declare_Prototype'>slash_yyget_column</span><span class='Parentheses'>(</span><a href="../pgbench/pgbench.h.html#LN22"><span class='Ref_to_Const'>yyscan_t</span></a> <span class='Declare_Parameter'>yyscanner</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN67"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>slash_yyset_column</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>column_no</span><span class='Delimiter'>, </span><a href="../pgbench/pgbench.h.html#LN22"><span class='Ref_to_Const'>yyscan_t</span></a> <span class='Declare_Parameter'>yyscanner</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Operator'>%</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* Except for the prefix, these options should match psqlscan.l */ 
</span><span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> reentrant 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> bison<span class='Operator'>-</span>bridge 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> <span class='Number'>8bit</span> 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> never<span class='Operator'>-</span>interactive 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> nodefault 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> noinput 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> nounput 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> noyywrap 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> <a href="../../interfaces/ecpg/test/expected/preproc-whenever.c.html#LN38"><span class='Ref_to_Func'>warn</span></a> 
<span class='Operator'>%</span><a href="../../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> prefix<span class='Operator'>=</span><span class='String'>"slash_yy"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * OK, here is a short description of lex/flex rules behavior. 
 * The longest pattern which matches an input string is always chosen. 
 * For equal-length patterns, the first occurring in the rules list is chosen. 
 * INITIAL is the starting state, to which all non-conditional rules apply. 
 * Exclusive states change parsing rules while the state is active.  When in 
 * an exclusive state, only those rules defined for that state apply. 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* Exclusive states for lexing backslash commands */ 
</span><span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslashcmd 
<span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslashargstart 
<span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslasharg 
<span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslashquote 
<span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslashbackquote 
<span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslashdquote 
<span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslashwholeline 
<span class='Operator'>%</span><a href="psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xslashend 
 
<span class='Comment_Multi_Line'>/* 
 * Assorted character class definitions that should match psqlscan.l. 
 */ 
</span>space           <span class='Delimiter'>[ </span><span class='Operator'>\</span>t<span class='Operator'>\</span>n<span class='Operator'>\</span>r<span class='Operator'>\</span>f<span class='Delimiter'>] 
</span>quote           <span class='String'>' 
xeoctesc        [\\][0-7]{1,3} 
</span><a name="LN108"></a><span class='String'>xehexesc        [\\]x[0-9A-Fa-f]{1,2} 
xqdouble        {quote}{quote} 
dquote          \" 
variable_char   [A-Za-z\200-\377_0-9] 
 
other           . 
 
%% 
 
%{ 
        /* Declare some local variables inside yylex(), for convenience */ 
        PsqlScanState cur_state = yyextra; 
        PQExpBuffer output_buf = cur_state-&GT;output_buf; 
 
        /* 
         * Force flex into the state indicated by start_state.  This has a 
         * couple of purposes: it lets some of the functions below set a new 
         * starting state without ugly direct access to flex variables, and it 
         * allows us to transition from one flex lexer to another so that we 
         * can lex different parts of the source string using separate lexers. 
         */ 
        BEGIN(cur_state-&GT;start_state); 
%} 
 
    /* 
     * We don'</span>t really expect to be invoked in the INITIAL <a href="../../timezone/pgtz.h.html#LN40"><span class='Ref_to_Struct'>state</span></a> in <span class='Keyword'>this 
</span>     <span class='Operator'>* </span>lexer<span class='Delimiter'>; </span>but <span class='Control'>if</span> we are<span class='Delimiter'>, </span>just spit data to the <a href="../../fe_utils/psqlscan.l.html#LN360"><span class='Ref_to_Global_Var'>output_buf</span></a> until EOF<span class='Operator'>. 
</span>     <span class='Operator'>*/ 
</span> 
<span class='Delimiter'>{</span>other<span class='Delimiter'>}</span><span class='Operator'>|\</span>n      <span class='Delimiter'>{ </span><a href="psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; } 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Exclusive lexer states to handle backslash command lexing 
     */ 
</span> 
<span class='Operator'>&LT;</span>xslashcmd<span class='Operator'>&GT;</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* command name ends at whitespace or backslash; eat all else */ 
</span> 
<span class='Delimiter'>{</span>space<span class='Delimiter'>}</span><span class='Operator'>|</span><span class='String'>"\\"</span>    <span class='Delimiter'>{ 
</span>                    <a href="../../backend/replication/repl_scanner.l.html#LN135"><span class='Ref_to_Proto'>yyless</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>= </span>YY_START<span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="psqlscanslash.l.html#LN53"><span class='Ref_to_Const'>LEXRES_OK</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>other<span class='Delimiter'>}</span>         <span class='Delimiter'>{ </span><a href="psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; } 
</span> 
<span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;</span>xslashargstart<span class='Operator'>&GT;</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Discard any whitespace before argument, then go to xslasharg state. 
     * An exception is that "|" is only special at start of argument, so we 
     * check for it here. 
     */ 
</span> 
<span class='Delimiter'>{</span>space<span class='Delimiter'>}</span><span class='Operator'>+</span>        <span class='Delimiter'>{ } 
</span> 
<span class='String'>"|"</span>             <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscanslash.l.html#LN45"><span class='Ref_to_Global_Var'>option_type</span></a> <span class='Operator'>== </span><a href="psqlscanslash.h.html#LN19"><span class='Ref_to_EnumConst'>OT_FILEPIPE</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* treat like whole-string case */ 
</span>                        <a href="psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                        <a href="../../backend/replication/syncrep_scanner.l.html#LN73"><span class='Ref_to_Proto'>BEGIN</span></a><span class='Parentheses'>(</span>xslashwholeline<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* vertical bar is not special otherwise */ 
</span>                        <a href="../../backend/replication/repl_scanner.l.html#LN135"><span class='Ref_to_Proto'>yyless</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="../../backend/replication/syncrep_scanner.l.html#LN73"><span class='Ref_to_Proto'>BEGIN</span></a><span class='Parentheses'>(</span>xslasharg<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>other<span class='Delimiter'>}</span>         <span class='Delimiter'>{ 
</span>                    <a href="../../backend/replication/repl_scanner.l.html#LN135"><span class='Ref_to_Proto'>yyless</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../backend/replication/syncrep_scanner.l.html#LN73"><span class='Ref_to_Proto'>BEGIN</span></a><span class='Parentheses'>(</span>xslasharg<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;</span>xslasharg<span class='Operator'>&GT;</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Default processing of text in a slash command's argument. 
     * 
     * Note: unquoted_option_chars counts the number of characters at the 
     * end of the argument that were not subject to any form of quoting. 
     * psql_scan_slash_option needs this to strip trailing semicolons safely. 
     */ 
</span> 
<span class='Delimiter'>{</span>space<span class='Delimiter'>}</span><span class='Operator'>|</span><span class='String'>"\\"</span>    <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Unquoted space is end of arg; do not eat.  Likewise 
                     * backslash is end of command or next command, do not eat 
                     * 
                     * XXX this means we can't conveniently accept options 
                     * that include unquoted backslashes; therefore, option 
                     * processing that encourages use of backslashes is rather 
                     * broken. 
                     */ 
</span>                    <a href="../../backend/replication/repl_scanner.l.html#LN135"><span class='Ref_to_Proto'>yyless</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>= </span>YY_START<span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="psqlscanslash.l.html#LN53"><span class='Ref_to_Const'>LEXRES_OK</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>quote<span class='Delimiter'>}</span>         <span class='Delimiter'>{ 
</span>                    <span class='Operator'>*</span><a href="psqlscanslash.l.html#LN46"><span class='Ref_to_Global_Var'>option_quote</span></a> <span class='Operator'>= </span><span class='String'>'\''</span><span class='Delimiter'>; 
</span>                    <a href="psqlscanslash.l.html#LN47"><span class='Ref_to_Global_Var'>unquoted_option_chars</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <a href="../../backend/replication/syncrep_scanner.l.html#LN73"><span class='Ref_to_Proto'>BEGIN</span></a><span class='Parentheses'>(</span>xslashquote<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='String'>"`"</span>             <span class='Delimiter'>{ 
</span>                    <a href="psqlscanslash.l.html#LN48"><span class='Ref_to_Global_Var'>backtick_start_offset</span></a> <span class='Operator'>= </span><a href="../../fe_utils/psqlscan.l.html#LN360"><span class='Ref_to_Global_Var'>output_buf</span></a><span class='Operator'>-&GT;</span><a href="../../interfaces/libpq/pqexpbuffer.h.html#LN46"><span class='Ref_to_Member'>len</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscanslash.l.html#LN46"><span class='Ref_to_Global_Var'>option_quote</span></a> <span class='Operator'>= </span><span class='String'>'`'</span><span class='Delimiter'>; 
</span>                    <a href="psqlscanslash.l.html#LN47"><span class='Ref_to_Global_Var'>unquoted_option_chars</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <a href="../../backend/replication/syncrep_scanner.l.html#LN73"><span class='Ref_to_Proto'>BEGIN</span></a><span class='Parentheses'>(</span>xslashbackquote<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>dquote<span class='Delimiter'>}</span>        <span class='Delimiter'>{ 
</span>                    <a href="psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscanslash.l.html#LN46"><span class='Ref_to_Global_Var'>option_quote</span></a> <span class='Operator'>= </span><span class='String'>'"'</span><span class='Delimiter'>; 
</span>                    <a href="psqlscanslash.l.html#LN47"><span class='Ref_to_Global_Var'>unquoted_option_chars</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN228"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xslashdquote<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>:</span><span class='Delimiter'>{</span>variable_char<span class='Delimiter'>}</span><span class='Operator'>+</span>   <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Possible psql variable substitution */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a><span class='Operator'>-&GT;</span>get_variable <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                        <a href="psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span><a name="LN237"></a>                        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>varname</span><span class='Delimiter'>; 
</span><a name="LN238"></a>                        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>value</span><span class='Delimiter'>; 
</span> 
                        <a href="../../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a> <span class='Operator'>= </span><a href="../../include/fe_utils/psqlscan_int.h.html#LN139"><span class='Ref_to_Proto'>psqlscan_extract_substring</span></a><span class='Parentheses'>(</span><a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, 
</span>                                                             yytext <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                                             yyleng <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Keyword'>value </span><span class='Operator'>= </span><a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a><span class='Operator'>-&GT;</span>get_variable<span class='Parentheses'>(</span><a href="../../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a><span class='Delimiter'>, 
</span>                                                                   <a href="../../include/fe_utils/psqlscan.h.html#LN53"><span class='Ref_to_EnumConst'>PQUOTE_PLAIN</span></a><span class='Delimiter'>, 
</span>                                                                   <a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../../include/fe_utils/psqlscan_int.h.html#LN121"><span class='Ref_to_Member'>cb_passthrough</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="../../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="../../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * The variable value is just emitted without any 
                         * further examination.  This is consistent with the 
                         * pre-8.0 code behavior, if not with the way that 
                         * variables are handled outside backslash commands. 
                         * Note that we needn't guard against recursion here. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="../../interfaces/libpq/pqexpbuffer.h.html#LN164"><span class='Ref_to_Proto'>appendPQExpBufferStr</span></a><span class='Parentheses'>(</span><a href="../../fe_utils/psqlscan.l.html#LN360"><span class='Ref_to_Global_Var'>output_buf</span></a><span class='Delimiter'>, </span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="../../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                            <a href="psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span> 
                        <span class='Operator'>*</span><a href="psqlscanslash.l.html#LN46"><span class='Ref_to_Global_Var'>option_quote</span></a> <span class='Operator'>= </span><span class='String'>':'</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
                    <a href="psqlscanslash.l.html#LN47"><span class='Ref_to_Global_Var'>unquoted_option_chars</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>:</span><span class='String'>'{variable_char}+'</span> <span class='Delimiter'>{ 
</span><a name="LN269"></a>                    <span class='Declare_Prototype'>psqlscan_escape_variable</span><span class='Parentheses'>(</span><a href="../pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, </span>yytext<span class='Delimiter'>, </span>yyleng<span class='Delimiter'>, 
</span>                                             <a href="../../include/fe_utils/psqlscan.h.html#LN54"><span class='Ref_to_EnumConst'>PQUOTE_SQL_LITERAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscanslash.l.html#LN46"><span class='Ref_to_Global_Var'>option_quote</span></a> <span class='Operator'>= </span><span class='String'>':'</span><span class='Delimiter'>; 
</span>                    <a href="psqlscanslash.l.html#LN47"><span class='Ref_to_Global_Var'>unquoted_option_chars</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
 
<span class='Operator'>:\</span><span class='String'>"{variable_char}+\"   { 
</span><a name="LN277"></a><span class='String'>                    psqlscan_escape_variable(cur_state, yytext, yyleng, 
                                             PQUOTE_SQL_IDENT); 
                    *option_quote = ':'; 
                    unquoted_option_chars = 0; 
                } 
 
:'{variable_char}*  { 
                    /* Throw back everything but the colon */ 
</span><a name="LN285"></a><span class='String'>                    yyless(1); 
                    unquoted_option_chars++; 
                    ECHO; 
                } 
 
:\"{variable_char}* { 
                    /* Throw back everything but the colon */ 
</span><a name="LN292"></a><span class='String'>                    yyless(1); 
                    unquoted_option_chars++; 
                    ECHO; 
                } 
 
{other}         { 
                    unquoted_option_chars++; 
                    ECHO; 
                } 
 
} 
 
&LT;xslashquote&GT;{ 
    /* 
     * single-quoted text: copy literally except for '' and backslash 
     * sequences 
     */ 
 
{quote}         { BEGIN(xslasharg); } 
 
{xqdouble}      { appendPQExpBufferChar(output_buf, '\''); } 
 
"</span><span class='Operator'>\\</span>n<span class='String'>"           { appendPQExpBufferChar(output_buf, '\n'); } 
"</span><span class='Operator'>\\</span>t<span class='String'>"           { appendPQExpBufferChar(output_buf, '\t'); } 
"</span><span class='Operator'>\\</span>b<span class='String'>"           { appendPQExpBufferChar(output_buf, '\b'); } 
"</span><span class='Operator'>\\</span>r<span class='String'>"           { appendPQExpBufferChar(output_buf, '\r'); } 
"</span><span class='Operator'>\\</span>f<span class='String'>"           { appendPQExpBufferChar(output_buf, '\f'); } 
 
{xeoctesc}      { 
                    /* octal case */ 
</span><a name="LN322"></a><span class='String'>                    appendPQExpBufferChar(output_buf, 
                                          (char) strtol(yytext + 1, NULL, 8)); 
                } 
 
{xehexesc}      { 
                    /* hex case */ 
</span><a name="LN328"></a><span class='String'>                    appendPQExpBufferChar(output_buf, 
                                          (char) strtol(yytext + 2, NULL, 16)); 
                } 
 
"</span><span class='Operator'>\\</span><span class='String'>".           { psqlscan_emit(cur_state, yytext + 1, 1); } 
 
{other}|\n      { ECHO; } 
 
} 
 
&LT;xslashbackquote&GT;{ 
    /* 
     * backticked text: copy everything until next backquote (expanding 
     * variable references, but doing nought else), then evaluate. 
     */ 
 
"</span><span class='Operator'>`</span><span class='String'>"             { 
                    /* In an inactive \if branch, don't evaluate the command */ 
                    if (cur_state-&GT;cb_passthrough == NULL || 
                        conditional_active((ConditionalStack) cur_state-&GT;cb_passthrough)) 
</span><a name="LN348"></a><span class='String'>                        evaluate_backtick(cur_state); 
</span><a name="LN349"></a><span class='String'>                    BEGIN(xslasharg); 
                } 
 
:{variable_char}+   { 
                    /* Possible psql variable substitution */ 
                    if (cur_state-&GT;callbacks-&GT;get_variable == NULL) 
                        ECHO; 
                    else 
                    { 
</span><a name="LN358"></a><span class='String'>                        char       *varname; 
</span><a name="LN359"></a><span class='String'>                        char       *value; 
 
                        varname = psqlscan_extract_substring(cur_state, 
                                                             yytext + 1, 
                                                             yyleng - 1); 
                        value = cur_state-&GT;callbacks-&GT;get_variable(varname, 
                                                                   PQUOTE_PLAIN, 
                                                                   cur_state-&GT;cb_passthrough); 
                        free(varname); 
 
                        if (value) 
                        { 
                            appendPQExpBufferStr(output_buf, value); 
                            free(value); 
                        } 
                        else 
                            ECHO; 
                    } 
                } 
 
:'{variable_char}+' { 
</span><a name="LN380"></a><span class='String'>                    psqlscan_escape_variable(cur_state, yytext, yyleng, 
                                             PQUOTE_SHELL_ARG); 
                } 
 
:'{variable_char}*  { 
                    /* Throw back everything but the colon */ 
</span><a name="LN386"></a><span class='String'>                    yyless(1); 
                    ECHO; 
                } 
 
{other}|\n      { ECHO; } 
 
} 
 
&LT;xslashdquote&GT;{ 
    /* double-quoted text: copy verbatim, including the double quotes */ 
 
{dquote}        { 
                    ECHO; 
</span><a name="LN399"></a><span class='String'>                    BEGIN(xslasharg); 
                } 
 
{other}|\n      { ECHO; } 
 
} 
 
&LT;xslashwholeline&GT;{ 
    /* copy everything until end of input line */ 
    /* but suppress leading whitespace */ 
 
{space}+        { 
                    if (output_buf-&GT;len &GT; 0) 
                        ECHO; 
                } 
 
{other}         { ECHO; } 
 
} 
 
&LT;xslashend&GT;{ 
    /* at end of command, eat a double backslash, but not anything else */ 
 
"</span><span class='Operator'>\\\\</span><span class='String'>"          { 
                    cur_state-&GT;start_state = YY_START; 
                    return LEXRES_OK; 
                } 
 
{other}|\n      { 
</span><a name="LN428"></a><span class='String'>                    yyless(0); 
                    cur_state-&GT;start_state = YY_START; 
                    return LEXRES_OK; 
                } 
 
} 
 
&LT;&LT;EOF&GT;&GT;         { 
                    if (cur_state-&GT;buffer_stack == NULL) 
                    { 
                        cur_state-&GT;start_state = YY_START; 
                        return LEXRES_EOL;      /* end of input reached */ 
                    } 
 
                    /* 
                     * We were expanding a variable, so pop the inclusion 
                     * stack and keep lexing 
                     */ 
</span><a name="LN446"></a><span class='String'>                    psqlscan_pop_buffer_stack(cur_state); 
</span><a name="LN447"></a><span class='String'>                    psqlscan_select_top_buffer(cur_state); 
                } 
 
%% 
 
/* 
 * Scan the command name of a psql backslash command.  This should be called 
 * after psql_scan() returns PSCAN_BACKSLASH.  It is assumed that the input 
 * has been consumed through the leading backslash. 
 * 
 * The return value is a malloc'd copy of the command name, as parsed off 
 * from the input. 
 */ 
char * 
</span><a name="LN461"></a><span class='String'>psql_scan_slash_command(PsqlScanState state) 
{ 
</span><a name="LN463"></a><span class='String'>    PQExpBufferData mybuf; 
 
    /* Must be scanning already */ 
    Assert(state-&GT;scanbufhandle != NULL); 
 
    /* Build a local buffer that we'll return the data of */ 
    initPQExpBuffer(&mybuf); 
 
    /* Set current output target */ 
    state-&GT;output_buf = &mybuf; 
 
    /* Set input source */ 
    if (state-&GT;buffer_stack != NULL) 
        yy_switch_to_buffer(state-&GT;buffer_stack-&GT;buf, state-&GT;scanner); 
    else 
        yy_switch_to_buffer(state-&GT;scanbufhandle, state-&GT;scanner); 
 
    /* 
     * Set lexer start state.  Note that this is sufficient to switch 
     * state-&GT;scanner over to using the tables in this lexer file. 
     */ 
    state-&GT;start_state = xslashcmd; 
 
    /* And lex. */ 
    yylex(NULL, state-&GT;scanner); 
 
    /* There are no possible errors in this lex state... */ 
 
    /* 
     * In case the caller returns to using the regular SQL lexer, reselect the 
     * appropriate initial state. 
     */ 
    psql_scan_reselect_sql_lexer(state); 
 
    return mybuf.data; 
} 
 
/* 
 * Parse off the next argument for a backslash command, and return it as a 
 * malloc'd string.  If there are no more arguments, returns NULL. 
 * 
 * type tells what processing, if any, to perform on the option string; 
 * for example, if it's a SQL identifier, we want to downcase any unquoted 
 * letters. 
 * 
 * if quote is not NULL, *quote is set to 0 if no quoting was found, else 
 * the last quote symbol used in the argument. 
 * 
 * if semicolon is true, unquoted trailing semicolon(s) that would otherwise 
 * be taken as part of the option string will be stripped. 
 * 
 * NOTE: the only possible syntax errors for backslash options are unmatched 
 * quotes, which are detected when we run out of input.  Therefore, on a 
 * syntax error we just throw away the string and return NULL; there is no 
 * need to worry about flushing remaining input. 
 */ 
char * 
</span><a name="LN520"></a><span class='String'>psql_scan_slash_option(PsqlScanState state, 
</span><a name="LN521"></a><span class='String'>                       enum slash_option_type type, 
</span><a name="LN522"></a><span class='String'>                       char *quote, 
</span><a name="LN523"></a><span class='String'>                       bool semicolon) 
{ 
</span><a name="LN525"></a><span class='String'>    PQExpBufferData mybuf; 
</span><a name="LN526"></a><span class='String'>    int         lexresult PG_USED_FOR_ASSERTS_ONLY; 
</span><a name="LN527"></a><span class='String'>    int         final_state; 
</span><a name="LN528"></a><span class='String'>    char        local_quote; 
 
    /* Must be scanning already */ 
    Assert(state-&GT;scanbufhandle != NULL); 
 
    if (quote == NULL) 
        quote = &local_quote; 
    *quote = 0; 
 
    /* Build a local buffer that we'll return the data of */ 
    initPQExpBuffer(&mybuf); 
 
    /* Set up static variables that will be used by yylex */ 
    option_type = type; 
    option_quote = quote; 
    unquoted_option_chars = 0; 
 
    /* Set current output target */ 
    state-&GT;output_buf = &mybuf; 
 
    /* Set input source */ 
    if (state-&GT;buffer_stack != NULL) 
        yy_switch_to_buffer(state-&GT;buffer_stack-&GT;buf, state-&GT;scanner); 
    else 
        yy_switch_to_buffer(state-&GT;scanbufhandle, state-&GT;scanner); 
 
    /* Set lexer start state */ 
    if (type == OT_WHOLE_LINE) 
        state-&GT;start_state = xslashwholeline; 
    else 
        state-&GT;start_state = xslashargstart; 
 
    /* And lex. */ 
    lexresult = yylex(NULL, state-&GT;scanner); 
 
    /* Save final state for a moment... */ 
    final_state = state-&GT;start_state; 
 
    /* 
     * In case the caller returns to using the regular SQL lexer, reselect the 
     * appropriate initial state. 
     */ 
    psql_scan_reselect_sql_lexer(state); 
 
    /* 
     * Check the lex result: we should have gotten back either LEXRES_OK 
     * or LEXRES_EOL (the latter indicating end of string).  If we were inside 
     * a quoted string, as indicated by final_state, EOL is an error. 
     */ 
    Assert(lexresult == LEXRES_EOL || lexresult == LEXRES_OK); 
 
    switch (final_state) 
    { 
        case xslashargstart: 
            /* empty arg */ 
            break; 
        case xslasharg: 
            /* Strip any unquoted trailing semi-colons if requested */ 
            if (semicolon) 
            { 
                while (unquoted_option_chars-- &GT; 0 && 
                       mybuf.len &GT; 0 && 
                       mybuf.data[mybuf.len - 1] == ';') 
                { 
                    mybuf.data[--mybuf.len] = '\0'; 
                } 
            } 
 
            /* 
             * If SQL identifier processing was requested, then we strip out 
             * excess double quotes and optionally downcase unquoted letters. 
             */ 
            if (type == OT_SQLID || type == OT_SQLIDHACK) 
            { 
                dequote_downcase_identifier(mybuf.data, 
                                            (type != OT_SQLIDHACK), 
                                            state-&GT;encoding); 
                /* update mybuf.len for possible shortening */ 
                mybuf.len = strlen(mybuf.data); 
            } 
            break; 
        case xslashquote: 
        case xslashbackquote: 
        case xslashdquote: 
            /* must have hit EOL inside quotes */ 
            state-&GT;callbacks-&GT;write_error("</span>unterminated quoted <a href="../../interfaces/ecpg/test/expected/preproc-type.c.html#LN45"><span class='Ref_to_Typedef'>string</span></a><span class='Operator'>\</span>n<span class='String'>"); 
            termPQExpBuffer(&mybuf); 
            return NULL; 
        case xslashwholeline: 
            /* always okay */ 
            break; 
        default: 
            /* can't get here */ 
            fprintf(stderr, "</span>invalid YY_START<span class='Operator'>\</span>n<span class='String'>"); 
            exit(1); 
    } 
 
    /* 
     * An unquoted empty argument isn't possible unless we are at end of 
     * command.  Return NULL instead. 
     */ 
    if (mybuf.len == 0 && *quote == 0) 
    { 
        termPQExpBuffer(&mybuf); 
        return NULL; 
    } 
 
    /* Else return the completed string. */ 
    return mybuf.data; 
} 
 
/* 
 * Eat up any unused \\ to complete a backslash command. 
 */ 
void 
</span><a name="LN643"></a><span class='String'>psql_scan_slash_command_end(PsqlScanState state) 
{ 
    /* Must be scanning already */ 
    Assert(state-&GT;scanbufhandle != NULL); 
 
    /* Set current output target */ 
    state-&GT;output_buf = NULL;   /* we won't output anything */ 
 
    /* Set input source */ 
    if (state-&GT;buffer_stack != NULL) 
        yy_switch_to_buffer(state-&GT;buffer_stack-&GT;buf, state-&GT;scanner); 
    else 
        yy_switch_to_buffer(state-&GT;scanbufhandle, state-&GT;scanner); 
 
    /* Set lexer start state */ 
    state-&GT;start_state = xslashend; 
 
    /* And lex. */ 
    yylex(NULL, state-&GT;scanner); 
 
    /* There are no possible errors in this lex state... */ 
 
    /* 
     * We expect the caller to return to using the regular SQL lexer, so 
     * reselect the appropriate initial state. 
     */ 
    psql_scan_reselect_sql_lexer(state); 
} 
 
/* 
 * Fetch current paren nesting depth 
 */ 
int 
</span><a name="LN676"></a><span class='String'>psql_scan_get_paren_depth(PsqlScanState state) 
{ 
    return state-&GT;paren_depth; 
} 
 
/* 
 * Set paren nesting depth 
 */ 
void 
</span><a name="LN685"></a><span class='String'>psql_scan_set_paren_depth(PsqlScanState state, int depth) 
{ 
    Assert(depth &GT;= 0); 
    state-&GT;paren_depth = depth; 
} 
 
/* 
 * De-quote and optionally downcase a SQL identifier. 
 * 
 * The string at *str is modified in-place; it can become shorter, 
 * but not longer. 
 * 
 * If downcase is true then non-quoted letters are folded to lower case. 
 * Ideally this behavior will match the backend's downcase_identifier(); 
 * but note that it could differ if LC_CTYPE is different in the frontend. 
 * 
 * Note that a string like FOO"</span>BAR<span class='String'>"BAZ will be converted to fooBARbaz; 
 * this is somewhat inconsistent with the SQL spec, which would have us 
 * parse it as several identifiers.  But for psql's purposes, we want a 
 * string like "</span>foo<span class='String'>"."</span>bar<span class='String'>" to be treated as one option, so there's little 
 * choice; this routine doesn't get to change the token boundaries. 
 */ 
void 
</span><a name="LN708"></a><span class='String'>dequote_downcase_identifier(char *str, bool downcase, int encoding) 
{ 
</span><a name="LN710"></a><span class='String'>    bool        inquotes = false; 
</span><a name="LN711"></a><span class='String'>    char       *cp = str; 
 
    while (*cp) 
    { 
        if (*cp == '"') 
        { 
            if (inquotes && cp[1] == '"') 
            { 
                /* Keep the first quote, remove the second */ 
                cp++; 
            } 
            else 
                inquotes = !inquotes; 
            /* Collapse out quote at *cp */ 
            memmove(cp, cp + 1, strlen(cp)); 
            /* do not advance cp */ 
        } 
        else 
        { 
            if (downcase && !inquotes) 
                *cp = pg_tolower((unsigned char) *cp); 
            cp += PQmblen(cp, encoding); 
        } 
    } 
} 
 
/* 
 * Evaluate a backticked substring of a slash command's argument. 
 * 
 * The portion of output_buf starting at backtick_start_offset is evaluated 
 * as a shell command and then replaced by the command's output. 
 */ 
static void 
</span><a name="LN744"></a><span class='String'>evaluate_backtick(PsqlScanState state) 
{ 
</span><a name="LN746"></a><span class='String'>    PQExpBuffer output_buf = state-&GT;output_buf; 
</span><a name="LN747"></a><span class='String'>    char       *cmd = output_buf-&GT;data + backtick_start_offset; 
</span><a name="LN748"></a><span class='String'>    PQExpBufferData cmd_output; 
</span><a name="LN749"></a><span class='String'>    FILE       *fd; 
</span><a name="LN750"></a><span class='String'>    bool        error = false; 
</span><a name="LN751"></a><span class='String'>    char        buf[512]; 
</span><a name="LN752"></a><span class='String'>    size_t      result; 
 
    initPQExpBuffer(&cmd_output); 
 
    fd = popen(cmd, PG_BINARY_R); 
    if (!fd) 
    { 
        state-&GT;callbacks-&GT;write_error("</span><span class='Operator'>%</span>s<span class='Operator'>: %</span>s<span class='Operator'>\</span>n<span class='String'>", cmd, strerror(errno)); 
        error = true; 
    } 
 
    if (!error) 
    { 
        do 
        { 
            result = fread(buf, 1, sizeof(buf), fd); 
            if (ferror(fd)) 
            { 
                state-&GT;callbacks-&GT;write_error("</span><span class='Operator'>%</span>s<span class='Operator'>: %</span>s<span class='Operator'>\</span>n<span class='String'>", cmd, strerror(errno)); 
                error = true; 
                break; 
            } 
            appendBinaryPQExpBuffer(&cmd_output, buf, result); 
        } while (!feof(fd)); 
    } 
 
    if (fd && pclose(fd) == -1) 
    { 
        state-&GT;callbacks-&GT;write_error("</span><span class='Operator'>%</span>s<span class='Operator'>: %</span>s<span class='Operator'>\</span>n<span class='String'>", cmd, strerror(errno)); 
        error = true; 
    } 
 
    if (PQExpBufferDataBroken(cmd_output)) 
    { 
        state-&GT;callbacks-&GT;write_error("</span><span class='Operator'>%</span>s<span class='Operator'>: </span>out of memory<span class='Operator'>\</span>n<span class='String'>", cmd); 
        error = true; 
    } 
 
    /* Now done with cmd, delete it from output_buf */ 
    output_buf-&GT;len = backtick_start_offset; 
    output_buf-&GT;data[output_buf-&GT;len] = '\0'; 
 
    /* If no error, transfer result to output_buf */ 
    if (!error) 
    { 
        /* strip any trailing newline */ 
        if (cmd_output.len &GT; 0 && 
            cmd_output.data[cmd_output.len - 1] == '\n') 
            cmd_output.len--; 
        appendBinaryPQExpBuffer(output_buf, cmd_output.data, cmd_output.len); 
    } 
 
    termPQExpBuffer(&cmd_output); 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>