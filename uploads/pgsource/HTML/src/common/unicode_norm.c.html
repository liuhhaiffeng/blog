<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\common\unicode_norm.c</title>
<LINK REL=StyleSheet HREF="../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\common\unicode_norm.c</b></p></td>
<td align='right'>
Wed Jun 14 08:26:02 2017
</td></tr>
<tr><td><a href='../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * unicode_norm.c 
 *      Normalize a Unicode string to NFKC form 
 * 
 * This implements Unicode normalization, per the documentation at 
 * http://www.unicode.org/reports/tr15/. 
 * 
 * Portions Copyright (c) 2017, PostgreSQL Global Development Group 
 * 
 * IDENTIFICATION 
 *    src/common/unicode_norm.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="../bin/pg_waldump/rmgrdesc.c.html#LN7"><span class='Ref_to_Const'>FRONTEND</span></a> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
<span class='Directive'>#else</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres_fe.h"</span> 
<span class='Directive'>#endif</span> 
 
<span class='Keyword'>#include </span><span class='String'>"common/unicode_norm.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"common/unicode_norm_table.h"</span> 
 
<span class='Directive'>#ifndef</span> <a href="../bin/pg_waldump/rmgrdesc.c.html#LN7"><span class='Ref_to_Const'>FRONTEND</span></a> 
<a name="LN24"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>ALLOC</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>size</span><span class='Parentheses'>) </span><a href="../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN24"><span class='Ref_to_Parameter'>size</span></a><span class='Parentheses'>) 
</span><a name="LN25"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>FREE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>size</span><span class='Parentheses'>) </span><a href="../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN25"><span class='Ref_to_Parameter'>size</span></a><span class='Parentheses'>) 
</span><span class='Directive'>#else</span> 
<a name="LN27"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>ALLOC</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>size</span><span class='Parentheses'>) </span><a href="../include/snowball/header.h.html#LN49"><span class='Ref_to_Macro'>malloc</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN27"><span class='Ref_to_Parameter'>size</span></a><span class='Parentheses'>) 
</span><a name="LN28"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>FREE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>size</span><span class='Parentheses'>) </span><a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN28"><span class='Ref_to_Parameter'>size</span></a><span class='Parentheses'>) 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* Constants for calculations with Hangul characters */ 
</span><a name="LN32"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SBASE</span>       <span class='Number'>0xAC00</span>      <span class='Comment_Single_Line'>/* U+AC00 */ 
</span><a name="LN33"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LBASE</span>       <span class='Number'>0x1100</span>      <span class='Comment_Single_Line'>/* U+1100 */ 
</span><a name="LN34"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>VBASE</span>       <span class='Number'>0x1161</span>      <span class='Comment_Single_Line'>/* U+1161 */ 
</span><a name="LN35"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>TBASE</span>       <span class='Number'>0x11A7</span>      <span class='Comment_Single_Line'>/* U+11A7 */ 
</span><a name="LN36"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LCOUNT</span>      <span class='Number'>19</span> 
<a name="LN37"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>VCOUNT</span>      <span class='Number'>21</span> 
<a name="LN38"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>TCOUNT</span>      <span class='Number'>28</span> 
<a name="LN39"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>NCOUNT</span>      <a href="unicode_norm.c.html#LN37"><span class='Ref_to_Const'>VCOUNT</span></a> <span class='Operator'>* </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a> 
<a name="LN40"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SCOUNT</span>      <a href="unicode_norm.c.html#LN36"><span class='Ref_to_Const'>LCOUNT</span></a> <span class='Operator'>* </span><a href="unicode_norm.c.html#LN39"><span class='Ref_to_Const'>NCOUNT</span></a> 
 
<span class='Comment_Multi_Line'>/* comparison routine for bsearch() of decomposition lookup table. */ 
</span><span class='Keyword'>static int 
</span><a name="LN44"></a><span class='Declare_Function'>conv_compare</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p1</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>p2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN46"></a>    <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>v1</span><span class='Delimiter'>, 
</span><a name="LN47"></a>                <span class='Declare_Local'>v2</span><span class='Delimiter'>; 
</span> 
    <a href="unicode_norm.c.html#LN46"><span class='Ref_To_Local'>v1</span></a> <span class='Operator'>= *</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="unicode_norm.c.html#LN44"><span class='Ref_to_Parameter'>p1</span></a><span class='Delimiter'>; 
</span>    <a href="unicode_norm.c.html#LN47"><span class='Ref_To_Local'>v2</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><span class='Keyword'>const </span><a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="unicode_norm.c.html#LN44"><span class='Ref_to_Parameter'>p2</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>codepoint<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN46"><span class='Ref_To_Local'>v1</span></a> <span class='Operator'>&GT; </span><a href="unicode_norm.c.html#LN47"><span class='Ref_To_Local'>v2</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Parentheses'>((</span><a href="unicode_norm.c.html#LN46"><span class='Ref_To_Local'>v1</span></a> <span class='Operator'>== </span><a href="unicode_norm.c.html#LN47"><span class='Ref_To_Local'>v2</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: -</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get the entry corresponding to code in the decomposition lookup table. 
 */ 
</span><span class='Keyword'>static </span><a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>* 
</span><a name="LN58"></a><span class='Declare_Function'>get_code_entry</span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Declare_Parameter'>code</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> bsearch<span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN58"><span class='Ref_to_Parameter'>code</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../include/common/unicode_norm_table.h.html#LN35"><span class='Ref_to_Global_Var'>UnicodeDecompMain</span></a><span class='Delimiter'>, 
</span>                   <a href="../include/c.h.html#LN561"><span class='Ref_to_Macro'>lengthof</span></a><span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN35"><span class='Ref_to_Global_Var'>UnicodeDecompMain</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="unicode_norm.c.html#LN43"><span class='Ref_to_Func'>conv_compare</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Given a decomposition entry looked up earlier, get the decomposed 
 * characters. 
 * 
 * Note: the returned pointer can point to statically allocated buffer, and 
 * is only valid until next call to this function! 
 */ 
</span><span class='Keyword'>static const </span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Operator'>* 
</span><a name="LN75"></a><span class='Declare_Function'>get_code_decomposition</span><span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>entry</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>dec_size</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN77"></a>    <span class='Keyword'>static </span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Declare_Local'>x</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN32"><span class='Ref_to_Macro'>DECOMPOSITION_IS_INLINE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN75"><span class='Ref_to_Parameter'>entry</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN30"><span class='Ref_to_Macro'>DECOMPOSITION_SIZE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN75"><span class='Ref_to_Parameter'>entry</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="unicode_norm.c.html#LN77"><span class='Ref_To_Local'>x</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a><span class='Parentheses'>) </span><a href="unicode_norm.c.html#LN75"><span class='Ref_to_Parameter'>entry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN23"><span class='Ref_to_Member'>dec_index</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="unicode_norm.c.html#LN75"><span class='Ref_to_Parameter'>dec_size</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Operator'>&</span><a href="unicode_norm.c.html#LN77"><span class='Ref_To_Local'>x</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="unicode_norm.c.html#LN75"><span class='Ref_to_Parameter'>dec_size</span></a> <span class='Operator'>= </span><a href="../include/common/unicode_norm_table.h.html#LN30"><span class='Ref_to_Macro'>DECOMPOSITION_SIZE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN75"><span class='Ref_to_Parameter'>entry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Operator'>&</span><a href="../include/common/unicode_norm_table.h.html#LN6573"><span class='Ref_to_Global_Var'>UnicodeDecomp_codepoints</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN75"><span class='Ref_to_Parameter'>entry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN23"><span class='Ref_to_Member'>dec_index</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Calculate how many characters a given character will decompose to. 
 * 
 * This needs to recurse, if the character decomposes into characters that 
 * are, in turn, decomposable. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN100"></a><span class='Declare_Function'>get_decomposed_size</span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Declare_Parameter'>code</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN102"></a>    <a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN103"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>size</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN104"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN105"></a>    <span class='Keyword'>const </span><a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Local'>decomp</span><span class='Delimiter'>; 
</span><a name="LN106"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>dec_size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fast path for Hangul characters not stored in tables to save memory as 
     * decomposition is algorithmic. See 
     * http://unicode.org/reports/tr15/tr15-18.html, annex 10 for details on 
     * the matter. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN100"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&GT;= </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a> <span class='Operator'>&& </span><a href="unicode_norm.c.html#LN100"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN40"><span class='Ref_to_Const'>SCOUNT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN116"></a>        <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>tindex</span><span class='Delimiter'>, 
</span><a name="LN117"></a>                    <span class='Declare_Local'>sindex</span><span class='Delimiter'>; 
</span> 
        <a href="unicode_norm.c.html#LN117"><span class='Ref_To_Local'>sindex</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN100"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>- </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a><span class='Delimiter'>; 
</span>        <a href="unicode_norm.c.html#LN116"><span class='Ref_To_Local'>tindex</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN117"><span class='Ref_To_Local'>sindex</span></a> <span class='Operator'>% </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN116"><span class='Ref_To_Local'>tindex</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Number'>3</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Number'>2</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="unicode_norm.c.html#LN102"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN57"><span class='Ref_to_Func'>get_code_entry</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN100"><span class='Ref_to_Parameter'>code</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Just count current code if no other decompositions.  A NULL entry is 
     * equivalent to a character with class 0 and no decompositions. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN102"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="../include/common/unicode_norm_table.h.html#LN30"><span class='Ref_to_Macro'>DECOMPOSITION_SIZE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN102"><span class='Ref_To_Local'>entry</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this entry has other decomposition codes look at them as well. First 
     * get its decomposition in the list of tables available. 
     */ 
</span>    <a href="unicode_norm.c.html#LN105"><span class='Ref_To_Local'>decomp</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN74"><span class='Ref_to_Func'>get_code_decomposition</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN102"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="unicode_norm.c.html#LN106"><span class='Ref_To_Local'>dec_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN104"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN104"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN106"><span class='Ref_To_Local'>dec_size</span></a><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN104"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN143"></a>        <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>lcode</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN105"><span class='Ref_To_Local'>decomp</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN104"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <a href="unicode_norm.c.html#LN103"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>+= </span><a href="unicode_norm.c.html#LN99"><span class='Ref_to_Func'>get_decomposed_size</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN143"><span class='Ref_To_Local'>lcode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="unicode_norm.c.html#LN103"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_decomposed_size &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Recompose a set of characters. For hangul characters, the calculation 
 * is algorithmic. For others, an inverse lookup at the decomposition 
 * table is necessary. Returns true if a recomposition can be done, and 
 * false otherwise. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN158"></a><span class='Declare_Function'>recompose_code</span><span class='Parentheses'>(</span><a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>start</span><span class='Delimiter'>, </span><a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>result</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Handle Hangul characters algorithmically, per the Unicode spec. 
     * 
     * Check if two current characters are L and V. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>&GT;= </span><a href="unicode_norm.c.html#LN33"><span class='Ref_to_Const'>LBASE</span></a> <span class='Operator'>&& </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN33"><span class='Ref_to_Const'>LBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN36"><span class='Ref_to_Const'>LCOUNT</span></a> <span class='Operator'>&& 
</span>        <a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&GT;= </span><a href="unicode_norm.c.html#LN34"><span class='Ref_to_Const'>VBASE</span></a> <span class='Operator'>&& </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN34"><span class='Ref_to_Const'>VBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN37"><span class='Ref_to_Const'>VCOUNT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* make syllable of form LV */ 
</span><a name="LN169"></a>        <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>lindex</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>- </span><a href="unicode_norm.c.html#LN33"><span class='Ref_to_Const'>LBASE</span></a><span class='Delimiter'>; 
</span><a name="LN170"></a>        <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>vindex</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>- </span><a href="unicode_norm.c.html#LN34"><span class='Ref_to_Const'>VBASE</span></a><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN169"><span class='Ref_To_Local'>lindex</span></a> <span class='Operator'>* </span><a href="unicode_norm.c.html#LN37"><span class='Ref_to_Const'>VCOUNT</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN170"><span class='Ref_To_Local'>vindex</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Check if two current characters are LV and T */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>&GT;= </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a> <span class='Operator'>&& </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN40"><span class='Ref_to_Const'>SCOUNT</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>             <span class='Parentheses'>((</span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>- </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a><span class='Parentheses'>) </span><span class='Operator'>% </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>             <a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&GT;= </span><a href="unicode_norm.c.html#LN35"><span class='Ref_to_Const'>TBASE</span></a> <span class='Operator'>&& </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN35"><span class='Ref_to_Const'>TBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* make syllable of from LVT */ 
</span><a name="LN181"></a>        <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>tindex</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>- </span><a href="unicode_norm.c.html#LN35"><span class='Ref_to_Const'>TBASE</span></a><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN181"><span class='Ref_To_Local'>tindex</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN188"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Do an inverse lookup of the decomposition tables to see if anything 
         * matches. The comparison just needs to be a perfect match on the 
         * sub-table of size two, because the start character has already been 
         * recomposed partially. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN188"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN188"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="../include/c.h.html#LN561"><span class='Ref_to_Macro'>lengthof</span></a><span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN35"><span class='Ref_to_Global_Var'>UnicodeDecompMain</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN188"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN198"></a>            <span class='Keyword'>const </span><a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span> <span class='Operator'>= &</span><a href="../include/common/unicode_norm_table.h.html#LN35"><span class='Ref_to_Global_Var'>UnicodeDecompMain</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN188"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN30"><span class='Ref_to_Macro'>DECOMPOSITION_SIZE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN198"><span class='Ref_To_Local'>entry</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../include/common/unicode_norm_table.h.html#LN31"><span class='Ref_to_Macro'>DECOMPOSITION_NO_COMPOSE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN198"><span class='Ref_To_Local'>entry</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>start</span></a> <span class='Operator'>== </span><a href="../include/common/unicode_norm_table.h.html#LN6573"><span class='Ref_to_Global_Var'>UnicodeDecomp_codepoints</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN198"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN23"><span class='Ref_to_Member'>dec_index</span></a><span class='Delimiter'>] </span><span class='Operator'>&& 
</span>                <a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>== </span><a href="../include/common/unicode_norm_table.h.html#LN6573"><span class='Ref_to_Global_Var'>UnicodeDecomp_codepoints</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN198"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN23"><span class='Ref_to_Member'>dec_index</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Operator'>*</span><a href="unicode_norm.c.html#LN158"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN198"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN20"><span class='Ref_to_Member'>codepoint</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end recompose_code &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Decompose the given code into the array given by caller. The 
 * decomposition begins at the position given by caller, saving one 
 * lookup on the decomposition table. The current position needs to be 
 * updated here to let the caller know from where to continue filling 
 * in the array result. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN226"></a><span class='Declare_Function'>decompose_code</span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>result</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>current</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN228"></a>    <a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN229"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN230"></a>    <span class='Keyword'>const </span><a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Local'>decomp</span><span class='Delimiter'>; 
</span><a name="LN231"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>dec_size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fast path for Hangul characters not stored in tables to save memory as 
     * decomposition is algorithmic. See 
     * http://unicode.org/reports/tr15/tr15-18.html, annex 10 for details on 
     * the matter. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&GT;= </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a> <span class='Operator'>&& </span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN40"><span class='Ref_to_Const'>SCOUNT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN241"></a>        <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>l</span><span class='Delimiter'>, 
</span><a name="LN242"></a>                    <span class='Declare_Local'>v</span><span class='Delimiter'>, 
</span><a name="LN243"></a>                    <span class='Declare_Local'>tindex</span><span class='Delimiter'>, 
</span><a name="LN244"></a>                    <span class='Declare_Local'>sindex</span><span class='Delimiter'>; 
</span><a name="LN245"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>res</span> <span class='Operator'>= *</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>result</span></a><span class='Delimiter'>; 
</span> 
        <a href="unicode_norm.c.html#LN244"><span class='Ref_To_Local'>sindex</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>code</span></a> <span class='Operator'>- </span><a href="unicode_norm.c.html#LN32"><span class='Ref_to_Const'>SBASE</span></a><span class='Delimiter'>; 
</span>        <a href="unicode_norm.c.html#LN241"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN33"><span class='Ref_to_Const'>LBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN244"><span class='Ref_To_Local'>sindex</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN37"><span class='Ref_to_Const'>VCOUNT</span></a> <span class='Operator'>* </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="unicode_norm.c.html#LN242"><span class='Ref_To_Local'>v</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN34"><span class='Ref_to_Const'>VBASE</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN244"><span class='Ref_To_Local'>sindex</span></a> <span class='Operator'>% </span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN37"><span class='Ref_to_Const'>VCOUNT</span></a> <span class='Operator'>* </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Parentheses'>))</span> <span class='Operator'>/ </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Delimiter'>; 
</span>        <a href="unicode_norm.c.html#LN243"><span class='Ref_To_Local'>tindex</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN244"><span class='Ref_To_Local'>sindex</span></a> <span class='Operator'>% </span><a href="unicode_norm.c.html#LN38"><span class='Ref_to_Const'>TCOUNT</span></a><span class='Delimiter'>; 
</span> 
        <a href="unicode_norm.c.html#LN245"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>[</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN241"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>; 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="unicode_norm.c.html#LN245"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>[</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN242"><span class='Ref_To_Local'>v</span></a><span class='Delimiter'>; 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN243"><span class='Ref_To_Local'>tindex</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="unicode_norm.c.html#LN245"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>[</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN35"><span class='Ref_to_Const'>TBASE</span></a> <span class='Operator'>+ </span><a href="unicode_norm.c.html#LN243"><span class='Ref_To_Local'>tindex</span></a><span class='Delimiter'>; 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if code&GT;=SBASE&&code&LT;SBA... &raquo; </span> 
 
    <a href="unicode_norm.c.html#LN228"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN57"><span class='Ref_to_Func'>get_code_entry</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>code</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Just fill in with the current decomposition if there are no 
     * decomposition codes to recurse to.  A NULL entry is equivalent to a 
     * character with class 0 and no decompositions, so just leave also in 
     * this case. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN228"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="../include/common/unicode_norm_table.h.html#LN30"><span class='Ref_to_Macro'>DECOMPOSITION_SIZE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN228"><span class='Ref_To_Local'>entry</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN276"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>res</span> <span class='Operator'>= *</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>result</span></a><span class='Delimiter'>; 
</span> 
        <a href="unicode_norm.c.html#LN276"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>[</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>code</span></a><span class='Delimiter'>; 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this entry has other decomposition codes look at them as well. 
     */ 
</span>    <a href="unicode_norm.c.html#LN230"><span class='Ref_To_Local'>decomp</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN74"><span class='Ref_to_Func'>get_code_decomposition</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN228"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="unicode_norm.c.html#LN231"><span class='Ref_To_Local'>dec_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN229"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN229"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN231"><span class='Ref_To_Local'>dec_size</span></a><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN229"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN289"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>    <span class='Declare_Local'>lcode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a><span class='Parentheses'>) </span><a href="unicode_norm.c.html#LN230"><span class='Ref_To_Local'>decomp</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN229"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* Leave if no more decompositions */ 
</span>        <a href="unicode_norm.c.html#LN225"><span class='Ref_to_Func'>decompose_code</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN289"><span class='Ref_To_Local'>lcode</span></a><span class='Delimiter'>, </span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>result</span></a><span class='Delimiter'>, </span><a href="unicode_norm.c.html#LN226"><span class='Ref_to_Parameter'>current</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end decompose_code &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * unicode_normalize_kc - Normalize a Unicode string to NFKC form. 
 * 
 * The input is a 0-terminated array of codepoints. 
 * 
 * In frontend, returns a 0-terminated array of codepoints, allocated with 
 * malloc. Or NULL if we run out of memory. In frontend, the returned 
 * string is palloc'd instead, and OOM is reported with ereport(). 
 */ 
</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Operator'>* 
</span><a name="LN306"></a><span class='Declare_Function'>unicode_normalize_kc</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>input</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN308"></a>    <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>decomp_chars</span><span class='Delimiter'>; 
</span><a name="LN309"></a>    <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>recomp_chars</span><span class='Delimiter'>; 
</span><a name="LN310"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>decomp_size</span><span class='Delimiter'>, 
</span><a name="LN311"></a>                <span class='Declare_Local'>current_size</span><span class='Delimiter'>; 
</span><a name="LN312"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span><span class='Delimiter'>; 
</span><a name="LN313"></a>    <span class='Keyword'>const </span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* variables for recomposition */ 
</span><a name="LN316"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>last_class</span><span class='Delimiter'>; 
</span><a name="LN317"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>starter_pos</span><span class='Delimiter'>; 
</span><a name="LN318"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>target_pos</span><span class='Delimiter'>; 
</span><a name="LN319"></a>    <a href="../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>starter_ch</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First, do character decomposition */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate how many characters long the decomposed version will be. 
     */ 
</span>    <a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN306"><span class='Ref_to_Parameter'>input</span></a><span class='Delimiter'>; </span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a> <span class='Operator'>+= </span><a href="unicode_norm.c.html#LN99"><span class='Ref_to_Func'>get_decomposed_size</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="unicode_norm.c.html#LN24"><span class='Ref_to_Macro'>ALLOC</span></a><span class='Parentheses'>((</span><a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now fill in each entry recursively. This needs a second pass on the 
     * decomposition table. 
     */ 
</span>    <a href="unicode_norm.c.html#LN311"><span class='Ref_To_Local'>current_size</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN306"><span class='Ref_to_Parameter'>input</span></a><span class='Delimiter'>; </span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="unicode_norm.c.html#LN225"><span class='Ref_to_Func'>decompose_code</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="unicode_norm.c.html#LN313"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="unicode_norm.c.html#LN311"><span class='Ref_To_Local'>current_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a> <span class='Operator'>== </span><a href="unicode_norm.c.html#LN311"><span class='Ref_To_Local'>current_size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now apply canonical ordering. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN349"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>    <span class='Declare_Local'>prev</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN350"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>    <span class='Declare_Local'>next</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>]; 
</span><a name="LN351"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>    <span class='Declare_Local'>tmp</span><span class='Delimiter'>; 
</span><a name="LN352"></a>        <a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Declare_Local'>prevEntry</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN57"><span class='Ref_to_Func'>get_code_entry</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN349"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN353"></a>        <a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Declare_Local'>nextEntry</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN57"><span class='Ref_to_Func'>get_code_entry</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN350"><span class='Ref_To_Local'>next</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If no entries are found, the character used is either an Hangul 
         * character or a character with a class of 0 and no decompositions, 
         * so move to next result. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN352"><span class='Ref_To_Local'>prevEntry</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="unicode_norm.c.html#LN353"><span class='Ref_To_Local'>nextEntry</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Per Unicode (http://unicode.org/reports/tr15/tr15-18.html) annex 4, 
         * a sequence of two adjacent characters in a string is an 
         * exchangeable pair if the combining class (from the Unicode 
         * Character Database) for the first character is greater than the 
         * combining class for the second, and the second is not a starter.  A 
         * character is a starter if its combining class is 0. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN353"><span class='Ref_To_Local'>nextEntry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN21"><span class='Ref_to_Member'>comb_class</span></a> <span class='Operator'>== </span><span class='Number'>0x0</span> <span class='Operator'>|| </span><a href="unicode_norm.c.html#LN352"><span class='Ref_To_Local'>prevEntry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN21"><span class='Ref_to_Member'>comb_class</span></a> <span class='Operator'>== </span><span class='Number'>0x0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN352"><span class='Ref_To_Local'>prevEntry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN21"><span class='Ref_to_Member'>comb_class</span></a> <span class='Operator'>&LT;= </span><a href="unicode_norm.c.html#LN353"><span class='Ref_To_Local'>nextEntry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN21"><span class='Ref_to_Member'>comb_class</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* exchange can happen */ 
</span>        <a href="unicode_norm.c.html#LN351"><span class='Ref_To_Local'>tmp</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>        <a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>]; 
</span>        <a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN351"><span class='Ref_To_Local'>tmp</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* backtrack to check again */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>-= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for count=1;count&LT;decomp_... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * The last phase of NFKC is the recomposition of the reordered Unicode 
     * string using combining classes. The recomposed string cannot be longer 
     * than the decomposed one, so make the allocation of the output string 
     * based on that assumption. 
     */ 
</span>    <a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="unicode_norm.c.html#LN24"><span class='Ref_to_Macro'>ALLOC</span></a><span class='Parentheses'>((</span><a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="unicode_norm.c.html#LN25"><span class='Ref_to_Macro'>FREE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="unicode_norm.c.html#LN316"><span class='Ref_To_Local'>last_class</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* this eliminates a special check */ 
</span>    <a href="unicode_norm.c.html#LN317"><span class='Ref_To_Local'>starter_pos</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="unicode_norm.c.html#LN318"><span class='Ref_To_Local'>target_pos</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="unicode_norm.c.html#LN319"><span class='Ref_To_Local'>starter_ch</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN310"><span class='Ref_To_Local'>decomp_size</span></a><span class='Delimiter'>; </span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN407"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>    <span class='Declare_Local'>ch</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN312"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>]; 
</span><a name="LN408"></a>        <a href="../include/common/unicode_norm_table.h.html#LN18"><span class='Ref_to_Typedef'>pg_unicode_decomposition</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ch_entry</span> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN57"><span class='Ref_to_Func'>get_code_entry</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN407"><span class='Ref_To_Local'>ch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN409"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>ch_class</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN408"><span class='Ref_To_Local'>ch_entry</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: </span><a href="unicode_norm.c.html#LN408"><span class='Ref_To_Local'>ch_entry</span></a><span class='Operator'>-&GT;</span><a href="../include/common/unicode_norm_table.h.html#LN21"><span class='Ref_to_Member'>comb_class</span></a><span class='Delimiter'>; 
</span><a name="LN410"></a>        <a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a>    <span class='Declare_Local'>composite</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN316"><span class='Ref_To_Local'>last_class</span></a> <span class='Operator'>&LT; </span><a href="unicode_norm.c.html#LN409"><span class='Ref_To_Local'>ch_class</span></a> <span class='Operator'>&& 
</span>            <a href="unicode_norm.c.html#LN157"><span class='Ref_to_Func'>recompose_code</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN319"><span class='Ref_To_Local'>starter_ch</span></a><span class='Delimiter'>, </span><a href="unicode_norm.c.html#LN407"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="unicode_norm.c.html#LN410"><span class='Ref_To_Local'>composite</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN317"><span class='Ref_To_Local'>starter_pos</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN410"><span class='Ref_To_Local'>composite</span></a><span class='Delimiter'>; 
</span>            <a href="unicode_norm.c.html#LN319"><span class='Ref_To_Local'>starter_ch</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN410"><span class='Ref_To_Local'>composite</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN409"><span class='Ref_To_Local'>ch_class</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="unicode_norm.c.html#LN317"><span class='Ref_To_Local'>starter_pos</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN318"><span class='Ref_To_Local'>target_pos</span></a><span class='Delimiter'>; 
</span>            <a href="unicode_norm.c.html#LN319"><span class='Ref_To_Local'>starter_ch</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN407"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>; 
</span>            <a href="unicode_norm.c.html#LN316"><span class='Ref_To_Local'>last_class</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN318"><span class='Ref_To_Local'>target_pos</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN407"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="unicode_norm.c.html#LN316"><span class='Ref_To_Local'>last_class</span></a> <span class='Operator'>= </span><a href="unicode_norm.c.html#LN409"><span class='Ref_To_Local'>ch_class</span></a><span class='Delimiter'>; 
</span>            <a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN318"><span class='Ref_To_Local'>target_pos</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="unicode_norm.c.html#LN407"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for count=1;count&LT;decomp_... &raquo; </span> 
    <a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a><span class='Delimiter'>[</span><a href="unicode_norm.c.html#LN318"><span class='Ref_To_Local'>target_pos</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../include/mb/pg_wchar.h.html#LN24"><span class='Ref_to_Typedef'>pg_wchar</span></a><span class='Parentheses'>) </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span> 
    <a href="unicode_norm.c.html#LN25"><span class='Ref_to_Macro'>FREE</span></a><span class='Parentheses'>(</span><a href="unicode_norm.c.html#LN308"><span class='Ref_To_Local'>decomp_chars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="unicode_norm.c.html#LN309"><span class='Ref_To_Local'>recomp_chars</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end unicode_normalize_kc &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>