<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\fe_utils\psqlscan.l</title>
<LINK REL=StyleSheet HREF="../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\fe_utils\psqlscan.l</b></p></td>
<td align='right'>
Wed Jun 14 08:26:02 2017
</td></tr>
<tr><td><a href='../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Operator'>%</span>top<span class='Delimiter'>{ 
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * psqlscan.l 
 *    lexical scanner for SQL commands 
 * 
 * This lexer used to be part of psql, and that heritage is reflected in 
 * the file name as well as function and typedef names, though it can now 
 * be used by other frontend programs as well.  It's also possible to extend 
 * this lexer with a compatible add-on lexer to handle program-specific 
 * backslash commands. 
 * 
 * This code is mainly concerned with determining where the end of a SQL 
 * statement is: we are looking for semicolons that are not within quotes, 
 * comments, or parentheses.  The most reliable way to handle this is to 
 * borrow the backend's flex lexer rules, lock, stock, and barrel.  The rules 
 * below are (except for a few) the same as the backend's, but their actions 
 * are just ECHO whereas the backend's actions generally do other things. 
 * 
 * XXX The rules in this file must be kept in sync with the backend lexer!!! 
 * 
 * XXX Avoid creating backtracking cases --- see the backend lexer for info. 
 * 
 * See psqlscan_int.h for additional commentary. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/fe_utils/psqlscan.l 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres_fe.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"fe_utils/psqlscan.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"libpq-fe.h"</span> 
<span class='Delimiter'>} 
</span> 
<span class='Operator'>%</span><span class='Delimiter'>{ 
</span><span class='Keyword'>#include </span><span class='String'>"fe_utils/psqlscan_int.h"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * We must have a typedef YYSTYPE for yylex's first argument, but this lexer 
 * doesn't presently make use of that argument, so just declare it as int. 
 */ 
</span><a name="LN47"></a><span class='Control'>typedef</span> <span class='Keyword'>int </span><span class='Declare_Typedef'>YYSTYPE</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Set the type of yyextra; we use it as a pointer back to the containing 
 * PsqlScanState. 
 */ 
</span><a name="LN53"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>YY_EXTRA_TYPE</span> <a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> 
 
 
<span class='Comment_Multi_Line'>/* Return values from yylex() */ 
</span><a name="LN57"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LEXRES_EOL</span>          <span class='Number'>0</span>   <span class='Comment_Single_Line'>/* end of input */ 
</span><a name="LN58"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LEXRES_SEMI</span>         <span class='Number'>1</span>   <span class='Comment_Single_Line'>/* command-terminating semicolon found */ 
</span><a name="LN59"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LEXRES_BACKSLASH</span>    <span class='Number'>2</span>   <span class='Comment_Single_Line'>/* backslash command start */ 
</span> 
 
<a name="LN62"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ECHO</span> <a href="../bin/pgbench/exprscan.l.html#LN97"><span class='Ref_to_Proto'>psqlscan_emit</span></a><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, </span>yytext<span class='Delimiter'>, </span>yyleng<span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Work around a bug in flex 2.5.35: it emits a couple of functions that 
 * it forgets to emit declarations for.  Since we use -Wmissing-prototypes, 
 * this would cause warnings.  Providing our own declarations should be 
 * harmless even when the bug gets fixed. 
 */ 
</span><a name="LN70"></a><span class='Keyword'>extern int</span>  <span class='Declare_Prototype'>psql_yyget_column</span><span class='Parentheses'>(</span><a href="../bin/pgbench/pgbench.h.html#LN22"><span class='Ref_to_Const'>yyscan_t</span></a> <span class='Declare_Parameter'>yyscanner</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN71"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>psql_yyset_column</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>column_no</span><span class='Delimiter'>, </span><a href="../bin/pgbench/pgbench.h.html#LN22"><span class='Ref_to_Const'>yyscan_t</span></a> <span class='Declare_Parameter'>yyscanner</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Operator'>%</span><span class='Delimiter'>} 
</span> 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> reentrant 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> bison<span class='Operator'>-</span>bridge 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> <span class='Number'>8bit</span> 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> never<span class='Operator'>-</span>interactive 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> nodefault 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> noinput 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> nounput 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> noyywrap 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> <a href="../interfaces/ecpg/test/expected/preproc-whenever.c.html#LN38"><span class='Ref_to_Func'>warn</span></a> 
<span class='Operator'>%</span><a href="../include/getopt_long.h.html#LN15"><span class='Ref_to_Struct'>option</span></a> prefix<span class='Operator'>=</span><span class='String'>"psql_yy"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * All of the following definitions and rules should exactly match 
 * src/backend/parser/scan.l so far as the flex patterns are concerned. 
 * The rule bodies are just ECHO as opposed to what the backend does, 
 * however.  (But be sure to duplicate code that affects the lexing process, 
 * such as BEGIN() and yyless().)  Also, psqlscan uses a single &LT;&LT;EOF&GT;&GT; rule 
 * whereas scan.l has a separate one for each exclusive state. 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * OK, here is a short description of lex/flex rules behavior. 
 * The longest pattern which matches an input string is always chosen. 
 * For equal-length patterns, the first occurring in the rules list is chosen. 
 * INITIAL is the starting state, to which all non-conditional rules apply. 
 * Exclusive states change parsing rules while the state is active.  When in 
 * an exclusive state, only those rules defined for that state apply. 
 * 
 * We use exclusive states for quoted strings, extended comments, 
 * and to eliminate parsing troubles for numeric strings. 
 * Exclusive states: 
 *  &LT;xb&GT; bit string literal 
 *  &LT;xc&GT; extended C-style comments 
 *  &LT;xd&GT; delimited identifiers (double-quoted identifiers) 
 *  &LT;xh&GT; hexadecimal numeric string 
 *  &LT;xq&GT; standard quoted strings 
 *  &LT;xe&GT; extended quoted strings (support backslash escape sequences) 
 *  &LT;xdolq&GT; $foo$ quoted strings 
 *  &LT;xui&GT; quoted identifier with Unicode escapes 
 *  &LT;xuiend&GT; end of a quoted identifier with Unicode escapes, UESCAPE can follow 
 *  &LT;xus&GT; quoted string with Unicode escapes 
 *  &LT;xusend&GT; end of a quoted string with Unicode escapes, UESCAPE can follow 
 * 
 * Note: we intentionally don't mimic the backend's &LT;xeu&GT; state; we have 
 * no need to distinguish it from &LT;xe&GT; state, and no good way to get out 
 * of it in error cases.  The backend just throws yyerror() in those 
 * cases, but that's not an option here. 
 */ 
</span> 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xb 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xc 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xd 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xh 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xe 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xq 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xdolq 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xui 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xuiend 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xus 
<span class='Operator'>%</span><a href="../bin/psql/psqlscanslash.l.html#LN108"><span class='Ref_to_Global_Var'>x</span></a> xusend 
 
<span class='Comment_Multi_Line'>/* 
 * In order to make the world safe for Windows and Mac clients as well as 
 * Unix ones, we accept either \n or \r as a newline.  A DOS-style \r\n 
 * sequence will be seen as two successive newlines, but that doesn't cause 
 * any problems.  Comments that start with -- and extend to the next 
 * newline are treated as equivalent to a single whitespace character. 
 * 
 * NOTE a fine point: if there is no newline following --, we will absorb 
 * everything to the end of the input as a comment.  This is correct.  Older 
 * versions of Postgres failed to recognize -- as a comment if the input 
 * did not end with a newline. 
 * 
 * XXX perhaps \f (formfeed) should be treated as a newline as well? 
 * 
 * XXX if you change the set of whitespace characters, fix scanner_isspace() 
 * to agree, and see also the plpgsql lexer. 
 */ 
</span> 
space           <span class='Delimiter'>[ </span><span class='Operator'>\</span>t<span class='Operator'>\</span>n<span class='Operator'>\</span>r<span class='Operator'>\</span>f<span class='Delimiter'>] 
</span>horiz_space     <span class='Delimiter'>[ </span><span class='Operator'>\</span>t<span class='Operator'>\</span>f<span class='Delimiter'>] 
</span><a href="../backend/regex/regcomp.c.html#LN89"><span class='Ref_to_Proto'>newline</span></a>         <span class='Delimiter'>[</span><span class='Operator'>\</span>n<span class='Operator'>\</span>r<span class='Delimiter'>] 
</span>non_newline     <span class='Delimiter'>[</span><span class='Operator'>^\</span>n<span class='Operator'>\</span>r<span class='Delimiter'>] 
</span> 
<a name="LN159"></a><span class='Declare_Function'>comment         </span><span class='Parentheses'>(</span><span class='String'>"--"</span><span class='Delimiter'>{</span>non_newline<span class='Delimiter'>}</span><span class='Operator'>*</span><span class='Parentheses'>) 
</span> 
whitespace      <span class='Parentheses'>(</span><span class='Delimiter'>{</span>space<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end comment &raquo; </span><span class='Operator'>+|</span><span class='Delimiter'>{</span><a href="../test/isolation/specscanner.l.html#LN31"><span class='Ref_to_Func'>comment</span></a><span class='Delimiter'>}</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SQL requires at least one newline in the whitespace separating 
 * string literals that are to be concatenated.  Silly, but who are we 
 * to argue?  Note that {whitespace_with_newline} should not have * after 
 * it, whereas {whitespace} should generally have a * after it... 
 */ 
</span> 
<a name="LN170"></a><span class='Declare_Function'>special_whitespace      </span><span class='Parentheses'>(</span><span class='Delimiter'>{</span>space<span class='Delimiter'>}</span><span class='Operator'>+|</span><span class='Delimiter'>{</span><a href="../test/isolation/specscanner.l.html#LN31"><span class='Ref_to_Func'>comment</span></a><span class='Delimiter'>}{</span><a href="../backend/regex/regcomp.c.html#LN89"><span class='Ref_to_Proto'>newline</span></a><span class='Delimiter'>}</span><span class='Parentheses'>) 
</span>horiz_whitespace        <span class='Parentheses'>(</span><span class='Delimiter'>{</span>horiz_space<span class='Delimiter'>}</span><span class='Operator'>|</span><span class='Delimiter'>{</span><a href="../test/isolation/specscanner.l.html#LN31"><span class='Ref_to_Func'>comment</span></a><span class='Delimiter'>}</span><span class='Parentheses'>) 
</span><a name="LN172"></a><span class='Declare_Function'>whitespace_with_newline </span><span class='Parentheses'>(</span><span class='Delimiter'>{</span>horiz_whitespace<span class='Delimiter'>}</span><span class='Operator'>*</span><span class='Delimiter'>{</span><a href="../backend/regex/regcomp.c.html#LN89"><span class='Ref_to_Proto'>newline</span></a><span class='Delimiter'>}{</span><a href="psqlscan.l.html#LN170"><span class='Ref_to_Func'>special_whitespace</span></a><span class='Delimiter'>}</span><span class='Operator'>*</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * To ensure that {quotecontinue} can be scanned without having to back up 
 * if the full pattern isn't matched, we include trailing whitespace in 
 * {quotestop}.  This matches all cases where {quotecontinue} fails to match, 
 * except for {quote} followed by whitespace and just one "-" (not two, 
 * which would start a {comment}).  To cover that we have {quotefail}. 
 * The actions for {quotestop} and {quotefail} must throw back characters 
 * beyond the quote proper. 
 */ 
</span>quote           <span class='String'>' 
quotestop       {quote}{whitespace}* 
quotecontinue   {quote}{whitespace_with_newline}{quote} 
quotefail       {quote}{whitespace}*"-" 
 
/* Bit string 
 * It is tempting to scan the string for only those characters 
 * which are allowed. However, this leads to silently swallowed 
 * characters if illegal characters are included in the string. 
 * For example, if xbinside is [01] then B'</span>ABCD<span class='String'>' is interpreted 
 * as a zero-length string, and the ABCD'</span> is lost<span class='Operator'>! 
</span> <span class='Operator'>* </span>Better to pass the <a href="../interfaces/ecpg/test/expected/preproc-type.c.html#LN45"><span class='Ref_to_Typedef'>string</span></a> forward and let the input routines 
 <span class='Operator'>* </span>validate the contents<span class='Operator'>. 
</span> <span class='Operator'>*/ 
</span>xbstart         <span class='Delimiter'>[</span>bB<span class='Delimiter'>]{</span>quote<span class='Delimiter'>} 
</span>xbinside        <span class='Delimiter'>[</span><span class='Operator'>^</span><span class='String'>']* 
 
/* Hexadecimal number */ 
</span><a name="LN201"></a><span class='String'>xhstart         [xX]{quote} 
xhinside        [^'</span><span class='Delimiter'>]</span><span class='Operator'>* 
</span> 
<span class='Comment_Multi_Line'>/* National character */ 
</span><a name="LN205"></a><span class='Declare_Var'>xnstart</span>         <span class='Delimiter'>[</span>nN<span class='Delimiter'>]{</span>quote<span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* Quoted string that allows backslash escapes */ 
</span>xestart         <span class='Delimiter'>[</span>eE<span class='Delimiter'>]{</span>quote<span class='Delimiter'>} 
</span>xeinside        <span class='Delimiter'>[</span><span class='Operator'>^\\</span><span class='String'>']+ 
xeescape        [\\][^0-7] 
</span><a name="LN211"></a><span class='String'>xeoctesc        [\\][0-7]{1,3} 
</span><a name="LN212"></a><span class='String'>xehexesc        [\\]x[0-9A-Fa-f]{1,2} 
</span><a name="LN213"></a><span class='String'>xeunicode       [\\](u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}) 
xeunicodefail   [\\](u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7}) 
 
/* Extended quote 
 * xqdouble implements embedded quote, '''' 
 */ 
xqstart         {quote} 
xqdouble        {quote}{quote} 
xqinside        [^'</span><span class='Delimiter'>]</span><span class='Operator'>+ 
</span> 
<span class='Comment_Multi_Line'>/* $foo$ style quotes ("dollar quoting") 
 * The quoted string starts with $foo$ where "foo" is an optional string 
 * in the form of an identifier, except that it may not contain "$", 
 * and extends to the first occurrence of an identical string. 
 * There is *no* processing of the quoted text. 
 * 
 * {dolqfailed} is an error rule to avoid scanner backup when {dolqdelim} 
 * fails to match its trailing "$". 
 */ 
</span>dolq_start      <span class='Delimiter'>[</span>A<span class='Operator'>-</span>Za<span class='Operator'>-</span>z<span class='Operator'>\</span><span class='Number'>200</span><span class='Operator'>-\</span><span class='Number'>377_</span><span class='Delimiter'>] 
</span>dolq_cont       <span class='Delimiter'>[</span>A<span class='Operator'>-</span>Za<span class='Operator'>-</span>z<span class='Operator'>\</span><span class='Number'>200</span><span class='Operator'>-\</span><span class='Number'>377_0</span><span class='Operator'>-</span><span class='Number'>9</span><span class='Delimiter'>] 
</span><a name="LN234"></a>dolqdelim       <span class='Operator'>\</span><span class='Declare_Function'>$</span><span class='Parentheses'>(</span><span class='Delimiter'>{</span>dolq_start<span class='Delimiter'>}{</span>dolq_cont<span class='Delimiter'>}</span><span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Operator'>?\</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN176"><span class='Ref_to_Func'>$</span></a> 
dolqfailed      <span class='Operator'>\</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN176"><span class='Ref_to_Func'>$</span></a><span class='Delimiter'>{</span>dolq_start<span class='Delimiter'>}{</span>dolq_cont<span class='Delimiter'>}</span><span class='Operator'>* 
</span>dolqinside      <span class='Delimiter'>[</span><span class='Operator'>^</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN176"><span class='Ref_to_Func'>$</span></a><span class='Delimiter'>]</span><span class='Operator'>+ 
</span> 
<span class='Comment_Multi_Line'>/* Double quote 
 * Allows embedded spaces and other special characters into identifiers. 
 */ 
</span>dquote          <span class='Operator'>\</span><span class='String'>" 
xdstart         {dquote} 
xdstop          {dquote} 
xddouble        {dquote}{dquote} 
xdinside        [^"</span><span class='Delimiter'>]</span><span class='Operator'>+ 
</span> 
<span class='Comment_Multi_Line'>/* Unicode escapes */ 
</span>uescape         <span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>][</span>sS<span class='Delimiter'>][</span>cC<span class='Delimiter'>][</span>aA<span class='Delimiter'>][</span>pP<span class='Delimiter'>][</span>eE<span class='Delimiter'>]{</span>whitespace<span class='Delimiter'>}</span><span class='Operator'>*</span><span class='Delimiter'>{</span>quote<span class='Delimiter'>}[</span><span class='Operator'>^</span><span class='String'>']{quote} 
/* error rule to avoid backup */ 
uescapefail     [uU][eE][sS][cC][aA][pP][eE]{whitespace}*"-"|[uU][eE][sS][cC][aA][pP][eE]{whitespace}*{quote}[^'</span><span class='Delimiter'>]</span><span class='Operator'>|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>][</span>sS<span class='Delimiter'>][</span>cC<span class='Delimiter'>][</span>aA<span class='Delimiter'>][</span>pP<span class='Delimiter'>][</span>eE<span class='Delimiter'>]{</span>whitespace<span class='Delimiter'>}</span><span class='Operator'>*</span><span class='Delimiter'>{</span>quote<span class='Delimiter'>}</span><span class='Operator'>|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>][</span>sS<span class='Delimiter'>][</span>cC<span class='Delimiter'>][</span>aA<span class='Delimiter'>][</span>pP<span class='Delimiter'>][</span>eE<span class='Delimiter'>]{</span>whitespace<span class='Delimiter'>}</span><span class='Operator'>*|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>][</span>sS<span class='Delimiter'>][</span>cC<span class='Delimiter'>][</span>aA<span class='Delimiter'>][</span>pP<span class='Delimiter'>]</span><span class='Operator'>|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>][</span>sS<span class='Delimiter'>][</span>cC<span class='Delimiter'>][</span>aA<span class='Delimiter'>]</span><span class='Operator'>|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>][</span>sS<span class='Delimiter'>][</span>cC<span class='Delimiter'>]</span><span class='Operator'>|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>][</span>sS<span class='Delimiter'>]</span><span class='Operator'>|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>][</span>eE<span class='Delimiter'>]</span><span class='Operator'>|</span><span class='Delimiter'>[</span>uU<span class='Delimiter'>] 
</span> 
<span class='Comment_Multi_Line'>/* Quoted identifier with Unicode escapes */ 
</span>xuistart        <span class='Delimiter'>[</span>uU<span class='Delimiter'>]</span><span class='Operator'>&</span><span class='Delimiter'>{</span>dquote<span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* Quoted string with Unicode escapes */ 
</span>xusstart        <span class='Delimiter'>[</span>uU<span class='Delimiter'>]</span><span class='Operator'>&</span><span class='Delimiter'>{</span>quote<span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* Optional UESCAPE after a quoted string or identifier with Unicode escapes. */ 
</span>xustop1     <span class='Delimiter'>{</span>uescapefail<span class='Delimiter'>}</span><span class='Operator'>? 
</span>xustop2     <span class='Delimiter'>{</span>uescape<span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* error rule to avoid backup */ 
</span>xufailed        <span class='Delimiter'>[</span>uU<span class='Delimiter'>]</span><span class='Operator'>& 
</span> 
 
<span class='Comment_Multi_Line'>/* C-style comments 
 * 
 * The "extended comment" syntax closely resembles allowable operator syntax. 
 * The tricky part here is to get lex to recognize a string starting with 
 * slash-star as a comment, when interpreting it as an operator would produce 
 * a longer match --- remember lex will prefer a longer match!  Also, if we 
 * have something like plus-slash-star, lex will think this is a 3-character 
 * operator whereas we want to see it as a + operator and a comment start. 
 * The solution is two-fold: 
 * 1. append {op_chars}* to xcstart so that it matches as much text as 
 *    {operator} would. Then the tie-breaker (first matching rule of same 
 *    length) ensures xcstart wins.  We put back the extra stuff with yyless() 
 *    in case it contains a star-slash that should terminate the comment. 
 * 2. In the operator rule, check for slash-star within the operator, and 
 *    if found throw it back with yyless().  This handles the plus-slash-star 
 *    problem. 
 * Dash-dash comments have similar interactions with the operator rule. 
 */ 
</span>xcstart         <span class='Operator'>\/\*</span><span class='Delimiter'>{</span>op_chars<span class='Delimiter'>}</span><span class='Operator'>* 
</span>xcstop          <span class='Operator'>\*+\/ 
</span>xcinside        <span class='Delimiter'>[</span><span class='Operator'>^*/</span><span class='Delimiter'>]</span><span class='Operator'>+ 
</span> 
digit           <span class='Delimiter'>[</span><span class='Number'>0</span><span class='Operator'>-</span><span class='Number'>9</span><span class='Delimiter'>] 
</span>ident_start     <span class='Delimiter'>[</span>A<span class='Operator'>-</span>Za<span class='Operator'>-</span>z<span class='Operator'>\</span><span class='Number'>200</span><span class='Operator'>-\</span><span class='Number'>377_</span><span class='Delimiter'>] 
</span>ident_cont      <span class='Delimiter'>[</span>A<span class='Operator'>-</span>Za<span class='Operator'>-</span>z<span class='Operator'>\</span><span class='Number'>200</span><span class='Operator'>-\</span><span class='Number'>377_0</span><span class='Operator'>-</span><span class='Number'>9</span><span class='Operator'>\</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN176"><span class='Ref_to_Func'>$</span></a><span class='Delimiter'>] 
</span> 
<a href="../backend/replication/syncrep_scanner.l.html#LN55"><span class='Ref_to_Global_Var'>identifier</span></a>      <span class='Delimiter'>{</span>ident_start<span class='Delimiter'>}{</span>ident_cont<span class='Delimiter'>}</span><span class='Operator'>* 
</span> 
<span class='Comment_Multi_Line'>/* Assorted special-case operators and operator-like tokens */ 
</span>typecast        <span class='String'>"::"</span> 
dot_dot         <span class='Operator'>\.\. 
</span>colon_equals    <span class='String'>":="</span> 
equals_greater  <span class='String'>"=&GT;"</span> 
less_equals     <span class='String'>"&LT;="</span> 
greater_equals  <span class='String'>"&GT;="</span> 
less_greater    <span class='String'>"&LT;&GT;"</span> 
not_equals      <span class='String'>"!="</span> 
 
<span class='Comment_Multi_Line'>/* 
 * "self" is the set of chars that should be returned as single-character 
 * tokens.  "op_chars" is the set of chars that can make up "Op" tokens, 
 * which can be one or more characters long (but if a single-char token 
 * appears in the "self" set, it is not to be returned as an Op).  Note 
 * that the sets overlap, but each has some chars that are not in the other. 
 * 
 * If you change either set, adjust the character lists appearing in the 
 * rule for "operator"! 
 */ 
</span>self            <span class='Delimiter'>[,</span><span class='Parentheses'>()</span><span class='Operator'>\</span><span class='Delimiter'>[</span><span class='Operator'>\</span><span class='Delimiter'>]</span><span class='Operator'>.</span><span class='Delimiter'>;</span><span class='Operator'>\:\+\-\*\/\%\^\&LT;\&GT;\=</span><span class='Delimiter'>] 
</span>op_chars        <span class='Delimiter'>[</span><span class='Operator'>\~\!\@\</span>#\<span class='Operator'>^\&\|\`\?\+\-\*\/\%\&LT;\&GT;\=</span><span class='Delimiter'>] 
</span><a name="LN316"></a><span class='Declare_Var'>operator</span>        <span class='Delimiter'>{</span>op_chars<span class='Delimiter'>}</span><span class='Operator'>+ 
</span> 
<span class='Comment_Multi_Line'>/* we no longer allow unary minus in numbers. 
 * instead we pass it separately to parser. there it gets 
 * coerced via doNegate() -- Leon aug 20 1999 
 * 
 * {decimalfail} is used because we would like "1..10" to lex as 1, dot_dot, 10. 
 * 
 * {realfail1} and {realfail2} are added to prevent the need for scanner 
 * backup when the {real} rule fails to match completely. 
 */ 
</span> 
integer         <span class='Delimiter'>{</span>digit<span class='Delimiter'>}</span><span class='Operator'>+ 
</span><a href="../interfaces/ecpg/test/expected/preproc-outofscope.c.html#LN53"><span class='Ref_to_Typedef'>decimal</span></a>         <span class='Parentheses'>((</span><span class='Delimiter'>{</span>digit<span class='Delimiter'>}</span><span class='Operator'>*\.</span><span class='Delimiter'>{</span>digit<span class='Delimiter'>}</span><span class='Operator'>+</span><span class='Parentheses'>)</span><span class='Operator'>|</span><span class='Parentheses'>(</span><span class='Delimiter'>{</span>digit<span class='Delimiter'>}</span><span class='Operator'>+\.</span><span class='Delimiter'>{</span>digit<span class='Delimiter'>}</span><span class='Operator'>*</span><span class='Parentheses'>))</span> 
decimalfail     <span class='Delimiter'>{</span>digit<span class='Delimiter'>}</span><span class='Operator'>+\.\. 
</span><a href="../../contrib/cube/cubescan.l.html#LN38"><span class='Ref_to_Func'>real</span></a>            <span class='Parentheses'>(</span><span class='Delimiter'>{</span>integer<span class='Delimiter'>}</span><span class='Operator'>|</span><span class='Delimiter'>{</span><a href="../interfaces/ecpg/test/expected/preproc-outofscope.c.html#LN53"><span class='Ref_to_Typedef'>decimal</span></a><span class='Delimiter'>}</span><span class='Parentheses'>)</span><span class='Delimiter'>[</span>Ee<span class='Delimiter'>][</span><span class='Operator'>-+</span><span class='Delimiter'>]</span><span class='Operator'>?</span><span class='Delimiter'>{</span>digit<span class='Delimiter'>}</span><span class='Operator'>+ 
</span>realfail1       <span class='Parentheses'>(</span><span class='Delimiter'>{</span>integer<span class='Delimiter'>}</span><span class='Operator'>|</span><span class='Delimiter'>{</span><a href="../interfaces/ecpg/test/expected/preproc-outofscope.c.html#LN53"><span class='Ref_to_Typedef'>decimal</span></a><span class='Delimiter'>}</span><span class='Parentheses'>)</span><span class='Delimiter'>[</span>Ee<span class='Delimiter'>] 
</span>realfail2       <span class='Parentheses'>(</span><span class='Delimiter'>{</span>integer<span class='Delimiter'>}</span><span class='Operator'>|</span><span class='Delimiter'>{</span><a href="../interfaces/ecpg/test/expected/preproc-outofscope.c.html#LN53"><span class='Ref_to_Typedef'>decimal</span></a><span class='Delimiter'>}</span><span class='Parentheses'>)</span><span class='Delimiter'>[</span>Ee<span class='Delimiter'>][</span><span class='Operator'>-+</span><span class='Delimiter'>] 
</span> 
param           <span class='Operator'>\</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN176"><span class='Ref_to_Func'>$</span></a><span class='Delimiter'>{</span>integer<span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* psql-specific: characters allowed in variable names */ 
</span>variable_char   <span class='Delimiter'>[</span>A<span class='Operator'>-</span>Za<span class='Operator'>-</span>z<span class='Operator'>\</span><span class='Number'>200</span><span class='Operator'>-\</span><span class='Number'>377_0</span><span class='Operator'>-</span><span class='Number'>9</span><span class='Delimiter'>] 
</span> 
other           <span class='Operator'>. 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Dollar quoted strings are totally opaque, and no escaping is done on them. 
 * Other quoted strings must allow some special characters such as single-quote 
 *  and newline. 
 * Embedded single-quotes are implemented both in the SQL standard 
 *  style of two adjacent single quotes "''" and in the Postgres/Java style 
 *  of escaped-quote "\'". 
 * Other embedded escaped characters are matched explicitly and the leading 
 *  backslash is dropped from the string. 
 * Note that xcstart must appear before operator, as explained above! 
 *  Also whitespace (comment) must appear before operator. 
 */ 
</span> 
<span class='Operator'>%% 
</span> 
<span class='Operator'>%</span><span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Declare some local variables inside yylex(), for convenience */ 
</span>        <a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a> <span class='Operator'>= </span>yyextra<span class='Delimiter'>; 
</span><a name="LN360"></a>        <a href="../interfaces/libpq/pqexpbuffer.h.html#LN50"><span class='Ref_to_Typedef'>PQExpBuffer</span></a> <span class='Declare_Var'>output_buf</span> <span class='Operator'>= </span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN87"><span class='Ref_to_Member'>output_buf</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Force flex into the state indicated by start_state.  This has a 
         * couple of purposes: it lets some of the functions below set a new 
         * starting state without ugly direct access to flex variables, and it 
         * allows us to transition from one flex lexer to another so that we 
         * can lex different parts of the source string using separate lexers. 
         */ 
</span><a name="LN369"></a>        <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Operator'>%</span><span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>whitespace<span class='Delimiter'>}</span>    <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Note that the whitespace rule includes both true 
                     * whitespace and single-line ("--" style) comments. 
                     * We suppress whitespace at the start of the query 
                     * buffer.  We also suppress all single-line comments, 
                     * which is pretty dubious but is the historical 
                     * behavior. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN360"><span class='Ref_to_Global_Var'>output_buf</span></a><span class='Operator'>-&GT;</span><a href="../interfaces/libpq/pqexpbuffer.h.html#LN46"><span class='Ref_to_Member'>len</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span>yytext<span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'-'</span><span class='Parentheses'>))</span> 
                        <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>xcstart<span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span>                    <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN113"><span class='Ref_to_Member'>xcdepth</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN387"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xc<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* Put back any characters past slash-star; see above */ 
</span><a name="LN389"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;</span>xc<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xcstart<span class='Delimiter'>}</span>   <span class='Delimiter'>{ 
</span>                    <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN113"><span class='Ref_to_Member'>xcdepth</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* Put back any characters past slash-star; see above */ 
</span><a name="LN396"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;</span>xc<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xcstop<span class='Delimiter'>}</span>    <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN113"><span class='Ref_to_Member'>xcdepth</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span><a name="LN402"></a>                        <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN113"><span class='Ref_to_Member'>xcdepth</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;</span>xc<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xcinside<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;</span>xc<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>op_chars<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;</span>xc<span class='Operator'>&GT;\*+</span>         <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>xbstart<span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span><a name="LN421"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xb<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xb<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotestop<span class='Delimiter'>} </span><span class='Operator'>| 
&LT;</span>xb<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotefail<span class='Delimiter'>} { 
</span><a name="LN426"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN427"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xh<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xhinside<span class='Delimiter'>}</span>  <span class='Operator'>| 
&LT;</span>xb<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xbinside<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xh<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotecontinue<span class='Delimiter'>} </span><span class='Operator'>| 
&LT;</span>xb<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotecontinue<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN142"><span class='Ref_to_Global_Var'>xhstart</span></a><span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Hexadecimal bit type. 
                     * At some point we should simply pass the string 
                     * forward to the parser and label it there. 
                     * In the meantime, place a leading "x" on the string 
                     * to mark it for the input routine as a hex string. 
                     */ 
</span><a name="LN446"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xh<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xh<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotestop<span class='Delimiter'>} </span><span class='Operator'>| 
&LT;</span>xh<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotefail<span class='Delimiter'>} { 
</span><a name="LN451"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN452"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN146"><span class='Ref_to_Global_Var'>xnstart</span></a><span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span><a name="LN457"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* eat only 'n' this time */ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>xqstart<span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN102"><span class='Ref_to_Member'>std_strings</span></a><span class='Parentheses'>) 
</span><a name="LN463"></a>                        <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xq<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
<a name="LN465"></a>                        <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xe<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span>xestart<span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span><a name="LN469"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xe<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span>xusstart<span class='Delimiter'>}</span>      <span class='Delimiter'>{ 
</span><a name="LN473"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xus<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xq<span class='Delimiter'>,</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotestop<span class='Delimiter'>}</span>  <span class='Operator'>| 
&LT;</span>xq<span class='Delimiter'>,</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotefail<span class='Delimiter'>} { 
</span><a name="LN478"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN479"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xus<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotestop<span class='Delimiter'>} </span><span class='Operator'>| 
&LT;</span>xus<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotefail<span class='Delimiter'>} { 
</span>                    <span class='Comment_Multi_Line'>/* throw back all but the quote */ 
</span><a name="LN485"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN486"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xusend<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xusend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>whitespace<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xusend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>other<span class='Delimiter'>} </span><span class='Operator'>| 
&LT;</span>xusend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xustop1<span class='Delimiter'>} { 
</span><a name="LN494"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN495"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xusend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xustop2<span class='Delimiter'>} { 
</span><a name="LN499"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xq<span class='Delimiter'>,</span>xe<span class='Delimiter'>,</span>xus<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xqdouble<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xq<span class='Delimiter'>,</span>xus<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xqinside<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xeinside<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN154"><span class='Ref_to_Func'>xeunicode</span></a><span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xeunicodefail<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xeescape<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN152"><span class='Ref_to_Global_Var'>xeoctesc</span></a><span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xe<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xehexesc<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xq<span class='Delimiter'>,</span>xe<span class='Delimiter'>,</span>xus<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>quotecontinue<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xe<span class='Operator'>&GT;.</span>           <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* This is only needed for \ just before EOF */ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>dolqdelim<span class='Delimiter'>}</span>     <span class='Delimiter'>{ 
</span>                    <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN114"><span class='Ref_to_Member'>dolqstart</span></a> <span class='Operator'>= </span><a href="../include/common/fe_memutils.h.html#LN24"><span class='Ref_to_Proto'>pg_strdup</span></a><span class='Parentheses'>(</span>yytext<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN536"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xdolq<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span>dolqfailed<span class='Delimiter'>}</span>    <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* throw back all but the initial "$" */ 
</span><a name="LN541"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xdolq<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>dolqdelim<span class='Delimiter'>} { 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span>yytext<span class='Delimiter'>, </span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN114"><span class='Ref_to_Member'>dolqstart</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN114"><span class='Ref_to_Member'>dolqstart</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN114"><span class='Ref_to_Member'>dolqstart</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                        <a href="../backend/replication/syncrep_scanner.l.html#LN73"><span class='Ref_to_Proto'>BEGIN</span></a><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * When we fail to match $...$ to dolqstart, transfer 
                         * the $... part to the output, but put back the final 
                         * $ for rescanning.  Consider $delim$...$junk$delim$ 
                         */ 
</span>                        <a href="../backend/replication/repl_scanner.l.html#LN135"><span class='Ref_to_Proto'>yyless</span></a><span class='Parentheses'>(</span>yyleng <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xdolq<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>dolqinside<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xdolq<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>dolqfailed<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xdolq<span class='Operator'>&GT;.</span>        <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* This is only needed for $ inside the quoted text */ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>xdstart<span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span><a name="LN574"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xd<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span>xuistart<span class='Delimiter'>}</span>      <span class='Delimiter'>{ 
</span><a name="LN578"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xui<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xd<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xdstop<span class='Delimiter'>}</span>    <span class='Delimiter'>{ 
</span><a name="LN582"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xui<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>dquote<span class='Delimiter'>} { 
</span><a name="LN586"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN587"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>xuiend<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xuiend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>whitespace<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xuiend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>other<span class='Delimiter'>} </span><span class='Operator'>| 
&LT;</span>xuiend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xustop1<span class='Delimiter'>} { 
</span><a name="LN595"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN596"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xuiend<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xustop2<span class='Delimiter'>}</span>   <span class='Delimiter'>{ 
</span><a name="LN600"></a>                    <span class='Declare_Prototype'>BEGIN</span><span class='Parentheses'>(</span>INITIAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xd<span class='Delimiter'>,</span>xui<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xddouble<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Operator'>&LT;</span>xd<span class='Delimiter'>,</span>xui<span class='Operator'>&GT;</span><span class='Delimiter'>{</span>xdinside<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>xufailed<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* throw back all but the initial u/U */ 
</span><a name="LN612"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>typecast<span class='Delimiter'>}</span>      <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>dot_dot<span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>colon_equals<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>equals_greater<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>less_equals<span class='Delimiter'>}</span>   <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>greater_equals<span class='Delimiter'>} { 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>less_greater<span class='Delimiter'>}</span>  <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>not_equals<span class='Delimiter'>}</span>    <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These rules are specific to psql --- they implement parenthesis 
     * counting and detection of command-ending semicolon.  These must 
     * appear before the {self} rule so that they take precedence over it. 
     */ 
</span> 
<span class='String'>"("</span>             <span class='Delimiter'>{ 
</span>                    <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN112"><span class='Ref_to_Member'>paren_depth</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='String'>")"</span>             <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN112"><span class='Ref_to_Member'>paren_depth</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                        <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN112"><span class='Ref_to_Member'>paren_depth</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='String'>";"</span>             <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN112"><span class='Ref_to_Member'>paren_depth</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Terminate lexing temporarily */ 
</span>                        <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>= </span>YY_START<span class='Delimiter'>; 
</span>                        <span class='Control'>return</span> <a href="psqlscan.l.html#LN58"><span class='Ref_to_Const'>LEXRES_SEMI</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * psql-specific rules to handle backslash commands and variable 
     * substitution.  We want these before {self}, also. 
     */ 
</span> 
<span class='String'>"\\"</span><span class='Delimiter'>[;</span><span class='Operator'>:</span><span class='Delimiter'>]</span>        <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Force a semicolon or colon into the query buffer */ 
</span><a name="LN682"></a>                    <span class='Declare_Prototype'>psqlscan_emit</span><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, </span>yytext <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='String'>"\\"</span>            <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Terminate lexing temporarily */ 
</span>                    <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>= </span>YY_START<span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <a href="psqlscan.l.html#LN59"><span class='Ref_to_Const'>LEXRES_BACKSLASH</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>:</span><span class='Delimiter'>{</span>variable_char<span class='Delimiter'>}</span><span class='Operator'>+</span>   <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Possible psql variable substitution */ 
</span><a name="LN693"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Var'>varname</span><span class='Delimiter'>; 
</span><a name="LN694"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Var'>value</span><span class='Delimiter'>; 
</span> 
                    <a href="../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan_int.h.html#LN139"><span class='Ref_to_Proto'>psqlscan_extract_substring</span></a><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, 
</span>                                                         yytext <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                                         yyleng <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a><span class='Operator'>-&GT;</span>get_variable<span class='Parentheses'>) 
</span>                        <span class='Keyword'>value </span><span class='Operator'>= </span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a><span class='Operator'>-&GT;</span>get_variable<span class='Parentheses'>(</span><a href="../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a><span class='Delimiter'>, 
</span>                                                                   <a href="../include/fe_utils/psqlscan.h.html#LN53"><span class='Ref_to_EnumConst'>PQUOTE_PLAIN</span></a><span class='Delimiter'>, 
</span>                                                                   <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN121"><span class='Ref_to_Member'>cb_passthrough</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <span class='Keyword'>value </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* It is a variable, check for recursion */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan_int.h.html#LN133"><span class='Ref_to_Proto'>psqlscan_var_is_current_source</span></a><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, </span><a href="../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* Recursive expansion --- don't go there */ 
</span>                            <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan.h.html#LN69"><span class='Ref_to_Member'>write_error</span></a><span class='Parentheses'>(</span><span class='String'>"skipping recursive expansion of variable \"%s\"\n"</span><span class='Delimiter'>, 
</span>                                                              <a href="../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Comment_Multi_Line'>/* Instead copy the string as is */ 
</span>                            <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* OK, perform substitution */ 
</span>                            <a href="../include/fe_utils/psqlscan_int.h.html#LN129"><span class='Ref_to_Proto'>psqlscan_push_new_buffer</span></a><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, </span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Comment_Multi_Line'>/* yy_scan_string already made buffer active */ 
</span>                        <span class='Delimiter'>} 
</span>                        <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * if the variable doesn't exist we'll copy the string 
                         * as is 
                         */ 
</span>                        <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
<a name="LN734"></a>                    <span class='Declare_Prototype'>free</span><span class='Parentheses'>(</span><a href="../pl/plpgsql/src/pl_gram.y.html#LN134"><span class='Ref_to_Global_Var'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>:</span><span class='String'>'{variable_char}+'</span> <span class='Delimiter'>{ 
</span><a name="LN738"></a>                    <span class='Declare_Prototype'>psqlscan_escape_variable</span><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Delimiter'>, </span>yytext<span class='Delimiter'>, </span>yyleng<span class='Delimiter'>, 
</span>                                             <a href="../include/fe_utils/psqlscan.h.html#LN54"><span class='Ref_to_EnumConst'>PQUOTE_SQL_LITERAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>:\</span><span class='String'>"{variable_char}+\"   { 
                    psqlscan_escape_variable(cur_state, yytext, yyleng, 
                                             PQUOTE_SQL_IDENT); 
                } 
 
    /* 
     * These rules just avoid the need for scanner backup if one of the 
     * two rules above fails to match completely. 
     */ 
 
:'{variable_char}*  { 
                    /* Throw back everything but the colon */ 
                    yyless(1); 
                    ECHO; 
                } 
 
:\"{variable_char}* { 
                    /* Throw back everything but the colon */ 
                    yyless(1); 
                    ECHO; 
                } 
 
    /* 
     * Back to backend-compatible rules. 
     */ 
 
{self}          { 
                    ECHO; 
                } 
 
{operator}      { 
                    /* 
                     * Check for embedded slash-star or dash-dash; those 
                     * are comment starts, so operator must stop there. 
                     * Note that slash-star or dash-dash at the first 
                     * character will match a prior rule, not this one. 
                     */ 
                    int         nchars = yyleng; 
                    char       *slashstar = strstr(yytext, "</span><span class='Comment_Multi_Line'>/*"); 
                    char       *dashdash = strstr(yytext, "--"); 
 
                    if (slashstar && dashdash) 
                    { 
                        /* if both appear, take the first one */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN666"><span class='Ref_to_Global_Var'>slashstar</span></a> <span class='Operator'>&GT; </span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN667"><span class='Ref_to_Global_Var'>dashdash</span></a><span class='Parentheses'>) 
</span>                            <a href="../interfaces/ecpg/preproc/pgc.l.html#LN666"><span class='Ref_to_Global_Var'>slashstar</span></a> <span class='Operator'>= </span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN667"><span class='Ref_to_Global_Var'>dashdash</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN666"><span class='Ref_to_Global_Var'>slashstar</span></a><span class='Parentheses'>) 
</span>                        <a href="../interfaces/ecpg/preproc/pgc.l.html#LN666"><span class='Ref_to_Global_Var'>slashstar</span></a> <span class='Operator'>= </span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN667"><span class='Ref_to_Global_Var'>dashdash</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN666"><span class='Ref_to_Global_Var'>slashstar</span></a><span class='Parentheses'>) 
</span>                        <a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a> <span class='Operator'>= </span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN666"><span class='Ref_to_Global_Var'>slashstar</span></a> <span class='Operator'>- </span>yytext<span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * For SQL compatibility, '+' and '-' cannot be the 
                     * last char of a multi-char operator unless the operator 
                     * contains chars that are not in SQL operators. 
                     * The idea is to lex '=-' as two operators, but not 
                     * to forbid operator names like '?-' that could not be 
                     * sequences of SQL operators. 
                     */ 
</span>                    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>                           <span class='Parentheses'>(</span>yytext<span class='Delimiter'>[</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'+'</span> <span class='Operator'>|| 
</span>                            yytext<span class='Delimiter'>[</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'-'</span><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span><a name="LN806"></a>                        <span class='Keyword'>int</span>         <span class='Declare_Local'>ic</span><span class='Delimiter'>; 
</span> 
                        <span class='Control'>for</span> <span class='Parentheses'>(</span>ic <span class='Operator'>= </span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a> <span class='Operator'>- </span><span class='Number'>2</span><span class='Delimiter'>; </span>ic <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span>ic<span class='Operator'>--</span><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span>strchr<span class='Parentheses'>(</span><span class='String'>"~!@#^&|`?%"</span><span class='Delimiter'>, </span>yytext<span class='Delimiter'>[</span>ic<span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                                <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span>ic <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* found a char that makes it OK */ 
</span>                        <a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a><span class='Operator'>--</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* else remove the +/-, and check again */ 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a> <span class='Operator'>&LT; </span>yyleng<span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Strip the unwanted chars from the token */ 
</span>                        <a href="../backend/replication/repl_scanner.l.html#LN135"><span class='Ref_to_Proto'>yyless</span></a><span class='Parentheses'>(</span><a href="../interfaces/ecpg/preproc/pgc.l.html#LN665"><span class='Ref_to_Global_Var'>nchars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>param<span class='Delimiter'>}</span>         <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>integer<span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span><a href="../interfaces/ecpg/test/expected/preproc-outofscope.c.html#LN53"><span class='Ref_to_Typedef'>decimal</span></a><span class='Delimiter'>}</span>       <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span>decimalfail<span class='Delimiter'>}</span>   <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* throw back the .., and treat as integer */ 
</span><a name="LN838"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span>yyleng <span class='Operator'>- </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span><a href="../../contrib/cube/cubescan.l.html#LN38"><span class='Ref_to_Func'>real</span></a><span class='Delimiter'>}</span>          <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span>realfail1<span class='Delimiter'>}</span>     <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * throw back the [Ee], and treat as {decimal}.  Note 
                     * that it is possible the input is actually {integer}, 
                     * but since this case will almost certainly lead to a 
                     * syntax error anyway, we don't bother to distinguish. 
                     */ 
</span><a name="LN851"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span>yyleng <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
{</span>realfail2<span class='Delimiter'>}</span>     <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* throw back the [Ee][+-], and proceed as above */ 
</span><a name="LN856"></a>                    <span class='Declare_Prototype'>yyless</span><span class='Parentheses'>(</span>yyleng <span class='Operator'>- </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
 
<span class='Delimiter'>{</span><a href="../backend/replication/syncrep_scanner.l.html#LN55"><span class='Ref_to_Global_Var'>identifier</span></a><span class='Delimiter'>}</span>    <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Delimiter'>{</span>other<span class='Delimiter'>}</span>         <span class='Delimiter'>{ 
</span>                    <a href="../bin/psql/psqlscanslash.l.html#LN58"><span class='Ref_to_Const'>ECHO</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>&LT;&LT;</span>EOF<span class='Operator'>&GT;&GT;</span>         <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>= </span>YY_START<span class='Delimiter'>; 
</span>                        <span class='Control'>return</span> <a href="../bin/psql/psqlscanslash.l.html#LN52"><span class='Ref_to_Const'>LEXRES_EOL</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* end of input reached */ 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * We were expanding a variable, so pop the inclusion 
                     * stack and keep lexing 
                     */ 
</span><a name="LN880"></a>                    <span class='Declare_Prototype'>psqlscan_pop_buffer_stack</span><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN881"></a>                    <span class='Declare_Prototype'>psqlscan_select_top_buffer</span><span class='Parentheses'>(</span><a href="../bin/pgbench/exprscan.l.html#LN78"><span class='Ref_to_Global_Var'>cur_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
<span class='Operator'>%% 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Create a lexer working state struct. 
 * 
 * callbacks is a struct of function pointers that encapsulate some 
 * behavior we need from the surrounding program.  This struct must 
 * remain valid for the lifespan of the PsqlScanState. 
 */ 
</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> 
<a name="LN894"></a><span class='Declare_Function'>psql_scan_create</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../include/fe_utils/psqlscan.h.html#LN60"><span class='Ref_to_Struct'>PsqlScanCallbacks</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>callbacks</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN896"></a>    <a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span> 
    <a href="psqlscan.l.html#LN896"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan_int.h.html#LN83"><span class='Ref_to_Struct'>PsqlScanStateData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../include/common/fe_memutils.h.html#LN26"><span class='Ref_to_Proto'>pg_malloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan_int.h.html#LN83"><span class='Ref_to_Struct'>PsqlScanStateData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="psqlscan.l.html#LN896"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN894"><span class='Ref_to_Parameter'>callbacks</span></a><span class='Delimiter'>; 
</span> 
    yylex_init<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="psqlscan.l.html#LN896"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    yyset_extra<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN896"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN896"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../include/fe_utils/psqlscan.h.html#LN90"><span class='Ref_to_Proto'>psql_scan_reset</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN896"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="psqlscan.l.html#LN896"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end psql_scan_create &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Destroy a lexer working state struct, releasing all resources. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN915"></a><span class='Declare_Function'>psql_scan_destroy</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../include/fe_utils/psqlscan.h.html#LN84"><span class='Ref_to_Proto'>psql_scan_finish</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN915"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../include/fe_utils/psqlscan.h.html#LN90"><span class='Ref_to_Proto'>psql_scan_reset</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN915"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    yylex_destroy<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN915"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN915"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Set the callback passthrough pointer for the lexer. 
 * 
 * This could have been integrated into psql_scan_create, but keeping it 
 * separate allows the application to change the pointer later, which might 
 * be useful. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN934"></a><span class='Declare_Function'>psql_scan_set_passthrough</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>passthrough</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="psqlscan.l.html#LN934"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN121"><span class='Ref_to_Member'>cb_passthrough</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN934"><span class='Ref_to_Parameter'>passthrough</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Set up to perform lexing of the given input line. 
 * 
 * The text at *line, extending for line_len bytes, will be scanned by 
 * subsequent calls to the psql_scan routines.  psql_scan_finish should 
 * be called when scanning is complete.  Note that the lexer retains 
 * a pointer to the storage at *line --- this string must not be altered 
 * or freed until after psql_scan_finish is called. 
 * 
 * encoding is the libpq identifier for the character encoding in use, 
 * and std_strings says whether standard_conforming_strings is on. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN952"></a><span class='Declare_Function'>psql_scan_setup</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, 
</span><a name="LN953"></a>                <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>line</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>line_len</span><span class='Delimiter'>, 
</span><a name="LN954"></a>                <span class='Keyword'>int </span><span class='Declare_Parameter'>encoding</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>std_strings</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Mustn't be scanning already */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do we need to hack the character set encoding? */ 
</span>    <a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN100"><span class='Ref_to_Member'>encoding</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN954"><span class='Ref_to_Parameter'>encoding</span></a><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN101"><span class='Ref_to_Member'>safe_encoding</span></a> <span class='Operator'>= </span><a href="../include/mb/pg_wchar.h.html#LN503"><span class='Ref_to_Proto'>pg_valid_server_encoding_id</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN954"><span class='Ref_to_Parameter'>encoding</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Save standard-strings flag as well */ 
</span>    <a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN102"><span class='Ref_to_Member'>std_strings</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN954"><span class='Ref_to_Parameter'>std_strings</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up flex input buffer with appropriate translation and padding */ 
</span>    <a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan_int.h.html#LN135"><span class='Ref_to_Proto'>psqlscan_prepare_buffer</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN953"><span class='Ref_to_Parameter'>line</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN953"><span class='Ref_to_Parameter'>line_len</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN96"><span class='Ref_to_Member'>scanbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN97"><span class='Ref_to_Member'>scanline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN953"><span class='Ref_to_Parameter'>line</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set lookaside data in case we have to map unsafe encoding */ 
</span>    <a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN103"><span class='Ref_to_Member'>curline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN96"><span class='Ref_to_Member'>scanbuf</span></a><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN104"><span class='Ref_to_Member'>refline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN952"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN97"><span class='Ref_to_Member'>scanline</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end psql_scan_setup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do lexical analysis of SQL command text. 
 * 
 * The text previously passed to psql_scan_setup is scanned, and appended 
 * (possibly with transformation) to query_buf. 
 * 
 * The return value indicates the condition that stopped scanning: 
 * 
 * PSCAN_SEMICOLON: found a command-ending semicolon.  (The semicolon is 
 * transferred to query_buf.)  The command accumulated in query_buf should 
 * be executed, then clear query_buf and call again to scan the remainder 
 * of the line. 
 * 
 * PSCAN_BACKSLASH: found a backslash that starts a special command. 
 * Any previous data on the line has been transferred to query_buf. 
 * The caller will typically next apply a separate flex lexer to scan 
 * the special command. 
 * 
 * PSCAN_INCOMPLETE: the end of the line was reached, but we have an 
 * incomplete SQL command.  *prompt is set to the appropriate prompt type. 
 * 
 * PSCAN_EOL: the end of the line was reached, and there is no lexical 
 * reason to consider the command incomplete.  The caller may or may not 
 * choose to send it.  *prompt is set to the appropriate prompt type if 
 * the caller chooses to collect more input. 
 * 
 * In the PSCAN_INCOMPLETE and PSCAN_EOL cases, psql_scan_finish() should 
 * be called next, then the cycle may be repeated with a fresh input line. 
 * 
 * In all cases, *prompt is set to an appropriate prompt type code for the 
 * next line-input operation. 
 */ 
</span><a href="../include/fe_utils/psqlscan.h.html#LN29"><span class='Ref_to_Typedef'>PsqlScanResult</span></a> 
<a name="LN1010"></a><span class='Declare_Function'>psql_scan</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, 
</span><a name="LN1011"></a>          <a href="../interfaces/libpq/pqexpbuffer.h.html#LN50"><span class='Ref_to_Typedef'>PQExpBuffer</span></a> <span class='Declare_Parameter'>query_buf</span><span class='Delimiter'>, 
</span><a name="LN1012"></a>          <a href="../include/fe_utils/psqlscan.h.html#LN38"><span class='Ref_to_Typedef'>promptStatus_t</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prompt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1014"></a>    <a href="../include/fe_utils/psqlscan.h.html#LN29"><span class='Ref_to_Typedef'>PsqlScanResult</span></a> <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN1015"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>lexresult</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Must be scanning already */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set current output target */ 
</span>    <a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN87"><span class='Ref_to_Member'>output_buf</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1011"><span class='Ref_to_Parameter'>query_buf</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set input source */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        yy_switch_to_buffer<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN70"><span class='Ref_to_Member'>buf</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        yy_switch_to_buffer<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And lex. */ 
</span>    <a href="psqlscan.l.html#LN1015"><span class='Ref_To_Local'>lexresult</span></a> <span class='Operator'>= </span>yylex<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check termination state and return appropriate result info. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1015"><span class='Ref_To_Local'>lexresult</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../bin/psql/psqlscanslash.l.html#LN52"><span class='Ref_to_Const'>LEXRES_EOL</span></a><span class='Operator'>:</span>        <span class='Comment_Single_Line'>/* end of input */ 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> INITIAL<span class='Operator'>: 
</span>                <span class='Control'>case</span> xuiend<span class='Operator'>:</span>    <span class='Comment_Single_Line'>/* we treat these like INITIAL */ 
</span>                <span class='Control'>case</span> xusend<span class='Operator'>: 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1010"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN112"><span class='Ref_to_Member'>paren_depth</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                        <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN46"><span class='Ref_to_EnumConst'>PROMPT_PAREN</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1011"><span class='Ref_to_Parameter'>query_buf</span></a><span class='Operator'>-&GT;</span><a href="../interfaces/libpq/pqexpbuffer.h.html#LN46"><span class='Ref_to_Member'>len</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN34"><span class='Ref_to_EnumConst'>PSCAN_EOL</span></a><span class='Delimiter'>; 
</span>                        <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN41"><span class='Ref_to_EnumConst'>PROMPT_CONTINUE</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* never bother to send an empty buffer */ 
</span>                        <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                        <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN40"><span class='Ref_to_EnumConst'>PROMPT_READY</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xb<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN43"><span class='Ref_to_EnumConst'>PROMPT_SINGLEQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xc<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN42"><span class='Ref_to_EnumConst'>PROMPT_COMMENT</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xd<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN44"><span class='Ref_to_EnumConst'>PROMPT_DOUBLEQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xh<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN43"><span class='Ref_to_EnumConst'>PROMPT_SINGLEQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xe<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN43"><span class='Ref_to_EnumConst'>PROMPT_SINGLEQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xq<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN43"><span class='Ref_to_EnumConst'>PROMPT_SINGLEQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xdolq<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN45"><span class='Ref_to_EnumConst'>PROMPT_DOLLARQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xui<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN44"><span class='Ref_to_EnumConst'>PROMPT_DOUBLEQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> xus<span class='Operator'>: 
</span>                    <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN33"><span class='Ref_to_EnumConst'>PSCAN_INCOMPLETE</span></a><span class='Delimiter'>; 
</span>                    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN43"><span class='Ref_to_EnumConst'>PROMPT_SINGLEQUOTE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* can't get here */ 
</span>                    <a href="../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span>stderr<span class='Delimiter'>, </span><span class='String'>"invalid YY_START\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../test/isolation/specscanner.l.html#LN91"><span class='Ref_to_Proto'>exit</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch state-&GT;start_state &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="psqlscan.l.html#LN58"><span class='Ref_to_Const'>LEXRES_SEMI</span></a><span class='Operator'>:</span>       <span class='Comment_Single_Line'>/* semicolon */ 
</span>            <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN31"><span class='Ref_to_EnumConst'>PSCAN_SEMICOLON</span></a><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN40"><span class='Ref_to_EnumConst'>PROMPT_READY</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="psqlscan.l.html#LN59"><span class='Ref_to_Const'>LEXRES_BACKSLASH</span></a><span class='Operator'>:</span>  <span class='Comment_Single_Line'>/* backslash */ 
</span>            <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN32"><span class='Ref_to_EnumConst'>PSCAN_BACKSLASH</span></a><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="psqlscan.l.html#LN1012"><span class='Ref_to_Parameter'>prompt</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan.h.html#LN40"><span class='Ref_to_EnumConst'>PROMPT_READY</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* can't get here */ 
</span>            <a href="../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span>stderr<span class='Delimiter'>, </span><span class='String'>"invalid yylex result\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../test/isolation/specscanner.l.html#LN91"><span class='Ref_to_Proto'>exit</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch lexresult &raquo; </span> 
 
    <span class='Control'>return</span> <a href="psqlscan.l.html#LN1014"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end psql_scan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Clean up after scanning a string.  This flushes any unread input and 
 * releases resources (but not the PsqlScanState itself).  Note however 
 * that this does not reset the lexer scan state; that can be done by 
 * psql_scan_reset(), which is an orthogonal operation. 
 * 
 * It is legal to call this when not scanning anything (makes it easier 
 * to deal with error recovery). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1129"></a><span class='Declare_Function'>psql_scan_finish</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Drop any incomplete variable expansions. */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../include/fe_utils/psqlscan_int.h.html#LN131"><span class='Ref_to_Proto'>psqlscan_pop_buffer_stack</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Done with the outer scan buffer, too */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a><span class='Parentheses'>) 
</span>        yy_delete_buffer<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN96"><span class='Ref_to_Member'>scanbuf</span></a><span class='Parentheses'>) 
</span>        <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN96"><span class='Ref_to_Member'>scanbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1129"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN96"><span class='Ref_to_Member'>scanbuf</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Reset lexer scanning state to start conditions.  This is appropriate 
 * for executing \r psql commands (or any other time that we discard the 
 * prior contents of query_buf).  It is not, however, necessary to do this 
 * when we execute and clear the buffer after getting a PSCAN_SEMICOLON or 
 * PSCAN_EOL scan result, because the scan state must be INITIAL when those 
 * conditions are returned. 
 * 
 * Note that this is unrelated to flushing unread input; that task is 
 * done by psql_scan_finish(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1156"></a><span class='Declare_Function'>psql_scan_reset</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="psqlscan.l.html#LN1156"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>= </span>INITIAL<span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1156"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN112"><span class='Ref_to_Member'>paren_depth</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1156"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN113"><span class='Ref_to_Member'>xcdepth</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* not really necessary */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1156"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN114"><span class='Ref_to_Member'>dolqstart</span></a><span class='Parentheses'>) 
</span>        <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1156"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN114"><span class='Ref_to_Member'>dolqstart</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1156"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN114"><span class='Ref_to_Member'>dolqstart</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Reselect this lexer (psqlscan.l) after using another one. 
 * 
 * Currently and for foreseeable uses, it's sufficient to reset to INITIAL 
 * state, because we'd never switch to another lexer in a different state. 
 * However, we don't want to reset e.g. paren_depth, so this can't be 
 * the same as psql_scan_reset(). 
 * 
 * Note: psql setjmp error recovery just calls psql_scan_reset(), so that 
 * must be a superset of this. 
 * 
 * Note: it seems likely that other lexers could just assign INITIAL for 
 * themselves, since that probably has the value zero in every flex-generated 
 * lexer.  But let's not assume that. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1182"></a><span class='Declare_Function'>psql_scan_reselect_sql_lexer</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="psqlscan.l.html#LN1182"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>= </span>INITIAL<span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return true if lexer is currently in an "inside quotes" state. 
 * 
 * This is pretty grotty but is needed to preserve the old behavior 
 * that mainloop.c drops blank lines not inside quotes without even 
 * echoing them. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1195"></a><span class='Declare_Function'>psql_scan_in_quote</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="psqlscan.l.html#LN1195"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN111"><span class='Ref_to_Member'>start_state</span></a> <span class='Operator'>!= </span>INITIAL<span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Push the given string onto the stack of stuff to scan. 
 * 
 * NOTE SIDE EFFECT: the new buffer is made the active flex input buffer. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1206"></a><span class='Declare_Function'>psqlscan_push_new_buffer</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>newstr</span><span class='Delimiter'>, 
</span><a name="LN1207"></a>                         <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>varname</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1209"></a>    <a href="../include/fe_utils/psqlscan_int.h.html#LN68"><span class='Ref_to_Struct'>StackElem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>stackelem</span><span class='Delimiter'>; 
</span> 
    <a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan_int.h.html#LN68"><span class='Ref_to_Struct'>StackElem</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../include/common/fe_memutils.h.html#LN25"><span class='Ref_to_Proto'>pg_malloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan_int.h.html#LN68"><span class='Ref_to_Struct'>StackElem</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In current usage, the passed varname points at the current flex input 
     * buffer; we must copy it before calling psqlscan_prepare_buffer() 
     * because that will change the buffer state. 
     */ 
</span>    <a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN73"><span class='Ref_to_Member'>varname</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1207"><span class='Ref_to_Parameter'>varname</span></a> <span class='Operator'>? </span><a href="../include/common/fe_memutils.h.html#LN24"><span class='Ref_to_Proto'>pg_strdup</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1207"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN70"><span class='Ref_to_Member'>buf</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan_int.h.html#LN135"><span class='Ref_to_Proto'>psqlscan_prepare_buffer</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>newstr</span></a><span class='Delimiter'>, </span>strlen<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>newstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                             <span class='Operator'>&</span><a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN71"><span class='Ref_to_Member'>bufstring</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN103"><span class='Ref_to_Member'>curline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN71"><span class='Ref_to_Member'>bufstring</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN101"><span class='Ref_to_Member'>safe_encoding</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN72"><span class='Ref_to_Member'>origstring</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN104"><span class='Ref_to_Member'>refline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN71"><span class='Ref_to_Member'>bufstring</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN72"><span class='Ref_to_Member'>origstring</span></a> <span class='Operator'>= </span><a href="../include/common/fe_memutils.h.html#LN24"><span class='Ref_to_Proto'>pg_strdup</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>newstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN104"><span class='Ref_to_Member'>refline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN72"><span class='Ref_to_Member'>origstring</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN74"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1206"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1209"><span class='Ref_To_Local'>stackelem</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end psqlscan_push_new_buffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Pop the topmost buffer stack item (there must be one!) 
 * 
 * NB: after this, the flex input state is unspecified; caller must 
 * switch to an appropriate buffer to continue lexing. 
 * See psqlscan_select_top_buffer(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1245"></a><span class='Declare_Function'>psqlscan_pop_buffer_stack</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1247"></a>    <a href="../include/fe_utils/psqlscan_int.h.html#LN68"><span class='Ref_to_Struct'>StackElem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>stackelem</span> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1245"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a><span class='Delimiter'>; 
</span> 
    <a href="psqlscan.l.html#LN1245"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN74"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    yy_delete_buffer<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN70"><span class='Ref_to_Member'>buf</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1245"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN71"><span class='Ref_to_Member'>bufstring</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN72"><span class='Ref_to_Member'>origstring</span></a><span class='Parentheses'>) 
</span>        <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN72"><span class='Ref_to_Member'>origstring</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN73"><span class='Ref_to_Member'>varname</span></a><span class='Parentheses'>) 
</span>        <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN73"><span class='Ref_to_Member'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1247"><span class='Ref_To_Local'>stackelem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Select the topmost surviving buffer as the active input. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1263"></a><span class='Declare_Function'>psqlscan_select_top_buffer</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1265"></a>    <a href="../include/fe_utils/psqlscan_int.h.html#LN68"><span class='Ref_to_Struct'>StackElem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>stackelem</span> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1265"><span class='Ref_To_Local'>stackelem</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        yy_switch_to_buffer<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1265"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN70"><span class='Ref_to_Member'>buf</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN103"><span class='Ref_to_Member'>curline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1265"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN71"><span class='Ref_to_Member'>bufstring</span></a><span class='Delimiter'>; 
</span>        <a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN104"><span class='Ref_to_Member'>refline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1265"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN72"><span class='Ref_to_Member'>origstring</span></a> <span class='Operator'>? </span><a href="psqlscan.l.html#LN1265"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN72"><span class='Ref_to_Member'>origstring</span></a> <span class='Operator'>: </span><a href="psqlscan.l.html#LN1265"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN71"><span class='Ref_to_Member'>bufstring</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        yy_switch_to_buffer<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN95"><span class='Ref_to_Member'>scanbufhandle</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN103"><span class='Ref_to_Member'>curline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN96"><span class='Ref_to_Member'>scanbuf</span></a><span class='Delimiter'>; 
</span>        <a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN104"><span class='Ref_to_Member'>refline</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1263"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN97"><span class='Ref_to_Member'>scanline</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check if specified variable name is the source for any string 
 * currently being scanned 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1286"></a><span class='Declare_Function'>psqlscan_var_is_current_source</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>varname</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1288"></a>    <a href="../include/fe_utils/psqlscan_int.h.html#LN68"><span class='Ref_to_Struct'>StackElem</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>stackelem</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1288"><span class='Ref_To_Local'>stackelem</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1286"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN89"><span class='Ref_to_Member'>buffer_stack</span></a><span class='Delimiter'>; 
</span>         <a href="psqlscan.l.html#LN1288"><span class='Ref_To_Local'>stackelem</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>         <a href="psqlscan.l.html#LN1288"><span class='Ref_To_Local'>stackelem</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1288"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN74"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1288"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN73"><span class='Ref_to_Member'>varname</span></a> <span class='Operator'>&& </span>strcmp<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1288"><span class='Ref_To_Local'>stackelem</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN73"><span class='Ref_to_Member'>varname</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1286"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Set up a flex input buffer to scan the given data.  We always make a 
 * copy of the data.  If working in an unsafe encoding, the copy has 
 * multibyte sequences replaced by FFs to avoid fooling the lexer rules. 
 * 
 * NOTE SIDE EFFECT: the new buffer is made the active flex input buffer. 
 */ 
</span><a href="../include/fe_utils/psqlscan_int.h.html#LN55"><span class='Ref_to_Typedef'>YY_BUFFER_STATE</span></a> 
<a name="LN1308"></a><span class='Declare_Function'>psqlscan_prepare_buffer</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>txt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>len</span><span class='Delimiter'>, 
</span><a name="LN1309"></a>                        <span class='Keyword'>char </span><span class='Operator'>**</span><span class='Declare_Parameter'>txtcopy</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1311"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>newtxt</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Flex wants two \0 characters after the actual data */ 
</span>    <a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a> <span class='Operator'>= </span><a href="../include/common/fe_memutils.h.html#LN25"><span class='Ref_to_Proto'>pg_malloc</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>+ </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="psqlscan.l.html#LN1309"><span class='Ref_to_Parameter'>txtcopy</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a><span class='Delimiter'>; 
</span>    <a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>len</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span>YY_END_OF_BUFFER_CHAR<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN101"><span class='Ref_to_Member'>safe_encoding</span></a><span class='Parentheses'>) 
</span>        memcpy<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>txt</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Gotta do it the hard way */ 
</span><a name="LN1323"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1323"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1327"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>thislen</span> <span class='Operator'>= </span><a href="../interfaces/libpq/libpq-fe.h.html#LN588"><span class='Ref_to_Proto'>PQmblen</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>txt</span></a> <span class='Operator'>+ </span><a href="psqlscan.l.html#LN1323"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN100"><span class='Ref_to_Member'>encoding</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* first byte should always be okay... */ 
</span>            <a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1323"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>txt</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1323"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="psqlscan.l.html#LN1323"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><a href="psqlscan.l.html#LN1327"><span class='Ref_To_Local'>thislen</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="psqlscan.l.html#LN1323"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>) 
</span>                <a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1323"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char</span><span class='Parentheses'>) </span><span class='Number'>0xFF</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> yy_scan_buffer<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1311"><span class='Ref_To_Local'>newtxt</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>+ </span><span class='Number'>2</span><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1308"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN85"><span class='Ref_to_Member'>scanner</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end psqlscan_prepare_buffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * psqlscan_emit() --- body for ECHO macro 
 * 
 * NB: this must be used for ALL and ONLY the text copied from the flex 
 * input data.  If you pass it something that is not part of the yytext 
 * string, you are making a mistake.  Internally generated text can be 
 * appended directly to state-&GT;output_buf. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1349"></a><span class='Declare_Function'>psqlscan_emit</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>txt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1351"></a>    <a href="../interfaces/libpq/pqexpbuffer.h.html#LN50"><span class='Ref_to_Typedef'>PQExpBuffer</span></a> <span class='Declare_Local'>output_buf</span> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN87"><span class='Ref_to_Member'>output_buf</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN101"><span class='Ref_to_Member'>safe_encoding</span></a><span class='Parentheses'>) 
</span>        <a href="../interfaces/libpq/pqexpbuffer.h.html#LN178"><span class='Ref_to_Proto'>appendBinaryPQExpBuffer</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1351"><span class='Ref_To_Local'>output_buf</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>txt</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Gotta do it the hard way */ 
</span><a name="LN1358"></a>        <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>reference</span> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN104"><span class='Ref_to_Member'>refline</span></a><span class='Delimiter'>; 
</span><a name="LN1359"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="psqlscan.l.html#LN1358"><span class='Ref_To_Local'>reference</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>txt</span></a> <span class='Operator'>- </span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN103"><span class='Ref_to_Member'>curline</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1359"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="psqlscan.l.html#LN1359"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>len</span></a><span class='Delimiter'>; </span><a href="psqlscan.l.html#LN1359"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1365"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>ch</span> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1349"><span class='Ref_to_Parameter'>txt</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1359"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1365"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>== </span><span class='Parentheses'>(</span><span class='Keyword'>char</span><span class='Parentheses'>) </span><span class='Number'>0xFF</span><span class='Parentheses'>)</span> 
                <a href="psqlscan.l.html#LN1365"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1358"><span class='Ref_To_Local'>reference</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1359"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="../interfaces/libpq/pqexpbuffer.h.html#LN171"><span class='Ref_to_Proto'>appendPQExpBufferChar</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1351"><span class='Ref_To_Local'>output_buf</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1365"><span class='Ref_To_Local'>ch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end psqlscan_emit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * psqlscan_extract_substring --- fetch value of (part of) the current token 
 * 
 * This is like psqlscan_emit(), except that the data is returned as a 
 * malloc'd string rather than being pushed directly to state-&GT;output_buf. 
 */ 
</span><span class='Keyword'>char </span><span class='Operator'>* 
</span><a name="LN1381"></a><span class='Declare_Function'>psqlscan_extract_substring</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>txt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1383"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../include/common/fe_memutils.h.html#LN25"><span class='Ref_to_Proto'>pg_malloc</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN101"><span class='Ref_to_Member'>safe_encoding</span></a><span class='Parentheses'>) 
</span>        memcpy<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1383"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>txt</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Gotta do it the hard way */ 
</span><a name="LN1390"></a>        <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>reference</span> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN104"><span class='Ref_to_Member'>refline</span></a><span class='Delimiter'>; 
</span><a name="LN1391"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="psqlscan.l.html#LN1390"><span class='Ref_To_Local'>reference</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>txt</span></a> <span class='Operator'>- </span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN103"><span class='Ref_to_Member'>curline</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1391"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="psqlscan.l.html#LN1391"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>len</span></a><span class='Delimiter'>; </span><a href="psqlscan.l.html#LN1391"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1397"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>ch</span> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>txt</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1391"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1397"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>== </span><span class='Parentheses'>(</span><span class='Keyword'>char</span><span class='Parentheses'>) </span><span class='Number'>0xFF</span><span class='Parentheses'>)</span> 
                <a href="psqlscan.l.html#LN1397"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>= </span><a href="psqlscan.l.html#LN1390"><span class='Ref_To_Local'>reference</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1391"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="psqlscan.l.html#LN1383"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1391"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="psqlscan.l.html#LN1397"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <a href="psqlscan.l.html#LN1383"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>[</span><a href="psqlscan.l.html#LN1381"><span class='Ref_to_Parameter'>len</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="psqlscan.l.html#LN1383"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end psqlscan_extract_substring &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * psqlscan_escape_variable --- process :'VARIABLE' or :"VARIABLE" 
 * 
 * If the variable name is found, escape its value using the appropriate 
 * quoting method and emit the value to output_buf.  (Since the result is 
 * surely quoted, there is never any reason to rescan it.)  If we don't 
 * find the variable or escaping fails, emit the token as-is. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1417"></a><span class='Declare_Function'>psqlscan_escape_variable</span><span class='Parentheses'>(</span><a href="../include/fe_utils/psqlscan.h.html#LN26"><span class='Ref_to_Typedef'>PsqlScanState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>txt</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>len</span><span class='Delimiter'>, 
</span><a name="LN1418"></a>                         <a href="../include/fe_utils/psqlscan.h.html#LN51"><span class='Ref_to_Typedef'>PsqlScanQuoteType</span></a> <span class='Declare_Parameter'>quote</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1420"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>varname</span><span class='Delimiter'>; 
</span><a name="LN1421"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>value</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Variable lookup. */ 
</span>    <a href="psqlscan.l.html#LN1420"><span class='Ref_To_Local'>varname</span></a> <span class='Operator'>= </span><a href="../include/fe_utils/psqlscan_int.h.html#LN139"><span class='Ref_to_Proto'>psqlscan_extract_substring</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>txt</span></a> <span class='Operator'>+ </span><span class='Number'>2</span><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>len</span></a> <span class='Operator'>- </span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a><span class='Operator'>-&GT;</span>get_variable<span class='Parentheses'>) 
</span>        <span class='Keyword'>value </span><span class='Operator'>= </span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN120"><span class='Ref_to_Member'>callbacks</span></a><span class='Operator'>-&GT;</span>get_variable<span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1420"><span class='Ref_To_Local'>varname</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1418"><span class='Ref_to_Parameter'>quote</span></a><span class='Delimiter'>, 
</span>                                               <a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN121"><span class='Ref_to_Member'>cb_passthrough</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Keyword'>value </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1420"><span class='Ref_To_Local'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Emit the suitably-escaped value */ 
</span>        <a href="../interfaces/libpq/pqexpbuffer.h.html#LN164"><span class='Ref_to_Proto'>appendPQExpBufferStr</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="../include/fe_utils/psqlscan_int.h.html#LN87"><span class='Ref_to_Member'>output_buf</span></a><span class='Delimiter'>, </span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../include/snowball/header.h.html#LN64"><span class='Ref_to_Macro'>free</span></a><span class='Parentheses'>(</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Emit original token as-is */ 
</span>        <a href="../bin/pgbench/exprscan.l.html#LN97"><span class='Ref_to_Proto'>psqlscan_emit</span></a><span class='Parentheses'>(</span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>txt</span></a><span class='Delimiter'>, </span><a href="psqlscan.l.html#LN1417"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end psqlscan_escape_variable &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>