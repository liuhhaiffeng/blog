<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\access\heapam_xlog.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\access\heapam_xlog.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:03 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * heapam_xlog.h 
 *    POSTGRES heap access XLOG definitions. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/access/heapam_xlog.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="heapam_xlog.h.html#LN14"><span class='Ref_to_Const'>HEAPAM_XLOG_H</span></a> 
<a name="LN14"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HEAPAM_XLOG_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlogreader.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/stringinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/buf.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufpage.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/relfilenode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/relcache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * WAL record definitions for heapam.c's WAL operations 
 * 
 * XLOG allows to store some information in high 4 bits of log 
 * record xl_info field.  We use 3 for opcode and one for init bit. 
 */ 
</span><a name="LN31"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_INSERT</span>        <span class='Number'>0x00</span> 
<a name="LN32"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_DELETE</span>        <span class='Number'>0x10</span> 
<a name="LN33"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_UPDATE</span>        <span class='Number'>0x20</span> 
<span class='Comment_Multi_Line'>/* 0x030 is free, was XLOG_HEAP_MOVE */ 
</span><a name="LN35"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_HOT_UPDATE</span>    <span class='Number'>0x40</span> 
<a name="LN36"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_CONFIRM</span>       <span class='Number'>0x50</span> 
<a name="LN37"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_LOCK</span>          <span class='Number'>0x60</span> 
<a name="LN38"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_INPLACE</span>       <span class='Number'>0x70</span> 
 
<a name="LN40"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_OPMASK</span>        <span class='Number'>0x70</span> 
<span class='Comment_Multi_Line'>/* 
 * When we insert 1st item on new page in INSERT, UPDATE, HOT_UPDATE, 
 * or MULTI_INSERT, we can (and we do) restore entire page in redo 
 */ 
</span><a name="LN45"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP_INIT_PAGE</span>     <span class='Number'>0x80</span> 
<span class='Comment_Multi_Line'>/* 
 * We ran out of opcodes, so heapam.c now has a second RmgrId.  These opcodes 
 * are associated with RM_HEAP2_ID, but are not logically different from 
 * the ones above associated with RM_HEAP_ID.  XLOG_HEAP_OPMASK applies to 
 * these, too. 
 */ 
</span><a name="LN52"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_REWRITE</span>      <span class='Number'>0x00</span> 
<a name="LN53"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_CLEAN</span>        <span class='Number'>0x10</span> 
<a name="LN54"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_FREEZE_PAGE</span>  <span class='Number'>0x20</span> 
<a name="LN55"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_CLEANUP_INFO</span> <span class='Number'>0x30</span> 
<a name="LN56"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_VISIBLE</span>      <span class='Number'>0x40</span> 
<a name="LN57"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_MULTI_INSERT</span> <span class='Number'>0x50</span> 
<a name="LN58"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_LOCK_UPDATED</span> <span class='Number'>0x60</span> 
<a name="LN59"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLOG_HEAP2_NEW_CID</span>      <span class='Number'>0x70</span> 
 
<span class='Comment_Multi_Line'>/* 
 * xl_heap_insert/xl_heap_multi_insert flag values, 8 bits are available. 
 */ 
/* PD_ALL_VISIBLE was cleared */ 
</span><a name="LN65"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_INSERT_ALL_VISIBLE_CLEARED</span>          <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>0</span><span class='Parentheses'>) 
</span><a name="LN66"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_INSERT_LAST_IN_MULTI</span>                <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN67"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_INSERT_IS_SPECULATIVE</span>               <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>2</span><span class='Parentheses'>) 
</span><a name="LN68"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_INSERT_CONTAINS_NEW_TUPLE</span>           <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>3</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * xl_heap_update flag values, 8 bits are available. 
 */ 
/* PD_ALL_VISIBLE was cleared */ 
</span><a name="LN74"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</span>      <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>0</span><span class='Parentheses'>) 
</span><span class='Comment_Multi_Line'>/* PD_ALL_VISIBLE was cleared in the 2nd page */ 
</span><a name="LN76"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</span>      <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN77"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_CONTAINS_OLD_TUPLE</span>           <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>2</span><span class='Parentheses'>) 
</span><a name="LN78"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_CONTAINS_OLD_KEY</span>             <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>3</span><span class='Parentheses'>) 
</span><a name="LN79"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_CONTAINS_NEW_TUPLE</span>           <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>4</span><span class='Parentheses'>) 
</span><a name="LN80"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_PREFIX_FROM_OLD</span>              <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>5</span><span class='Parentheses'>) 
</span><a name="LN81"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_SUFFIX_FROM_OLD</span>              <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>6</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* convenience macro for checking whether any form of old tuple was logged */ 
</span><a name="LN84"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_UPDATE_CONTAINS_OLD</span>                     <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN77"><span class='Ref_to_Const'>XLH_UPDATE_CONTAINS_OLD_TUPLE</span></a> <span class='Operator'>| </span><a href="heapam_xlog.h.html#LN78"><span class='Ref_to_Const'>XLH_UPDATE_CONTAINS_OLD_KEY</span></a><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * xl_heap_delete flag values, 8 bits are available. 
 */ 
/* PD_ALL_VISIBLE was cleared */ 
</span><a name="LN91"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_DELETE_ALL_VISIBLE_CLEARED</span>          <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>0</span><span class='Parentheses'>) 
</span><a name="LN92"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_DELETE_CONTAINS_OLD_TUPLE</span>           <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN93"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_DELETE_CONTAINS_OLD_KEY</span>             <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>2</span><span class='Parentheses'>) 
</span><a name="LN94"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_DELETE_IS_SUPER</span>                     <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>3</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* convenience macro for checking whether any form of old tuple was logged */ 
</span><a name="LN97"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_DELETE_CONTAINS_OLD</span>                     <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN92"><span class='Ref_to_Const'>XLH_DELETE_CONTAINS_OLD_TUPLE</span></a> <span class='Operator'>| </span><a href="heapam_xlog.h.html#LN93"><span class='Ref_to_Const'>XLH_DELETE_CONTAINS_OLD_KEY</span></a><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* This is what we need to know about delete */ 
</span><a name="LN101"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_delete</span> 
<span class='Delimiter'>{ 
</span><a name="LN103"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xmax</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* xmax of the deleted tuple */ 
</span><a name="LN104"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offnum</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* deleted tuple's offset */ 
</span><a name="LN105"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>infobits_set</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* infomask bits */ 
</span><a name="LN106"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>; 
</span><a name="LN107"></a>} <span class='Declare_Typedef'>xl_heap_delete</span><span class='Delimiter'>; 
</span> 
<a name="LN109"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapDelete</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN101"><span class='Ref_to_Struct'>xl_heap_delete</span></a><span class='Delimiter'>, </span><a href="../../pl/plperl/ppport.h.html#LN4803"><span class='Ref_to_Global_Var'>flags</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * We don't store the whole fixed part (HeapTupleHeaderData) of an inserted 
 * or updated tuple in WAL; we can save a few bytes by reconstructing the 
 * fields that are available elsewhere in the WAL record, or perhaps just 
 * plain needn't be reconstructed.  These are the fields we must store. 
 * NOTE: t_hoff could be recomputed, but we may as well store it because 
 * it will come for free due to alignment considerations. 
 */ 
</span><a name="LN119"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_header</span> 
<span class='Delimiter'>{ 
</span><a name="LN121"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>t_infomask2</span><span class='Delimiter'>; 
</span><a name="LN122"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>t_infomask</span><span class='Delimiter'>; 
</span><a name="LN123"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>t_hoff</span><span class='Delimiter'>; 
</span><a name="LN124"></a>} <span class='Declare_Typedef'>xl_heap_header</span><span class='Delimiter'>; 
</span> 
<a name="LN126"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapHeader</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN119"><span class='Ref_to_Struct'>xl_heap_header</span></a><span class='Delimiter'>, </span>t_hoff<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* This is what we need to know about insert */ 
</span><a name="LN129"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_insert</span> 
<span class='Delimiter'>{ 
</span><a name="LN131"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offnum</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* inserted tuple's offset */ 
</span><a name="LN132"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* xl_heap_header & TUPLE DATA in backup block 0 */ 
</span><a name="LN135"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_heap_insert</span><span class='Delimiter'>; 
</span> 
<a name="LN137"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapInsert</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN129"><span class='Ref_to_Struct'>xl_heap_insert</span></a><span class='Delimiter'>, </span><a href="../../pl/plperl/ppport.h.html#LN4803"><span class='Ref_to_Global_Var'>flags</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This is what we need to know about a multi-insert. 
 * 
 * The main data of the record consists of this xl_heap_multi_insert header. 
 * 'offsets' array is omitted if the whole page is reinitialized 
 * (XLOG_HEAP_INIT_PAGE). 
 * 
 * In block 0's data portion, there is an xl_multi_insert_tuple struct, 
 * followed by the tuple data for each tuple. There is padding to align 
 * each xl_multi_insert struct. 
 */ 
</span><a name="LN150"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_multi_insert</span> 
<span class='Delimiter'>{ 
</span><a name="LN152"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>; 
</span><a name="LN153"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>ntuples</span><span class='Delimiter'>; 
</span><a name="LN154"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offsets</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN155"></a>} <span class='Declare_Typedef'>xl_heap_multi_insert</span><span class='Delimiter'>; 
</span> 
<a name="LN157"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapMultiInsert</span>   <a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN150"><span class='Ref_to_Struct'>xl_heap_multi_insert</span></a><span class='Delimiter'>, </span>offsets<span class='Parentheses'>) 
</span> 
<a name="LN159"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_multi_insert_tuple</span> 
<span class='Delimiter'>{ 
</span><a name="LN161"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>datalen</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* size of tuple data that follows */ 
</span><a name="LN162"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>t_infomask2</span><span class='Delimiter'>; 
</span><a name="LN163"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>t_infomask</span><span class='Delimiter'>; 
</span><a name="LN164"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>t_hoff</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* TUPLE DATA FOLLOWS AT END OF STRUCT */ 
</span><a name="LN166"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_multi_insert_tuple</span><span class='Delimiter'>; 
</span> 
<a name="LN168"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfMultiInsertTuple</span>  <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN159"><span class='Ref_to_Struct'>xl_multi_insert_tuple</span></a><span class='Delimiter'>, </span>t_hoff<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This is what we need to know about update|hot_update 
 * 
 * Backup blk 0: new page 
 * 
 * If XLOG_HEAP_PREFIX_FROM_OLD or XLOG_HEAP_SUFFIX_FROM_OLD flags are set, 
 * the prefix and/or suffix come first, as one or two uint16s. 
 * 
 * After that, xl_heap_header and new tuple data follow.  The new tuple 
 * data doesn't include the prefix and suffix, which are copied from the 
 * old tuple on replay. 
 * 
 * If HEAP_CONTAINS_NEW_TUPLE_DATA flag is given, the tuple data is 
 * included even if a full-page image was taken. 
 * 
 * Backup blk 1: old page, if different. (no data, just a reference to the blk) 
 */ 
</span><a name="LN187"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_update</span> 
<span class='Delimiter'>{ 
</span><a name="LN189"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>old_xmax</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* xmax of the old tuple */ 
</span><a name="LN190"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>old_offnum</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* old tuple's offset */ 
</span><a name="LN191"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>old_infobits_set</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* infomask bits to set on old tuple */ 
</span><a name="LN192"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>; 
</span><a name="LN193"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>new_xmax</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* xmax of the new tuple */ 
</span><a name="LN194"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>new_offnum</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* new tuple's offset */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If XLOG_HEAP_CONTAINS_OLD_TUPLE or XLOG_HEAP_CONTAINS_OLD_KEY flags are 
     * set, a xl_heap_header struct and tuple data for the old tuple follows. 
     */ 
</span><a name="LN200"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_heap_update</span><span class='Delimiter'>; 
</span> 
<a name="LN202"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapUpdate</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN187"><span class='Ref_to_Struct'>xl_heap_update</span></a><span class='Delimiter'>, </span>new_offnum<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This is what we need to know about vacuum page cleanup/redirect 
 * 
 * The array of OffsetNumbers following the fixed part of the record contains: 
 *  * for each redirected item: the item offset, then the offset redirected to 
 *  * for each now-dead item: the item offset 
 *  * for each now-unused item: the item offset 
 * The total number of OffsetNumbers is therefore 2*nredirected+ndead+nunused. 
 * Note that nunused is not explicitly stored, but may be found by reference 
 * to the total record length. 
 */ 
</span><a name="LN215"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_clean</span> 
<span class='Delimiter'>{ 
</span><a name="LN217"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>latestRemovedXid</span><span class='Delimiter'>; 
</span><a name="LN218"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>nredirected</span><span class='Delimiter'>; 
</span><a name="LN219"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>ndead</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* OFFSET NUMBERS are in the block reference 0 */ 
</span><a name="LN221"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_heap_clean</span><span class='Delimiter'>; 
</span> 
<a name="LN223"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapClean</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN215"><span class='Ref_to_Struct'>xl_heap_clean</span></a><span class='Delimiter'>, </span>ndead<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Cleanup_info is required in some cases during a lazy VACUUM. 
 * Used for reporting the results of HeapTupleHeaderAdvanceLatestRemovedXid() 
 * see vacuumlazy.c for full explanation 
 */ 
</span><a name="LN230"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_cleanup_info</span> 
<span class='Delimiter'>{ 
</span><a name="LN232"></a>    <a href="../storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Member'>node</span><span class='Delimiter'>; 
</span><a name="LN233"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>latestRemovedXid</span><span class='Delimiter'>; 
</span><a name="LN234"></a>} <span class='Declare_Typedef'>xl_heap_cleanup_info</span><span class='Delimiter'>; 
</span> 
<a name="LN236"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapCleanupInfo</span> <span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN230"><span class='Ref_to_Struct'>xl_heap_cleanup_info</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* flags for infobits_set */ 
</span><a name="LN239"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLHL_XMAX_IS_MULTI</span>      <span class='Number'>0x01</span> 
<a name="LN240"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLHL_XMAX_LOCK_ONLY</span>     <span class='Number'>0x02</span> 
<a name="LN241"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLHL_XMAX_EXCL_LOCK</span>     <span class='Number'>0x04</span> 
<a name="LN242"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLHL_XMAX_KEYSHR_LOCK</span>   <span class='Number'>0x08</span> 
<a name="LN243"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLHL_KEYS_UPDATED</span>       <span class='Number'>0x10</span> 
 
<span class='Comment_Multi_Line'>/* flag bits for xl_heap_lock / xl_heap_lock_updated's flag field */ 
</span><a name="LN246"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>XLH_LOCK_ALL_FROZEN_CLEARED</span>     <span class='Number'>0x01</span> 
 
<span class='Comment_Multi_Line'>/* This is what we need to know about lock */ 
</span><a name="LN249"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_lock</span> 
<span class='Delimiter'>{ 
</span><a name="LN251"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>locking_xid</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* might be a MultiXactId not xid */ 
</span><a name="LN252"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offnum</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* locked tuple's offset on page */ 
</span><a name="LN253"></a>    <a href="../c.h.html#LN253"><span class='Ref_to_Typedef'>int8</span></a>        <span class='Declare_Member'>infobits_set</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* infomask and infomask2 bits to set */ 
</span><a name="LN254"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* XLH_LOCK_* flag bits */ 
</span><a name="LN255"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_heap_lock</span><span class='Delimiter'>; 
</span> 
<a name="LN257"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapLock</span>  <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN249"><span class='Ref_to_Struct'>xl_heap_lock</span></a><span class='Delimiter'>, </span><a href="../../pl/plperl/ppport.h.html#LN4803"><span class='Ref_to_Global_Var'>flags</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN253"><span class='Ref_to_Typedef'>int8</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* This is what we need to know about locking an updated version of a row */ 
</span><a name="LN260"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_lock_updated</span> 
<span class='Delimiter'>{ 
</span><a name="LN262"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xmax</span><span class='Delimiter'>; 
</span><a name="LN263"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offnum</span><span class='Delimiter'>; 
</span><a name="LN264"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>infobits_set</span><span class='Delimiter'>; 
</span><a name="LN265"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>; 
</span><a name="LN266"></a>} <span class='Declare_Typedef'>xl_heap_lock_updated</span><span class='Delimiter'>; 
</span> 
<a name="LN268"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapLockUpdated</span>   <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN260"><span class='Ref_to_Struct'>xl_heap_lock_updated</span></a><span class='Delimiter'>, </span><a href="../../pl/plperl/ppport.h.html#LN4803"><span class='Ref_to_Global_Var'>flags</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* This is what we need to know about confirmation of speculative insertion */ 
</span><a name="LN271"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_confirm</span> 
<span class='Delimiter'>{ 
</span><a name="LN273"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offnum</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* confirmed tuple's offset on page */ 
</span><a name="LN274"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_heap_confirm</span><span class='Delimiter'>; 
</span> 
<a name="LN276"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapConfirm</span>   <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN271"><span class='Ref_to_Struct'>xl_heap_confirm</span></a><span class='Delimiter'>, </span>offnum<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* This is what we need to know about in-place update */ 
</span><a name="LN279"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_inplace</span> 
<span class='Delimiter'>{ 
</span><a name="LN281"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offnum</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* updated tuple's offset on page */ 
</span>    <span class='Comment_Multi_Line'>/* TUPLE DATA FOLLOWS AT END OF STRUCT */ 
</span><a name="LN283"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_heap_inplace</span><span class='Delimiter'>; 
</span> 
<a name="LN285"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapInplace</span>   <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN279"><span class='Ref_to_Struct'>xl_heap_inplace</span></a><span class='Delimiter'>, </span>offnum<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This struct represents a 'freeze plan', which is what we need to know about 
 * a single tuple being frozen during vacuum. 
 */ 
/* 0x01 was XLH_FREEZE_XMIN */ 
</span><a name="LN292"></a><span class='Keyword'>#define</span>     <span class='Declare_Constant'>XLH_FREEZE_XVAC</span>     <span class='Number'>0x02</span> 
<a name="LN293"></a><span class='Keyword'>#define</span>     <span class='Declare_Constant'>XLH_INVALID_XVAC</span>    <span class='Number'>0x04</span> 
 
<a name="LN295"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_freeze_tuple</span> 
<span class='Delimiter'>{ 
</span><a name="LN297"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xmax</span><span class='Delimiter'>; 
</span><a name="LN298"></a>    <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>offset</span><span class='Delimiter'>; 
</span><a name="LN299"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>t_infomask2</span><span class='Delimiter'>; 
</span><a name="LN300"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>t_infomask</span><span class='Delimiter'>; 
</span><a name="LN301"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>frzflags</span><span class='Delimiter'>; 
</span><a name="LN302"></a>} <span class='Declare_Typedef'>xl_heap_freeze_tuple</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This is what we need to know about a block being frozen during vacuum 
 * 
 * Backup block 0's data contains an array of xl_heap_freeze_tuple structs, 
 * one for each tuple. 
 */ 
</span><a name="LN310"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_freeze_page</span> 
<span class='Delimiter'>{ 
</span><a name="LN312"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>cutoff_xid</span><span class='Delimiter'>; 
</span><a name="LN313"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>      <span class='Declare_Member'>ntuples</span><span class='Delimiter'>; 
</span><a name="LN314"></a>} <span class='Declare_Typedef'>xl_heap_freeze_page</span><span class='Delimiter'>; 
</span> 
<a name="LN316"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapFreezePage</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN310"><span class='Ref_to_Struct'>xl_heap_freeze_page</span></a><span class='Delimiter'>, </span>ntuples<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This is what we need to know about setting a visibility map bit 
 * 
 * Backup blk 0: visibility map buffer 
 * Backup blk 1: heap buffer 
 */ 
</span><a name="LN324"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_visible</span> 
<span class='Delimiter'>{ 
</span><a name="LN326"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>cutoff_xid</span><span class='Delimiter'>; 
</span><a name="LN327"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>; 
</span><a name="LN328"></a>} <span class='Declare_Typedef'>xl_heap_visible</span><span class='Delimiter'>; 
</span> 
<a name="LN330"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapVisible</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN324"><span class='Ref_to_Struct'>xl_heap_visible</span></a><span class='Delimiter'>, </span><a href="../../pl/plperl/ppport.h.html#LN4803"><span class='Ref_to_Global_Var'>flags</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a><span class='Parentheses'>))</span> 
 
<a name="LN332"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_new_cid</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * store toplevel xid so we don't have to merge cids from different 
     * transactions 
     */ 
</span><a name="LN338"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>top_xid</span><span class='Delimiter'>; 
</span><a name="LN339"></a>    <a href="../c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Member'>cmin</span><span class='Delimiter'>; 
</span><a name="LN340"></a>    <a href="../c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Member'>cmax</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * don't really need the combocid since we have the actual values right in 
     * this struct, but the padding makes it free and its useful for 
     * debugging. 
     */ 
</span><a name="LN347"></a>    <a href="../c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Member'>combocid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Store the relfilenode/ctid pair to facilitate lookups. 
     */ 
</span><a name="LN352"></a>    <a href="../storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Member'>target_node</span><span class='Delimiter'>; 
</span><a name="LN353"></a>    <a href="../storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Member'>target_tid</span><span class='Delimiter'>; 
</span><a name="LN354"></a>}<span class='Auto_Annotations'> &laquo; end xl_heap_new_cid &raquo; </span> <span class='Declare_Typedef'>xl_heap_new_cid</span><span class='Delimiter'>; 
</span> 
<a name="LN356"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SizeOfHeapNewCid</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="heapam_xlog.h.html#LN332"><span class='Ref_to_Struct'>xl_heap_new_cid</span></a><span class='Delimiter'>, </span>target_tid<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* logical rewrite xlog record header */ 
</span><a name="LN359"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>xl_heap_rewrite_mapping</span> 
<span class='Delimiter'>{ 
</span><a name="LN361"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>mapped_xid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* xid that might need to see the row */ 
</span><a name="LN362"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>mapped_db</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* DbOid or InvalidOid for shared rels */ 
</span><a name="LN363"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>mapped_rel</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* Oid of the mapped relation */ 
</span><a name="LN364"></a>    off_t       <span class='Declare_Member'>offset</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* How far have we written so far */ 
</span><a name="LN365"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>num_mappings</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* Number of in-memory mappings */ 
</span><a name="LN366"></a>    <a href="xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>start_lsn</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* Insert LSN at begin of rewrite */ 
</span><a name="LN367"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>xl_heap_rewrite_mapping</span><span class='Delimiter'>; 
</span> 
<a name="LN369"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>HeapTupleHeaderAdvanceLatestRemovedXid</span><span class='Parentheses'>(</span><a href="htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN370"></a>                                       <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>latestRemovedXid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN372"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>heap_redo</span><span class='Parentheses'>(</span><a href="xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN373"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>heap_desc</span><span class='Parentheses'>(</span><a href="../lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN374"></a><span class='Keyword'>extern const char </span><span class='Operator'>*</span><span class='Declare_Prototype'>heap_identify</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN375"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>heap_mask</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>pagedata</span><span class='Delimiter'>, </span><a href="../storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blkno</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN376"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>heap2_redo</span><span class='Parentheses'>(</span><a href="xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN377"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>heap2_desc</span><span class='Parentheses'>(</span><a href="../lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN378"></a><span class='Keyword'>extern const char </span><span class='Operator'>*</span><span class='Declare_Prototype'>heap2_identify</span><span class='Parentheses'>(</span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a> <span class='Declare_Parameter'>info</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN379"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>heap_xlog_logical_rewrite</span><span class='Parentheses'>(</span><a href="xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN381"></a><span class='Keyword'>extern </span><a href="xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>log_heap_cleanup_info</span><span class='Parentheses'>(</span><a href="../storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Parameter'>rnode</span><span class='Delimiter'>, 
</span><a name="LN382"></a>                      <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestRemovedXid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN383"></a><span class='Keyword'>extern </span><a href="xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>log_heap_clean</span><span class='Parentheses'>(</span><a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, 
</span><a name="LN384"></a>               <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>redirected</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nredirected</span><span class='Delimiter'>, 
</span><a name="LN385"></a>               <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nowdead</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>ndead</span><span class='Delimiter'>, 
</span><a name="LN386"></a>               <a href="../storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nowunused</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nunused</span><span class='Delimiter'>, 
</span><a name="LN387"></a>               <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>latestRemovedXid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN388"></a><span class='Keyword'>extern </span><a href="xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>log_heap_freeze</span><span class='Parentheses'>(</span><a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>reln</span><span class='Delimiter'>, </span><a href="../storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, 
</span><a name="LN389"></a>                <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>cutoff_xid</span><span class='Delimiter'>, </span><a href="heapam_xlog.h.html#LN295"><span class='Ref_to_Struct'>xl_heap_freeze_tuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tuples</span><span class='Delimiter'>, 
</span><a name="LN390"></a>                <span class='Keyword'>int </span><span class='Declare_Parameter'>ntuples</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN391"></a><span class='Keyword'>extern bool </span><span class='Declare_Prototype'>heap_prepare_freeze_tuple</span><span class='Parentheses'>(</span><a href="htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN392"></a>                          <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>cutoff_xid</span><span class='Delimiter'>, 
</span><a name="LN393"></a>                          <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>cutoff_multi</span><span class='Delimiter'>, 
</span><a name="LN394"></a>                          <a href="heapam_xlog.h.html#LN295"><span class='Ref_to_Struct'>xl_heap_freeze_tuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>frz</span><span class='Delimiter'>, 
</span><a name="LN395"></a>                          <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>totally_frozen</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN396"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>heap_execute_freeze_tuple</span><span class='Parentheses'>(</span><a href="htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN397"></a>                          <a href="heapam_xlog.h.html#LN295"><span class='Ref_to_Struct'>xl_heap_freeze_tuple</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xlrec_tp</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN398"></a><span class='Keyword'>extern </span><a href="xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>log_heap_visible</span><span class='Parentheses'>(</span><a href="../storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Parameter'>rnode</span><span class='Delimiter'>, </span><a href="../storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>heap_buffer</span><span class='Delimiter'>, 
</span><a name="LN399"></a>                 <a href="../storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>vm_buffer</span><span class='Delimiter'>, </span><a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>cutoff_xid</span><span class='Delimiter'>, </span><a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a> <span class='Declare_Parameter'>flags</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* HEAPAM_XLOG_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>