<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\c.h</title>
<LINK REL=StyleSheet HREF="../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\c.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:02 2017
</td></tr>
<tr><td><a href='../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * c.h 
 *    Fundamental C definitions.  This is included by every .c file in 
 *    PostgreSQL (via either postgres.h or postgres_fe.h, as appropriate). 
 * 
 *    Note that the definitions here are not intended to be exposed to clients 
 *    of the frontend interface libraries --- so we don't worry much about 
 *    polluting the namespace with lots of stuff... 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/c.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
/* 
 *---------------------------------------------------------------- 
 *   TABLE OF CONTENTS 
 * 
 *      When adding stuff to this file, please try to put stuff 
 *      into the relevant section, or add new sections as appropriate. 
 * 
 *    section   description 
 *    -------   ------------------------------------------------ 
 *      0)      pg_config.h and standard system headers 
 *      1)      hacks to cope with non-ANSI C compilers 
 *      2)      bool, true, false, TRUE, FALSE, NULL 
 *      3)      standard system types 
 *      4)      IsValid macros for system types 
 *      5)      offsetof, lengthof, endof, alignment 
 *      6)      assertions 
 *      7)      widely useful macros 
 *      8)      random stuff 
 *      9)      system-specific hacks 
 * 
 * NOTE: since this file is included by both frontend and backend modules, it's 
 * almost certainly wrong to put an "extern" declaration here.  typedefs and 
 * macros are the kind of thing that might go here. 
 * 
 *---------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="c.h.html#LN45"><span class='Ref_to_Const'>C_H</span></a> 
<a name="LN45"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>C_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"postgres_ext.h"</span> 
 
<span class='Comment_Multi_Line'>/* Must undef pg_config_ext.h symbols before including pg_config.h */ 
</span><span class='Keyword'>#undef </span>PG_INT64_TYPE 
 
<span class='Keyword'>#include </span><span class='String'>"pg_config.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pg_config_manual.h"</span>   <span class='Comment_Single_Line'>/* must be after pg_config.h */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * We always rely on the WIN32 macro being set by our build system, 
 * but _WIN32 is the compiler pre-defined macro. So make sure we define 
 * WIN32 whenever _WIN32 is set, to facilitate standalone building. 
 */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>_WIN32<span class='Parentheses'>) </span><span class='Operator'>&& !</span>defined<span class='Parentheses'>(</span><a href="c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a><span class='Parentheses'>) 
</span><a name="LN61"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>WIN32</span> 
<span class='Directive'>#endif</span> 
 
<span class='Directive'>#if</span> <span class='Operator'>!</span>defined<span class='Parentheses'>(</span><a href="c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span>defined<span class='Parentheses'>(</span>__CYGWIN__<span class='Parentheses'>)</span>     <span class='Comment_Single_Line'>/* win32 includes further down */ 
</span><span class='Keyword'>#include </span><span class='String'>"pg_config_os.h"</span>       <span class='Comment_Single_Line'>/* must be before any system header files */ 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#if</span> _MSC_VER <span class='Operator'>&GT;= </span><span class='Number'>1400</span> <span class='Operator'>|| </span>defined<span class='Parentheses'>(</span>HAVE_CRTDEFS_H<span class='Parentheses'>) 
</span><a name="LN69"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>errcode</span> __msvc_errcode 
<span class='Keyword'>#include </span><span class='String'>&LT;crtdefs.h&GT;</span> 
<span class='Keyword'>#undef </span><a href="../pl/plpython/plpython.h.html#LN47"><span class='Ref_to_Const'>errcode</span></a> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * We have to include stdlib.h here because it defines many of these macros 
 * on some platforms, and we only want our definitions used if stdlib.h doesn't 
 * have its own.  The same goes for stddef and stdarg if present. 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;stdio.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;stdlib.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;string.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;stddef.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;stdarg.h&GT;</span> 
<span class='Directive'>#ifdef</span> HAVE_STRINGS_H 
<span class='Keyword'>#include </span><span class='String'>&LT;strings.h&GT;</span> 
<span class='Directive'>#endif</span> 
<span class='Directive'>#ifdef</span> HAVE_STDINT_H 
<span class='Keyword'>#include </span><span class='String'>&LT;stdint.h&GT;</span> 
<span class='Directive'>#endif</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;sys/types.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;errno.h&GT;</span> 
<span class='Directive'>#if</span> defined<span class='Parentheses'>(</span><a href="c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span>defined<span class='Parentheses'>(</span>__CYGWIN__<span class='Parentheses'>) 
</span><span class='Keyword'>#include </span><span class='String'>&LT;fcntl.h&GT;</span>              <span class='Comment_Single_Line'>/* ensure O_BINARY is available */ 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#if</span> defined<span class='Parentheses'>(</span><a href="c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span>defined<span class='Parentheses'>(</span>__CYGWIN__<span class='Parentheses'>) 
</span><span class='Comment_Multi_Line'>/* We have to redefine some system functions after they are included above. */ 
</span><span class='Keyword'>#include </span><span class='String'>"pg_config_os.h"</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Force disable inlining if PG_FORCE_DISABLE_INLINE is defined. This is used 
 * to work around compiler bugs and might also be useful for investigatory 
 * purposes by defining the symbol in the platform's header.. 
 * 
 * This is done early (in slightly the wrong section) as functionality later 
 * in this file might want to rely on inline functions. 
 */ 
</span><span class='Directive'>#ifdef</span> <a href="port/aix.h.html#LN12"><span class='Ref_to_Const'>PG_FORCE_DISABLE_INLINE</span></a> 
<span class='Keyword'>#undef inline 
</span><a name="LN113"></a>#define <span class='Declare_Constant'>inline</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* Must be before gettext() games below */ 
</span><span class='Keyword'>#include </span><span class='String'>&LT;locale.h&GT;</span> 
 
<a name="LN119"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>_</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) </span><a href="c.h.html#LN124"><span class='Ref_to_Macro'>gettext</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN119"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) 
</span> 
<span class='Directive'>#ifdef</span> ENABLE_NLS 
<span class='Keyword'>#include </span><span class='String'>&LT;libintl.h&GT;</span> 
<span class='Directive'>#else</span> 
<a name="LN124"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>gettext</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) (</span><a href="c.h.html#LN124"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) 
</span><a name="LN125"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dgettext</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>d</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) (</span><a href="c.h.html#LN125"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) 
</span><a name="LN126"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>ngettext</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>s</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>p</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>n</span><span class='Parentheses'>) ((</span><a href="c.h.html#LN126"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="c.h.html#LN126"><span class='Ref_to_Parameter'>s</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Parentheses'>(</span><a href="c.h.html#LN126"><span class='Ref_to_Parameter'>p</span></a><span class='Parentheses'>))</span> 
<a name="LN127"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dngettext</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>d</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>s</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>p</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>n</span><span class='Parentheses'>) ((</span><a href="c.h.html#LN127"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="c.h.html#LN127"><span class='Ref_to_Parameter'>s</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Parentheses'>(</span><a href="c.h.html#LN127"><span class='Ref_to_Parameter'>p</span></a><span class='Parentheses'>))</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 *  Use this to mark string constants as needing translation at some later 
 *  time, rather than immediately.  This is useful for cases where you need 
 *  access to the original string and translated string, and for cases where 
 *  immediate translation is not possible, like when initializing global 
 *  variables. 
 *      http://www.gnu.org/software/autoconf/manual/gettext/Special-cases.html 
 */ 
</span><a name="LN138"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>gettext_noop</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) (</span><a href="c.h.html#LN138"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 1: hacks to cope with non-ANSI C compilers 
 * 
 * type prefixes (const, signed, volatile, inline) are handled in pg_config.h. 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CppAsString 
 *      Convert the argument to a string, using the C preprocessor. 
 * CppAsString2 
 *      Convert the argument to a string, after one round of macro expansion. 
 * CppConcat 
 *      Concatenate two arguments together, using the C preprocessor. 
 * 
 * Note: There used to be support here for pre-ANSI C compilers that didn't 
 * support # and ##.  Nowadays, these macros are just for clarity and/or 
 * backward compatibility with existing PostgreSQL code. 
 */ 
</span><a name="LN160"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>CppAsString</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>identifier</span><span class='Parentheses'>) </span>#identifier 
<a name="LN161"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>CppAsString2</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>         <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN161"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) 
</span><a name="LN162"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>CppConcat</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>y</span><span class='Parentheses'>)</span>         <a href="c.h.html#LN162"><span class='Ref_to_Parameter'>x</span></a>##<a href="c.h.html#LN162"><span class='Ref_to_Parameter'>y</span></a> 
 
<span class='Comment_Multi_Line'>/* 
 * dummyret is used to set return values in macros that use ?: to make 
 * assignments.  gcc wants these to be void, other compilers like char 
 */ 
</span><span class='Directive'>#ifdef</span> __GNUC__                 <span class='Comment_Single_Line'>/* GNU cc */ 
</span><a name="LN169"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>dummyret</span>    <span class='Keyword'>void 
</span><span class='Directive'>#else</span> 
<a name="LN171"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>dummyret</span>    <span class='Keyword'>char 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* Which __func__ symbol do we have, if any? */ 
</span><span class='Directive'>#ifdef</span> HAVE_FUNCNAME__FUNC 
<a name="LN176"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_FUNCNAME_MACRO</span>   __func__ 
<span class='Directive'>#else</span> 
<span class='Directive'>#ifdef</span> HAVE_FUNCNAME__FUNCTION 
<a name="LN179"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_FUNCNAME_MACRO</span>   __FUNCTION__ 
<span class='Directive'>#else</span> 
<a name="LN181"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_FUNCNAME_MACRO</span>   <span class='Null_Value'>NULL 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 2:  bool, true, false, TRUE, FALSE, NULL 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * bool 
 *      Boolean value, either true or false. 
 * 
 * XXX for C++ compilers, we assume the compiler has a compatible 
 * built-in definition of bool. 
 */ 
</span> 
<span class='Directive'>#ifndef</span> __cplusplus 
 
<span class='Directive'>#ifndef</span> <span class='Keyword'>bool 
</span><a name="LN201"></a><span class='Control'>typedef</span> <span class='Keyword'>char </span><span class='Declare_Typedef'>bool</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#ifndef</span> <span class='Boolean'>true 
</span><a name="LN205"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>true</span>    <span class='Parentheses'>((</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span> 
 
<span class='Directive'>#ifndef</span> <span class='Boolean'>false 
</span><a name="LN209"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>false</span>   <span class='Parentheses'>((</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* not C++ */ 
</span> 
<a name="LN213"></a><span class='Control'>typedef</span> <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Typedef'>BoolPtr</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifndef</span> <span class='Boolean'>TRUE 
</span><a name="LN216"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>TRUE</span>    <span class='Number'>1</span> 
<span class='Directive'>#endif</span> 
 
<span class='Directive'>#ifndef</span> <span class='Boolean'>FALSE 
</span><a name="LN220"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FALSE</span>   <span class='Number'>0</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * NULL 
 *      Null pointer. 
 */ 
</span><span class='Directive'>#ifndef</span> <span class='Null_Value'>NULL 
</span><a name="LN228"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>NULL</span>    <span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 3:  standard system types 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Pointer 
 *      Variable holding address of any memory resident object. 
 * 
 *      XXX Pointer arithmetic is done with this, so it can't be void * 
 *      under "true" ANSI compilers. 
 */ 
</span><a name="LN244"></a><span class='Control'>typedef</span> <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Typedef'>Pointer</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * intN 
 *      Signed integer, EXACTLY N BITS IN SIZE, 
 *      used for numerical computations and the 
 *      frontend/backend protocol. 
 */ 
</span><span class='Directive'>#ifndef</span> HAVE_INT8 
<a name="LN253"></a><span class='Control'>typedef</span> <span class='Keyword'>signed char </span><span class='Declare_Typedef'>int8</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* == 8 bits */ 
</span><a name="LN254"></a><span class='Control'>typedef</span> <span class='Keyword'>signed short </span><span class='Declare_Typedef'>int16</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* == 16 bits */ 
</span><a name="LN255"></a><span class='Control'>typedef</span> <span class='Keyword'>signed int </span><span class='Declare_Typedef'>int32</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* == 32 bits */ 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* not HAVE_INT8 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * uintN 
 *      Unsigned integer, EXACTLY N BITS IN SIZE, 
 *      used for numerical computations and the 
 *      frontend/backend protocol. 
 */ 
</span><span class='Directive'>#ifndef</span> HAVE_UINT8 
<a name="LN265"></a><span class='Control'>typedef</span> <span class='Keyword'>unsigned char </span><span class='Declare_Typedef'>uint8</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* == 8 bits */ 
</span><a name="LN266"></a><span class='Control'>typedef</span> <span class='Keyword'>unsigned short </span><span class='Declare_Typedef'>uint16</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* == 16 bits */ 
</span><a name="LN267"></a><span class='Control'>typedef</span> <span class='Keyword'>unsigned int </span><span class='Declare_Typedef'>uint32</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* == 32 bits */ 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* not HAVE_UINT8 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * bitsN 
 *      Unit of bitwise operation, AT LEAST N BITS IN SIZE. 
 */ 
</span><a name="LN274"></a><span class='Control'>typedef</span> <a href="c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a> <span class='Declare_Typedef'>bits8</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* &GT;= 8 bits */ 
</span><a name="LN275"></a><span class='Control'>typedef</span> <a href="c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a> <span class='Declare_Typedef'>bits16</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* &GT;= 16 bits */ 
</span><a name="LN276"></a><span class='Control'>typedef</span> <a href="c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Typedef'>bits32</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* &GT;= 32 bits */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * 64-bit integers 
 */ 
</span><span class='Directive'>#ifdef</span> HAVE_LONG_INT_64 
<span class='Comment_Multi_Line'>/* Plain "long int" fits, use it */ 
</span> 
<span class='Directive'>#ifndef</span> HAVE_INT64 
<a name="LN285"></a><span class='Control'>typedef</span> <span class='Keyword'>long int </span><span class='Declare_Typedef'>int64</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifndef</span> HAVE_UINT64 
<a name="LN288"></a><span class='Control'>typedef</span> <span class='Keyword'>unsigned long int </span><span class='Declare_Typedef'>uint64</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#elif</span> defined<span class='Parentheses'>(</span>HAVE_LONG_LONG_INT_64<span class='Parentheses'>) 
</span><span class='Comment_Multi_Line'>/* We have working support for "long long int", use that */ 
</span> 
<span class='Directive'>#ifndef</span> HAVE_INT64 
<a name="LN294"></a><span class='Control'>typedef</span> <span class='Keyword'>long long int </span><span class='Declare_Typedef'>int64</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifndef</span> HAVE_UINT64 
<a name="LN297"></a><span class='Control'>typedef</span> <span class='Keyword'>unsigned long long int </span><span class='Declare_Typedef'>uint64</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#else</span> 
<span class='Comment_Multi_Line'>/* neither HAVE_LONG_INT_64 nor HAVE_LONG_LONG_INT_64 */ 
</span>#error must have a working <span class='Number'>64</span><span class='Operator'>-</span><a href="../backend/utils/adt/varbit.c.html#LN359"><span class='Ref_to_Func'>bit</span></a> integer datatype 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* Decide if we need to decorate 64-bit constants */ 
</span><span class='Directive'>#ifdef</span> HAVE_LL_CONSTANTS 
<a name="LN306"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>INT64CONST</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><a href="c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) </span><a href="c.h.html#LN306"><span class='Ref_to_Parameter'>x</span></a>##LL<span class='Parentheses'>)</span> 
<a name="LN307"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>UINT64CONST</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) ((</span><a href="c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="c.h.html#LN307"><span class='Ref_to_Parameter'>x</span></a>##ULL<span class='Parentheses'>)</span> 
<span class='Directive'>#else</span> 
<a name="LN309"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>INT64CONST</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><a href="c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>) </span><a href="c.h.html#LN309"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span> 
<a name="LN310"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>UINT64CONST</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) ((</span><a href="c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="c.h.html#LN310"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* snprintf format strings to use for 64-bit integers */ 
</span><a name="LN314"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>INT64_FORMAT</span> <span class='String'>"%"</span> INT64_MODIFIER <span class='String'>"d"</span> 
<a name="LN315"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>UINT64_FORMAT</span> <span class='String'>"%"</span> INT64_MODIFIER <span class='String'>"u"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * 128-bit signed and unsigned integers 
 *      There currently is only a limited support for the type. E.g. 128bit 
 *      literals and snprintf are not supported; but math is. 
 */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>PG_INT128_TYPE<span class='Parentheses'>) 
</span><a name="LN323"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HAVE_INT128</span> 
<a name="LN324"></a><span class='Control'>typedef</span> PG_INT128_TYPE <span class='Declare_Typedef'>int128</span><span class='Delimiter'>; 
</span><a name="LN325"></a><span class='Control'>typedef</span> <span class='Keyword'>unsigned </span>PG_INT128_TYPE <span class='Declare_Typedef'>uint128</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * stdint.h limits aren't guaranteed to be present and aren't guaranteed to 
 * have compatible types with our fixed width types. So just define our own. 
 */ 
</span><a name="LN332"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT8_MIN</span>     <span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>0x7F</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN333"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT8_MAX</span>     <span class='Parentheses'>(</span><span class='Number'>0x7F</span><span class='Parentheses'>) 
</span><a name="LN334"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_UINT8_MAX</span>    <span class='Parentheses'>(</span><span class='Number'>0xFF</span><span class='Parentheses'>) 
</span><a name="LN335"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT16_MIN</span>    <span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>0x7FFF</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN336"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT16_MAX</span>    <span class='Parentheses'>(</span><span class='Number'>0x7FFF</span><span class='Parentheses'>) 
</span><a name="LN337"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_UINT16_MAX</span>   <span class='Parentheses'>(</span><span class='Number'>0xFFFF</span><span class='Parentheses'>) 
</span><a name="LN338"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT32_MIN</span>    <span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>0x7FFFFFFF</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN339"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT32_MAX</span>    <span class='Parentheses'>(</span><span class='Number'>0x7FFFFFFF</span><span class='Parentheses'>) 
</span><a name="LN340"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_UINT32_MAX</span>   <span class='Parentheses'>(</span><span class='Number'>0xFFFFFFFF</span><span class='Parentheses'>) 
</span><a name="LN341"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT64_MIN</span>    <span class='Parentheses'>(</span><span class='Operator'>-</span><a href="c.h.html#LN306"><span class='Ref_to_Macro'>INT64CONST</span></a><span class='Parentheses'>(</span><span class='Number'>0x7FFFFFFFFFFFFFFF</span><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
<a name="LN342"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_INT64_MAX</span>    <a href="c.h.html#LN306"><span class='Ref_to_Macro'>INT64CONST</span></a><span class='Parentheses'>(</span><span class='Number'>0x7FFFFFFFFFFFFFFF</span><span class='Parentheses'>) 
</span><a name="LN343"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_UINT64_MAX</span>   <a href="c.h.html#LN307"><span class='Ref_to_Macro'>UINT64CONST</span></a><span class='Parentheses'>(</span><span class='Number'>0xFFFFFFFFFFFFFFFF</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * We now always use int64 timestamps, but keep this symbol defined for the 
 * benefit of external code that might test it. 
 */ 
</span><a name="LN349"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HAVE_INT64_TIMESTAMP</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Size 
 *      Size of any memory resident object, as returned by sizeof. 
 */ 
</span><a name="LN355"></a><span class='Control'>typedef</span> size_t <span class='Declare_Typedef'>Size</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Index 
 *      Index into any memory resident array. 
 * 
 * Note: 
 *      Indices are non negative. 
 */ 
</span><a name="LN364"></a><span class='Control'>typedef</span> <span class='Keyword'>unsigned int </span><span class='Declare_Typedef'>Index</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Offset 
 *      Offset into any memory resident array. 
 * 
 * Note: 
 *      This differs from an Index in that an Index is always 
 *      non negative, whereas Offset may be negative. 
 */ 
</span><a name="LN374"></a><span class='Control'>typedef</span> <span class='Keyword'>signed int </span><span class='Declare_Typedef'>Offset</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Common Postgres datatype names (as used in the catalogs) 
 */ 
</span><a name="LN379"></a><span class='Control'>typedef</span> <span class='Keyword'>float </span><span class='Declare_Typedef'>float4</span><span class='Delimiter'>; 
</span><a name="LN380"></a><span class='Control'>typedef</span> <span class='Keyword'>double </span><span class='Declare_Typedef'>float8</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Oid, RegProcedure, TransactionId, SubTransactionId, MultiXactId, 
 * CommandId 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* typedef Oid is in postgres_ext.h */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * regproc is the type name used in the include/catalog headers, but 
 * RegProcedure is the preferred name in C code. 
 */ 
</span><a name="LN393"></a><span class='Control'>typedef</span> <a href="postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Typedef'>regproc</span><span class='Delimiter'>; 
</span><a name="LN394"></a><span class='Control'>typedef</span> <a href="c.h.html#LN393"><span class='Ref_to_Typedef'>regproc</span></a> <span class='Declare_Typedef'>RegProcedure</span><span class='Delimiter'>; 
</span> 
<a name="LN396"></a><span class='Control'>typedef</span> <a href="c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Typedef'>TransactionId</span><span class='Delimiter'>; 
</span> 
<a name="LN398"></a><span class='Control'>typedef</span> <a href="c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Typedef'>LocalTransactionId</span><span class='Delimiter'>; 
</span> 
<a name="LN400"></a><span class='Control'>typedef</span> <a href="c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Typedef'>SubTransactionId</span><span class='Delimiter'>; 
</span> 
<a name="LN402"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>InvalidSubTransactionId</span>     <span class='Parentheses'>((</span><a href="c.h.html#LN400"><span class='Ref_to_Typedef'>SubTransactionId</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN403"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>TopSubTransactionId</span>         <span class='Parentheses'>((</span><a href="c.h.html#LN400"><span class='Ref_to_Typedef'>SubTransactionId</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* MultiXactId must be equivalent to TransactionId, to fit in t_xmax */ 
</span><a name="LN406"></a><span class='Control'>typedef</span> <a href="c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Typedef'>MultiXactId</span><span class='Delimiter'>; 
</span> 
<a name="LN408"></a><span class='Control'>typedef</span> <a href="c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Typedef'>MultiXactOffset</span><span class='Delimiter'>; 
</span> 
<a name="LN410"></a><span class='Control'>typedef</span> <a href="c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Typedef'>CommandId</span><span class='Delimiter'>; 
</span> 
<a name="LN412"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FirstCommandId</span>  <span class='Parentheses'>((</span><a href="c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN413"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>InvalidCommandId</span>    <span class='Parentheses'>(</span><span class='Operator'>~</span><span class='Parentheses'>(</span><a href="c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a><span class='Parentheses'>)</span><span class='Number'>0</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Array indexing support 
 */ 
</span><a name="LN418"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>MAXDIM</span> <span class='Number'>6</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN421"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>indx</span><span class='Delimiter'>[</span><a href="c.h.html#LN418"><span class='Ref_to_Const'>MAXDIM</span></a><span class='Delimiter'>]; 
</span><a name="LN422"></a>}   <span class='Declare_Typedef'>IntArray</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      Variable-length datatypes all share the 'struct varlena' header. 
 * 
 * NOTE: for TOASTable types, this is an oversimplification, since the value 
 * may be compressed or moved out-of-line.  However datatype-specific routines 
 * are mostly content to deal with de-TOASTed values only, and of course 
 * client-side routines should never see a TOASTed value.  But even in a 
 * de-TOASTed value, beware of touching vl_len_ directly, as its 
 * representation is no longer convenient.  It's recommended that code always 
 * use macros VARDATA_ANY, VARSIZE_ANY, VARSIZE_ANY_EXHDR, VARDATA, VARSIZE, 
 * and SET_VARSIZE instead of relying on direct mentions of the struct fields. 
 * See postgres.h for details of the TOASTed form. 
 * ---------------- 
 */ 
</span><a name="LN438"></a><span class='Control'>struct</span> <span class='Declare_Struct'>varlena</span> 
<span class='Delimiter'>{ 
</span><a name="LN440"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>vl_len_</span><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>];</span>     <span class='Comment_Single_Line'>/* Do not touch this field directly! */ 
</span><a name="LN441"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>vl_dat</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>];</span>  <span class='Comment_Single_Line'>/* Data content is here */ 
</span><span class='Delimiter'>}; 
</span> 
<a name="LN444"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>VARHDRSZ</span>        <span class='Parentheses'>((</span><a href="c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * These widely-used datatypes are just a varlena header and the data bytes. 
 * There is no terminating null or anything like that --- the data length is 
 * always VARSIZE_ANY_EXHDR(ptr). 
 */ 
</span><a name="LN451"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="c.h.html#LN438"><span class='Ref_to_Struct'>varlena</span></a> <span class='Declare_Typedef'>bytea</span><span class='Delimiter'>; 
</span><a name="LN452"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="c.h.html#LN438"><span class='Ref_to_Struct'>varlena</span></a> <span class='Declare_Typedef'>text</span><span class='Delimiter'>; 
</span><a name="LN453"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="c.h.html#LN438"><span class='Ref_to_Struct'>varlena</span></a> <span class='Declare_Typedef'>BpChar</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* blank-padded char, ie SQL char(n) */ 
</span><a name="LN454"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="c.h.html#LN438"><span class='Ref_to_Struct'>varlena</span></a> <span class='Declare_Typedef'>VarChar</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* var-length char, ie SQL varchar(n) */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Specialized array types.  These are physically laid out just the same 
 * as regular arrays (so that the regular array subscripting code works 
 * with them).  They exist as distinct types mostly for historical reasons: 
 * they have nonstandard I/O behavior which we don't want to change for fear 
 * of breaking applications that look at the system catalogs.  There is also 
 * an implementation issue for oidvector: it's part of the primary key for 
 * pg_proc, and we can't use the normal btree array support routines for that 
 * without circularity. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN468"></a>    <a href="c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>vl_len_</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* these fields must match ArrayType! */ 
</span><a name="LN469"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ndim</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* always 1 for int2vector */ 
</span><a name="LN470"></a>    <a href="c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>dataoffset</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* always 0 for int2vector */ 
</span><a name="LN471"></a>    <a href="postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>elemtype</span><span class='Delimiter'>; 
</span><a name="LN472"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>dim1</span><span class='Delimiter'>; 
</span><a name="LN473"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>lbound1</span><span class='Delimiter'>; 
</span><a name="LN474"></a>    <a href="c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Member'>values</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN475"></a>} <span class='Declare_Typedef'>int2vector</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN479"></a>    <a href="c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>vl_len_</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* these fields must match ArrayType! */ 
</span><a name="LN480"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ndim</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* always 1 for oidvector */ 
</span><a name="LN481"></a>    <a href="c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>dataoffset</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* always 0 for oidvector */ 
</span><a name="LN482"></a>    <a href="postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>elemtype</span><span class='Delimiter'>; 
</span><a name="LN483"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>dim1</span><span class='Delimiter'>; 
</span><a name="LN484"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>lbound1</span><span class='Delimiter'>; 
</span><a name="LN485"></a>    <a href="postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>values</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN486"></a>} <span class='Declare_Typedef'>oidvector</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Representation of a Name: effectively just a C string, but null-padded to 
 * exactly NAMEDATALEN bytes.  The use of a struct is historical. 
 */ 
</span><a name="LN492"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>nameData</span> 
<span class='Delimiter'>{ 
</span><a name="LN494"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>data</span><span class='Delimiter'>[</span><a href="../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>]; 
</span><a name="LN495"></a>} <span class='Declare_Typedef'>NameData</span><span class='Delimiter'>; 
</span><a name="LN496"></a><span class='Control'>typedef</span> <a href="c.h.html#LN492"><span class='Ref_to_Typedef'>NameData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>Name</span><span class='Delimiter'>; 
</span> 
<a name="LN498"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>NameStr</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>name</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><a href="c.h.html#LN498"><span class='Ref_to_Parameter'>name</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>data<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Support macros for escaping strings.  escape_backslash should be TRUE 
 * if generating a non-standard-conforming string.  Prefixing a string 
 * with ESCAPE_STRING_SYNTAX guarantees it is non-standard-conforming. 
 * Beware of multiple evaluation of the "ch" argument! 
 */ 
</span><a name="LN506"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SQL_STR_DOUBLE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ch</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>escape_backslash</span><span class='Parentheses'>)</span>    <span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="c.h.html#LN506"><span class='Ref_to_Parameter'>ch</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='String'>'\''</span> <span class='Operator'>|| </span><span class='Parentheses'>((</span><a href="c.h.html#LN506"><span class='Ref_to_Parameter'>ch</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='String'>'\\'</span> <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="c.h.html#LN506"><span class='Ref_to_Parameter'>escape_backslash</span></a><span class='Parentheses'>)))</span> 
 
<a name="LN509"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ESCAPE_STRING_SYNTAX</span>    <span class='String'>'E'</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 4:  IsValid macros for system types 
 * ---------------------------------------------------------------- 
 */ 
/* 
 * BoolIsValid 
 *      True iff bool is valid. 
 */ 
</span><a name="LN519"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>BoolIsValid</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>boolean</span><span class='Parentheses'>)</span>    <span class='Parentheses'>((</span><a href="c.h.html#LN519"><span class='Ref_to_Parameter'>boolean</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Boolean'>false </span><span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="c.h.html#LN519"><span class='Ref_to_Parameter'>boolean</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * PointerIsValid 
 *      True iff pointer is valid. 
 */ 
</span><a name="LN525"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PointerIsValid</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>pointer</span><span class='Parentheses'>) ((</span><span class='Keyword'>const void</span><span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="c.h.html#LN525"><span class='Ref_to_Parameter'>pointer</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * PointerIsAligned 
 *      True iff pointer is properly aligned to point to the given type. 
 */ 
</span><a name="LN531"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PointerIsAligned</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>pointer</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>type</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>        <span class='Parentheses'>(((</span>uintptr_t<span class='Parentheses'>)(</span><a href="c.h.html#LN531"><span class='Ref_to_Parameter'>pointer</span></a><span class='Parentheses'>)</span> <span class='Operator'>% </span><span class='Parentheses'>(</span><span class='Keyword'>sizeof </span><span class='Parentheses'>(</span><a href="c.h.html#LN531"><span class='Ref_to_Parameter'>type</span></a><span class='Parentheses'>)))</span> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
 
<a name="LN534"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>OffsetToPointer</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>base</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>offset</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>        <span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>)((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="c.h.html#LN534"><span class='Ref_to_Parameter'>base</span></a> <span class='Operator'>+ </span><a href="c.h.html#LN534"><span class='Ref_to_Parameter'>offset</span></a><span class='Parentheses'>))</span> 
 
<a name="LN537"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>OidIsValid</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>objectId</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><span class='Keyword'>bool</span><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="c.h.html#LN537"><span class='Ref_to_Parameter'>objectId</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>))</span> 
 
<a name="LN539"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>RegProcedureIsValid</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>p</span><span class='Parentheses'>)</span>  <a href="c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN539"><span class='Ref_to_Parameter'>p</span></a><span class='Parentheses'>) 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 5:  offsetof, lengthof, endof, alignment 
 * ---------------------------------------------------------------- 
 */ 
/* 
 * offsetof 
 *      Offset of a structure/union field within that structure/union. 
 * 
 *      XXX This is supposed to be part of stddef.h, but isn't on 
 *      some systems (like SunOS 4). 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a> 
<a name="LN554"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>offsetof</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>type</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>field</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Keyword'>long</span><span class='Parentheses'>)</span> <span class='Operator'>&</span><span class='Parentheses'>((</span><a href="c.h.html#LN554"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>field<span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* offsetof */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * lengthof 
 *      Number of elements in an array. 
 */ 
</span><a name="LN561"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>lengthof</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>array</span><span class='Parentheses'>) (</span><span class='Keyword'>sizeof </span><span class='Parentheses'>(</span><a href="c.h.html#LN561"><span class='Ref_to_Parameter'>array</span></a><span class='Parentheses'>)</span> <span class='Operator'>/ </span><span class='Keyword'>sizeof </span><span class='Parentheses'>((</span><a href="c.h.html#LN561"><span class='Ref_to_Parameter'>array</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * endof 
 *      Address of the element one past the last in an array. 
 */ 
</span><a name="LN567"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>endof</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>array</span><span class='Parentheses'>)</span>    <span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="c.h.html#LN567"><span class='Ref_to_Parameter'>array</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><a href="c.h.html#LN561"><span class='Ref_to_Macro'>lengthof</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN567"><span class='Ref_to_Parameter'>array</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 * Alignment macros: align a length or address appropriately for a given type. 
 * The fooALIGN() macros round up to a multiple of the required alignment, 
 * while the fooALIGN_DOWN() macros round down.  The latter are more useful 
 * for problems like "how many X-sized structures will fit in a page?". 
 * 
 * NOTE: TYPEALIGN[_DOWN] will not work if ALIGNVAL is not a power of 2. 
 * That case seems extremely unlikely to be needed in practice, however. 
 * ---------------- 
 */ 
</span> 
<a name="LN580"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>TYPEALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ALIGNVAL</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>  <span class='Operator'>\ 
</span>    <span class='Parentheses'>(((</span>uintptr_t<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="c.h.html#LN580"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>)</span> <span class='Operator'>+ </span><span class='Parentheses'>((</span><a href="c.h.html#LN580"><span class='Ref_to_Parameter'>ALIGNVAL</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> <span class='Operator'>& ~</span><span class='Parentheses'>((</span>uintptr_t<span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="c.h.html#LN580"><span class='Ref_to_Parameter'>ALIGNVAL</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)))</span> 
 
<a name="LN583"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SHORTALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>         <a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span>ALIGNOF_SHORT<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN583"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN584"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>INTALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>           <a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span>ALIGNOF_INT<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN584"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN585"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LONGALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>          <a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span>ALIGNOF_LONG<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN585"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN586"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>DOUBLEALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>        <a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span>ALIGNOF_DOUBLE<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN586"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN587"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>MAXALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>           <a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span>MAXIMUM_ALIGNOF<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN587"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<span class='Comment_Multi_Line'>/* MAXALIGN covers only built-in types, not buffers */ 
</span><a name="LN589"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>BUFFERALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>        <a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span><a href="pg_config_manual.h.html#LN113"><span class='Ref_to_Const'>ALIGNOF_BUFFER</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN589"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN590"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>CACHELINEALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>     <a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span><a href="pg_config_manual.h.html#LN236"><span class='Ref_to_Const'>PG_CACHE_LINE_SIZE</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN590"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
 
<a name="LN592"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>TYPEALIGN_DOWN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ALIGNVAL</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>  <span class='Operator'>\ 
</span>    <span class='Parentheses'>(((</span>uintptr_t<span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="c.h.html#LN592"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> <span class='Operator'>& ~</span><span class='Parentheses'>((</span>uintptr_t<span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="c.h.html#LN592"><span class='Ref_to_Parameter'>ALIGNVAL</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)))</span> 
 
<a name="LN595"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SHORTALIGN_DOWN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>    <a href="c.h.html#LN592"><span class='Ref_to_Macro'>TYPEALIGN_DOWN</span></a><span class='Parentheses'>(</span>ALIGNOF_SHORT<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN595"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN596"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>INTALIGN_DOWN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>      <a href="c.h.html#LN592"><span class='Ref_to_Macro'>TYPEALIGN_DOWN</span></a><span class='Parentheses'>(</span>ALIGNOF_INT<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN596"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN597"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LONGALIGN_DOWN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>     <a href="c.h.html#LN592"><span class='Ref_to_Macro'>TYPEALIGN_DOWN</span></a><span class='Parentheses'>(</span>ALIGNOF_LONG<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN597"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN598"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>DOUBLEALIGN_DOWN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>   <a href="c.h.html#LN592"><span class='Ref_to_Macro'>TYPEALIGN_DOWN</span></a><span class='Parentheses'>(</span>ALIGNOF_DOUBLE<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN598"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
<a name="LN599"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>MAXALIGN_DOWN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>      <a href="c.h.html#LN592"><span class='Ref_to_Macro'>TYPEALIGN_DOWN</span></a><span class='Parentheses'>(</span>MAXIMUM_ALIGNOF<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN599"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The above macros will not work with types wider than uintptr_t, like with 
 * uint64 on 32-bit platforms.  That's not problem for the usual use where a 
 * pointer or a length is aligned, but for the odd case that you need to 
 * align something (potentially) wider, use TYPEALIGN64. 
 */ 
</span><a name="LN607"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>TYPEALIGN64</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ALIGNVAL</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>  <span class='Operator'>\ 
</span>    <span class='Parentheses'>(((</span><a href="c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="c.h.html#LN607"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>)</span> <span class='Operator'>+ </span><span class='Parentheses'>((</span><a href="c.h.html#LN607"><span class='Ref_to_Parameter'>ALIGNVAL</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> <span class='Operator'>& ~</span><span class='Parentheses'>((</span><a href="c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="c.h.html#LN607"><span class='Ref_to_Parameter'>ALIGNVAL</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)))</span> 
 
<span class='Comment_Multi_Line'>/* we don't currently need wider versions of the other ALIGN macros */ 
</span><a name="LN611"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>MAXALIGN64</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>LEN</span><span class='Parentheses'>)</span>         <a href="c.h.html#LN607"><span class='Ref_to_Macro'>TYPEALIGN64</span></a><span class='Parentheses'>(</span>MAXIMUM_ALIGNOF<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN611"><span class='Ref_to_Parameter'>LEN</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 * Attribute macros 
 * 
 * GCC: https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html 
 * GCC: https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html 
 * Sunpro: https://docs.oracle.com/cd/E18659_01/html/821-1384/gjzke.html 
 * XLC: http://www-01.ibm.com/support/knowledgecenter/SSGH2K_11.1.0/com.ibm.xlc111.aix.doc/language_ref/function_attributes.html 
 * XLC: http://www-01.ibm.com/support/knowledgecenter/SSGH2K_11.1.0/com.ibm.xlc111.aix.doc/language_ref/type_attrib.html 
 * ---------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* only GCC supports the unused attribute */ 
</span><span class='Directive'>#ifdef</span> __GNUC__ 
<a name="LN626"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_unused</span><span class='Parentheses'>() </span>__attribute__<span class='Parentheses'>((</span>unused<span class='Parentheses'>))</span> 
<span class='Directive'>#else</span> 
<a name="LN628"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_unused</span><span class='Parentheses'>() 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* GCC and XLC support format attributes */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>__GNUC__<span class='Parentheses'>) </span><span class='Operator'>|| </span>defined<span class='Parentheses'>(</span>__IBMC__<span class='Parentheses'>) 
</span><a name="LN633"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_format_arg</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>a</span><span class='Parentheses'>) </span>__attribute__<span class='Parentheses'>((</span>format_arg<span class='Parentheses'>(</span><a href="c.h.html#LN633"><span class='Ref_to_Parameter'>a</span></a><span class='Parentheses'>)))</span> 
<a name="LN634"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_printf</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>f</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>a</span><span class='Parentheses'>) </span>__attribute__<span class='Parentheses'>((</span><a href="../bin/pg_basebackup/pg_basebackup.c.html#LN79"><span class='Ref_to_Global_Var'>format</span></a><span class='Parentheses'>(</span>PG_PRINTF_ATTRIBUTE<span class='Delimiter'>, </span><a href="c.h.html#LN634"><span class='Ref_to_Parameter'>f</span></a><span class='Delimiter'>, </span><a href="c.h.html#LN634"><span class='Ref_to_Parameter'>a</span></a><span class='Parentheses'>)))</span> 
<span class='Directive'>#else</span> 
<a name="LN636"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_format_arg</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>a</span><span class='Parentheses'>) 
</span><a name="LN637"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_printf</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>f</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>a</span><span class='Parentheses'>) 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* GCC, Sunpro and XLC support aligned, packed and noreturn */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>__GNUC__<span class='Parentheses'>) </span><span class='Operator'>|| </span>defined<span class='Parentheses'>(</span>__SUNPRO_C<span class='Parentheses'>) </span><span class='Operator'>|| </span>defined<span class='Parentheses'>(</span>__IBMC__<span class='Parentheses'>) 
</span><a name="LN642"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_aligned</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>a</span><span class='Parentheses'>) </span>__attribute__<span class='Parentheses'>((</span>aligned<span class='Parentheses'>(</span><a href="c.h.html#LN642"><span class='Ref_to_Parameter'>a</span></a><span class='Parentheses'>)))</span> 
<a name="LN643"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_noreturn</span><span class='Parentheses'>() </span>__attribute__<span class='Parentheses'>((</span>noreturn<span class='Parentheses'>))</span> 
<a name="LN644"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_packed</span><span class='Parentheses'>() </span>__attribute__<span class='Parentheses'>((</span>packed<span class='Parentheses'>))</span> 
<a name="LN645"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HAVE_PG_ATTRIBUTE_NORETURN</span> <span class='Number'>1</span> 
<span class='Directive'>#else</span> 
<span class='Comment_Multi_Line'>/* 
 * NB: aligned and packed are not given default definitions because they 
 * affect code functionality; they *must* be implemented by the compiler 
 * if they are to be used. 
 */ 
</span><a name="LN652"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_attribute_noreturn</span><span class='Parentheses'>() 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 6:  assertions 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * USE_ASSERT_CHECKING, if defined, turns on all the assertions. 
 * - plai  9/5/90 
 * 
 * It should _NOT_ be defined in releases or in benchmark copies 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Assert() can be used in both frontend and backend code. In frontend code it 
 * just calls the standard assert, if it's available. If use of assertions is 
 * not configured, it does nothing. 
 */ 
</span><span class='Directive'>#ifndef</span> USE_ASSERT_CHECKING 
 
<a name="LN674"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Assert</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
<a name="LN675"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertMacro</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
<a name="LN676"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertArg</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>)</span>    <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
<a name="LN677"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertState</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
<a name="LN678"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertPointerAlignment</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ptr</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>bndr</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
<a name="LN679"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Trap</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errorType</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
<a name="LN680"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>TrapMacro</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errorType</span><span class='Parentheses'>) (</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span> 
<span class='Directive'>#elif</span> defined<span class='Parentheses'>(</span><a href="../bin/pg_waldump/rmgrdesc.c.html#LN7"><span class='Ref_to_Const'>FRONTEND</span></a><span class='Parentheses'>) 
</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;assert.h&GT;</span> 
<a name="LN685"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Assert</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>p</span><span class='Parentheses'>) </span><span class='Debug'>assert</span><span class='Parentheses'>(</span><a href="c.h.html#LN685"><span class='Ref_to_Parameter'>p</span></a><span class='Parentheses'>) 
</span><a name="LN686"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertMacro</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>p</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Debug'>assert</span><span class='Parentheses'>(</span><a href="c.h.html#LN686"><span class='Ref_to_Parameter'>p</span></a><span class='Parentheses'>))</span> 
<a name="LN687"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertArg</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>) </span><span class='Debug'>assert</span><span class='Parentheses'>(</span><a href="c.h.html#LN687"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>) 
</span><a name="LN688"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertState</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>) </span><span class='Debug'>assert</span><span class='Parentheses'>(</span><a href="c.h.html#LN688"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>) 
</span><a name="LN689"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertPointerAlignment</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ptr</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>bndr</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Boolean'>true</span><span class='Parentheses'>)</span> 
<span class='Directive'>#else</span>                           <span class='Comment_Single_Line'>/* USE_ASSERT_CHECKING && !FRONTEND */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Trap 
 *      Generates an exception if the given condition is true. 
 */ 
</span><a name="LN696"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Trap</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errorType</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="c.h.html#LN696"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>            <a href="../backend/utils/error/assert.c.html#LN24"><span class='Ref_to_Func'>ExceptionalCondition</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN696"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN696"><span class='Ref_to_Parameter'>errorType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                                 __FILE__<span class='Delimiter'>, </span>__LINE__<span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  TrapMacro is the same as Trap but it's intended for use in macros: 
 * 
 *      #define foo(x) (AssertMacro(x != 0), bar(x)) 
 * 
 *  Isn't CPP fun? 
 */ 
</span><a name="LN710"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>TrapMacro</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errorType</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><span class='Keyword'>bool</span><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><span class='Operator'>! </span><span class='Parentheses'>(</span><a href="c.h.html#LN710"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| \ 
</span>             <span class='Parentheses'>(</span><a href="../backend/utils/error/assert.c.html#LN24"><span class='Ref_to_Func'>ExceptionalCondition</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN710"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN710"><span class='Ref_to_Parameter'>errorType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                                   __FILE__<span class='Delimiter'>, </span>__LINE__<span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)))</span> 
 
<a name="LN715"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Assert</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>        <a href="c.h.html#LN679"><span class='Ref_to_Macro'>Trap</span></a><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="c.h.html#LN715"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"FailedAssertion"</span><span class='Parentheses'>)</span> 
 
<a name="LN718"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertMacro</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>        <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span> <a href="c.h.html#LN680"><span class='Ref_to_Macro'>TrapMacro</span></a><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="c.h.html#LN718"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"FailedAssertion"</span><span class='Parentheses'>))</span> 
 
<a name="LN721"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertArg</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>        <a href="c.h.html#LN679"><span class='Ref_to_Macro'>Trap</span></a><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="c.h.html#LN721"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"BadArgument"</span><span class='Parentheses'>)</span> 
 
<a name="LN724"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertState</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>        <a href="c.h.html#LN679"><span class='Ref_to_Macro'>Trap</span></a><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="c.h.html#LN724"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"BadState"</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check that `ptr' is `bndr' aligned. 
 */ 
</span><a name="LN730"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertPointerAlignment</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ptr</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>bndr</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <a href="c.h.html#LN679"><span class='Ref_to_Macro'>Trap</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN730"><span class='Ref_to_Parameter'>bndr</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span>uintptr_t<span class='Parentheses'>)(</span><a href="c.h.html#LN730"><span class='Ref_to_Parameter'>ptr</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Parentheses'>(</span>uintptr_t<span class='Parentheses'>)(</span><a href="c.h.html#LN730"><span class='Ref_to_Parameter'>ptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>         <span class='String'>"UnalignedPointer"</span><span class='Parentheses'>)</span> 
 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* USE_ASSERT_CHECKING && !FRONTEND */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Macros to support compile-time assertion checks. 
 * 
 * If the "condition" (a compile-time-constant expression) evaluates to false, 
 * throw a compile error using the "errmessage" (a string literal). 
 * 
 * gcc 4.6 and up supports _Static_assert(), but there are bizarre syntactic 
 * placement restrictions.  These macros make it safe to use as a statement 
 * or in an expression, respectively. 
 * 
 * Otherwise we fall back on a kluge that assumes the compiler will complain 
 * about a negative width for a struct bit-field.  This will not include a 
 * helpful error message, but it beats not getting an error at all. 
 */ 
</span><span class='Directive'>#ifdef</span> HAVE__STATIC_ASSERT 
<a name="LN751"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>StaticAssertStmt</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errmessage</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span>_Static_assert<span class='Parentheses'>(</span><a href="c.h.html#LN751"><span class='Ref_to_Parameter'>condition</span></a><span class='Delimiter'>, </span><a href="c.h.html#LN751"><span class='Ref_to_Parameter'>errmessage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; } </span><span class='Control'>while</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span><a name="LN753"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>StaticAssertExpr</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errmessage</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><span class='Delimiter'>{ </span><a href="c.h.html#LN751"><span class='Ref_to_Macro'>StaticAssertStmt</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN753"><span class='Ref_to_Parameter'>condition</span></a><span class='Delimiter'>, </span><a href="c.h.html#LN753"><span class='Ref_to_Parameter'>errmessage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Boolean'>true</span><span class='Delimiter'>; }</span><span class='Parentheses'>)</span> 
<span class='Directive'>#else</span>                           <span class='Comment_Single_Line'>/* !HAVE__STATIC_ASSERT */ 
</span><a name="LN756"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>StaticAssertStmt</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errmessage</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span> <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Control'>struct</span> <span class='Delimiter'>{ </span><span class='Keyword'>int </span>static_assert_failure <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="c.h.html#LN756"><span class='Ref_to_Parameter'>condition</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: -</span><span class='Number'>1</span><span class='Delimiter'>; }</span><span class='Parentheses'>))</span> 
<a name="LN758"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>StaticAssertExpr</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>condition</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>errmessage</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <a href="c.h.html#LN751"><span class='Ref_to_Macro'>StaticAssertStmt</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN758"><span class='Ref_to_Parameter'>condition</span></a><span class='Delimiter'>, </span><a href="c.h.html#LN758"><span class='Ref_to_Parameter'>errmessage</span></a><span class='Parentheses'>) 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* HAVE__STATIC_ASSERT */ 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compile-time checks that a variable (or expression) has the specified type. 
 * 
 * AssertVariableIsOfType() can be used as a statement. 
 * AssertVariableIsOfTypeMacro() is intended for use in macros, eg 
 *      #define foo(x) (AssertVariableIsOfTypeMacro(x, int), bar(x)) 
 * 
 * If we don't have __builtin_types_compatible_p, we can still assert that 
 * the types have the same size.  This is far from ideal (especially on 32-bit 
 * platforms) but it provides at least some coverage. 
 */ 
</span><span class='Directive'>#ifdef</span> HAVE__BUILTIN_TYPES_COMPATIBLE_P 
<a name="LN775"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertVariableIsOfType</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>varname</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>typename</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <a href="c.h.html#LN751"><span class='Ref_to_Macro'>StaticAssertStmt</span></a><span class='Parentheses'>(</span>__builtin_types_compatible_p<span class='Parentheses'>(</span>__typeof__<span class='Parentheses'>(</span><a href="c.h.html#LN775"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>typename</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>    <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN775"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>)</span> <span class='String'>" does not have type "</span> <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><span class='Keyword'>typename</span><span class='Parentheses'>))</span> 
<a name="LN778"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertVariableIsOfTypeMacro</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>varname</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>typename</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span> <a href="c.h.html#LN753"><span class='Ref_to_Macro'>StaticAssertExpr</span></a><span class='Parentheses'>(</span>__builtin_types_compatible_p<span class='Parentheses'>(</span>__typeof__<span class='Parentheses'>(</span><a href="c.h.html#LN778"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>typename</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN778"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>)</span> <span class='String'>" does not have type "</span> <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><span class='Keyword'>typename</span><span class='Parentheses'>)))</span> 
<span class='Directive'>#else</span>                           <span class='Comment_Single_Line'>/* !HAVE__BUILTIN_TYPES_COMPATIBLE_P */ 
</span><a name="LN782"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertVariableIsOfType</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>varname</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>typename</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <a href="c.h.html#LN751"><span class='Ref_to_Macro'>StaticAssertStmt</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="c.h.html#LN782"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>typename</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>    <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN782"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>) </span><span class='String'>" does not have type "</span> <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><span class='Keyword'>typename</span><span class='Parentheses'>))</span> 
<a name="LN785"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>AssertVariableIsOfTypeMacro</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>varname</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>typename</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>)</span> <a href="c.h.html#LN753"><span class='Ref_to_Macro'>StaticAssertExpr</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="c.h.html#LN785"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>typename</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>       <span class='Operator'>\ 
</span>     <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><a href="c.h.html#LN785"><span class='Ref_to_Parameter'>varname</span></a><span class='Parentheses'>) </span><span class='String'>" does not have type "</span> <a href="c.h.html#LN160"><span class='Ref_to_Macro'>CppAsString</span></a><span class='Parentheses'>(</span><span class='Keyword'>typename</span><span class='Parentheses'>)))</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* HAVE__BUILTIN_TYPES_COMPATIBLE_P */ 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 7:  widely useful macros 
 * ---------------------------------------------------------------- 
 */ 
/* 
 * Max 
 *      Return the maximum of two numbers. 
 */ 
</span><a name="LN799"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Max</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>y</span><span class='Parentheses'>)</span>       <span class='Parentheses'>((</span><a href="c.h.html#LN799"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Parentheses'>(</span><a href="c.h.html#LN799"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Parentheses'>(</span><a href="c.h.html#LN799"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Parentheses'>(</span><a href="c.h.html#LN799"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Min 
 *      Return the minimum of two numbers. 
 */ 
</span><a name="LN805"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Min</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>y</span><span class='Parentheses'>)</span>       <span class='Parentheses'>((</span><a href="c.h.html#LN805"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="c.h.html#LN805"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Parentheses'>(</span><a href="c.h.html#LN805"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Parentheses'>(</span><a href="c.h.html#LN805"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Abs 
 *      Return the absolute value of the argument. 
 */ 
</span><a name="LN811"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>Abs</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>          <span class='Parentheses'>((</span><a href="c.h.html#LN811"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="c.h.html#LN811"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>: -</span><span class='Parentheses'>(</span><a href="c.h.html#LN811"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * StrNCpy 
 *  Like standard library function strncpy(), except that result string 
 *  is guaranteed to be null-terminated --- that is, at most N-1 bytes 
 *  of the source string will be kept. 
 *  Also, the macro returns no result (too hard to do that without 
 *  evaluating the arguments multiple times, which seems worse). 
 * 
 *  BTW: when you need to copy a non-null-terminated string (like a text 
 *  datum) and add a null, do not do it with StrNCpy(..., len+1).  That 
 *  might seem to work, but it fetches one byte more than there is in the 
 *  text object.  One fine day you'll have a SIGSEGV because there isn't 
 *  another byte before the end of memory.  Don't laugh, we've had real 
 *  live bug reports from real live users over exactly this mistake. 
 *  Do it honestly with "memcpy(dst,src,len); dst[len] = '\0';", instead. 
 */ 
</span><a name="LN829"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>StrNCpy</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>dst</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>src</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Operator'>\ 
</span>    <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Keyword'>char </span><span class='Operator'>* </span>_dst <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="c.h.html#LN829"><span class='Ref_to_Parameter'>dst</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <a href="c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> _len <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="c.h.html#LN829"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>_len <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>        <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>            strncpy<span class='Parentheses'>(</span>_dst<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="c.h.html#LN829"><span class='Ref_to_Parameter'>src</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span>_len<span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>            _dst<span class='Delimiter'>[</span>_len<span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Delimiter'>} </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
 
<span class='Comment_Multi_Line'>/* Get a bit mask of the bits set in non-long aligned addresses */ 
</span><a name="LN844"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>LONG_ALIGN_MASK</span> <span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * MemSet 
 *  Exactly the same as standard library function memset(), but considerably 
 *  faster for zeroing small word-aligned structures (such as parsetree nodes). 
 *  This has to be a macro because the main point is to avoid function-call 
 *  overhead.   However, we have also found that the loop is faster than 
 *  native libc memset() on some platforms, even those with assembler 
 *  memset() functions.  More research needs to be done, perhaps with 
 *  MEMSET_LOOP_LIMIT tests in configure. 
 */ 
</span><a name="LN856"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>MemSet</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>start</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>val</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Operator'>\ 
</span>    <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Comment_Multi_Line'>/* must be void* because we don't know if it is integer aligned yet */ </span><span class='Operator'>\ 
</span>        <span class='Keyword'>void</span>   <span class='Operator'>*</span>_vstart <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="c.h.html#LN856"><span class='Ref_to_Parameter'>start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Keyword'>int</span>     _val <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="c.h.html#LN856"><span class='Ref_to_Parameter'>val</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <a href="c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>    _len <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="c.h.html#LN856"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((((</span>uintptr_t<span class='Parentheses'>) </span>_vstart<span class='Parentheses'>)</span> <span class='Operator'>& </span><a href="c.h.html#LN844"><span class='Ref_to_Const'>LONG_ALIGN_MASK</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& \ 
</span>            <span class='Parentheses'>(</span>_len <span class='Operator'>& </span><a href="c.h.html#LN844"><span class='Ref_to_Const'>LONG_ALIGN_MASK</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& \ 
</span>            _val <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& \ 
</span>            _len <span class='Operator'>&LT;= </span>MEMSET_LOOP_LIMIT <span class='Operator'>&& \ 
</span>            <span class='Comment_Multi_Line'>/* \ 
             *  If MEMSET_LOOP_LIMIT == 0, optimizer should find \ 
             *  the whole "if" false at compile time. \ 
             */ </span><span class='Operator'>\ 
</span>            MEMSET_LOOP_LIMIT <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> <span class='Operator'>\ 
</span>        <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>            <span class='Keyword'>long </span><span class='Operator'>*</span>_start <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long </span><span class='Operator'>*</span><span class='Parentheses'>) </span>_vstart<span class='Delimiter'>; </span><span class='Operator'>\ 
</span>            <span class='Keyword'>long </span><span class='Operator'>*</span>_stop <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long </span><span class='Operator'>*</span><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span>_start <span class='Operator'>+ </span>_len<span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span>_start <span class='Operator'>&LT; </span>_stop<span class='Parentheses'>) </span><span class='Operator'>\ 
</span>                <span class='Operator'>*</span>_start<span class='Operator'>++ = </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Delimiter'>} </span><span class='Operator'>\ 
</span>        <span class='Control'>else</span> <span class='Operator'>\ 
</span>            memset<span class='Parentheses'>(</span>_vstart<span class='Delimiter'>, </span>_val<span class='Delimiter'>, </span>_len<span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end MemSet &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * MemSetAligned is the same as MemSet except it omits the test to see if 
 * "start" is word-aligned.  This is okay to use if the caller knows a-priori 
 * that the pointer is suitably aligned (typically, because he just got it 
 * from palloc(), which always delivers a max-aligned pointer). 
 */ 
</span><a name="LN889"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>MemSetAligned</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>start</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>val</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Operator'>\ 
</span>    <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Keyword'>long</span>   <span class='Operator'>*</span>_start <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="c.h.html#LN889"><span class='Ref_to_Parameter'>start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Keyword'>int</span>     _val <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="c.h.html#LN889"><span class='Ref_to_Parameter'>val</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <a href="c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>    _len <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="c.h.html#LN889"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span>_len <span class='Operator'>& </span><a href="c.h.html#LN844"><span class='Ref_to_Const'>LONG_ALIGN_MASK</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& \ 
</span>            _val <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& \ 
</span>            _len <span class='Operator'>&LT;= </span>MEMSET_LOOP_LIMIT <span class='Operator'>&& \ 
</span>            MEMSET_LOOP_LIMIT <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> <span class='Operator'>\ 
</span>        <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>            <span class='Keyword'>long </span><span class='Operator'>*</span>_stop <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long </span><span class='Operator'>*</span><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span>_start <span class='Operator'>+ </span>_len<span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span>_start <span class='Operator'>&LT; </span>_stop<span class='Parentheses'>) </span><span class='Operator'>\ 
</span>                <span class='Operator'>*</span>_start<span class='Operator'>++ = </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Delimiter'>} </span><span class='Operator'>\ 
</span>        <span class='Control'>else</span> <span class='Operator'>\ 
</span>            memset<span class='Parentheses'>(</span>_start<span class='Delimiter'>, </span>_val<span class='Delimiter'>, </span>_len<span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * MemSetTest/MemSetLoop are a variant version that allow all the tests in 
 * MemSet to be done at compile time in cases where "val" and "len" are 
 * constants *and* we know the "start" pointer must be word-aligned. 
 * If MemSetTest succeeds, then it is okay to use MemSetLoop, otherwise use 
 * MemSetAligned.  Beware of multiple evaluations of the arguments when using 
 * this approach. 
 */ 
</span><a name="LN918"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>MemSetTest</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>val</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span> <span class='Parentheses'>((</span><a href="c.h.html#LN918"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="c.h.html#LN844"><span class='Ref_to_Const'>LONG_ALIGN_MASK</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& \ 
</span>    <span class='Parentheses'>(</span><a href="c.h.html#LN918"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>)</span> <span class='Operator'>&LT;= </span>MEMSET_LOOP_LIMIT <span class='Operator'>&& \ 
</span>    MEMSET_LOOP_LIMIT <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& \ 
</span>    <span class='Parentheses'>(</span><a href="c.h.html#LN918"><span class='Ref_to_Parameter'>val</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Parentheses'>)</span> 
 
<a name="LN924"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>MemSetLoop</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>start</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>val</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>len</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Operator'>\ 
</span>    <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Keyword'>long </span><span class='Operator'>* </span>_start <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="c.h.html#LN924"><span class='Ref_to_Parameter'>start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Keyword'>long </span><span class='Operator'>* </span>_stop <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long </span><span class='Operator'>*</span><span class='Parentheses'>) ((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span>_start <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) (</span><a href="c.h.html#LN924"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Operator'>\ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span>_start <span class='Operator'>&LT; </span>_stop<span class='Parentheses'>) </span><span class='Operator'>\ 
</span>            <span class='Operator'>*</span>_start<span class='Operator'>++ = </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Mark a point as unreachable in a portable fashion.  This should preferably 
 * be something that the compiler understands, to aid code generation. 
 * In assert-enabled builds, we prefer abort() for debugging reasons. 
 */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>HAVE__BUILTIN_UNREACHABLE<span class='Parentheses'>) </span><span class='Operator'>&& !</span>defined<span class='Parentheses'>(</span>USE_ASSERT_CHECKING<span class='Parentheses'>) 
</span><a name="LN941"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_unreachable</span><span class='Parentheses'>() </span>__builtin_unreachable<span class='Parentheses'>() 
</span><span class='Directive'>#elif</span> defined<span class='Parentheses'>(</span>_MSC_VER<span class='Parentheses'>) </span><span class='Operator'>&& !</span>defined<span class='Parentheses'>(</span>USE_ASSERT_CHECKING<span class='Parentheses'>) 
</span><a name="LN943"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_unreachable</span><span class='Parentheses'>() </span>__assume<span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span><span class='Directive'>#else</span> 
<a name="LN945"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>pg_unreachable</span><span class='Parentheses'>() </span>abort<span class='Parentheses'>() 
</span><span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Hints to the compiler about the likelihood of a branch. Both likely() and 
 * unlikely() return the boolean value of the contained expression. 
 * 
 * These should only be used sparingly, in very hot code paths. It's very easy 
 * to mis-estimate likelihoods. 
 */ 
</span><span class='Directive'>#if</span> __GNUC__ <span class='Operator'>&GT;= </span><span class='Number'>3</span> 
<a name="LN957"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>likely</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>   __builtin_expect<span class='Parentheses'>((</span><a href="c.h.html#LN957"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
<a name="LN958"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>unlikely</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) </span>__builtin_expect<span class='Parentheses'>((</span><a href="c.h.html#LN958"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<span class='Directive'>#else</span> 
<a name="LN960"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>likely</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><a href="c.h.html#LN960"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN961"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>unlikely</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>) ((</span><a href="c.h.html#LN961"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 8:  random stuff 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* msb for char */ 
</span><a name="LN971"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HIGHBIT</span>                 <span class='Parentheses'>(</span><span class='Number'>0x80</span><span class='Parentheses'>) 
</span><a name="LN972"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_HIGHBIT_SET</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>ch</span><span class='Parentheses'>)</span>      <span class='Parentheses'>((</span><span class='Keyword'>unsigned char</span><span class='Parentheses'>)(</span><a href="c.h.html#LN972"><span class='Ref_to_Parameter'>ch</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="c.h.html#LN971"><span class='Ref_to_Const'>HIGHBIT</span></a><span class='Parentheses'>)</span> 
 
<a name="LN974"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>STATUS_OK</span>               <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span><a name="LN975"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>STATUS_ERROR</span>            <span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN976"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>STATUS_EOF</span>              <span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>2</span><span class='Parentheses'>) 
</span><a name="LN977"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>STATUS_FOUND</span>            <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN978"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>STATUS_WAITING</span>          <span class='Parentheses'>(</span><span class='Number'>2</span><span class='Parentheses'>) 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Append PG_USED_FOR_ASSERTS_ONLY to definitions of variables that are only 
 * used in assert-enabled builds, to avoid compiler warnings about unused 
 * variables in assert-disabled builds. 
 */ 
</span><span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
<a name="LN987"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_USED_FOR_ASSERTS_ONLY</span> 
<span class='Directive'>#else</span> 
<a name="LN989"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_USED_FOR_ASSERTS_ONLY</span> <a href="../backend/commands/collationcmds.c.html#LN352"><span class='Ref_to_Func'>pg_attribute_unused</span></a><span class='Parentheses'>() 
</span><span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* gettext domain name mangling */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * To better support parallel installations of major PostgreSQL 
 * versions as well as parallel installations of major library soname 
 * versions, we mangle the gettext domain name by appending those 
 * version numbers.  The coding rule ought to be that wherever the 
 * domain name is mentioned as a literal, it must be wrapped into 
 * PG_TEXTDOMAIN().  The macros below do not work on non-literals; but 
 * that is somewhat intentional because it avoids having to worry 
 * about multiple states of premangling and postmangling as the values 
 * are being passed around. 
 * 
 * Make sure this matches the installation rules in nls-global.mk. 
 */ 
</span><span class='Directive'>#ifdef</span> SO_MAJOR_VERSION 
<a name="LN1009"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PG_TEXTDOMAIN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>domain</span><span class='Parentheses'>) (</span><a href="c.h.html#LN1009"><span class='Ref_to_Parameter'>domain</span></a> <a href="c.h.html#LN161"><span class='Ref_to_Macro'>CppAsString2</span></a><span class='Parentheses'>(</span>SO_MAJOR_VERSION<span class='Parentheses'>) </span><span class='String'>"-"</span> PG_MAJORVERSION<span class='Parentheses'>)</span> 
<span class='Directive'>#else</span> 
<a name="LN1011"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PG_TEXTDOMAIN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>domain</span><span class='Parentheses'>) (</span><a href="c.h.html#LN1011"><span class='Ref_to_Parameter'>domain</span></a> <span class='String'>"-"</span> PG_MAJORVERSION<span class='Parentheses'>) 
</span><span class='Directive'>#endif</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *              Section 9: system-specific hacks 
 * 
 *      This should be limited to things that absolutely have to be 
 *      included in every source file.  The port-specific header file 
 *      is usually a better place for this sort of thing. 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  NOTE:  this is also used for opening text files. 
 *  WIN32 treats Control-Z as EOF in files opened in text mode. 
 *  Therefore, we open files in binary mode on Win32 so we can read 
 *  literal control-Z.  The other affect is that we see CRLF, but 
 *  that is OK because we can already handle those cleanly. 
 */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span><a href="c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span>defined<span class='Parentheses'>(</span>__CYGWIN__<span class='Parentheses'>) 
</span><a name="LN1032"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY</span>   O_BINARY 
<a name="LN1033"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY_A</span> <span class='String'>"ab"</span> 
<a name="LN1034"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY_R</span> <span class='String'>"rb"</span> 
<a name="LN1035"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY_W</span> <span class='String'>"wb"</span> 
<span class='Directive'>#else</span> 
<a name="LN1037"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY</span>   <span class='Number'>0</span> 
<a name="LN1038"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY_A</span> <span class='String'>"a"</span> 
<a name="LN1039"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY_R</span> <span class='String'>"r"</span> 
<a name="LN1040"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PG_BINARY_W</span> <span class='String'>"w"</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Provide prototypes for routines not present in a particular machine's 
 * standard C library. 
 */ 
</span> 
<span class='Directive'>#if</span> <span class='Operator'>!</span>HAVE_DECL_SNPRINTF 
<a name="LN1049"></a><span class='Keyword'>extern int</span>  <a href="../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><a href="../test/isolation/specparse.y.html#LN26"><span class='Ref_to_Global_Var'>str</span></a><span class='Delimiter'>, </span>size_t count<span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span>fmt<span class='Delimiter'>,</span><span class='Operator'>...</span><span class='Parentheses'>) </span><span class='Declare_Var'>pg_attribute_printf</span><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#if</span> <span class='Operator'>!</span>HAVE_DECL_VSNPRINTF 
<a name="LN1053"></a><span class='Keyword'>extern int</span>  <span class='Declare_Prototype'>vsnprintf</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>str</span><span class='Delimiter'>, </span>size_t <span class='Declare_Parameter'>count</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>fmt</span><span class='Delimiter'>, </span>va_list <span class='Declare_Parameter'>args</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#if</span> <span class='Operator'>!</span>defined<span class='Parentheses'>(</span>HAVE_MEMMOVE<span class='Parentheses'>) </span><span class='Operator'>&& !</span>defined<span class='Parentheses'>(</span><a href="c.h.html#LN1057"><span class='Ref_to_Macro'>memmove</span></a><span class='Parentheses'>) 
</span><a name="LN1057"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>memmove</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>d</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>s</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>c</span><span class='Parentheses'>)</span>        bcopy<span class='Parentheses'>(</span><a href="c.h.html#LN1057"><span class='Ref_to_Parameter'>s</span></a><span class='Delimiter'>, </span><a href="c.h.html#LN1057"><span class='Ref_to_Parameter'>d</span></a><span class='Delimiter'>, </span><a href="c.h.html#LN1057"><span class='Ref_to_Parameter'>c</span></a><span class='Parentheses'>) 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* no special DLL markers on most ports */ 
</span><span class='Directive'>#ifndef</span> <a href="../interfaces/ecpg/include/sqlca.h.html#LN5"><span class='Ref_to_Const'>PGDLLIMPORT</span></a> 
<a name="LN1062"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PGDLLIMPORT</span> 
<span class='Directive'>#endif</span> 
<span class='Directive'>#ifndef</span> <a href="port/cygwin.h.html#LN17"><span class='Ref_to_Const'>PGDLLEXPORT</span></a> 
<a name="LN1065"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PGDLLEXPORT</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The following is used as the arg list for signal handlers.  Any ports 
 * that take something other than an int argument should override this in 
 * their pg_config_os.h file.  Note that variable names are required 
 * because it is used in both the prototypes as well as the definitions. 
 * Note also the long name.  We expect that this won't collide with 
 * other names causing compiler warnings. 
 */ 
</span> 
<span class='Directive'>#ifndef</span> <a href="c.h.html#LN1078"><span class='Ref_to_Const'>SIGNAL_ARGS</span></a> 
<a name="LN1078"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SIGNAL_ARGS</span>  <span class='Keyword'>int </span>postgres_signal_arg 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * When there is no sigsetjmp, its functionality is provided by plain 
 * setjmp. Incidentally, nothing provides setjmp's functionality in 
 * that case.  We now support the case only on Windows. 
 */ 
</span><span class='Directive'>#ifdef</span> <a href="c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a> 
<a name="LN1087"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>sigjmp_buf</span> jmp_buf 
<a name="LN1088"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>sigsetjmp</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>y</span><span class='Parentheses'>) </span>setjmp<span class='Parentheses'>(</span><a href="c.h.html#LN1088"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) 
</span><a name="LN1089"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>siglongjmp</span> longjmp 
<span class='Directive'>#endif</span> 
 
<span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>HAVE_FDATASYNC<span class='Parentheses'>) </span><span class='Operator'>&& !</span>HAVE_DECL_FDATASYNC 
<a name="LN1093"></a><span class='Keyword'>extern int</span>  <span class='Declare_Prototype'>fdatasync</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>fildes</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* If strtoq() exists, rename it to the more standard strtoll() */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>HAVE_LONG_LONG_INT_64<span class='Parentheses'>) </span><span class='Operator'>&& !</span>defined<span class='Parentheses'>(</span><a href="c.h.html#LN1099"><span class='Ref_to_Const'>HAVE_STRTOLL</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span>defined<span class='Parentheses'>(</span>HAVE_STRTOQ<span class='Parentheses'>) 
</span><a name="LN1098"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>strtoll</span> strtoq 
<a name="LN1099"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HAVE_STRTOLL</span> <span class='Number'>1</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* If strtouq() exists, rename it to the more standard strtoull() */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>HAVE_LONG_LONG_INT_64<span class='Parentheses'>) </span><span class='Operator'>&& !</span>defined<span class='Parentheses'>(</span><a href="c.h.html#LN1105"><span class='Ref_to_Const'>HAVE_STRTOULL</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span>defined<span class='Parentheses'>(</span>HAVE_STRTOUQ<span class='Parentheses'>) 
</span><a name="LN1104"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>strtoull</span> strtouq 
<a name="LN1105"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>HAVE_STRTOULL</span> <span class='Number'>1</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * We assume if we have these two functions, we have their friends too, and 
 * can use the wide-character functions. 
 */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>HAVE_WCSTOMBS<span class='Parentheses'>) </span><span class='Operator'>&& </span>defined<span class='Parentheses'>(</span>HAVE_TOWLOWER<span class='Parentheses'>) 
</span><a name="LN1113"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>USE_WIDE_UPPER_LOWER</span> 
<span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* EXEC_BACKEND defines */ 
</span><span class='Directive'>#ifdef</span> EXEC_BACKEND 
<a name="LN1118"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>NON_EXEC_STATIC</span> 
<span class='Directive'>#else</span> 
<a name="LN1120"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>NON_EXEC_STATIC</span> <span class='Keyword'>static 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* /port compatibility functions */ 
</span><span class='Keyword'>#include </span><span class='String'>"port.h"</span> 
 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* C_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>