<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\lib\ilist.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\lib\ilist.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:07 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * ilist.h 
 *      integrated/inline doubly- and singly-linked lists 
 * 
 * These list types are useful when there are only a predetermined set of 
 * lists that an object could be in.  List links are embedded directly into 
 * the objects, and thus no extra memory management overhead is required. 
 * (Of course, if only a small proportion of existing objects are in a list, 
 * the link fields in the remainder would be wasted space.  But usually, 
 * it saves space to not have separately-allocated list nodes.) 
 * 
 * None of the functions here allocate any memory; they just manipulate 
 * externally managed memory.  The APIs for singly and doubly linked lists 
 * are identical as far as capabilities of both allow. 
 * 
 * Each list has a list header, which exists even when the list is empty. 
 * An empty singly-linked list has a NULL pointer in its header. 
 * There are two kinds of empty doubly linked lists: those that have been 
 * initialized to NULL, and those that have been initialized to circularity. 
 * (If a dlist is modified and then all its elements are deleted, it will be 
 * in the circular state.)  We prefer circular dlists because there are some 
 * operations that can be done without branches (and thus faster) on lists 
 * that use circular representation.  However, it is often convenient to 
 * initialize list headers to zeroes rather than setting them up with an 
 * explicit initialization function, so we also allow the other case. 
 * 
 * EXAMPLES 
 * 
 * Here's a simple example demonstrating how this can be used.  Let's assume 
 * we want to store information about the tables contained in a database. 
 * 
 * #include "lib/ilist.h" 
 * 
 * // Define struct for the databases including a list header that will be 
 * // used to access the nodes in the table list later on. 
 * typedef struct my_database 
 * { 
 *      char       *datname; 
 *      dlist_head  tables; 
 *      // ... 
 * } my_database; 
 * 
 * // Define struct for the tables.  Note the list_node element which stores 
 * // prev/next list links.  The list_node element need not be first. 
 * typedef struct my_table 
 * { 
 *      char       *tablename; 
 *      dlist_node  list_node; 
 *      perm_t      permissions; 
 *      // ... 
 * } my_table; 
 * 
 * // create a database 
 * my_database *db = create_database(); 
 * 
 * // and add a few tables to its table list 
 * dlist_push_head(&db-&GT;tables, &create_table(db, "a")-&GT;list_node); 
 * ... 
 * dlist_push_head(&db-&GT;tables, &create_table(db, "b")-&GT;list_node); 
 * 
 * 
 * To iterate over the table list, we allocate an iterator variable and use 
 * a specialized looping construct.  Inside a dlist_foreach, the iterator's 
 * 'cur' field can be used to access the current element.  iter.cur points to 
 * a 'dlist_node', but most of the time what we want is the actual table 
 * information; dlist_container() gives us that, like so: 
 * 
 * dlist_iter   iter; 
 * dlist_foreach(iter, &db-&GT;tables) 
 * { 
 *      my_table   *tbl = dlist_container(my_table, list_node, iter.cur); 
 *      printf("we have a table: %s in database %s\n", 
 *             tbl-&GT;tablename, db-&GT;datname); 
 * } 
 * 
 * 
 * While a simple iteration is useful, we sometimes also want to manipulate 
 * the list while iterating.  There is a different iterator element and looping 
 * construct for that.  Suppose we want to delete tables that meet a certain 
 * criterion: 
 * 
 * dlist_mutable_iter miter; 
 * dlist_foreach_modify(miter, &db-&GT;tables) 
 * { 
 *      my_table   *tbl = dlist_container(my_table, list_node, miter.cur); 
 * 
 *      if (!tbl-&GT;to_be_deleted) 
 *          continue;       // don't touch this one 
 * 
 *      // unlink the current table from the linked list 
 *      dlist_delete(miter.cur); 
 *      // as these lists never manage memory, we can still access the table 
 *      // after it's been unlinked 
 *      drop_table(db, tbl); 
 * } 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *      src/include/lib/ilist.h 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="ilist.h.html#LN106"><span class='Ref_to_Const'>ILIST_H</span></a> 
<a name="LN106"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ILIST_H</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Enable for extra debugging. This is rather expensive, so it's not enabled by 
 * default even when USE_ASSERT_CHECKING. 
 */ 
/* #define ILIST_DEBUG */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Node of a doubly linked list. 
 * 
 * Embed this in structs that need to be part of a doubly linked list. 
 */ 
</span><a name="LN119"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Declare_Typedef'>dlist_node</span><span class='Delimiter'>; 
</span><a name="LN120"></a><span class='Control'>struct</span> <span class='Declare_Struct'>dlist_node</span> 
<span class='Delimiter'>{ 
</span><a name="LN122"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>prev</span><span class='Delimiter'>; 
</span><a name="LN123"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>next</span><span class='Delimiter'>; 
}; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Head of a doubly linked list. 
 * 
 * Non-empty lists are internally circularly linked.  Circular lists have the 
 * advantage of not needing any branches in the most common list manipulations. 
 * An empty list can also be represented as a pair of NULL pointers, making 
 * initialization easier. 
 */ 
</span><a name="LN134"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>dlist_head</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * head.next either points to the first element of the list; to &head if 
     * it's a circular empty list; or to NULL if empty and not circular. 
     * 
     * head.prev either points to the last element of the list; to &head if 
     * it's a circular empty list; or to NULL if empty and not circular. 
     */ 
</span><a name="LN143"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a>  <span class='Declare_Member'>head</span><span class='Delimiter'>; 
</span><a name="LN144"></a>} <span class='Declare_Typedef'>dlist_head</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Doubly linked list iterator. 
 * 
 * Used as state in dlist_foreach() and dlist_reverse_foreach(). To get the 
 * current element of the iteration use the 'cur' member. 
 * 
 * Iterations using this are *not* allowed to change the list while iterating! 
 * 
 * NB: We use an extra "end" field here to avoid multiple evaluations of 
 * arguments in the dlist_foreach() macro. 
 */ 
</span><a name="LN158"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>dlist_iter</span> 
<span class='Delimiter'>{ 
</span><a name="LN160"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cur</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* current element */ 
</span><a name="LN161"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>end</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* last node we'll iterate to */ 
</span><a name="LN162"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>dlist_iter</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Doubly linked list iterator allowing some modifications while iterating. 
 * 
 * Used as state in dlist_foreach_modify(). To get the current element of the 
 * iteration use the 'cur' member. 
 * 
 * Iterations using this are only allowed to change the list at the current 
 * point of iteration. It is fine to delete the current node, but it is *not* 
 * fine to insert or delete adjacent nodes. 
 * 
 * NB: We need a separate type for mutable iterations so that we can store 
 * the 'next' node of the current node in case it gets deleted or modified. 
 */ 
</span><a name="LN177"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>dlist_mutable_iter</span> 
<span class='Delimiter'>{ 
</span><a name="LN179"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cur</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* current element */ 
</span><a name="LN180"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>next</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* next node we'll iterate to */ 
</span><a name="LN181"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>end</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* last node we'll iterate to */ 
</span><a name="LN182"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>dlist_mutable_iter</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Node of a singly linked list. 
 * 
 * Embed this in structs that need to be part of a singly linked list. 
 */ 
</span><a name="LN189"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Declare_Typedef'>slist_node</span><span class='Delimiter'>; 
</span><a name="LN190"></a><span class='Control'>struct</span> <span class='Declare_Struct'>slist_node</span> 
<span class='Delimiter'>{ 
</span><a name="LN192"></a>    <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>next</span><span class='Delimiter'>; 
}; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Head of a singly linked list. 
 * 
 * Singly linked lists are not circularly linked, in contrast to doubly linked 
 * lists; we just set head.next to NULL if empty.  This doesn't incur any 
 * additional branches in the usual manipulations. 
 */ 
</span><a name="LN202"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>slist_head</span> 
<span class='Delimiter'>{ 
</span><a name="LN204"></a>    <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a>  <span class='Declare_Member'>head</span><span class='Delimiter'>; 
</span><a name="LN205"></a>} <span class='Declare_Typedef'>slist_head</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Singly linked list iterator. 
 * 
 * Used as state in slist_foreach(). To get the current element of the 
 * iteration use the 'cur' member. 
 * 
 * It's allowed to modify the list while iterating, with the exception of 
 * deleting the iterator's current node; deletion of that node requires 
 * care if the iteration is to be continued afterward.  (Doing so and also 
 * deleting or inserting adjacent list elements might misbehave; also, if 
 * the user frees the current node's storage, continuing the iteration is 
 * not safe.) 
 * 
 * NB: this wouldn't really need to be an extra struct, we could use an 
 * slist_node * directly. We prefer a separate type for consistency. 
 */ 
</span><a name="LN223"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>slist_iter</span> 
<span class='Delimiter'>{ 
</span><a name="LN225"></a>    <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cur</span><span class='Delimiter'>; 
</span><a name="LN226"></a>} <span class='Declare_Typedef'>slist_iter</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Singly linked list iterator allowing some modifications while iterating. 
 * 
 * Used as state in slist_foreach_modify(). To get the current element of the 
 * iteration use the 'cur' member. 
 * 
 * The only list modification allowed while iterating is to remove the current 
 * node via slist_delete_current() (*not* slist_delete()).  Insertion or 
 * deletion of nodes adjacent to the current node would misbehave. 
 */ 
</span><a name="LN238"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>slist_mutable_iter</span> 
<span class='Delimiter'>{ 
</span><a name="LN240"></a>    <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cur</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* current element */ 
</span><a name="LN241"></a>    <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>next</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* next node we'll iterate to */ 
</span><a name="LN242"></a>    <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Member'>prev</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* prev node, for deletions */ 
</span><a name="LN243"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>slist_mutable_iter</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* Static initializers */ 
</span><a name="LN247"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>DLIST_STATIC_INIT</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>name</span><span class='Parentheses'>) </span><span class='Delimiter'>{{</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN247"><span class='Ref_to_Parameter'>name</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>head<span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN247"><span class='Ref_to_Parameter'>name</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>head<span class='Delimiter'>}} 
</span><a name="LN248"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SLIST_STATIC_INIT</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>name</span><span class='Parentheses'>) </span><span class='Delimiter'>{{</span><span class='Null_Value'>NULL</span><span class='Delimiter'>}} 
</span> 
 
<span class='Comment_Multi_Line'>/* Prototypes for functions too big to be inline */ 
</span> 
<span class='Comment_Multi_Line'>/* Caution: this is O(n); consider using slist_delete_current() instead */ 
</span><a name="LN254"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>slist_delete</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> ILIST_DEBUG 
<a name="LN257"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>dlist_check</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN258"></a><span class='Keyword'>extern void </span><span class='Declare_Prototype'>slist_check</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#else</span> 
<span class='Comment_Multi_Line'>/* 
 * These seemingly useless casts to void are here to keep the compiler quiet 
 * about the argument being unused in many functions in a non-debug compile, 
 * in which functions the only point of passing the list head pointer is to be 
 * able to run these checks. 
 */ 
</span><a name="LN266"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dlist_check</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) (</span><a href="ilist.h.html#LN266"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>))</span> 
<a name="LN267"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>slist_check</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>)</span>   <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) (</span><a href="ilist.h.html#LN267"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>))</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* ILIST_DEBUG */ 
</span> 
<span class='Comment_Multi_Line'>/* doubly linked list implementation */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Initialize a doubly linked list. 
 * Previous state will be thrown away without any cleanup. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN277"></a><span class='Declare_Function'>dlist_init</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="ilist.h.html#LN277"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN277"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= &</span><a href="ilist.h.html#LN277"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Is the list empty? 
 * 
 * An empty list has either its first 'next' pointer set to NULL, or to itself. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN288"></a><span class='Declare_Function'>dlist_is_empty</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../backend/lib/ilist.c.html#LN57"><span class='Ref_to_Func'>dlist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN288"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="ilist.h.html#LN288"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="ilist.h.html#LN288"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== &</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN288"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert a node at the beginning of the list. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN299"></a><span class='Declare_Function'>dlist_push_head</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* convert NULL header to circular */ 
</span>        <a href="ilist.h.html#LN276"><span class='Ref_to_Func'>dlist_init</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= &</span><a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../backend/lib/ilist.c.html#LN57"><span class='Ref_to_Func'>dlist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN299"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert a node at the end of the list. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN316"></a><span class='Declare_Function'>dlist_push_tail</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>    <span class='Comment_Single_Line'>/* convert NULL header to circular */ 
</span>        <a href="ilist.h.html#LN276"><span class='Ref_to_Func'>dlist_init</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= &</span><a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../backend/lib/ilist.c.html#LN57"><span class='Ref_to_Func'>dlist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN316"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert a node after another *in the same list* 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN333"></a><span class='Declare_Function'>dlist_insert_after</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>after</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>after</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>after</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>after</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN333"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert a node before another *in the same list* 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN345"></a><span class='Declare_Function'>dlist_insert_before</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>before</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>before</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>before</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>before</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN345"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Delete 'node' from its list (it must be in one). 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN357"></a><span class='Declare_Function'>dlist_delete</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="ilist.h.html#LN357"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN357"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN357"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN357"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Remove and return the first node from a list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>* 
</span><a name="LN367"></a><span class='Declare_Function'>dlist_pop_head_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN369"></a>    <a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Local'>node</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN367"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN369"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN367"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN356"><span class='Ref_to_Func'>dlist_delete</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN369"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="ilist.h.html#LN369"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Move element from its current position in the list to the head position in 
 * the same list. 
 * 
 * Undefined behaviour if 'node' is not already part of the list. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN384"></a><span class='Declare_Function'>dlist_move_head</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* fast path if it's already at the head */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="ilist.h.html#LN384"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><a href="ilist.h.html#LN384"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="ilist.h.html#LN356"><span class='Ref_to_Func'>dlist_delete</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN384"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN298"><span class='Ref_to_Func'>dlist_push_head</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN384"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN384"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../backend/lib/ilist.c.html#LN57"><span class='Ref_to_Func'>dlist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN384"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check whether 'node' has a following node. 
 * Caution: unreliable if 'node' is not in the list. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN401"></a><span class='Declare_Function'>dlist_has_next</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="ilist.h.html#LN401"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>!= &</span><a href="ilist.h.html#LN401"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check whether 'node' has a preceding node. 
 * Caution: unreliable if 'node' is not in the list. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN411"></a><span class='Declare_Function'>dlist_has_prev</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="ilist.h.html#LN411"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>!= &</span><a href="ilist.h.html#LN411"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the next node in the list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>* 
</span><a name="LN420"></a><span class='Declare_Function'>dlist_next_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN400"><span class='Ref_to_Func'>dlist_has_next</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN420"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN420"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="ilist.h.html#LN420"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return previous node in the list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>* 
</span><a name="LN430"></a><span class='Declare_Function'>dlist_prev_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN410"><span class='Ref_to_Func'>dlist_has_prev</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN430"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN430"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="ilist.h.html#LN430"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* internal support function to get address of head element's struct */ 
</span><span class='Keyword'>static inline void </span><span class='Operator'>* 
</span><a name="LN438"></a><span class='Declare_Function'>dlist_head_element_off</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span>size_t <span class='Declare_Parameter'>off</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN438"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ilist.h.html#LN438"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN123"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>- </span><a href="ilist.h.html#LN438"><span class='Ref_to_Parameter'>off</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the first node in the list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>* 
</span><a name="LN448"></a><span class='Declare_Function'>dlist_head_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ilist.h.html#LN437"><span class='Ref_to_Func'>dlist_head_element_off</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN448"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* internal support function to get address of tail element's struct */ 
</span><span class='Keyword'>static inline void </span><span class='Operator'>* 
</span><a name="LN455"></a><span class='Declare_Function'>dlist_tail_element_off</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span>size_t <span class='Declare_Parameter'>off</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="ilist.h.html#LN287"><span class='Ref_to_Func'>dlist_is_empty</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN455"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ilist.h.html#LN455"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN143"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN122"><span class='Ref_to_Member'>prev</span></a> <span class='Operator'>- </span><a href="ilist.h.html#LN455"><span class='Ref_to_Parameter'>off</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the last node in the list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>* 
</span><a name="LN465"></a><span class='Declare_Function'>dlist_tail_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ilist.h.html#LN454"><span class='Ref_to_Func'>dlist_tail_element_off</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN465"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the containing struct of 'type' where 'membername' is the dlist_node 
 * pointed at by 'ptr'. 
 * 
 * This is used to convert a dlist_node * back to its containing struct. 
 */ 
</span><a name="LN476"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dlist_container</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>type</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>membername</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>ptr</span><span class='Parentheses'>)</span>                              <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN476"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                        <span class='Operator'>\ 
</span>     <a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(((</span><a href="ilist.h.html#LN476"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>membername<span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>  <span class='Operator'>\ 
</span>     <span class='Parentheses'>((</span><a href="ilist.h.html#LN476"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="ilist.h.html#LN476"><span class='Ref_to_Parameter'>ptr</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN476"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN476"><span class='Ref_to_Parameter'>membername</span></a><span class='Parentheses'>))))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the address of the first element in the list. 
 * 
 * The list must not be empty. 
 */ 
</span><a name="LN486"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dlist_head_element</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>type</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>membername</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                         <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(((</span><a href="ilist.h.html#LN486"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>membername<span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>  <span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="ilist.h.html#LN486"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="ilist.h.html#LN437"><span class='Ref_to_Func'>dlist_head_element_off</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN486"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN486"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN486"><span class='Ref_to_Parameter'>membername</span></a><span class='Parentheses'>)))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the address of the last element in the list. 
 * 
 * The list must not be empty. 
 */ 
</span><a name="LN495"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dlist_tail_element</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>type</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>membername</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                         <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(((</span><a href="ilist.h.html#LN495"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>membername<span class='Delimiter'>, </span><a href="ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>  <span class='Operator'>\ 
</span>     <span class='Parentheses'>((</span><a href="ilist.h.html#LN495"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="ilist.h.html#LN454"><span class='Ref_to_Func'>dlist_tail_element_off</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN495"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN495"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN495"><span class='Ref_to_Parameter'>membername</span></a><span class='Parentheses'>))))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Iterate through the list pointed at by 'lhead' storing the state in 'iter'. 
 * 
 * Access the current element with iter.cur. 
 * 
 * It is *not* allowed to manipulate the list during iteration. 
 */ 
</span><a name="LN506"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dlist_foreach</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>iter</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                                          <span class='Operator'>\ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN158"><span class='Ref_to_Struct'>dlist_iter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                     <span class='Operator'>\ 
</span>         <a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                  <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>lhead</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>head<span class='Delimiter'>,</span>                                       <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Operator'>-&GT;</span>next <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Operator'>-&GT;</span>next <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Delimiter'>;</span>     <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Delimiter'>;</span>                                          <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN506"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur<span class='Operator'>-&GT;</span>next<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Iterate through the list pointed at by 'lhead' storing the state in 'iter'. 
 * 
 * Access the current element with iter.cur. 
 * 
 * Iterations using this are only allowed to change the list at the current 
 * point of iteration. It is fine to delete the current node, but it is *not* 
 * fine to insert or delete adjacent nodes. 
 */ 
</span><a name="LN523"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dlist_foreach_modify</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>iter</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                                   <span class='Operator'>\ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN177"><span class='Ref_to_Struct'>dlist_mutable_iter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>             <span class='Operator'>\ 
</span>         <a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                  <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>lhead</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>head<span class='Delimiter'>,</span>                                       <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Operator'>-&GT;</span>next <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Operator'>-&GT;</span>next <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Delimiter'>,</span>     <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur<span class='Operator'>-&GT;</span>next<span class='Delimiter'>;</span>                                    <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Delimiter'>;</span>                                          <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN523"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur<span class='Operator'>-&GT;</span>next<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Iterate through the list in reverse order. 
 * 
 * It is *not* allowed to manipulate the list during iteration. 
 */ 
</span><a name="LN537"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>dlist_reverse_foreach</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>iter</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                                  <span class='Operator'>\ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN158"><span class='Ref_to_Struct'>dlist_iter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                     <span class='Operator'>\ 
</span>         <a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                  <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>lhead</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>head<span class='Delimiter'>,</span>                                       <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Operator'>-&GT;</span>prev <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Operator'>-&GT;</span>prev <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Delimiter'>;</span>     <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>end<span class='Delimiter'>;</span>                                          <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN537"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur<span class='Operator'>-&GT;</span>prev<span class='Parentheses'>)</span> 
 
 
<span class='Comment_Multi_Line'>/* singly linked list implementation */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Initialize a singly linked list. 
 * Previous state will be thrown away without any cleanup. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN553"></a><span class='Declare_Function'>slist_init</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="ilist.h.html#LN553"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN204"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Is the list empty? 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN562"></a><span class='Declare_Function'>slist_is_empty</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../backend/lib/ilist.c.html#LN94"><span class='Ref_to_Func'>slist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN562"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="ilist.h.html#LN562"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN204"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert a node at the beginning of the list. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN573"></a><span class='Declare_Function'>slist_push_head</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="ilist.h.html#LN573"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN573"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN204"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN573"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN204"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN573"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../backend/lib/ilist.c.html#LN94"><span class='Ref_to_Func'>slist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN573"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert a node after another *in the same list* 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN585"></a><span class='Declare_Function'>slist_insert_after</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>after</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="ilist.h.html#LN585"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN585"><span class='Ref_to_Parameter'>after</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN585"><span class='Ref_to_Parameter'>after</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN585"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Remove and return the first node from a list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>* 
</span><a name="LN595"></a><span class='Declare_Function'>slist_pop_head_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN597"></a>    <a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Local'>node</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="ilist.h.html#LN561"><span class='Ref_to_Func'>slist_is_empty</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN595"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN597"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN595"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN204"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="ilist.h.html#LN595"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN204"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN597"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="../../backend/lib/ilist.c.html#LN94"><span class='Ref_to_Func'>slist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN595"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="ilist.h.html#LN597"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check whether 'node' has a following node. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN610"></a><span class='Declare_Function'>slist_has_next</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../backend/lib/ilist.c.html#LN94"><span class='Ref_to_Func'>slist_check</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN610"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="ilist.h.html#LN610"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the next node in the list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>* 
</span><a name="LN621"></a><span class='Declare_Function'>slist_next_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN609"><span class='Ref_to_Func'>slist_has_next</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN621"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN621"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="ilist.h.html#LN621"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* internal support function to get address of head element's struct */ 
</span><span class='Keyword'>static inline void </span><span class='Operator'>* 
</span><a name="LN629"></a><span class='Declare_Function'>slist_head_element_off</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Delimiter'>, </span>size_t <span class='Declare_Parameter'>off</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="ilist.h.html#LN561"><span class='Ref_to_Func'>slist_is_empty</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN629"><span class='Ref_to_Parameter'>head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ilist.h.html#LN629"><span class='Ref_to_Parameter'>head</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN204"><span class='Ref_to_Member'>head</span></a><span class='Operator'>.</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>- </span><a href="ilist.h.html#LN629"><span class='Ref_to_Parameter'>off</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the first node in the list (there must be one). 
 */ 
</span><span class='Keyword'>static inline </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>* 
</span><a name="LN639"></a><span class='Declare_Function'>slist_head_node</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>head</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="ilist.h.html#LN628"><span class='Ref_to_Func'>slist_head_element_off</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN639"><span class='Ref_to_Parameter'>head</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Delete the list element the iterator currently points to. 
 * 
 * Caution: this modifies iter-&GT;cur, so don't use that again in the current 
 * loop iteration. 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN651"></a><span class='Declare_Function'>slist_delete_current</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN238"><span class='Ref_to_Struct'>slist_mutable_iter</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>iter</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Update previous element's forward link.  If the iteration is at the 
     * first list element, iter-&GT;prev will point to the list header's "head" 
     * field, so we don't need a special case for that. 
     */ 
</span>    <a href="ilist.h.html#LN651"><span class='Ref_to_Parameter'>iter</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN242"><span class='Ref_to_Member'>prev</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN192"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN651"><span class='Ref_to_Parameter'>iter</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN241"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset cur to prev, so that prev will continue to point to the prior 
     * valid list element after slist_foreach_modify() advances to the next. 
     */ 
</span>    <a href="ilist.h.html#LN651"><span class='Ref_to_Parameter'>iter</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN240"><span class='Ref_to_Member'>cur</span></a> <span class='Operator'>= </span><a href="ilist.h.html#LN651"><span class='Ref_to_Parameter'>iter</span></a><span class='Operator'>-&GT;</span><a href="ilist.h.html#LN242"><span class='Ref_to_Member'>prev</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the containing struct of 'type' where 'membername' is the slist_node 
 * pointed at by 'ptr'. 
 * 
 * This is used to convert a slist_node * back to its containing struct. 
 */ 
</span><a name="LN673"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>slist_container</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>type</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>membername</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>ptr</span><span class='Parentheses'>)</span>                              <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN673"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                        <span class='Operator'>\ 
</span>     <a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(((</span><a href="ilist.h.html#LN673"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>membername<span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>  <span class='Operator'>\ 
</span>     <span class='Parentheses'>((</span><a href="ilist.h.html#LN673"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="ilist.h.html#LN673"><span class='Ref_to_Parameter'>ptr</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN673"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN673"><span class='Ref_to_Parameter'>membername</span></a><span class='Parentheses'>))))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the address of the first element in the list. 
 * 
 * The list must not be empty. 
 */ 
</span><a name="LN683"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>slist_head_element</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>type</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>membername</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                         <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(((</span><a href="ilist.h.html#LN683"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>membername<span class='Delimiter'>, </span><a href="ilist.h.html#LN190"><span class='Ref_to_Struct'>slist_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>  <span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="ilist.h.html#LN683"><span class='Ref_to_Parameter'>type</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="ilist.h.html#LN628"><span class='Ref_to_Func'>slist_head_element_off</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN683"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="../c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN683"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN683"><span class='Ref_to_Parameter'>membername</span></a><span class='Parentheses'>)))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Iterate through the list pointed at by 'lhead' storing the state in 'iter'. 
 * 
 * Access the current element with iter.cur. 
 * 
 * It's allowed to modify the list while iterating, with the exception of 
 * deleting the iterator's current node; deletion of that node requires 
 * care if the iteration is to be continued afterward.  (Doing so and also 
 * deleting or inserting adjacent list elements might misbehave; also, if 
 * the user frees the current node's storage, continuing the iteration is 
 * not safe.) 
 */ 
</span><a name="LN699"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>slist_foreach</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>iter</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                                          <span class='Operator'>\ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN699"><span class='Ref_to_Parameter'>iter</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN223"><span class='Ref_to_Struct'>slist_iter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                     <span class='Operator'>\ 
</span>         <a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN699"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                  <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN699"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN699"><span class='Ref_to_Parameter'>lhead</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>head<span class='Operator'>.</span>next<span class='Delimiter'>;</span>                                   <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN699"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                                                <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN699"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN699"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur<span class='Operator'>-&GT;</span>next<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Iterate through the list pointed at by 'lhead' storing the state in 'iter'. 
 * 
 * Access the current element with iter.cur. 
 * 
 * The only list modification allowed while iterating is to remove the current 
 * node via slist_delete_current() (*not* slist_delete()).  Insertion or 
 * deletion of nodes adjacent to the current node would misbehave. 
 */ 
</span><a name="LN715"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>slist_foreach_modify</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>iter</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>lhead</span><span class='Parentheses'>)</span>                                   <span class='Operator'>\ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN238"><span class='Ref_to_Struct'>slist_mutable_iter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>,</span>             <span class='Operator'>\ 
</span>         <a href="../c.h.html#LN778"><span class='Ref_to_Macro'>AssertVariableIsOfTypeMacro</span></a><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>lhead</span></a><span class='Delimiter'>, </span><a href="ilist.h.html#LN202"><span class='Ref_to_Struct'>slist_head</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span><span class='Delimiter'>,</span>                  <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>prev <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>lhead</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>head<span class='Delimiter'>,</span>                                      <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>prev<span class='Operator'>-&GT;</span>next<span class='Delimiter'>,</span>                                    <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur<span class='Operator'>-&GT;</span>next <span class='Operator'>: </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                                                <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>prev <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur<span class='Delimiter'>,</span>                                          <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>cur <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next<span class='Delimiter'>,</span>                                          <span class='Operator'>\ 
</span>         <span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="ilist.h.html#LN715"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>next<span class='Operator'>-&GT;</span>next <span class='Operator'>: </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* ILIST_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>