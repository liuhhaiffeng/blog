<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\nodes\execnodes.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\nodes\execnodes.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:07 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * execnodes.h 
 *    definitions for executor state nodes 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/nodes/execnodes.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="execnodes.h.html#LN14"><span class='Ref_to_Const'>EXECNODES_H</span></a> 
<a name="LN14"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EXECNODES_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/genam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/heapam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/tupconvert.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/instrument.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/pairingheap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/params.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/plannodes.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/hsearch.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/queryenvironment.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/reltrigger.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/sortsupport.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tuplestore.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tuplesort.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/tidbitmap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/condition_variable.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      ExprState node 
 * 
 * ExprState is the top-level node for expression evaluation. 
 * It contains instructions (in -&GT;steps) to evaluate the expression. 
 * ---------------- 
 */ 
</span><span class='Control'>struct</span> <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a><span class='Delimiter'>;</span>               <span class='Comment_Single_Line'>/* forward references in this file */ 
</span><span class='Control'>struct</span> <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a><span class='Delimiter'>; 
</span><span class='Control'>struct</span> <a href="../executor/execExpr.h.html#LN219"><span class='Ref_to_Struct'>ExprEvalStep</span></a><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* avoid including execExpr.h everywhere */ 
</span> 
<a name="LN44"></a><span class='Control'>typedef</span> <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Typedef'>ExprStateEvalFunc</span><span class='Parentheses'>) (</span><span class='Control'>struct</span> <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>*</span>expression<span class='Delimiter'>, 
</span>                                                <span class='Control'>struct</span> <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span>econtext<span class='Delimiter'>, 
</span>                                                <span class='Keyword'>bool </span><span class='Operator'>*</span>isNull<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Bits in ExprState-&GT;flags (see also execExpr.h for private flag bits): */ 
/* expression is for use with ExecQual() */ 
</span><a name="LN50"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>EEO_FLAG_IS_QUAL</span>                    <span class='Parentheses'>(</span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<a name="LN52"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ExprState</span> 
<span class='Delimiter'>{ 
</span><a name="LN54"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>        <span class='Declare_Member'>tag</span><span class='Delimiter'>; 
</span> 
<a name="LN56"></a>    <a href="../c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Member'>flags</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* bitmask of EEO_FLAG_* bits, see above */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Storage for result value of a scalar expression, or for individual 
     * column results within expressions built by ExecBuildProjectionInfo(). 
     */ 
</span><a name="LN62"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>resnull</span><span class='Delimiter'>; 
</span><a name="LN63"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>resvalue</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If projecting a tuple result, this slot holds the result; else NULL. 
     */ 
</span><a name="LN68"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>resultslot</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Instructions to compute expression's return value. 
     */ 
</span><a name="LN73"></a>    <span class='Control'>struct</span> <a href="../executor/execExpr.h.html#LN219"><span class='Ref_to_Struct'>ExprEvalStep</span></a> <span class='Operator'>*</span><span class='Declare_Member'>steps</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Function that actually evaluates the expression.  This can be set to 
     * different values depending on the complexity of the expression. 
     */ 
</span><a name="LN79"></a>    <a href="execnodes.h.html#LN44"><span class='Ref_to_Typedef'>ExprStateEvalFunc</span></a> <span class='Declare_Member'>evalfunc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* original expression tree, for debugging only */ 
</span><a name="LN82"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX: following only needed during "compilation", could be thrown away. 
     */ 
</span> 
<a name="LN88"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>steps_len</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* number of steps currently */ 
</span><a name="LN89"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>steps_alloc</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* allocated length of steps array */ 
</span> 
<a name="LN91"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>innermost_caseval</span><span class='Delimiter'>; 
</span><a name="LN92"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>innermost_casenull</span><span class='Delimiter'>; 
</span> 
<a name="LN94"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>innermost_domainval</span><span class='Delimiter'>; 
</span><a name="LN95"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>innermost_domainnull</span><span class='Delimiter'>; 
</span><a name="LN96"></a>}<span class='Auto_Annotations'> &laquo; end ExprState &raquo; </span> <span class='Declare_Typedef'>ExprState</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *    IndexInfo information 
 * 
 *      this struct holds the information needed to construct new index 
 *      entries for a particular index.  Used for both index_build and 
 *      retail creation of index entries. 
 * 
 *      NumIndexAttrs       number of columns in this index 
 *      KeyAttrNumbers      underlying-rel attribute numbers used as keys 
 *                          (zeroes indicate expressions) 
 *      Expressions         expr trees for expression entries, or NIL if none 
 *      ExpressionsState    exec state for expressions, or NIL if none 
 *      Predicate           partial-index predicate, or NIL if none 
 *      PredicateState      exec state for predicate, or NIL if none 
 *      ExclusionOps        Per-column exclusion operators, or NULL if none 
 *      ExclusionProcs      Underlying function OIDs for ExclusionOps 
 *      ExclusionStrats     Opclass strategy numbers for ExclusionOps 
 *      UniqueOps           Theses are like Exclusion*, but for unique indexes 
 *      UniqueProcs 
 *      UniqueStrats 
 *      Unique              is it a unique index? 
 *      ReadyForInserts     is it valid for inserts? 
 *      Concurrent          are we doing a concurrent index build? 
 *      BrokenHotChain      did we detect any broken HOT chains? 
 *      AmCache             private cache area for index AM 
 *      Context             memory context holding this IndexInfo 
 * 
 * ii_Concurrent and ii_BrokenHotChain are used only during index build; 
 * they're conventionally set to false otherwise. 
 * ---------------- 
 */ 
</span><a name="LN130"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN132"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN133"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ii_NumIndexAttrs</span><span class='Delimiter'>; 
</span><a name="LN134"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>ii_KeyAttrNumbers</span><span class='Delimiter'>[</span><a href="../pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN135"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ii_Expressions</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* list of Expr */ 
</span><a name="LN136"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ii_ExpressionsState</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* list of ExprState */ 
</span><a name="LN137"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ii_Predicate</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of Expr */ 
</span><a name="LN138"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>ii_PredicateState</span><span class='Delimiter'>; 
</span><a name="LN139"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>ii_ExclusionOps</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array with one entry per column */ 
</span><a name="LN140"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>ii_ExclusionProcs</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* array with one entry per column */ 
</span><a name="LN141"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>ii_ExclusionStrats</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* array with one entry per column */ 
</span><a name="LN142"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>ii_UniqueOps</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* array with one entry per column */ 
</span><a name="LN143"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>ii_UniqueProcs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* array with one entry per column */ 
</span><a name="LN144"></a>    <a href="../c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>ii_UniqueStrats</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array with one entry per column */ 
</span><a name="LN145"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ii_Unique</span><span class='Delimiter'>; 
</span><a name="LN146"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ii_ReadyForInserts</span><span class='Delimiter'>; 
</span><a name="LN147"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ii_Concurrent</span><span class='Delimiter'>; 
</span><a name="LN148"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ii_BrokenHotChain</span><span class='Delimiter'>; 
</span><a name="LN149"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>ii_AmCache</span><span class='Delimiter'>; 
</span><a name="LN150"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>ii_Context</span><span class='Delimiter'>; 
</span><a name="LN151"></a>}<span class='Auto_Annotations'> &laquo; end IndexInfo &raquo; </span> <span class='Declare_Typedef'>IndexInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *    ExprContext_CB 
 * 
 *      List of callbacks to be called at ExprContext shutdown. 
 * ---------------- 
 */ 
</span><a name="LN159"></a><span class='Control'>typedef</span> <span class='Keyword'>void </span><span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Typedef'>ExprContextCallbackFunction</span><span class='Parentheses'>) (</span><a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> arg<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN161"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ExprContext_CB</span> 
<span class='Delimiter'>{ 
</span><a name="LN163"></a>    <span class='Control'>struct</span> <a href="execnodes.h.html#LN161"><span class='Ref_to_Struct'>ExprContext_CB</span></a> <span class='Operator'>*</span><span class='Declare_Member'>next</span><span class='Delimiter'>; 
</span><a name="LN164"></a>    <a href="execnodes.h.html#LN159"><span class='Ref_to_Typedef'>ExprContextCallbackFunction</span></a> <span class='Declare_Member'>function</span><span class='Delimiter'>; 
</span><a name="LN165"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>arg</span><span class='Delimiter'>; 
</span><a name="LN166"></a>} <span class='Declare_Typedef'>ExprContext_CB</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *    ExprContext 
 * 
 *      This class holds the "current context" information 
 *      needed to evaluate expressions for doing tuple qualifications 
 *      and tuple projections.  For example, if an expression refers 
 *      to an attribute in the current inner tuple then we need to know 
 *      what the current inner tuple is and so we look at the expression 
 *      context. 
 * 
 *  There are two memory contexts associated with an ExprContext: 
 *  * ecxt_per_query_memory is a query-lifespan context, typically the same 
 *    context the ExprContext node itself is allocated in.  This context 
 *    can be used for purposes such as storing function call cache info. 
 *  * ecxt_per_tuple_memory is a short-term context for expression results. 
 *    As the name suggests, it will typically be reset once per tuple, 
 *    before we begin to evaluate expressions for that tuple.  Each 
 *    ExprContext normally has its very own per-tuple memory context. 
 * 
 *  CurrentMemoryContext should be set to ecxt_per_tuple_memory before 
 *  calling ExecEvalExpr() --- see ExecEvalExprSwitchContext(). 
 * ---------------- 
 */ 
</span><a name="LN191"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ExprContext</span> 
<span class='Delimiter'>{ 
</span><a name="LN193"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Tuples that Var nodes in expression may refer to */ 
</span><a name="LN196"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ecxt_scantuple</span><span class='Delimiter'>; 
</span><a name="LN197"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ecxt_innertuple</span><span class='Delimiter'>; 
</span><a name="LN198"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ecxt_outertuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Memory contexts for expression evaluation --- see notes above */ 
</span><a name="LN201"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>ecxt_per_query_memory</span><span class='Delimiter'>; 
</span><a name="LN202"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>ecxt_per_tuple_memory</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Values to substitute for Param nodes in expression */ 
</span><a name="LN205"></a>    <a href="params.h.html#LN96"><span class='Ref_to_Struct'>ParamExecData</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ecxt_param_exec_vals</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* for PARAM_EXEC params */ 
</span><a name="LN206"></a>    <a href="params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Member'>ecxt_param_list_info</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* for other param types */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Values to substitute for Aggref nodes in the expressions of an Agg 
     * node, or for WindowFunc nodes within a WindowAgg node. 
     */ 
</span><a name="LN212"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>ecxt_aggvalues</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* precomputed values for aggs/windowfuncs */ 
</span><a name="LN213"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>ecxt_aggnulls</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* null flags for aggs/windowfuncs */ 
</span> 
    <span class='Comment_Multi_Line'>/* Value to substitute for CaseTestExpr nodes in expression */ 
</span><a name="LN216"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>caseValue_datum</span><span class='Delimiter'>; 
</span><a name="LN217"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>caseValue_isNull</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Value to substitute for CoerceToDomainValue nodes in expression */ 
</span><a name="LN220"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>domainValue_datum</span><span class='Delimiter'>; 
</span><a name="LN221"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>domainValue_isNull</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Link to containing EState (NULL if a standalone ExprContext) */ 
</span><a name="LN224"></a>    <span class='Control'>struct</span> <a href="execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ecxt_estate</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Functions to call back when ExprContext is shut down or rescanned */ 
</span><a name="LN227"></a>    <a href="execnodes.h.html#LN161"><span class='Ref_to_Struct'>ExprContext_CB</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ecxt_callbacks</span><span class='Delimiter'>; 
</span><a name="LN228"></a>}<span class='Auto_Annotations'> &laquo; end ExprContext &raquo; </span> <span class='Declare_Typedef'>ExprContext</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Set-result status used when evaluating functions potentially returning a 
 * set. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN236"></a>    <span class='Declare_Enum_Const'>ExprSingleResult</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* expression does not return a set */ 
</span><a name="LN237"></a>    <span class='Declare_Enum_Const'>ExprMultipleResult</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* this result is an element of a set */ 
</span><a name="LN238"></a>    <span class='Declare_Enum_Const'>ExprEndResult</span>               <span class='Comment_Single_Line'>/* there are no more elements in the set */ 
</span><a name="LN239"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ExprDoneCond</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return modes for functions returning sets.  Note values must be chosen 
 * as separate bits so that a bitmask can be formed to indicate supported 
 * modes.  SFRM_Materialize_Random and SFRM_Materialize_Preferred are 
 * auxiliary flags about SFRM_Materialize mode, rather than separate modes. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN249"></a>    <span class='Declare_Enum_Const'>SFRM_ValuePerCall</span> <span class='Operator'>= </span><span class='Number'>0x01</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* one value returned per call */ 
</span><a name="LN250"></a>    <span class='Declare_Enum_Const'>SFRM_Materialize</span> <span class='Operator'>= </span><span class='Number'>0x02</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* result set instantiated in Tuplestore */ 
</span><a name="LN251"></a>    <span class='Declare_Enum_Const'>SFRM_Materialize_Random</span> <span class='Operator'>= </span><span class='Number'>0x04</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* Tuplestore needs randomAccess */ 
</span><a name="LN252"></a>    <span class='Declare_Enum_Const'>SFRM_Materialize_Preferred</span> <span class='Operator'>= </span><span class='Number'>0x08</span>   <span class='Comment_Single_Line'>/* caller prefers Tuplestore */ 
</span><a name="LN253"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SetFunctionReturnMode</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When calling a function that might return a set (multiple rows), 
 * a node of this type is passed as fcinfo-&GT;resultinfo to allow 
 * return status to be passed back.  A function returning set should 
 * raise an error if no such resultinfo is provided. 
 */ 
</span><a name="LN261"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ReturnSetInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN263"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* values set by caller: */ 
</span><a name="LN265"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>econtext</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* context function is being called in */ 
</span><a name="LN266"></a>    <a href="../access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>expectedDesc</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* tuple descriptor expected by caller */ 
</span><a name="LN267"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>allowedModes</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* bitmask: return modes caller can handle */ 
</span>    <span class='Comment_Multi_Line'>/* result status from function (but pre-initialized by caller): */ 
</span><a name="LN269"></a>    <a href="execnodes.h.html#LN247"><span class='Ref_to_Typedef'>SetFunctionReturnMode</span></a> <span class='Declare_Member'>returnMode</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* actual return mode */ 
</span><a name="LN270"></a>    <a href="execnodes.h.html#LN234"><span class='Ref_to_Typedef'>ExprDoneCond</span></a> <span class='Declare_Member'>isDone</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* status for ValuePerCall mode */ 
</span>    <span class='Comment_Multi_Line'>/* fields filled by function in Materialize return mode: */ 
</span><a name="LN272"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>setResult</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* holds the complete returned tuple set */ 
</span><a name="LN273"></a>    <a href="../access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>setDesc</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* actual descriptor for returned tuples */ 
</span><a name="LN274"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ReturnSetInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      ProjectionInfo node information 
 * 
 *      This is all the information needed to perform projections --- 
 *      that is, form new tuples by evaluation of targetlist expressions. 
 *      Nodes which need to do projections create one of these. 
 * 
 *      The target tuple slot is kept in ProjectionInfo-&GT;pi_state.resultslot. 
 *      ExecProject() evaluates the tlist, forms a tuple, and stores it 
 *      in the given slot.  Note that the result will be a "virtual" tuple 
 *      unless ExecMaterializeSlot() is then called to force it to be 
 *      converted to a physical tuple.  The slot must have a tupledesc 
 *      that matches the output of the tlist! 
 * ---------------- 
 */ 
</span><a name="LN291"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ProjectionInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN293"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* instructions to evaluate projection */ 
</span><a name="LN295"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>   <span class='Declare_Member'>pi_state</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* expression context in which to evaluate expression */ 
</span><a name="LN297"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pi_exprContext</span><span class='Delimiter'>; 
</span><a name="LN298"></a>} <span class='Declare_Typedef'>ProjectionInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *    JunkFilter 
 * 
 *    This class is used to store information regarding junk attributes. 
 *    A junk attribute is an attribute in a tuple that is needed only for 
 *    storing intermediate information in the executor, and does not belong 
 *    in emitted tuples.  For example, when we do an UPDATE query, 
 *    the planner adds a "junk" entry to the targetlist so that the tuples 
 *    returned to ExecutePlan() contain an extra attribute: the ctid of 
 *    the tuple to be updated.  This is needed to do the update, but we 
 *    don't want the ctid to be part of the stored new tuple!  So, we 
 *    apply a "junk filter" to remove the junk attributes and form the 
 *    real output tuple.  The junkfilter code also provides routines to 
 *    extract the values of the junk attribute(s) from the input tuple. 
 * 
 *    targetList:       the original target list (including junk attributes). 
 *    cleanTupType:     the tuple descriptor for the "clean" tuple (with 
 *                      junk attributes removed). 
 *    cleanMap:         A map with the correspondence between the non-junk 
 *                      attribute numbers of the "original" tuple and the 
 *                      attribute numbers of the "clean" tuple. 
 *    resultSlot:       tuple slot used to hold cleaned tuple. 
 *    junkAttNo:        not used by junkfilter code.  Can be used by caller 
 *                      to remember the attno of a specific junk attribute 
 *                      (nodeModifyTable.c keeps the "ctid" or "wholerow" 
 *                      attno here). 
 * ---------------- 
 */ 
</span><a name="LN328"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>JunkFilter</span> 
<span class='Delimiter'>{ 
</span><a name="LN330"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN331"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>jf_targetList</span><span class='Delimiter'>; 
</span><a name="LN332"></a>    <a href="../access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>jf_cleanTupType</span><span class='Delimiter'>; 
</span><a name="LN333"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>jf_cleanMap</span><span class='Delimiter'>; 
</span><a name="LN334"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>jf_resultSlot</span><span class='Delimiter'>; 
</span><a name="LN335"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>jf_junkAttNo</span><span class='Delimiter'>; 
</span><a name="LN336"></a>} <span class='Declare_Typedef'>JunkFilter</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *    ResultRelInfo information 
 * 
 *      Whenever we update an existing relation, we have to 
 *      update indices on the relation, and perhaps also fire triggers. 
 *      The ResultRelInfo class is used to hold all the information needed 
 *      about a result relation, including indices.. -cim 10/15/89 
 * 
 *      RangeTableIndex         result relation's range table index 
 *      RelationDesc            relation descriptor for result relation 
 *      NumIndices              # of indices existing on result relation 
 *      IndexRelationDescs      array of relation descriptors for indices 
 *      IndexRelationInfo       array of key/attr info for indices 
 *      TrigDesc                triggers to be fired, if any 
 *      TrigFunctions           cached lookup info for trigger functions 
 *      TrigWhenExprs           array of trigger WHEN expr states 
 *      TrigInstrument          optional runtime measurements for triggers 
 *      FdwRoutine              FDW callback functions, if foreign table 
 *      FdwState                available to save private state of FDW 
 *      usesFdwDirectModify     true when modifying foreign table directly 
 *      WithCheckOptions        list of WithCheckOption's to be checked 
 *      WithCheckOptionExprs    list of WithCheckOption expr states 
 *      ConstraintExprs         array of constraint-checking expr states 
 *      junkFilter              for removing junk attributes from tuples 
 *      projectReturning        for computing a RETURNING list 
 *      onConflictSetProj       for computing ON CONFLICT DO UPDATE SET 
 *      onConflictSetWhere      list of ON CONFLICT DO UPDATE exprs (qual) 
 *      PartitionCheck          partition check expression 
 *      PartitionCheckExpr      partition check expression state 
 * ---------------- 
 */ 
</span><a name="LN369"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ResultRelInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN371"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN372"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>ri_RangeTableIndex</span><span class='Delimiter'>; 
</span><a name="LN373"></a>    <a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>ri_RelationDesc</span><span class='Delimiter'>; 
</span><a name="LN374"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ri_NumIndices</span><span class='Delimiter'>; 
</span><a name="LN375"></a>    <a href="../utils/relcache.h.html#LN28"><span class='Ref_to_Typedef'>RelationPtr</span></a> <span class='Declare_Member'>ri_IndexRelationDescs</span><span class='Delimiter'>; 
</span><a name="LN376"></a>    <a href="execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>**</span><span class='Declare_Member'>ri_IndexRelationInfo</span><span class='Delimiter'>; 
</span><a name="LN377"></a>    <a href="../utils/reltrigger.h.html#LN45"><span class='Ref_to_Struct'>TriggerDesc</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ri_TrigDesc</span><span class='Delimiter'>; 
</span><a name="LN378"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>ri_TrigFunctions</span><span class='Delimiter'>; 
</span><a name="LN379"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>**</span><span class='Declare_Member'>ri_TrigWhenExprs</span><span class='Delimiter'>; 
</span><a name="LN380"></a>    <a href="../executor/instrument.h.html#LN43"><span class='Ref_to_Struct'>Instrumentation</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ri_TrigInstrument</span><span class='Delimiter'>; 
</span><a name="LN381"></a>    <span class='Control'>struct</span> <a href="../foreign/fdwapi.h.html#LN168"><span class='Ref_to_Struct'>FdwRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ri_FdwRoutine</span><span class='Delimiter'>; 
</span><a name="LN382"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>ri_FdwState</span><span class='Delimiter'>; 
</span><a name="LN383"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ri_usesFdwDirectModify</span><span class='Delimiter'>; 
</span><a name="LN384"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ri_WithCheckOptions</span><span class='Delimiter'>; 
</span><a name="LN385"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ri_WithCheckOptionExprs</span><span class='Delimiter'>; 
</span><a name="LN386"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>**</span><span class='Declare_Member'>ri_ConstraintExprs</span><span class='Delimiter'>; 
</span><a name="LN387"></a>    <a href="execnodes.h.html#LN328"><span class='Ref_to_Struct'>JunkFilter</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ri_junkFilter</span><span class='Delimiter'>; 
</span><a name="LN388"></a>    <a href="execnodes.h.html#LN291"><span class='Ref_to_Struct'>ProjectionInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ri_projectReturning</span><span class='Delimiter'>; 
</span><a name="LN389"></a>    <a href="execnodes.h.html#LN291"><span class='Ref_to_Struct'>ProjectionInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ri_onConflictSetProj</span><span class='Delimiter'>; 
</span><a name="LN390"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>ri_onConflictSetWhere</span><span class='Delimiter'>; 
</span><a name="LN391"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ri_PartitionCheck</span><span class='Delimiter'>; 
</span><a name="LN392"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>ri_PartitionCheckExpr</span><span class='Delimiter'>; 
</span><a name="LN393"></a>    <a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>ri_PartitionRoot</span><span class='Delimiter'>; 
</span><a name="LN394"></a>}<span class='Auto_Annotations'> &laquo; end ResultRelInfo &raquo; </span> <span class='Declare_Typedef'>ResultRelInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *    EState information 
 * 
 * Master working state for an Executor invocation 
 * ---------------- 
 */ 
</span><a name="LN402"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>EState</span> 
<span class='Delimiter'>{ 
</span><a name="LN404"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Basic state for all query types: */ 
</span><a name="LN407"></a>    <a href="../access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Member'>es_direction</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* current scan direction */ 
</span><a name="LN408"></a>    <a href="../utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a>    <span class='Declare_Member'>es_snapshot</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* time qual to use */ 
</span><a name="LN409"></a>    <a href="../utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a>    <span class='Declare_Member'>es_crosscheck_snapshot</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* crosscheck time qual for RI */ 
</span><a name="LN410"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>es_range_table</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* List of RangeTblEntry */ 
</span><a name="LN411"></a>    <a href="plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_plannedstmt</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* link to top of plan tree */ 
</span><a name="LN412"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Member'>es_sourceText</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* Source text from QueryDesc */ 
</span> 
<a name="LN414"></a>    <a href="execnodes.h.html#LN328"><span class='Ref_to_Struct'>JunkFilter</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_junkFilter</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* top-level junk filter, if any */ 
</span> 
    <span class='Comment_Multi_Line'>/* If query can insert/delete tuples, the command ID to mark them with */ 
</span><a name="LN417"></a>    <a href="../c.h.html#LN410"><span class='Ref_to_Typedef'>CommandId</span></a>   <span class='Declare_Member'>es_output_cid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Info about target table(s) for insert/update/delete queries: */ 
</span><a name="LN420"></a>    <a href="execnodes.h.html#LN369"><span class='Ref_to_Struct'>ResultRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_result_relations</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* array of ResultRelInfos */ 
</span><a name="LN421"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>es_num_result_relations</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* length of array */ 
</span><a name="LN422"></a>    <a href="execnodes.h.html#LN369"><span class='Ref_to_Struct'>ResultRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_result_relation_info</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* currently active array elt */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Info about the target partitioned target table root(s) for 
     * update/delete queries.  They required only to fire any per-statement 
     * triggers defined on the table.  It exists separately from 
     * es_result_relations, because partitioned tables don't appear in the 
     * plan tree for the update/delete cases. 
     */ 
</span><a name="LN431"></a>    <a href="execnodes.h.html#LN369"><span class='Ref_to_Struct'>ResultRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_root_result_relations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of ResultRelInfos */ 
</span><a name="LN432"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>es_num_root_result_relations</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* length of the array */ 
</span> 
    <span class='Comment_Multi_Line'>/* Stuff used for firing triggers: */ 
</span><a name="LN435"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>es_trig_target_relations</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* trigger-only ResultRelInfos */ 
</span><a name="LN436"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_trig_tuple_slot</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* for trigger output tuples */ 
</span><a name="LN437"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_trig_oldtup_slot</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* for TriggerEnabled */ 
</span><a name="LN438"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_trig_newtup_slot</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* for TriggerEnabled */ 
</span> 
    <span class='Comment_Multi_Line'>/* Parameter info: */ 
</span><a name="LN441"></a>    <a href="params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Member'>es_param_list_info</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* values of external params */ 
</span><a name="LN442"></a>    <a href="params.h.html#LN96"><span class='Ref_to_Struct'>ParamExecData</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_param_exec_vals</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* values of internal params */ 
</span> 
<a name="LN444"></a>    <a href="../../backend/utils/misc/queryenvironment.c.html#LN31"><span class='Ref_to_Struct'>QueryEnvironment</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_queryEnv</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* query environment */ 
</span> 
    <span class='Comment_Multi_Line'>/* Other working state: */ 
</span><a name="LN447"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>es_query_cxt</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* per-query context in which EState lives */ 
</span> 
<a name="LN449"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>es_tupleTable</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* List of TupleTableSlots */ 
</span> 
<a name="LN451"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>es_rowMarks</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* List of ExecRowMarks */ 
</span> 
<a name="LN453"></a>    <a href="../c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Member'>es_processed</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* # of tuples processed */ 
</span><a name="LN454"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>es_lastoid</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* last oid processed (by INSERT) */ 
</span> 
<a name="LN456"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>es_top_eflags</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* eflags passed to ExecutorStart */ 
</span><a name="LN457"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>es_instrument</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OR of InstrumentOption flags */ 
</span><a name="LN458"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>es_finished</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* true when ExecutorFinish is done */ 
</span> 
<a name="LN460"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>es_exprcontexts</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* List of ExprContexts within EState */ 
</span> 
<a name="LN462"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>es_subplanstates</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* List of PlanState for SubPlans */ 
</span> 
<a name="LN464"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>es_auxmodifytables</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* List of secondary ModifyTableStates */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * this ExprContext is for per-output-tuple operations, such as constraint 
     * checks and index-value computations.  It will be reset for each output 
     * tuple.  Note that it will be created only if needed. 
     */ 
</span><a name="LN471"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_per_tuple_exprcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These fields are for re-evaluating plan quals when an updated tuple is 
     * substituted in READ COMMITTED mode.  es_epqTuple[] contains tuples that 
     * scan plan nodes should return instead of whatever they'd normally 
     * return, or NULL if nothing to return; es_epqTupleSet[] is true if a 
     * particular array entry is valid; and es_epqScanDone[] is state to 
     * remember if the tuple has been returned already.  Arrays are of size 
     * list_length(es_range_table) and are indexed by scan node scanrelid - 1. 
     */ 
</span><a name="LN482"></a>    <a href="../access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>es_epqTuple</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of EPQ substitute tuples */ 
</span><a name="LN483"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>es_epqTupleSet</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* true if EPQ tuple is provided */ 
</span><a name="LN484"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>es_epqScanDone</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* true if EPQ tuple has been fetched */ 
</span> 
    <span class='Comment_Multi_Line'>/* The per-query shared memory area to use for parallel execution. */ 
</span><a name="LN487"></a>    <span class='Control'>struct</span> <a href="../../backend/utils/mmgr/dsa.c.html#LN353"><span class='Ref_to_Struct'>dsa_area</span></a> <span class='Operator'>*</span><span class='Declare_Member'>es_query_dsa</span><span class='Delimiter'>; 
</span><a name="LN488"></a>}<span class='Auto_Annotations'> &laquo; end EState &raquo; </span> <span class='Declare_Typedef'>EState</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecRowMark - 
 *     runtime representation of FOR [KEY] UPDATE/SHARE clauses 
 * 
 * When doing UPDATE, DELETE, or SELECT FOR [KEY] UPDATE/SHARE, we will have an 
 * ExecRowMark for each non-target relation in the query (except inheritance 
 * parent RTEs, which can be ignored at runtime).  Virtual relations such as 
 * subqueries-in-FROM will have an ExecRowMark with relation == NULL.  See 
 * PlanRowMark for details about most of the fields.  In addition to fields 
 * directly derived from PlanRowMark, we store an activity flag (to denote 
 * inactive children of inheritance trees), curCtid, which is used by the 
 * WHERE CURRENT OF code, and ermExtra, which is available for use by the plan 
 * node that sources the relation (e.g., for a foreign table the FDW can use 
 * ermExtra to hold information). 
 * 
 * EState-&GT;es_rowMarks is a list of these structs. 
 */ 
</span><a name="LN508"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ExecRowMark</span> 
<span class='Delimiter'>{ 
</span><a name="LN510"></a>    <a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* opened and suitably locked relation */ 
</span><a name="LN511"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>relid</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* its OID (or InvalidOid, if subquery) */ 
</span><a name="LN512"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>rti</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* its range table index */ 
</span><a name="LN513"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>prti</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* parent range table index, if child */ 
</span><a name="LN514"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>rowmarkId</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* unique identifier for resjunk columns */ 
</span><a name="LN515"></a>    <a href="plannodes.h.html#LN951"><span class='Ref_to_Enum'>RowMarkType</span></a> <span class='Declare_Member'>markType</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* see enum in nodes/plannodes.h */ 
</span><a name="LN516"></a>    <a href="lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Member'>strength</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* LockingClause's strength, or LCS_NONE */ 
</span><a name="LN517"></a>    <a href="lockoptions.h.html#LN35"><span class='Ref_to_Enum'>LockWaitPolicy</span></a> <span class='Declare_Member'>waitPolicy</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* NOWAIT and SKIP LOCKED */ 
</span><a name="LN518"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ermActive</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* is this mark relevant for current tuple? */ 
</span><a name="LN519"></a>    <a href="../storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Member'>curCtid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* ctid of currently locked tuple, if any */ 
</span><a name="LN520"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>ermExtra</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* available for use by relation source node */ 
</span><a name="LN521"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ExecRowMark</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ExecAuxRowMark - 
 *     additional runtime representation of FOR [KEY] UPDATE/SHARE clauses 
 * 
 * Each LockRows and ModifyTable node keeps a list of the rowmarks it needs to 
 * deal with.  In addition to a pointer to the related entry in es_rowMarks, 
 * this struct carries the column number(s) of the resjunk columns associated 
 * with the rowmark (see comments for PlanRowMark for more detail).  In the 
 * case of ModifyTable, there has to be a separate ExecAuxRowMark list for 
 * each child plan, because the resjunk columns could be at different physical 
 * column positions in different subplans. 
 */ 
</span><a name="LN535"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ExecAuxRowMark</span> 
<span class='Delimiter'>{ 
</span><a name="LN537"></a>    <a href="execnodes.h.html#LN508"><span class='Ref_to_Struct'>ExecRowMark</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rowmark</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* related entry in es_rowMarks */ 
</span><a name="LN538"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>ctidAttNo</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* resno of ctid junk attribute, if any */ 
</span><a name="LN539"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>toidAttNo</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* resno of tableoid junk attribute, if any */ 
</span><a name="LN540"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>wholeAttNo</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* resno of whole-row junk attribute, if any */ 
</span><a name="LN541"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ExecAuxRowMark</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *               Tuple Hash Tables 
 * 
 * All-in-memory tuple hash tables are used for a number of purposes. 
 * 
 * Note: tab_hash_funcs are for the key datatype(s) stored in the table, 
 * and tab_eq_funcs are non-cross-type equality operators for those types. 
 * Normally these are the only functions used, but FindTupleHashEntry() 
 * supports searching a hashtable using cross-data-type hashing.  For that, 
 * the caller must supply hash functions for the LHS datatype as well as 
 * the cross-type equality operators to use.  in_hash_funcs and cur_eq_funcs 
 * are set to point to the caller's function arrays while doing such a search. 
 * During LookupTupleHashEntry(), they point to tab_hash_funcs and 
 * tab_eq_funcs respectively. 
 * ---------------------------------------------------------------- 
 */ 
</span><a name="LN560"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>TupleHashEntry</span><span class='Delimiter'>; 
</span><a name="LN561"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="execnodes.h.html#LN579"><span class='Ref_to_Struct'>TupleHashTableData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>TupleHashTable</span><span class='Delimiter'>; 
</span> 
<a name="LN563"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TupleHashEntryData</span> 
<span class='Delimiter'>{ 
</span><a name="LN565"></a>    <a href="../access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Member'>firstTuple</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* copy of first tuple in this group */ 
</span><a name="LN566"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>additional</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* user data */ 
</span><a name="LN567"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>status</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* hash status */ 
</span><a name="LN568"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>hash</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* hash value (cached) */ 
</span><a name="LN569"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TupleHashEntryData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* define paramters necessary to generate the tuple hash table interface */ 
</span><a name="LN572"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_PREFIX</span> tuplehash 
<a name="LN573"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_ELEMENT_TYPE</span> <a href="execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> 
<a name="LN574"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_KEY_TYPE</span> <a href="../access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> 
<a name="LN575"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_SCOPE</span> <span class='Keyword'>extern 
</span><a name="LN576"></a>#define <span class='Declare_Constant'>SH_DECLARE</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/simplehash.h"</span> 
 
<a name="LN579"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TupleHashTableData</span> 
<span class='Delimiter'>{ 
</span><a name="LN581"></a>    tuplehash_hash <span class='Operator'>*</span><span class='Declare_Member'>hashtab</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* underlying hash table */ 
</span><a name="LN582"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of columns in lookup key */ 
</span><a name="LN583"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>keyColIdx</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* attr numbers of key columns */ 
</span><a name="LN584"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>tab_hash_funcs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* hash functions for table datatype(s) */ 
</span><a name="LN585"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>tab_eq_funcs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality functions for table datatype(s) */ 
</span><a name="LN586"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tablecxt</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* memory context containing table */ 
</span><a name="LN587"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tempcxt</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* context for function evaluations */ 
</span><a name="LN588"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>entrysize</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* actual size to make each hash entry */ 
</span><a name="LN589"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tableslot</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* slot for referencing table entries */ 
</span>    <span class='Comment_Multi_Line'>/* The following fields are set transiently for each table search: */ 
</span><a name="LN591"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>inputslot</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* current input tuple's slot */ 
</span><a name="LN592"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>in_hash_funcs</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* hash functions for input datatype(s) */ 
</span><a name="LN593"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>cur_eq_funcs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality functions for input vs. table */ 
</span><a name="LN594"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>hash_iv</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* hash-function IV */ 
</span><a name="LN595"></a><span class='Delimiter'>}</span>   <span class='Declare_Typedef'>TupleHashTableData</span><span class='Delimiter'>; 
</span> 
<a name="LN597"></a><span class='Control'>typedef</span> tuplehash_iterator <span class='Declare_Typedef'>TupleHashIterator</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Use InitTupleHashIterator/TermTupleHashIterator for a read/write scan. 
 * Use ResetTupleHashIterator if the table can be frozen (in this case no 
 * explicit scan termination is needed). 
 */ 
</span><a name="LN604"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>InitTupleHashIterator</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>htable</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>iter</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    tuplehash_start_iterate<span class='Parentheses'>(</span><a href="execnodes.h.html#LN604"><span class='Ref_to_Parameter'>htable</span></a><span class='Operator'>-&GT;</span>hashtab<span class='Delimiter'>, </span><a href="execnodes.h.html#LN604"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>) 
</span><a name="LN606"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>TermTupleHashIterator</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>iter</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
<a name="LN608"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>ResetTupleHashIterator</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>htable</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>iter</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <a href="execnodes.h.html#LN604"><span class='Ref_to_Macro'>InitTupleHashIterator</span></a><span class='Parentheses'>(</span><a href="execnodes.h.html#LN608"><span class='Ref_to_Parameter'>htable</span></a><span class='Delimiter'>, </span><a href="execnodes.h.html#LN608"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>) 
</span><a name="LN610"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>ScanTupleHashTable</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>htable</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>iter</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    tuplehash_iterate<span class='Parentheses'>(</span><a href="execnodes.h.html#LN610"><span class='Ref_to_Parameter'>htable</span></a><span class='Operator'>-&GT;</span>hashtab<span class='Delimiter'>, </span><a href="execnodes.h.html#LN610"><span class='Ref_to_Parameter'>iter</span></a><span class='Parentheses'>) 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *               Expression State Nodes 
 * 
 * Formerly, there was a separate executor expression state node corresponding 
 * to each node in a planned expression tree.  That's no longer the case; for 
 * common expression node types, all the execution info is embedded into 
 * step(s) in a single ExprState node.  But we still have a few executor state 
 * node types for selected expression node types, mostly those in which info 
 * has to be shared with other parts of the execution state tree. 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      AggrefExprState node 
 * ---------------- 
 */ 
</span><a name="LN630"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggrefExprState</span> 
<span class='Delimiter'>{ 
</span><a name="LN632"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN633"></a>    <a href="primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>aggref</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* expression plan node */ 
</span><a name="LN634"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>aggno</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* ID number for agg within its plan node */ 
</span><a name="LN635"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AggrefExprState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      WindowFuncExprState node 
 * ---------------- 
 */ 
</span><a name="LN641"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WindowFuncExprState</span> 
<span class='Delimiter'>{ 
</span><a name="LN643"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN644"></a>    <a href="primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Member'>wfunc</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* expression plan node */ 
</span><a name="LN645"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ExprStates for argument expressions */ 
</span><a name="LN646"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>aggfilter</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* FILTER expression */ 
</span><a name="LN647"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>wfuncno</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* ID number for wfunc within its plan node */ 
</span><a name="LN648"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WindowFuncExprState</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      SetExprState node 
 * 
 * State for evaluating a potentially set-returning expression (like FuncExpr 
 * or OpExpr).  In some cases, like some of the expressions in ROWS FROM(...) 
 * the expression might not be a SRF, but nonetheless it uses the same 
 * machinery as SRFs; it will be treated as a SRF returning a single row. 
 * ---------------- 
 */ 
</span><a name="LN660"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SetExprState</span> 
<span class='Delimiter'>{ 
</span><a name="LN662"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN663"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expression plan node */ 
</span><a name="LN664"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ExprStates for argument expressions */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In ROWS FROM, functions can be inlined, removing the FuncExpr normally 
     * inside.  In such a case this is the compiled expression (which cannot 
     * return a set), which'll be evaluated using regular ExecEvalExpr(). 
     */ 
</span><a name="LN671"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>elidedFuncState</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Function manager's lookup info for the target function.  If func.fn_oid 
     * is InvalidOid, we haven't initialized it yet (nor any of the following 
     * fields, except funcReturnsSet). 
     */ 
</span><a name="LN678"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Member'>func</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For a set-returning function (SRF) that returns a tuplestore, we keep 
     * the tuplestore here and dole out the result rows one at a time. The 
     * slot holds the row currently being returned. 
     */ 
</span><a name="LN685"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>funcResultStore</span><span class='Delimiter'>; 
</span><a name="LN686"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>funcResultSlot</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In some cases we need to compute a tuple descriptor for the function's 
     * output.  If so, it's stored here. 
     */ 
</span><a name="LN692"></a>    <a href="../access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>funcResultDesc</span><span class='Delimiter'>; 
</span><a name="LN693"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>funcReturnsTuple</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* valid when funcResultDesc isn't 
                                         * NULL */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remember whether the function is declared to return a set.  This is set 
     * by ExecInitExpr, and is valid even before the FmgrInfo is set up. 
     */ 
</span><a name="LN700"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>funcReturnsSet</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * setArgsValid is true when we are evaluating a set-returning function 
     * that uses value-per-call mode and we are in the middle of a call 
     * series; we want to pass the same argument values to the function again 
     * (and again, until it returns ExprEndResult).  This indicates that 
     * fcinfo_data already contains valid argument data. 
     */ 
</span><a name="LN709"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>setArgsValid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Flag to remember whether we have registered a shutdown callback for 
     * this SetExprState.  We do so only if funcResultStore or setArgsValid 
     * has been set at least once (since all the callback is for is to release 
     * the tuplestore or clear setArgsValid). 
     */ 
</span><a name="LN717"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>shutdown_reg</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* a shutdown callback is registered */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Call parameter structure for the function.  This has been initialized 
     * (by InitFunctionCallInfoData) if func.fn_oid is valid.  It also saves 
     * argument values between calls, when setArgsValid is true. 
     */ 
</span><a name="LN724"></a>    <a href="../fmgr.h.html#LN76"><span class='Ref_to_Struct'>FunctionCallInfoData</span></a> <span class='Declare_Member'>fcinfo_data</span><span class='Delimiter'>; 
</span><a name="LN725"></a>}<span class='Auto_Annotations'> &laquo; end SetExprState &raquo; </span> <span class='Declare_Typedef'>SetExprState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      SubPlanState node 
 * ---------------- 
 */ 
</span><a name="LN731"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SubPlanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN733"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN734"></a>    <a href="primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a>    <span class='Operator'>*</span><span class='Declare_Member'>subplan</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* expression plan node */ 
</span><a name="LN735"></a>    <span class='Control'>struct</span> <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>planstate</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* subselect plan's state tree */ 
</span><a name="LN736"></a>    <span class='Control'>struct</span> <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>parent</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* parent plan node's state tree */ 
</span><a name="LN737"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>testexpr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* state of combining expression */ 
</span><a name="LN738"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* states of argument expression(s) */ 
</span><a name="LN739"></a>    <a href="../access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Member'>curTuple</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* copy of most recent tuple from subplan */ 
</span><a name="LN740"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>curArray</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* most recent array from ARRAY() subplan */ 
</span>    <span class='Comment_Multi_Line'>/* these are used when hashing the subselect's output: */ 
</span><a name="LN742"></a>    <a href="execnodes.h.html#LN291"><span class='Ref_to_Struct'>ProjectionInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>projLeft</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* for projecting lefthand exprs */ 
</span><a name="LN743"></a>    <a href="execnodes.h.html#LN291"><span class='Ref_to_Struct'>ProjectionInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>projRight</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* for projecting subselect output */ 
</span><a name="LN744"></a>    <a href="execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Member'>hashtable</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hash table for no-nulls subselect rows */ 
</span><a name="LN745"></a>    <a href="execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Member'>hashnulls</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hash table for rows with null(s) */ 
</span><a name="LN746"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>havehashrows</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* TRUE if hashtable is not empty */ 
</span><a name="LN747"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>havenullrows</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* TRUE if hashnulls is not empty */ 
</span><a name="LN748"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>hashtablecxt</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* memory context containing hash tables */ 
</span><a name="LN749"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>hashtempcxt</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* temp memory context for hash tables */ 
</span><a name="LN750"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>innerecontext</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* econtext for computing inner tuples */ 
</span><a name="LN751"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>keyColIdx</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* control data for hash tables */ 
</span><a name="LN752"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>tab_hash_funcs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* hash functions for table datatype(s) */ 
</span><a name="LN753"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>tab_eq_funcs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality functions for table datatype(s) */ 
</span><a name="LN754"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>lhs_hash_funcs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* hash functions for lefthand datatype(s) */ 
</span><a name="LN755"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>cur_eq_funcs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality functions for LHS vs. table */ 
</span><a name="LN756"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end SubPlanState &raquo; </span> <span class='Declare_Typedef'>SubPlanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      AlternativeSubPlanState node 
 * ---------------- 
 */ 
</span><a name="LN762"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlternativeSubPlanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN764"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN765"></a>    <a href="primnodes.h.html#LN722"><span class='Ref_to_Struct'>AlternativeSubPlan</span></a> <span class='Operator'>*</span><span class='Declare_Member'>subplan</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expression plan node */ 
</span><a name="LN766"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subplans</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* SubPlanStates of alternative subplans */ 
</span><a name="LN767"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>active</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* list index of the one we're using */ 
</span><a name="LN768"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlternativeSubPlanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * DomainConstraintState - one item to check during CoerceToDomain 
 * 
 * Note: we consider this to be part of an ExprState tree, so we give it 
 * a name following the xxxState convention.  But there's no directly 
 * associated plan-tree node. 
 */ 
</span><a name="LN777"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>DomainConstraintType</span> 
<span class='Delimiter'>{ 
</span><a name="LN779"></a>    <span class='Declare_Enum_Const'>DOM_CONSTRAINT_NOTNULL</span><span class='Delimiter'>, 
</span><a name="LN780"></a>    <span class='Declare_Enum_Const'>DOM_CONSTRAINT_CHECK</span> 
<a name="LN781"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DomainConstraintType</span><span class='Delimiter'>; 
</span> 
<a name="LN783"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DomainConstraintState</span> 
<span class='Delimiter'>{ 
</span><a name="LN785"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN786"></a>    <a href="execnodes.h.html#LN777"><span class='Ref_to_Enum'>DomainConstraintType</span></a> <span class='Declare_Member'>constrainttype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* constraint type */ 
</span><a name="LN787"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* name of constraint (for error msgs) */ 
</span><a name="LN788"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>check_expr</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* for CHECK, a boolean expression */ 
</span><a name="LN789"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>check_exprstate</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* check_expr's eval state, or NULL */ 
</span><a name="LN790"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DomainConstraintState</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *               Executor State Trees 
 * 
 * An executing query has a PlanState tree paralleling the Plan tree 
 * that describes the plan. 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      PlanState node 
 * 
 * We never actually instantiate any PlanState nodes; this is just the common 
 * abstract superclass for all PlanState-type nodes. 
 * ---------------- 
 */ 
</span><a name="LN808"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN810"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN812"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>plan</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* associated Plan node */ 
</span> 
<a name="LN814"></a>    <a href="execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>state</span><span class='Delimiter'>;</span>          <span class='Comment_Multi_Line'>/* at execution time, states of individual 
                                 * nodes point to one EState for the whole 
                                 * top-level plan */ 
</span> 
<a name="LN818"></a>    <a href="../executor/instrument.h.html#LN43"><span class='Ref_to_Struct'>Instrumentation</span></a> <span class='Operator'>*</span><span class='Declare_Member'>instrument</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Optional runtime stats for this node */ 
</span><a name="LN819"></a>    <a href="../executor/instrument.h.html#LN65"><span class='Ref_to_Struct'>WorkerInstrumentation</span></a> <span class='Operator'>*</span><span class='Declare_Member'>worker_instrument</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* per-worker instrumentation */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Common structural data for all Plan types.  These links to subsidiary 
     * state trees parallel links in the associated plan tree (except for the 
     * subPlan list, which does not exist in the plan tree). 
     */ 
</span><a name="LN826"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* boolean qual condition */ 
</span><a name="LN827"></a>    <span class='Control'>struct</span> <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>lefttree</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* input plan tree(s) */ 
</span><a name="LN828"></a>    <span class='Control'>struct</span> <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>righttree</span><span class='Delimiter'>; 
</span><a name="LN829"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>initPlan</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* Init SubPlanState nodes (un-correlated expr 
                                 * subselects) */ 
</span><a name="LN831"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subPlan</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* SubPlanState nodes in my expressions */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * State for management of parameter-change-driven rescanning 
     */ 
</span><a name="LN836"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>chgParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* set of IDs of changed Params */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Other run-time state needed by most if not all node types. 
     */ 
</span><a name="LN841"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ps_ResultTupleSlot</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* slot for my result tuples */ 
</span><a name="LN842"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ps_ExprContext</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* node's expression-evaluation context */ 
</span><a name="LN843"></a>    <a href="execnodes.h.html#LN291"><span class='Ref_to_Struct'>ProjectionInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ps_ProjInfo</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* info for doing tuple projection */ 
</span><a name="LN844"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end PlanState &raquo; </span> <span class='Declare_Typedef'>PlanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *  these are defined to avoid confusion problems with "left" 
 *  and "right" and "inner" and "outer".  The convention is that 
 *  the "left" plan is the "outer" plan and the "right" plan is 
 *  the inner plan, but these make the code more readable. 
 * ---------------- 
 */ 
</span><a name="LN853"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>innerPlanState</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span>        <span class='Parentheses'>(((</span><a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="execnodes.h.html#LN853"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>righttree<span class='Parentheses'>)</span> 
<a name="LN854"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>outerPlanState</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span>        <span class='Parentheses'>(((</span><a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="execnodes.h.html#LN854"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>lefttree<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* Macros for inline access to certain instrumentation counters */ 
</span><a name="LN857"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>InstrCountFiltered1</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>delta</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="execnodes.h.html#LN857"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>instrument<span class='Parentheses'>)</span> <span class='Operator'>\ 
</span>            <span class='Parentheses'>((</span><a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="execnodes.h.html#LN857"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>instrument<span class='Operator'>-&GT;</span>nfiltered1 <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="execnodes.h.html#LN857"><span class='Ref_to_Parameter'>delta</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span><a name="LN862"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>InstrCountFiltered2</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>delta</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="execnodes.h.html#LN862"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>instrument<span class='Parentheses'>)</span> <span class='Operator'>\ 
</span>            <span class='Parentheses'>((</span><a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="execnodes.h.html#LN862"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>instrument<span class='Operator'>-&GT;</span>nfiltered2 <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="execnodes.h.html#LN862"><span class='Ref_to_Parameter'>delta</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * EPQState is state for executing an EvalPlanQual recheck on a candidate 
 * tuple in ModifyTable or LockRows.  The estate and planstate fields are 
 * NULL if inactive. 
 */ 
</span><a name="LN873"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>EPQState</span> 
<span class='Delimiter'>{ 
</span><a name="LN875"></a>    <a href="execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>estate</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* subsidiary EState */ 
</span><a name="LN876"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>planstate</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* plan state tree ready to be executed */ 
</span><a name="LN877"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>origslot</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* original output tuple to be rechecked */ 
</span><a name="LN878"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>plan</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* plan tree to be executed */ 
</span><a name="LN879"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arowMarks</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ExecAuxRowMarks (non-locking only) */ 
</span><a name="LN880"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>epqParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ID of Param to force scan node re-eval */ 
</span><a name="LN881"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>EPQState</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ResultState information 
 * ---------------- 
 */ 
</span><a name="LN888"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ResultState</span> 
<span class='Delimiter'>{ 
</span><a name="LN890"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN891"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>resconstantqual</span><span class='Delimiter'>; 
</span><a name="LN892"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>rs_done</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* are we done? */ 
</span><a name="LN893"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>rs_checkqual</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* do we need to check the qual? */ 
</span><a name="LN894"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ResultState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ProjectSetState information 
 * 
 * Note: at least one of the "elems" will be a SetExprState; the rest are 
 * regular ExprStates. 
 * ---------------- 
 */ 
</span><a name="LN903"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ProjectSetState</span> 
<span class='Delimiter'>{ 
</span><a name="LN905"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN906"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>      <span class='Operator'>**</span><span class='Declare_Member'>elems</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* array of expression states */ 
</span><a name="LN907"></a>    <a href="execnodes.h.html#LN234"><span class='Ref_to_Typedef'>ExprDoneCond</span></a> <span class='Operator'>*</span><span class='Declare_Member'>elemdone</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* array of per-SRF is-done states */ 
</span><a name="LN908"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nelems</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* length of elemdone[] array */ 
</span><a name="LN909"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>pending_srf_tuples</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* still evaluating srfs in tlist? */ 
</span><a name="LN910"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ProjectSetState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ModifyTableState information 
 * ---------------- 
 */ 
</span><a name="LN916"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ModifyTableState</span> 
<span class='Delimiter'>{ 
</span><a name="LN918"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN919"></a>    <a href="nodes.h.html#LN647"><span class='Ref_to_Enum'>CmdType</span></a>     <span class='Declare_Member'>operation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* INSERT, UPDATE, or DELETE */ 
</span><a name="LN920"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>canSetTag</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* do we set the command tag/es_processed? */ 
</span><a name="LN921"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mt_done</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* are we done? */ 
</span><a name="LN922"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>**</span><span class='Declare_Member'>mt_plans</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* subplans (one per target rel) */ 
</span><a name="LN923"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>mt_nplans</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* number of plans in the array */ 
</span><a name="LN924"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>mt_whichplan</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* which one is being executed (0..n-1) */ 
</span><a name="LN925"></a>    <a href="execnodes.h.html#LN369"><span class='Ref_to_Struct'>ResultRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>resultRelInfo</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* per-subplan target relations */ 
</span><a name="LN926"></a>    <a href="execnodes.h.html#LN369"><span class='Ref_to_Struct'>ResultRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rootResultRelInfo</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* root target relation (partitioned 
                                         * table root) */ 
</span><a name="LN928"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Member'>mt_arowmarks</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* per-subplan ExecAuxRowMark lists */ 
</span><a name="LN929"></a>    <a href="execnodes.h.html#LN873"><span class='Ref_to_Struct'>EPQState</span></a>    <span class='Declare_Member'>mt_epqstate</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* for evaluating EvalPlanQual rechecks */ 
</span><a name="LN930"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>fireBSTriggers</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* do we need to fire stmt triggers? */ 
</span><a name="LN931"></a>    <a href="nodes.h.html#LN797"><span class='Ref_to_Enum'>OnConflictAction</span></a> <span class='Declare_Member'>mt_onconflict</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* ON CONFLICT type */ 
</span><a name="LN932"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>mt_arbiterindexes</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* unique index OIDs to arbitrate 
                                         * taking alt path */ 
</span><a name="LN934"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mt_existing</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* slot to store existing target tuple in */ 
</span><a name="LN935"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>mt_excludedtlist</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* the excluded pseudo relation's 
                                         * tlist  */ 
</span><a name="LN937"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mt_conflproj</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* CONFLICT ... SET ... projection 
                                         * target */ 
</span><a name="LN939"></a>    <span class='Control'>struct</span> <a href="../catalog/partition.h.html#LN59"><span class='Ref_to_Struct'>PartitionDispatchData</span></a> <span class='Operator'>**</span><span class='Declare_Member'>mt_partition_dispatch_info</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Tuple-routing support info */ 
</span><a name="LN941"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>mt_num_dispatch</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Number of entries in the above array */ 
</span><a name="LN942"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>mt_num_partitions</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* Number of members in the following 
                                         * arrays */ 
</span><a name="LN944"></a>    <a href="execnodes.h.html#LN369"><span class='Ref_to_Struct'>ResultRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mt_partitions</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Per partition result relation */ 
</span><a name="LN945"></a>    <a href="../access/tupconvert.h.html#LN20"><span class='Ref_to_Struct'>TupleConversionMap</span></a> <span class='Operator'>**</span><span class='Declare_Member'>mt_partition_tupconv_maps</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Per partition tuple conversion map */ 
</span><a name="LN947"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mt_partition_tuple_slot</span><span class='Delimiter'>; 
</span><a name="LN948"></a>}<span class='Auto_Annotations'> &laquo; end ModifyTableState &raquo; </span> <span class='Declare_Typedef'>ModifyTableState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   AppendState information 
 * 
 *      nplans          how many plans are in the array 
 *      whichplan       which plan is being executed (0 .. n-1) 
 * ---------------- 
 */ 
</span><a name="LN957"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AppendState</span> 
<span class='Delimiter'>{ 
</span><a name="LN959"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN960"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>**</span><span class='Declare_Member'>appendplans</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of PlanStates for my inputs */ 
</span><a name="LN961"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>as_nplans</span><span class='Delimiter'>; 
</span><a name="LN962"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>as_whichplan</span><span class='Delimiter'>; 
</span><a name="LN963"></a>} <span class='Declare_Typedef'>AppendState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   MergeAppendState information 
 * 
 *      nplans          how many plans are in the array 
 *      nkeys           number of sort key columns 
 *      sortkeys        sort keys in SortSupport representation 
 *      slots           current output tuple of each subplan 
 *      heap            heap of active tuples 
 *      initialized     true if we have fetched first tuple from each subplan 
 * ---------------- 
 */ 
</span><a name="LN976"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MergeAppendState</span> 
<span class='Delimiter'>{ 
</span><a name="LN978"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN979"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>**</span><span class='Declare_Member'>mergeplans</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* array of PlanStates for my inputs */ 
</span><a name="LN980"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ms_nplans</span><span class='Delimiter'>; 
</span><a name="LN981"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ms_nkeys</span><span class='Delimiter'>; 
</span><a name="LN982"></a>    <a href="../utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Member'>ms_sortkeys</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of length ms_nkeys */ 
</span><a name="LN983"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>**</span><span class='Declare_Member'>ms_slots</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* array of length ms_nplans */ 
</span><a name="LN984"></a>    <span class='Control'>struct</span> <a href="../lib/binaryheap.h.html#LN29"><span class='Ref_to_Struct'>binaryheap</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ms_heap</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* binary heap of slot indices */ 
</span><a name="LN985"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ms_initialized</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* are subplans started? */ 
</span><a name="LN986"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MergeAppendState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   RecursiveUnionState information 
 * 
 *      RecursiveUnionState is used for performing a recursive union. 
 * 
 *      recursing           T when we're done scanning the non-recursive term 
 *      intermediate_empty  T if intermediate_table is currently empty 
 *      working_table       working table (to be scanned by recursive term) 
 *      intermediate_table  current recursive output (next generation of WT) 
 * ---------------- 
 */ 
</span><a name="LN999"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RecursiveUnionState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1001"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1002"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>recursing</span><span class='Delimiter'>; 
</span><a name="LN1003"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>intermediate_empty</span><span class='Delimiter'>; 
</span><a name="LN1004"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>working_table</span><span class='Delimiter'>; 
</span><a name="LN1005"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>intermediate_table</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Remaining fields are unused in UNION ALL case */ 
</span><a name="LN1007"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>eqfunctions</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-grouping-field equality fns */ 
</span><a name="LN1008"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>hashfunctions</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* per-grouping-field hash fns */ 
</span><a name="LN1009"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tempContext</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* short-term context for comparisons */ 
</span><a name="LN1010"></a>    <a href="execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Member'>hashtable</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hash table for tuples already seen */ 
</span><a name="LN1011"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tableContext</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* memory context containing hash table */ 
</span><a name="LN1012"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RecursiveUnionState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   BitmapAndState information 
 * ---------------- 
 */ 
</span><a name="LN1018"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapAndState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1020"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1021"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>**</span><span class='Declare_Member'>bitmapplans</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of PlanStates for my inputs */ 
</span><a name="LN1022"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nplans</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* number of input plans */ 
</span><a name="LN1023"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BitmapAndState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   BitmapOrState information 
 * ---------------- 
 */ 
</span><a name="LN1029"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapOrState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1031"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1032"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>**</span><span class='Declare_Member'>bitmapplans</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of PlanStates for my inputs */ 
</span><a name="LN1033"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nplans</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* number of input plans */ 
</span><a name="LN1034"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BitmapOrState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *               Scan State Information 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ScanState information 
 * 
 *      ScanState extends PlanState for node types that represent 
 *      scans of an underlying relation.  It can also be used for nodes 
 *      that scan the output of an underlying plan node --- in that case, 
 *      only ScanTupleSlot is actually useful, and it refers to the tuple 
 *      retrieved from the subplan. 
 * 
 *      currentRelation    relation being scanned (NULL if none) 
 *      currentScanDesc    current scan descriptor for scan (NULL if none) 
 *      ScanTupleSlot      pointer to slot in tuple table holding scan tuple 
 * ---------------- 
 */ 
</span><a name="LN1055"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1057"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1058"></a>    <a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>ss_currentRelation</span><span class='Delimiter'>; 
</span><a name="LN1059"></a>    <a href="../access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Member'>ss_currentScanDesc</span><span class='Delimiter'>; 
</span><a name="LN1060"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ss_ScanTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1061"></a>} <span class='Declare_Typedef'>ScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   SeqScanState information 
 * ---------------- 
 */ 
</span><a name="LN1067"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SeqScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1069"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1070"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>pscan_len</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* size of parallel heap scan descriptor */ 
</span><a name="LN1071"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SeqScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   SampleScanState information 
 * ---------------- 
 */ 
</span><a name="LN1077"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SampleScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1079"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>; 
</span><a name="LN1080"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expr states for TABLESAMPLE params */ 
</span><a name="LN1081"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>repeatable</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* expr state for REPEATABLE expr */ 
</span>    <span class='Comment_Multi_Line'>/* use struct pointer to avoid including tsmapi.h here */ 
</span><a name="LN1083"></a>    <span class='Control'>struct</span> <a href="../access/tsmapi.h.html#LN54"><span class='Ref_to_Struct'>TsmRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tsmroutine</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* descriptor for tablesample method */ 
</span><a name="LN1084"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>tsm_state</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* tablesample method can keep state here */ 
</span><a name="LN1085"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>use_bulkread</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* use bulkread buffer access strategy? */ 
</span><a name="LN1086"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>use_pagemode</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* use page-at-a-time visibility checking? */ 
</span><a name="LN1087"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>begun</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* false means need to call BeginSampleScan */ 
</span><a name="LN1088"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>seed</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* random seed */ 
</span><a name="LN1089"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SampleScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * These structs store information about index quals that don't have simple 
 * constant right-hand sides.  See comments for ExecIndexBuildScanKeys() 
 * for discussion. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN1098"></a>    <a href="../access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Member'>scan_key</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* scankey to put value into */ 
</span><a name="LN1099"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>key_expr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* expr to evaluate to get value */ 
</span><a name="LN1100"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>key_toastable</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* is expr's result a toastable datatype? */ 
</span><a name="LN1101"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>IndexRuntimeKeyInfo</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN1105"></a>    <a href="../access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Member'>scan_key</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* scankey to put value into */ 
</span><a name="LN1106"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>array_expr</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* expr to evaluate to get array value */ 
</span><a name="LN1107"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>next_elem</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* next array element to use */ 
</span><a name="LN1108"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_elems</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* number of elems in current array value */ 
</span><a name="LN1109"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>elem_values</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of num_elems Datums */ 
</span><a name="LN1110"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>elem_nulls</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* array of num_elems is-null flags */ 
</span><a name="LN1111"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>IndexArrayKeyInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   IndexScanState information 
 * 
 *      indexqualorig      execution state for indexqualorig expressions 
 *      indexorderbyorig   execution state for indexorderbyorig expressions 
 *      ScanKeys           Skey structures for index quals 
 *      NumScanKeys        number of ScanKeys 
 *      OrderByKeys        Skey structures for index ordering operators 
 *      NumOrderByKeys     number of OrderByKeys 
 *      RuntimeKeys        info about Skeys that must be evaluated at runtime 
 *      NumRuntimeKeys     number of RuntimeKeys 
 *      RuntimeKeysReady   true if runtime Skeys have been computed 
 *      RuntimeContext     expr context for evaling runtime Skeys 
 *      RelationDesc       index relation descriptor 
 *      ScanDesc           index scan descriptor 
 * 
 *      ReorderQueue       tuples that need reordering due to re-check 
 *      ReachedEnd         have we fetched all tuples from index already? 
 *      OrderByValues      values of ORDER BY exprs of last fetched tuple 
 *      OrderByNulls       null flags for OrderByValues 
 *      SortSupport        for reordering ORDER BY exprs 
 *      OrderByTypByVals   is the datatype of order by expression pass-by-value? 
 *      OrderByTypLens     typlens of the datatypes of order by expressions 
 *      pscan_len          size of parallel index scan descriptor 
 * ---------------- 
 */ 
</span><a name="LN1139"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1141"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1142"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>indexqualorig</span><span class='Delimiter'>; 
</span><a name="LN1143"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexorderbyorig</span><span class='Delimiter'>; 
</span><a name="LN1144"></a>    <a href="../access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Member'>iss_ScanKeys</span><span class='Delimiter'>; 
</span><a name="LN1145"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>iss_NumScanKeys</span><span class='Delimiter'>; 
</span><a name="LN1146"></a>    <a href="../access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Member'>iss_OrderByKeys</span><span class='Delimiter'>; 
</span><a name="LN1147"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>iss_NumOrderByKeys</span><span class='Delimiter'>; 
</span><a name="LN1148"></a>    <a href="execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>iss_RuntimeKeys</span><span class='Delimiter'>; 
</span><a name="LN1149"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>iss_NumRuntimeKeys</span><span class='Delimiter'>; 
</span><a name="LN1150"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>iss_RuntimeKeysReady</span><span class='Delimiter'>; 
</span><a name="LN1151"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>iss_RuntimeContext</span><span class='Delimiter'>; 
</span><a name="LN1152"></a>    <a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>iss_RelationDesc</span><span class='Delimiter'>; 
</span><a name="LN1153"></a>    <a href="../access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Member'>iss_ScanDesc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* These are needed for re-checking ORDER BY expr ordering */ 
</span><a name="LN1156"></a>    <a href="../lib/pairingheap.h.html#LN70"><span class='Ref_to_Struct'>pairingheap</span></a> <span class='Operator'>*</span><span class='Declare_Member'>iss_ReorderQueue</span><span class='Delimiter'>; 
</span><a name="LN1157"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>iss_ReachedEnd</span><span class='Delimiter'>; 
</span><a name="LN1158"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>iss_OrderByValues</span><span class='Delimiter'>; 
</span><a name="LN1159"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>iss_OrderByNulls</span><span class='Delimiter'>; 
</span><a name="LN1160"></a>    <a href="../utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Member'>iss_SortSupport</span><span class='Delimiter'>; 
</span><a name="LN1161"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>iss_OrderByTypByVals</span><span class='Delimiter'>; 
</span><a name="LN1162"></a>    <a href="../c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>iss_OrderByTypLens</span><span class='Delimiter'>; 
</span><a name="LN1163"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>iss_PscanLen</span><span class='Delimiter'>; 
</span><a name="LN1164"></a>}<span class='Auto_Annotations'> &laquo; end IndexScanState &raquo; </span> <span class='Declare_Typedef'>IndexScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   IndexOnlyScanState information 
 * 
 *      indexqual          execution state for indexqual expressions 
 *      ScanKeys           Skey structures for index quals 
 *      NumScanKeys        number of ScanKeys 
 *      OrderByKeys        Skey structures for index ordering operators 
 *      NumOrderByKeys     number of OrderByKeys 
 *      RuntimeKeys        info about Skeys that must be evaluated at runtime 
 *      NumRuntimeKeys     number of RuntimeKeys 
 *      RuntimeKeysReady   true if runtime Skeys have been computed 
 *      RuntimeContext     expr context for evaling runtime Skeys 
 *      RelationDesc       index relation descriptor 
 *      ScanDesc           index scan descriptor 
 *      VMBuffer           buffer in use for visibility map testing, if any 
 *      HeapFetches        number of tuples we were forced to fetch from heap 
 *      ioss_PscanLen      Size of parallel index-only scan descriptor 
 * ---------------- 
 */ 
</span><a name="LN1185"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexOnlyScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1187"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1188"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>indexqual</span><span class='Delimiter'>; 
</span><a name="LN1189"></a>    <a href="../access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Member'>ioss_ScanKeys</span><span class='Delimiter'>; 
</span><a name="LN1190"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ioss_NumScanKeys</span><span class='Delimiter'>; 
</span><a name="LN1191"></a>    <a href="../access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Member'>ioss_OrderByKeys</span><span class='Delimiter'>; 
</span><a name="LN1192"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ioss_NumOrderByKeys</span><span class='Delimiter'>; 
</span><a name="LN1193"></a>    <a href="execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ioss_RuntimeKeys</span><span class='Delimiter'>; 
</span><a name="LN1194"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ioss_NumRuntimeKeys</span><span class='Delimiter'>; 
</span><a name="LN1195"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ioss_RuntimeKeysReady</span><span class='Delimiter'>; 
</span><a name="LN1196"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ioss_RuntimeContext</span><span class='Delimiter'>; 
</span><a name="LN1197"></a>    <a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>ioss_RelationDesc</span><span class='Delimiter'>; 
</span><a name="LN1198"></a>    <a href="../access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Member'>ioss_ScanDesc</span><span class='Delimiter'>; 
</span><a name="LN1199"></a>    <a href="../storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Member'>ioss_VMBuffer</span><span class='Delimiter'>; 
</span><a name="LN1200"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>ioss_HeapFetches</span><span class='Delimiter'>; 
</span><a name="LN1201"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>ioss_PscanLen</span><span class='Delimiter'>; 
</span><a name="LN1202"></a>} <span class='Declare_Typedef'>IndexOnlyScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   BitmapIndexScanState information 
 * 
 *      result             bitmap to return output into, or NULL 
 *      ScanKeys           Skey structures for index quals 
 *      NumScanKeys        number of ScanKeys 
 *      RuntimeKeys        info about Skeys that must be evaluated at runtime 
 *      NumRuntimeKeys     number of RuntimeKeys 
 *      ArrayKeys          info about Skeys that come from ScalarArrayOpExprs 
 *      NumArrayKeys       number of ArrayKeys 
 *      RuntimeKeysReady   true if runtime Skeys have been computed 
 *      RuntimeContext     expr context for evaling runtime Skeys 
 *      RelationDesc       index relation descriptor 
 *      ScanDesc           index scan descriptor 
 * ---------------- 
 */ 
</span><a name="LN1220"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapIndexScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1222"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1223"></a>    <a href="../../backend/nodes/tidbitmap.c.html#LN146"><span class='Ref_to_Struct'>TIDBitmap</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>biss_result</span><span class='Delimiter'>; 
</span><a name="LN1224"></a>    <a href="../access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Member'>biss_ScanKeys</span><span class='Delimiter'>; 
</span><a name="LN1225"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>biss_NumScanKeys</span><span class='Delimiter'>; 
</span><a name="LN1226"></a>    <a href="execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>biss_RuntimeKeys</span><span class='Delimiter'>; 
</span><a name="LN1227"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>biss_NumRuntimeKeys</span><span class='Delimiter'>; 
</span><a name="LN1228"></a>    <a href="execnodes.h.html#LN1103"><span class='Ref_to_Typedef'>IndexArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>biss_ArrayKeys</span><span class='Delimiter'>; 
</span><a name="LN1229"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>biss_NumArrayKeys</span><span class='Delimiter'>; 
</span><a name="LN1230"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>biss_RuntimeKeysReady</span><span class='Delimiter'>; 
</span><a name="LN1231"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>biss_RuntimeContext</span><span class='Delimiter'>; 
</span><a name="LN1232"></a>    <a href="../utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>biss_RelationDesc</span><span class='Delimiter'>; 
</span><a name="LN1233"></a>    <a href="../access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Member'>biss_ScanDesc</span><span class='Delimiter'>; 
</span><a name="LN1234"></a>} <span class='Declare_Typedef'>BitmapIndexScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   SharedBitmapState information 
 * 
 *      BM_INITIAL      TIDBitmap creation is not yet started, so first worker 
 *                      to see this state will set the state to BM_INPROGRESS 
 *                      and that process will be responsible for creating 
 *                      TIDBitmap. 
 *      BM_INPROGRESS   TIDBitmap creation is in progress; workers need to 
 *                      sleep until it's finished. 
 *      BM_FINISHED     TIDBitmap creation is done, so now all workers can 
 *                      proceed to iterate over TIDBitmap. 
 * ---------------- 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN1251"></a>    <span class='Declare_Enum_Const'>BM_INITIAL</span><span class='Delimiter'>, 
</span><a name="LN1252"></a>    <span class='Declare_Enum_Const'>BM_INPROGRESS</span><span class='Delimiter'>, 
</span><a name="LN1253"></a>    <span class='Declare_Enum_Const'>BM_FINISHED</span> 
<a name="LN1254"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SharedBitmapState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ParallelBitmapHeapState information 
 *      tbmiterator             iterator for scanning current pages 
 *      prefetch_iterator       iterator for prefetching ahead of current page 
 *      mutex                   mutual exclusion for the prefetching variable 
 *                              and state 
 *      prefetch_pages          # pages prefetch iterator is ahead of current 
 *      prefetch_target         current target prefetch distance 
 *      state                   current state of the TIDBitmap 
 *      cv                      conditional wait variable 
 *      phs_snapshot_data       snapshot data shared to workers 
 * ---------------- 
 */ 
</span><a name="LN1269"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ParallelBitmapHeapState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1271"></a>    <a href="../utils/dsa.h.html#LN61"><span class='Ref_to_Typedef'>dsa_pointer</span></a> <span class='Declare_Member'>tbmiterator</span><span class='Delimiter'>; 
</span><a name="LN1272"></a>    <a href="../utils/dsa.h.html#LN61"><span class='Ref_to_Typedef'>dsa_pointer</span></a> <span class='Declare_Member'>prefetch_iterator</span><span class='Delimiter'>; 
</span><a name="LN1273"></a>    <a href="../storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a>     <span class='Declare_Member'>mutex</span><span class='Delimiter'>; 
</span><a name="LN1274"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>prefetch_pages</span><span class='Delimiter'>; 
</span><a name="LN1275"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>prefetch_target</span><span class='Delimiter'>; 
</span><a name="LN1276"></a>    <a href="execnodes.h.html#LN1249"><span class='Ref_to_Typedef'>SharedBitmapState</span></a> <span class='Declare_Member'>state</span><span class='Delimiter'>; 
</span><a name="LN1277"></a>    <a href="../storage/condition_variable.h.html#LN27"><span class='Ref_to_Typedef'>ConditionVariable</span></a> <span class='Declare_Member'>cv</span><span class='Delimiter'>; 
</span><a name="LN1278"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>phs_snapshot_data</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN1279"></a>} <span class='Declare_Typedef'>ParallelBitmapHeapState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   BitmapHeapScanState information 
 * 
 *      bitmapqualorig     execution state for bitmapqualorig expressions 
 *      tbm                bitmap obtained from child index scan(s) 
 *      tbmiterator        iterator for scanning current pages 
 *      tbmres             current-page data 
 *      exact_pages        total number of exact pages retrieved 
 *      lossy_pages        total number of lossy pages retrieved 
 *      prefetch_iterator  iterator for prefetching ahead of current page 
 *      prefetch_pages     # pages prefetch iterator is ahead of current 
 *      prefetch_target    current target prefetch distance 
 *      prefetch_maximum   maximum value for prefetch_target 
 *      pscan_len          size of the shared memory for parallel bitmap 
 *      initialized        is node is ready to iterate 
 *      shared_tbmiterator     shared iterator 
 *      shared_prefetch_iterator shared iterator for prefetching 
 *      pstate             shared state for parallel bitmap scan 
 * ---------------- 
 */ 
</span><a name="LN1301"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapHeapScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1303"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1304"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>bitmapqualorig</span><span class='Delimiter'>; 
</span><a name="LN1305"></a>    <a href="../../backend/nodes/tidbitmap.c.html#LN146"><span class='Ref_to_Struct'>TIDBitmap</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>tbm</span><span class='Delimiter'>; 
</span><a name="LN1306"></a>    <a href="../../backend/nodes/tidbitmap.c.html#LN175"><span class='Ref_to_Struct'>TBMIterator</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tbmiterator</span><span class='Delimiter'>; 
</span><a name="LN1307"></a>    <a href="tidbitmap.h.html#LN39"><span class='Ref_to_Typedef'>TBMIterateResult</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tbmres</span><span class='Delimiter'>; 
</span><a name="LN1308"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>exact_pages</span><span class='Delimiter'>; 
</span><a name="LN1309"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>lossy_pages</span><span class='Delimiter'>; 
</span><a name="LN1310"></a>    <a href="../../backend/nodes/tidbitmap.c.html#LN175"><span class='Ref_to_Struct'>TBMIterator</span></a> <span class='Operator'>*</span><span class='Declare_Member'>prefetch_iterator</span><span class='Delimiter'>; 
</span><a name="LN1311"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>prefetch_pages</span><span class='Delimiter'>; 
</span><a name="LN1312"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>prefetch_target</span><span class='Delimiter'>; 
</span><a name="LN1313"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>prefetch_maximum</span><span class='Delimiter'>; 
</span><a name="LN1314"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>pscan_len</span><span class='Delimiter'>; 
</span><a name="LN1315"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initialized</span><span class='Delimiter'>; 
</span><a name="LN1316"></a>    <a href="../../backend/nodes/tidbitmap.c.html#LN216"><span class='Ref_to_Struct'>TBMSharedIterator</span></a> <span class='Operator'>*</span><span class='Declare_Member'>shared_tbmiterator</span><span class='Delimiter'>; 
</span><a name="LN1317"></a>    <a href="../../backend/nodes/tidbitmap.c.html#LN216"><span class='Ref_to_Struct'>TBMSharedIterator</span></a> <span class='Operator'>*</span><span class='Declare_Member'>shared_prefetch_iterator</span><span class='Delimiter'>; 
</span><a name="LN1318"></a>    <a href="execnodes.h.html#LN1269"><span class='Ref_to_Struct'>ParallelBitmapHeapState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pstate</span><span class='Delimiter'>; 
</span><a name="LN1319"></a>} <span class='Declare_Typedef'>BitmapHeapScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   TidScanState information 
 * 
 *      tidexprs       list of TidExpr structs (see nodeTidscan.c) 
 *      isCurrentOf    scan has a CurrentOfExpr qual 
 *      NumTids        number of tids in this scan 
 *      TidPtr         index of currently fetched tid 
 *      TidList        evaluated item pointers (array of size NumTids) 
 *      htup           currently-fetched tuple, if any 
 * ---------------- 
 */ 
</span><a name="LN1332"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TidScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1334"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1335"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tss_tidexprs</span><span class='Delimiter'>; 
</span><a name="LN1336"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>tss_isCurrentOf</span><span class='Delimiter'>; 
</span><a name="LN1337"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tss_NumTids</span><span class='Delimiter'>; 
</span><a name="LN1338"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tss_TidPtr</span><span class='Delimiter'>; 
</span><a name="LN1339"></a>    <a href="../storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tss_TidList</span><span class='Delimiter'>; 
</span><a name="LN1340"></a>    <a href="../access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Member'>tss_htup</span><span class='Delimiter'>; 
</span><a name="LN1341"></a>} <span class='Declare_Typedef'>TidScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   SubqueryScanState information 
 * 
 *      SubqueryScanState is used for scanning a sub-query in the range table. 
 *      ScanTupleSlot references the current output tuple of the sub-query. 
 * ---------------- 
 */ 
</span><a name="LN1350"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SubqueryScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1352"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1353"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>subplan</span><span class='Delimiter'>; 
</span><a name="LN1354"></a>} <span class='Declare_Typedef'>SubqueryScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   FunctionScanState information 
 * 
 *      Function nodes are used to scan the results of a 
 *      function appearing in FROM (typically a function returning set). 
 * 
 *      eflags              node's capability flags 
 *      ordinality          is this scan WITH ORDINALITY? 
 *      simple              true if we have 1 function and no ordinality 
 *      ordinal             current ordinal column value 
 *      nfuncs              number of functions being executed 
 *      funcstates          per-function execution states (private in 
 *                          nodeFunctionscan.c) 
 *      argcontext          memory context to evaluate function arguments in 
 * ---------------- 
 */ 
</span><span class='Control'>struct</span> <a href="../../backend/executor/nodeFunctionscan.c.html#LN35"><span class='Ref_to_Struct'>FunctionScanPerFuncState</span></a><span class='Delimiter'>; 
</span> 
<a name="LN1374"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FunctionScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1376"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1377"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>eflags</span><span class='Delimiter'>; 
</span><a name="LN1378"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ordinality</span><span class='Delimiter'>; 
</span><a name="LN1379"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>simple</span><span class='Delimiter'>; 
</span><a name="LN1380"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>ordinal</span><span class='Delimiter'>; 
</span><a name="LN1381"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nfuncs</span><span class='Delimiter'>; 
</span><a name="LN1382"></a>    <span class='Control'>struct</span> <a href="../../backend/executor/nodeFunctionscan.c.html#LN35"><span class='Ref_to_Struct'>FunctionScanPerFuncState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>funcstates</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* array of length 
                                                         * nfuncs */ 
</span><a name="LN1384"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>argcontext</span><span class='Delimiter'>; 
</span><a name="LN1385"></a>} <span class='Declare_Typedef'>FunctionScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ValuesScanState information 
 * 
 *      ValuesScan nodes are used to scan the results of a VALUES list 
 * 
 *      rowcontext          per-expression-list context 
 *      exprlists           array of expression lists being evaluated 
 *      array_len           size of array 
 *      curr_idx            current array index (0-based) 
 * 
 *  Note: ss.ps.ps_ExprContext is used to evaluate any qual or projection 
 *  expressions attached to the node.  We create a second ExprContext, 
 *  rowcontext, in which to build the executor expression state for each 
 *  Values sublist.  Resetting this context lets us get rid of expression 
 *  state for each row, avoiding major memory leakage over a long values list. 
 * ---------------- 
 */ 
</span><a name="LN1404"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ValuesScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1406"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1407"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rowcontext</span><span class='Delimiter'>; 
</span><a name="LN1408"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Member'>exprlists</span><span class='Delimiter'>; 
</span><a name="LN1409"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>array_len</span><span class='Delimiter'>; 
</span><a name="LN1410"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>curr_idx</span><span class='Delimiter'>; 
</span><a name="LN1411"></a>} <span class='Declare_Typedef'>ValuesScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      TableFuncScanState node 
 * 
 * Used in table-expression functions like XMLTABLE. 
 * ---------------- 
 */ 
</span><a name="LN1419"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TableFuncScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1421"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1422"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>docexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* state for document expression */ 
</span><a name="LN1423"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>rowexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* state for row-generating expression */ 
</span><a name="LN1424"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colexprs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* state for column-generating expression */ 
</span><a name="LN1425"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coldefexprs</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* state for column default expressions */ 
</span><a name="LN1426"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ns_names</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of str nodes with namespace names */ 
</span><a name="LN1427"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ns_uris</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of states of namespace uri exprs */ 
</span><a name="LN1428"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>notnulls</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* nullability flag for each output column */ 
</span><a name="LN1429"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>opaque</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* table builder private space */ 
</span><a name="LN1430"></a>    <span class='Keyword'>const </span><span class='Control'>struct</span> <a href="../executor/tablefunc.h.html#LN51"><span class='Ref_to_Struct'>TableFuncRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Member'>routine</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* table builder methods */ 
</span><a name="LN1431"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>in_functions</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* input function for each column */ 
</span><a name="LN1432"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>typioparams</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* typioparam for each column */ 
</span><a name="LN1433"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>ordinal</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* row number to be output next */ 
</span><a name="LN1434"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>perValueCxt</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* short life context for value evaluation */ 
</span><a name="LN1435"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tupstore</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* output tuple store */ 
</span><a name="LN1436"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TableFuncScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   CteScanState information 
 * 
 *      CteScan nodes are used to scan a CommonTableExpr query. 
 * 
 * Multiple CteScan nodes can read out from the same CTE query.  We use 
 * a tuplestore to hold rows that have been read from the CTE query but 
 * not yet consumed by all readers. 
 * ---------------- 
 */ 
</span><a name="LN1448"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CteScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1450"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1451"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>eflags</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* capability flags to pass to tuplestore */ 
</span><a name="LN1452"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>readptr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* index of my tuplestore read pointer */ 
</span><a name="LN1453"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>cteplanstate</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* PlanState for the CTE query itself */ 
</span>    <span class='Comment_Multi_Line'>/* Link to the "leader" CteScanState (possibly this same node) */ 
</span><a name="LN1455"></a>    <span class='Control'>struct</span> <a href="execnodes.h.html#LN1448"><span class='Ref_to_Struct'>CteScanState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>leader</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* The remaining fields are only valid in the "leader" CteScanState */ 
</span><a name="LN1457"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cte_table</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* rows already read from the CTE query */ 
</span><a name="LN1458"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>eof_cte</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* reached end of CTE query? */ 
</span><a name="LN1459"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CteScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   NamedTuplestoreScanState information 
 * 
 *      NamedTuplestoreScan nodes are used to scan a Tuplestore created and 
 *      named prior to execution of the query.  An example is a transition 
 *      table for an AFTER trigger. 
 * 
 * Multiple NamedTuplestoreScan nodes can read out from the same Tuplestore. 
 * ---------------- 
 */ 
</span><a name="LN1471"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NamedTuplestoreScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1473"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1474"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>readptr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* index of my tuplestore read pointer */ 
</span><a name="LN1475"></a>    <a href="../access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>tupdesc</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* format of the tuples in the tuplestore */ 
</span><a name="LN1476"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* the rows */ 
</span><a name="LN1477"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NamedTuplestoreScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   WorkTableScanState information 
 * 
 *      WorkTableScan nodes are used to scan the work table created by 
 *      a RecursiveUnion node.  We locate the RecursiveUnion node 
 *      during executor startup. 
 * ---------------- 
 */ 
</span><a name="LN1487"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WorkTableScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1489"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1490"></a>    <a href="execnodes.h.html#LN999"><span class='Ref_to_Struct'>RecursiveUnionState</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rustate</span><span class='Delimiter'>; 
</span><a name="LN1491"></a>} <span class='Declare_Typedef'>WorkTableScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ForeignScanState information 
 * 
 *      ForeignScan nodes are used to scan foreign-data tables. 
 * ---------------- 
 */ 
</span><a name="LN1499"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ForeignScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1501"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1502"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>fdw_recheck_quals</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* original quals not in ss.ps.qual */ 
</span><a name="LN1503"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>pscan_len</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* size of parallel coordination information */ 
</span>    <span class='Comment_Multi_Line'>/* use struct pointer to avoid including fdwapi.h here */ 
</span><a name="LN1505"></a>    <span class='Control'>struct</span> <a href="../foreign/fdwapi.h.html#LN168"><span class='Ref_to_Struct'>FdwRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Member'>fdwroutine</span><span class='Delimiter'>; 
</span><a name="LN1506"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_state</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* foreign-data wrapper can keep state here */ 
</span><a name="LN1507"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ForeignScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   CustomScanState information 
 * 
 *      CustomScan nodes are used to execute custom code within executor. 
 * 
 * Core code must avoid assuming that the CustomScanState is only as large as 
 * the structure declared here; providers are allowed to make it the first 
 * element in a larger structure, and typically would need to do so.  The 
 * struct is actually allocated by the CreateCustomScanState method associated 
 * with the plan node.  Any additional fields can be initialized there, or in 
 * the BeginCustomScan method. 
 * ---------------- 
 */ 
</span><span class='Control'>struct</span> <a href="extensible.h.html#LN116"><span class='Ref_to_Struct'>CustomExecMethods</span></a><span class='Delimiter'>; 
</span> 
<a name="LN1524"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CustomScanState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1526"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>; 
</span><a name="LN1527"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>flags</span><span class='Delimiter'>;</span>          <span class='Comment_Multi_Line'>/* mask of CUSTOMPATH_* flags, see 
                                 * nodes/extensible.h */ 
</span><a name="LN1529"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>custom_ps</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of child PlanState nodes, if any */ 
</span><a name="LN1530"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>pscan_len</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* size of parallel coordination information */ 
</span><a name="LN1531"></a>    <span class='Keyword'>const </span><span class='Control'>struct</span> <a href="extensible.h.html#LN116"><span class='Ref_to_Struct'>CustomExecMethods</span></a> <span class='Operator'>*</span><span class='Declare_Member'>methods</span><span class='Delimiter'>; 
</span><a name="LN1532"></a>} <span class='Declare_Typedef'>CustomScanState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *               Join State Information 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   JoinState information 
 * 
 *      Superclass for state nodes of join plans. 
 * ---------------- 
 */ 
</span><a name="LN1545"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>JoinState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1547"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>; 
</span><a name="LN1548"></a>    <a href="nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Member'>jointype</span><span class='Delimiter'>; 
</span><a name="LN1549"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>single_match</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* True if we should skip to next outer tuple 
                                 * after finding one inner match */ 
</span><a name="LN1551"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>joinqual</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* JOIN quals (in addition to ps.qual) */ 
</span><a name="LN1552"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>JoinState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   NestLoopState information 
 * 
 *      NeedNewOuter       true if need new outer tuple on next call 
 *      MatchedOuter       true if found a join match for current outer tuple 
 *      NullInnerTupleSlot prepared null tuple for left outer joins 
 * ---------------- 
 */ 
</span><a name="LN1562"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NestLoopState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1564"></a>    <a href="execnodes.h.html#LN1545"><span class='Ref_to_Struct'>JoinState</span></a>   <span class='Declare_Member'>js</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1565"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>nl_NeedNewOuter</span><span class='Delimiter'>; 
</span><a name="LN1566"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>nl_MatchedOuter</span><span class='Delimiter'>; 
</span><a name="LN1567"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>nl_NullInnerTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1568"></a>} <span class='Declare_Typedef'>NestLoopState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   MergeJoinState information 
 * 
 *      NumClauses         number of mergejoinable join clauses 
 *      Clauses            info for each mergejoinable clause 
 *      JoinState          current state of ExecMergeJoin state machine 
 *      SkipMarkRestore    true if we may skip Mark and Restore operations 
 *      ExtraMarks         true to issue extra Mark operations on inner scan 
 *      ConstFalseJoin     true if we have a constant-false joinqual 
 *      FillOuter          true if should emit unjoined outer tuples anyway 
 *      FillInner          true if should emit unjoined inner tuples anyway 
 *      MatchedOuter       true if found a join match for current outer tuple 
 *      MatchedInner       true if found a join match for current inner tuple 
 *      OuterTupleSlot     slot in tuple table for cur outer tuple 
 *      InnerTupleSlot     slot in tuple table for cur inner tuple 
 *      MarkedTupleSlot    slot in tuple table for marked tuple 
 *      NullOuterTupleSlot prepared null tuple for right outer joins 
 *      NullInnerTupleSlot prepared null tuple for left outer joins 
 *      OuterEContext      workspace for computing outer tuple's join values 
 *      InnerEContext      workspace for computing inner tuple's join values 
 * ---------------- 
 */ 
/* private in nodeMergejoin.c: */ 
</span><a name="LN1593"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeMergejoin.c.html#LN119"><span class='Ref_to_Struct'>MergeJoinClauseData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>MergeJoinClause</span><span class='Delimiter'>; 
</span> 
<a name="LN1595"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MergeJoinState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1597"></a>    <a href="execnodes.h.html#LN1545"><span class='Ref_to_Struct'>JoinState</span></a>   <span class='Declare_Member'>js</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1598"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>mj_NumClauses</span><span class='Delimiter'>; 
</span><a name="LN1599"></a>    <a href="execnodes.h.html#LN1593"><span class='Ref_to_Typedef'>MergeJoinClause</span></a> <span class='Declare_Member'>mj_Clauses</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* array of length mj_NumClauses */ 
</span><a name="LN1600"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>mj_JoinState</span><span class='Delimiter'>; 
</span><a name="LN1601"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mj_SkipMarkRestore</span><span class='Delimiter'>; 
</span><a name="LN1602"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mj_ExtraMarks</span><span class='Delimiter'>; 
</span><a name="LN1603"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mj_ConstFalseJoin</span><span class='Delimiter'>; 
</span><a name="LN1604"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mj_FillOuter</span><span class='Delimiter'>; 
</span><a name="LN1605"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mj_FillInner</span><span class='Delimiter'>; 
</span><a name="LN1606"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mj_MatchedOuter</span><span class='Delimiter'>; 
</span><a name="LN1607"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>mj_MatchedInner</span><span class='Delimiter'>; 
</span><a name="LN1608"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mj_OuterTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1609"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mj_InnerTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1610"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mj_MarkedTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1611"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mj_NullOuterTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1612"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mj_NullInnerTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1613"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mj_OuterEContext</span><span class='Delimiter'>; 
</span><a name="LN1614"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>mj_InnerEContext</span><span class='Delimiter'>; 
</span><a name="LN1615"></a>}<span class='Auto_Annotations'> &laquo; end MergeJoinState &raquo; </span> <span class='Declare_Typedef'>MergeJoinState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   HashJoinState information 
 * 
 *      hashclauses             original form of the hashjoin condition 
 *      hj_OuterHashKeys        the outer hash keys in the hashjoin condition 
 *      hj_InnerHashKeys        the inner hash keys in the hashjoin condition 
 *      hj_HashOperators        the join operators in the hashjoin condition 
 *      hj_HashTable            hash table for the hashjoin 
 *                              (NULL if table not built yet) 
 *      hj_CurHashValue         hash value for current outer tuple 
 *      hj_CurBucketNo          regular bucket# for current outer tuple 
 *      hj_CurSkewBucketNo      skew bucket# for current outer tuple 
 *      hj_CurTuple             last inner tuple matched to current outer 
 *                              tuple, or NULL if starting search 
 *                              (hj_CurXXX variables are undefined if 
 *                              OuterTupleSlot is empty!) 
 *      hj_OuterTupleSlot       tuple slot for outer tuples 
 *      hj_HashTupleSlot        tuple slot for inner (hashed) tuples 
 *      hj_NullOuterTupleSlot   prepared null tuple for right/full outer joins 
 *      hj_NullInnerTupleSlot   prepared null tuple for left/full outer joins 
 *      hj_FirstOuterTupleSlot  first tuple retrieved from outer plan 
 *      hj_JoinState            current state of ExecHashJoin state machine 
 *      hj_MatchedOuter         true if found a join match for current outer 
 *      hj_OuterNotEmpty        true if outer relation known not empty 
 * ---------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* these structs are defined in executor/hashjoin.h: */ 
</span><a name="LN1645"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../executor/hashjoin.h.html#LN63"><span class='Ref_to_Struct'>HashJoinTupleData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>HashJoinTuple</span><span class='Delimiter'>; 
</span><a name="LN1646"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../executor/hashjoin.h.html#LN125"><span class='Ref_to_Struct'>HashJoinTableData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>HashJoinTable</span><span class='Delimiter'>; 
</span> 
<a name="LN1648"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>HashJoinState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1650"></a>    <a href="execnodes.h.html#LN1545"><span class='Ref_to_Struct'>JoinState</span></a>   <span class='Declare_Member'>js</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1651"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>hashclauses</span><span class='Delimiter'>; 
</span><a name="LN1652"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>hj_OuterHashKeys</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of ExprState nodes */ 
</span><a name="LN1653"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>hj_InnerHashKeys</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of ExprState nodes */ 
</span><a name="LN1654"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>hj_HashOperators</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of operator OIDs */ 
</span><a name="LN1655"></a>    <a href="execnodes.h.html#LN1646"><span class='Ref_to_Typedef'>HashJoinTable</span></a> <span class='Declare_Member'>hj_HashTable</span><span class='Delimiter'>; 
</span><a name="LN1656"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>hj_CurHashValue</span><span class='Delimiter'>; 
</span><a name="LN1657"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>hj_CurBucketNo</span><span class='Delimiter'>; 
</span><a name="LN1658"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>hj_CurSkewBucketNo</span><span class='Delimiter'>; 
</span><a name="LN1659"></a>    <a href="execnodes.h.html#LN1645"><span class='Ref_to_Typedef'>HashJoinTuple</span></a> <span class='Declare_Member'>hj_CurTuple</span><span class='Delimiter'>; 
</span><a name="LN1660"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hj_OuterTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1661"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hj_HashTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1662"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hj_NullOuterTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1663"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hj_NullInnerTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1664"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hj_FirstOuterTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN1665"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>hj_JoinState</span><span class='Delimiter'>; 
</span><a name="LN1666"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hj_MatchedOuter</span><span class='Delimiter'>; 
</span><a name="LN1667"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hj_OuterNotEmpty</span><span class='Delimiter'>; 
</span><a name="LN1668"></a>}<span class='Auto_Annotations'> &laquo; end HashJoinState &raquo; </span> <span class='Declare_Typedef'>HashJoinState</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *               Materialization State Information 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   MaterialState information 
 * 
 *      materialize nodes are used to materialize the results 
 *      of a subplan into a temporary file. 
 * 
 *      ss.ss_ScanTupleSlot refers to output of underlying plan. 
 * ---------------- 
 */ 
</span><a name="LN1685"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MaterialState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1687"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1688"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>eflags</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* capability flags to pass to tuplestore */ 
</span><a name="LN1689"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>eof_underlying</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* reached end of underlying plan? */ 
</span><a name="LN1690"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tuplestorestate</span><span class='Delimiter'>; 
</span><a name="LN1691"></a>} <span class='Declare_Typedef'>MaterialState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   SortState information 
 * ---------------- 
 */ 
</span><a name="LN1697"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SortState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1699"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1700"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>randomAccess</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* need random access to sort output? */ 
</span><a name="LN1701"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>bounded</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* is the result set bounded? */ 
</span><a name="LN1702"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>bound</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* if bounded, how many tuples are needed */ 
</span><a name="LN1703"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>sort_Done</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* sort completed yet? */ 
</span><a name="LN1704"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>bounded_Done</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* value of bounded we did the sort with */ 
</span><a name="LN1705"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>bound_Done</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* value of bound we did the sort with */ 
</span><a name="LN1706"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>tuplesortstate</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* private state of tuplesort.c */ 
</span><a name="LN1707"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SortState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* --------------------- 
 *  GroupState information 
 * --------------------- 
 */ 
</span><a name="LN1713"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GroupState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1715"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1716"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>eqfunctions</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-field lookup data for equality fns */ 
</span><a name="LN1717"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>grp_done</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* indicates completion of Group scan */ 
</span><a name="LN1718"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GroupState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* --------------------- 
 *  AggState information 
 * 
 *  ss.ss_ScanTupleSlot refers to output of underlying plan. 
 * 
 *  Note: ss.ps.ps_ExprContext contains ecxt_aggvalues and 
 *  ecxt_aggnulls arrays, which hold the computed agg values for the current 
 *  input group during evaluation of an Agg node's output tuple(s).  We 
 *  create a second ExprContext, tmpcontext, in which to evaluate input 
 *  expressions and run the aggregate transition functions. 
 * --------------------- 
 */ 
/* these structs are private in nodeAgg.c: */ 
</span><a name="LN1733"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeAgg.c.html#LN404"><span class='Ref_to_Struct'>AggStatePerAggData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>AggStatePerAgg</span><span class='Delimiter'>; 
</span><a name="LN1734"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeAgg.c.html#LN240"><span class='Ref_to_Struct'>AggStatePerTransData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>AggStatePerTrans</span><span class='Delimiter'>; 
</span><a name="LN1735"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeAgg.c.html#LN459"><span class='Ref_to_Struct'>AggStatePerGroupData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>AggStatePerGroup</span><span class='Delimiter'>; 
</span><a name="LN1736"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeAgg.c.html#LN486"><span class='Ref_to_Struct'>AggStatePerPhaseData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>AggStatePerPhase</span><span class='Delimiter'>; 
</span><a name="LN1737"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeAgg.c.html#LN504"><span class='Ref_to_Struct'>AggStatePerHashData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>AggStatePerHash</span><span class='Delimiter'>; 
</span> 
<a name="LN1739"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1741"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1742"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggs</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* all Aggref nodes in targetlist & quals */ 
</span><a name="LN1743"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numaggs</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* length of list (could be zero!) */ 
</span><a name="LN1744"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numtrans</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* number of pertrans items */ 
</span><a name="LN1745"></a>    <a href="nodes.h.html#LN733"><span class='Ref_to_Enum'>AggStrategy</span></a> <span class='Declare_Member'>aggstrategy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* strategy mode */ 
</span><a name="LN1746"></a>    <a href="nodes.h.html#LN755"><span class='Ref_to_Enum'>AggSplit</span></a>    <span class='Declare_Member'>aggsplit</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* agg-splitting mode, see nodes.h */ 
</span><a name="LN1747"></a>    <a href="execnodes.h.html#LN1736"><span class='Ref_to_Typedef'>AggStatePerPhase</span></a> <span class='Declare_Member'>phase</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* pointer to current phase data */ 
</span><a name="LN1748"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numphases</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* number of phases (including phase 0) */ 
</span><a name="LN1749"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>current_phase</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* current phase number */ 
</span><a name="LN1750"></a>    <a href="execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Member'>peragg</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* per-Aggref information */ 
</span><a name="LN1751"></a>    <a href="execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Member'>pertrans</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* per-Trans state information */ 
</span><a name="LN1752"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hashcontext</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* econtexts for long-lived data (hashtable) */ 
</span><a name="LN1753"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>**</span><span class='Declare_Member'>aggcontexts</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* econtexts for long-lived data (per GS) */ 
</span><a name="LN1754"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tmpcontext</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* econtext for input expressions */ 
</span><a name="LN1755"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>curaggcontext</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* currently active aggcontext */ 
</span><a name="LN1756"></a>    <a href="execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Member'>curpertrans</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* currently active trans state */ 
</span><a name="LN1757"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>input_done</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* indicates end of input */ 
</span><a name="LN1758"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>agg_done</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* indicates completion of Agg scan */ 
</span><a name="LN1759"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>projected_set</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* The last projected grouping set */ 
</span><a name="LN1760"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>current_set</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* The current grouping set being evaluated */ 
</span><a name="LN1761"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>grouped_cols</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* grouped cols in current projection */ 
</span><a name="LN1762"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>all_grouped_cols</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* list of all grouped cols in DESC 
                                         * order */ 
</span>    <span class='Comment_Multi_Line'>/* These fields are for grouping set phase data */ 
</span><a name="LN1765"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>maxsets</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* The max number of sets in any phase */ 
</span><a name="LN1766"></a>    <a href="execnodes.h.html#LN1736"><span class='Ref_to_Typedef'>AggStatePerPhase</span></a> <span class='Declare_Member'>phases</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of all phases */ 
</span><a name="LN1767"></a>    <a href="../../backend/utils/sort/tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sort_in</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* sorted input to phases &GT; 1 */ 
</span><a name="LN1768"></a>    <a href="../../backend/utils/sort/tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sort_out</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* input is copied here for next phase */ 
</span><a name="LN1769"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sort_slot</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* slot for sort results */ 
</span>    <span class='Comment_Multi_Line'>/* these fields are used in AGG_PLAIN and AGG_SORTED modes: */ 
</span><a name="LN1771"></a>    <a href="execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Member'>pergroup</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* per-Aggref-per-group working state */ 
</span><a name="LN1772"></a>    <a href="../access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Member'>grp_firstTuple</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* copy of first tuple of current group */ 
</span>    <span class='Comment_Multi_Line'>/* these fields are used in AGG_HASHED and AGG_MIXED modes: */ 
</span><a name="LN1774"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>table_filled</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hash table filled yet? */ 
</span><a name="LN1775"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_hashes</span><span class='Delimiter'>; 
</span><a name="LN1776"></a>    <a href="execnodes.h.html#LN1737"><span class='Ref_to_Typedef'>AggStatePerHash</span></a> <span class='Declare_Member'>perhash</span><span class='Delimiter'>; 
</span><a name="LN1777"></a>    <a href="execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hash_pergroup</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of per-group pointers */ 
</span>    <span class='Comment_Multi_Line'>/* support for evaluation of agg inputs */ 
</span><a name="LN1779"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>evalslot</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* slot for agg inputs */ 
</span><a name="LN1780"></a>    <a href="execnodes.h.html#LN291"><span class='Ref_to_Struct'>ProjectionInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>evalproj</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* projection machinery */ 
</span><a name="LN1781"></a>    <a href="../access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>evaldesc</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* descriptor of input tuples */ 
</span><a name="LN1782"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end AggState &raquo; </span> <span class='Declare_Typedef'>AggState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *  WindowAggState information 
 * ---------------- 
 */ 
/* these structs are private in nodeWindowAgg.c: */ 
</span><a name="LN1789"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeWindowAgg.c.html#LN74"><span class='Ref_to_Struct'>WindowStatePerFuncData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>WindowStatePerFunc</span><span class='Delimiter'>; 
</span><a name="LN1790"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeWindowAgg.c.html#LN102"><span class='Ref_to_Struct'>WindowStatePerAggData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>WindowStatePerAgg</span><span class='Delimiter'>; 
</span> 
<a name="LN1792"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WindowAggState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1794"></a>    <a href="execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a>   <span class='Declare_Member'>ss</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span> 
    <span class='Comment_Multi_Line'>/* these fields are filled in by ExecInitExpr: */ 
</span><a name="LN1797"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funcs</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* all WindowFunc nodes in targetlist */ 
</span><a name="LN1798"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numfuncs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* total number of window functions */ 
</span><a name="LN1799"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numaggs</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number that are plain aggregates */ 
</span> 
<a name="LN1801"></a>    <a href="execnodes.h.html#LN1789"><span class='Ref_to_Typedef'>WindowStatePerFunc</span></a> <span class='Declare_Member'>perfunc</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* per-window-function information */ 
</span><a name="LN1802"></a>    <a href="execnodes.h.html#LN1790"><span class='Ref_to_Typedef'>WindowStatePerAgg</span></a> <span class='Declare_Member'>peragg</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* per-plain-aggregate information */ 
</span><a name="LN1803"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>partEqfunctions</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* equality funcs for partition columns */ 
</span><a name="LN1804"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>ordEqfunctions</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* equality funcs for ordering columns */ 
</span><a name="LN1805"></a>    <a href="../../backend/utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>buffer</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* stores rows of current partition */ 
</span><a name="LN1806"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>current_ptr</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* read pointer # for current */ 
</span><a name="LN1807"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>spooled_rows</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* total # of rows in buffer */ 
</span><a name="LN1808"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>currentpos</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* position of current row in partition */ 
</span><a name="LN1809"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>frameheadpos</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* current frame head position */ 
</span><a name="LN1810"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>frametailpos</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* current frame tail position */ 
</span>    <span class='Comment_Multi_Line'>/* use struct pointer to avoid including windowapi.h here */ 
</span><a name="LN1812"></a>    <span class='Control'>struct</span> <a href="../../backend/executor/nodeWindowAgg.c.html#LN58"><span class='Ref_to_Struct'>WindowObjectData</span></a> <span class='Operator'>*</span><span class='Declare_Member'>agg_winobj</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* winobj for aggregate 
                                                 * fetches */ 
</span><a name="LN1814"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>aggregatedbase</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* start row for current aggregates */ 
</span><a name="LN1815"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>aggregatedupto</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* rows before this one are aggregated */ 
</span> 
<a name="LN1817"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>frameOptions</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* frame_clause options, see WindowDef */ 
</span><a name="LN1818"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>startOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expression for starting bound offset */ 
</span><a name="LN1819"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>endOffset</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* expression for ending bound offset */ 
</span><a name="LN1820"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>startOffsetValue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* result of startOffset evaluation */ 
</span><a name="LN1821"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>endOffsetValue</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* result of endOffset evaluation */ 
</span> 
<a name="LN1823"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>partcontext</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* context for partition-lifespan data */ 
</span><a name="LN1824"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>aggcontext</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* shared context for aggregate working data */ 
</span><a name="LN1825"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>curaggcontext</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* current aggregate's working data */ 
</span><a name="LN1826"></a>    <a href="execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tmpcontext</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* short-term evaluation context */ 
</span> 
<a name="LN1828"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>all_first</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* true if the scan is starting */ 
</span><a name="LN1829"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>all_done</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true if the scan is finished */ 
</span><a name="LN1830"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>partition_spooled</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* true if all tuples in current 
                                         * partition have been spooled into 
                                         * tuplestore */ 
</span><a name="LN1833"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>more_partitions</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* true if there's more partitions after this 
                                 * one */ 
</span><a name="LN1835"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>framehead_valid</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* true if frameheadpos is known up to date 
                                 * for current row */ 
</span><a name="LN1837"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>frametail_valid</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* true if frametailpos is known up to date 
                                 * for current row */ 
</span> 
<a name="LN1840"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>first_part_slot</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* first tuple of current or next 
                                         * partition */ 
</span> 
    <span class='Comment_Multi_Line'>/* temporary slots for tuples fetched back from tuplestore */ 
</span><a name="LN1844"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>agg_row_slot</span><span class='Delimiter'>; 
</span><a name="LN1845"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>temp_slot_1</span><span class='Delimiter'>; 
</span><a name="LN1846"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>temp_slot_2</span><span class='Delimiter'>; 
</span><a name="LN1847"></a>}<span class='Auto_Annotations'> &laquo; end WindowAggState &raquo; </span> <span class='Declare_Typedef'>WindowAggState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   UniqueState information 
 * 
 *      Unique nodes are used "on top of" sort nodes to discard 
 *      duplicate tuples returned from the sort phase.  Basically 
 *      all it does is compare the current tuple from the subplan 
 *      with the previously fetched tuple (stored in its result slot). 
 *      If the two are identical in all interesting fields, then 
 *      we just fetch another tuple from the sort and try again. 
 * ---------------- 
 */ 
</span><a name="LN1860"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>UniqueState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1862"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1863"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>eqfunctions</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-field lookup data for equality fns */ 
</span><a name="LN1864"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tempContext</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* short-term context for comparisons */ 
</span><a name="LN1865"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UniqueState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * GatherState information 
 * 
 *      Gather nodes launch 1 or more parallel workers, run a subplan 
 *      in those workers, and collect the results. 
 * ---------------- 
 */ 
</span><a name="LN1874"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GatherState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1876"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1877"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initialized</span><span class='Delimiter'>; 
</span><a name="LN1878"></a>    <span class='Control'>struct</span> <a href="../executor/execParallel.h.html#LN23"><span class='Ref_to_Struct'>ParallelExecutorInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pei</span><span class='Delimiter'>; 
</span><a name="LN1879"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nreaders</span><span class='Delimiter'>; 
</span><a name="LN1880"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nextreader</span><span class='Delimiter'>; 
</span><a name="LN1881"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nworkers_launched</span><span class='Delimiter'>; 
</span><a name="LN1882"></a>    <span class='Control'>struct</span> <a href="../../backend/executor/tqueue.c.html#LN167"><span class='Ref_to_Struct'>TupleQueueReader</span></a> <span class='Operator'>**</span><span class='Declare_Member'>reader</span><span class='Delimiter'>; 
</span><a name="LN1883"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>funnel_slot</span><span class='Delimiter'>; 
</span><a name="LN1884"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>need_to_scan_locally</span><span class='Delimiter'>; 
</span><a name="LN1885"></a>} <span class='Declare_Typedef'>GatherState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * GatherMergeState information 
 * 
 *      Gather merge nodes launch 1 or more parallel workers, run a 
 *      subplan which produces sorted output in each worker, and then 
 *      merge the results into a single sorted stream. 
 * ---------------- 
 */ 
</span><span class='Control'>struct</span> GMReaderTuple<span class='Delimiter'>; 
</span> 
<a name="LN1897"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GatherMergeState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1899"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1900"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initialized</span><span class='Delimiter'>; 
</span><a name="LN1901"></a>    <span class='Control'>struct</span> <a href="../executor/execParallel.h.html#LN23"><span class='Ref_to_Struct'>ParallelExecutorInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pei</span><span class='Delimiter'>; 
</span><a name="LN1902"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nreaders</span><span class='Delimiter'>; 
</span><a name="LN1903"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nworkers_launched</span><span class='Delimiter'>; 
</span><a name="LN1904"></a>    <span class='Control'>struct</span> <a href="../../backend/executor/tqueue.c.html#LN167"><span class='Ref_to_Struct'>TupleQueueReader</span></a> <span class='Operator'>**</span><span class='Declare_Member'>reader</span><span class='Delimiter'>; 
</span><a name="LN1905"></a>    <a href="../access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>tupDesc</span><span class='Delimiter'>; 
</span><a name="LN1906"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>**</span><span class='Declare_Member'>gm_slots</span><span class='Delimiter'>; 
</span><a name="LN1907"></a>    <span class='Control'>struct</span> <a href="../lib/binaryheap.h.html#LN29"><span class='Ref_to_Struct'>binaryheap</span></a> <span class='Operator'>*</span><span class='Declare_Member'>gm_heap</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* binary heap of slot indices */ 
</span><a name="LN1908"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>gm_initialized</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* gather merge initilized ? */ 
</span><a name="LN1909"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>need_to_scan_locally</span><span class='Delimiter'>; 
</span><a name="LN1910"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>gm_nkeys</span><span class='Delimiter'>; 
</span><a name="LN1911"></a>    <a href="../utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Member'>gm_sortkeys</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array of length ms_nkeys */ 
</span><a name="LN1912"></a>    <span class='Control'>struct</span> <a href="../../backend/executor/nodeGatherMerge.c.html#LN31"><span class='Ref_to_Struct'>GMReaderTupleBuffer</span></a> <span class='Operator'>*</span><span class='Declare_Member'>gm_tuple_buffers</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* tuple buffer per 
                                                         * reader */ 
</span><a name="LN1914"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GatherMergeState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   HashState information 
 * ---------------- 
 */ 
</span><a name="LN1920"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>HashState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1922"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1923"></a>    <a href="execnodes.h.html#LN1646"><span class='Ref_to_Typedef'>HashJoinTable</span></a> <span class='Declare_Member'>hashtable</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* hash table for the hashjoin */ 
</span><a name="LN1924"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>hashkeys</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of ExprState nodes */ 
</span>    <span class='Comment_Multi_Line'>/* hashkeys is same as parent's hj_InnerHashKeys */ 
</span><a name="LN1926"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>HashState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   SetOpState information 
 * 
 *      Even in "sorted" mode, SetOp nodes are more complex than a simple 
 *      Unique, since we have to count how many duplicates to return.  But 
 *      we also support hashing, so this is really more like a cut-down 
 *      form of Agg. 
 * ---------------- 
 */ 
/* this struct is private in nodeSetOp.c: */ 
</span><a name="LN1938"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="../../backend/executor/nodeSetOp.c.html#LN62"><span class='Ref_to_Struct'>SetOpStatePerGroupData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>SetOpStatePerGroup</span><span class='Delimiter'>; 
</span> 
<a name="LN1940"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SetOpState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1942"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1943"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>eqfunctions</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-grouping-field equality fns */ 
</span><a name="LN1944"></a>    <a href="../fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>hashfunctions</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* per-grouping-field hash fns */ 
</span><a name="LN1945"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>setop_done</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* indicates completion of output scan */ 
</span><a name="LN1946"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>numOutput</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* number of dups left to output */ 
</span><a name="LN1947"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tempContext</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* short-term context for comparisons */ 
</span>    <span class='Comment_Multi_Line'>/* these fields are used in SETOP_SORTED mode: */ 
</span><a name="LN1949"></a>    <a href="execnodes.h.html#LN1938"><span class='Ref_to_Typedef'>SetOpStatePerGroup</span></a> <span class='Declare_Member'>pergroup</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-group working state */ 
</span><a name="LN1950"></a>    <a href="../access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Member'>grp_firstTuple</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* copy of first tuple of current group */ 
</span>    <span class='Comment_Multi_Line'>/* these fields are used in SETOP_HASHED mode: */ 
</span><a name="LN1952"></a>    <a href="execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Member'>hashtable</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hash table with one entry per group */ 
</span><a name="LN1953"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>tableContext</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* memory context containing hash table */ 
</span><a name="LN1954"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>table_filled</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hash table filled yet? */ 
</span><a name="LN1955"></a>    <a href="execnodes.h.html#LN597"><span class='Ref_to_Typedef'>TupleHashIterator</span></a> <span class='Declare_Member'>hashiter</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* for iterating through hash table */ 
</span><a name="LN1956"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SetOpState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   LockRowsState information 
 * 
 *      LockRows nodes are used to enforce FOR [KEY] UPDATE/SHARE locking. 
 * ---------------- 
 */ 
</span><a name="LN1964"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LockRowsState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1966"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1967"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>lr_arowMarks</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* List of ExecAuxRowMarks */ 
</span><a name="LN1968"></a>    <a href="execnodes.h.html#LN873"><span class='Ref_to_Struct'>EPQState</span></a>    <span class='Declare_Member'>lr_epqstate</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* for evaluating EvalPlanQual rechecks */ 
</span><a name="LN1969"></a>    <a href="../access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>lr_curtuples</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* locked tuples (one entry per RT entry) */ 
</span><a name="LN1970"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>lr_ntables</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* length of lr_curtuples[] array */ 
</span><a name="LN1971"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LockRowsState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   LimitState information 
 * 
 *      Limit nodes are used to enforce LIMIT/OFFSET clauses. 
 *      They just select the desired subrange of their subplan's output. 
 * 
 * offset is the number of initial tuples to skip (0 does nothing). 
 * count is the number of tuples to return after skipping the offset tuples. 
 * If no limit count was specified, count is undefined and noCount is true. 
 * When lstate == LIMIT_INITIAL, offset/count/noCount haven't been set yet. 
 * ---------------- 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN1987"></a>    <span class='Declare_Enum_Const'>LIMIT_INITIAL</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* initial state for LIMIT node */ 
</span><a name="LN1988"></a>    <span class='Declare_Enum_Const'>LIMIT_RESCAN</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* rescan after recomputing parameters */ 
</span><a name="LN1989"></a>    <span class='Declare_Enum_Const'>LIMIT_EMPTY</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* there are no returnable rows */ 
</span><a name="LN1990"></a>    <span class='Declare_Enum_Const'>LIMIT_INWINDOW</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* have returned a row in the window */ 
</span><a name="LN1991"></a>    <span class='Declare_Enum_Const'>LIMIT_SUBPLANEOF</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* at EOF of subplan (within window) */ 
</span><a name="LN1992"></a>    <span class='Declare_Enum_Const'>LIMIT_WINDOWEND</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* stepped off end of window */ 
</span><a name="LN1993"></a>    <span class='Declare_Enum_Const'>LIMIT_WINDOWSTART</span>           <span class='Comment_Single_Line'>/* stepped off beginning of window */ 
</span><a name="LN1994"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LimitStateCond</span><span class='Delimiter'>; 
</span> 
<a name="LN1996"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LimitState</span> 
<span class='Delimiter'>{ 
</span><a name="LN1998"></a>    <a href="execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>   <span class='Declare_Member'>ps</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* its first field is NodeTag */ 
</span><a name="LN1999"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>limitOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OFFSET parameter, or NULL if none */ 
</span><a name="LN2000"></a>    <a href="execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>limitCount</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* COUNT parameter, or NULL if none */ 
</span><a name="LN2001"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>offset</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* current OFFSET value */ 
</span><a name="LN2002"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>count</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* current COUNT, if any */ 
</span><a name="LN2003"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>noCount</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* if true, ignore count */ 
</span><a name="LN2004"></a>    <a href="execnodes.h.html#LN1985"><span class='Ref_to_Typedef'>LimitStateCond</span></a> <span class='Declare_Member'>lstate</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* state machine status, as above */ 
</span><a name="LN2005"></a>    <a href="../c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Member'>position</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* 1-based index of last tuple returned */ 
</span><a name="LN2006"></a>    <a href="../executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>subSlot</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* tuple last obtained from subplan */ 
</span><a name="LN2007"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LimitState</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* EXECNODES_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>