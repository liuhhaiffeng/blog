<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\nodes\parsenodes.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\nodes\parsenodes.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:07 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * parsenodes.h 
 *    definitions for parse tree nodes 
 * 
 * Many of the node types used in parsetrees include a "location" field. 
 * This is a byte (not character) offset in the original source text, to be 
 * used for positioning an error cursor when there is an error related to 
 * the node.  Access to the original source text is needed to make use of 
 * the location.  At the topmost (statement) level, we also provide a 
 * statement length, likewise measured in bytes, for convenience in 
 * identifying statement boundaries in multi-statement source strings. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/nodes/parsenodes.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="parsenodes.h.html#LN22"><span class='Ref_to_Const'>PARSENODES_H</span></a> 
<a name="LN22"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PARSENODES_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"nodes/bitmapset.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/lockoptions.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/primnodes.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/value.h"</span> 
 
<a name="LN29"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>OverridingKind</span> 
<span class='Delimiter'>{ 
</span><a name="LN31"></a>    <span class='Declare_Enum_Const'>OVERRIDING_NOT_SET</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN32"></a>    <span class='Declare_Enum_Const'>OVERRIDING_USER_VALUE</span><span class='Delimiter'>, 
</span><a name="LN33"></a>    <span class='Declare_Enum_Const'>OVERRIDING_SYSTEM_VALUE</span> 
<a name="LN34"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OverridingKind</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Possible sources of a Query */ 
</span><a name="LN37"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>QuerySource</span> 
<span class='Delimiter'>{ 
</span><a name="LN39"></a>    <span class='Declare_Enum_Const'>QSRC_ORIGINAL</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* original parsetree (explicit query) */ 
</span><a name="LN40"></a>    <span class='Declare_Enum_Const'>QSRC_PARSER</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* added by parse analysis (now unused) */ 
</span><a name="LN41"></a>    <span class='Declare_Enum_Const'>QSRC_INSTEAD_RULE</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* added by unconditional INSTEAD rule */ 
</span><a name="LN42"></a>    <span class='Declare_Enum_Const'>QSRC_QUAL_INSTEAD_RULE</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* added by conditional INSTEAD rule */ 
</span><a name="LN43"></a>    <span class='Declare_Enum_Const'>QSRC_NON_INSTEAD_RULE</span>       <span class='Comment_Single_Line'>/* added by non-INSTEAD rule */ 
</span><a name="LN44"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>QuerySource</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Sort ordering options for ORDER BY and CREATE INDEX */ 
</span><a name="LN47"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>SortByDir</span> 
<span class='Delimiter'>{ 
</span><a name="LN49"></a>    <span class='Declare_Enum_Const'>SORTBY_DEFAULT</span><span class='Delimiter'>, 
</span><a name="LN50"></a>    <span class='Declare_Enum_Const'>SORTBY_ASC</span><span class='Delimiter'>, 
</span><a name="LN51"></a>    <span class='Declare_Enum_Const'>SORTBY_DESC</span><span class='Delimiter'>, 
</span><a name="LN52"></a>    <span class='Declare_Enum_Const'>SORTBY_USING</span>                <span class='Comment_Single_Line'>/* not allowed in CREATE INDEX ... */ 
</span><a name="LN53"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SortByDir</span><span class='Delimiter'>; 
</span> 
<a name="LN55"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>SortByNulls</span> 
<span class='Delimiter'>{ 
</span><a name="LN57"></a>    <span class='Declare_Enum_Const'>SORTBY_NULLS_DEFAULT</span><span class='Delimiter'>, 
</span><a name="LN58"></a>    <span class='Declare_Enum_Const'>SORTBY_NULLS_FIRST</span><span class='Delimiter'>, 
</span><a name="LN59"></a>    <span class='Declare_Enum_Const'>SORTBY_NULLS_LAST</span> 
<a name="LN60"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SortByNulls</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Grantable rights are encoded so that we can OR them together in a bitmask. 
 * The present representation of AclItem limits us to 16 distinct rights, 
 * even though AclMode is defined as uint32.  See utils/acl.h. 
 * 
 * Caution: changing these codes breaks stored ACLs, hence forces initdb. 
 */ 
</span><a name="LN69"></a><span class='Control'>typedef</span> <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Typedef'>AclMode</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* a bitmask of privilege bits */ 
</span> 
<a name="LN71"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_INSERT</span>      <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>0</span><span class='Parentheses'>)</span>  <span class='Comment_Single_Line'>/* for relations */ 
</span><a name="LN72"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_SELECT</span>      <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>1</span><span class='Parentheses'>) 
</span><a name="LN73"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_UPDATE</span>      <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>2</span><span class='Parentheses'>) 
</span><a name="LN74"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_DELETE</span>      <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>3</span><span class='Parentheses'>) 
</span><a name="LN75"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_TRUNCATE</span>    <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>4</span><span class='Parentheses'>) 
</span><a name="LN76"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_REFERENCES</span>  <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>5</span><span class='Parentheses'>) 
</span><a name="LN77"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_TRIGGER</span>     <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>6</span><span class='Parentheses'>) 
</span><a name="LN78"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_EXECUTE</span>     <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>7</span><span class='Parentheses'>)</span>  <span class='Comment_Single_Line'>/* for functions */ 
</span><a name="LN79"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_USAGE</span>       <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>8</span><span class='Parentheses'>)</span>  <span class='Comment_Multi_Line'>/* for languages, namespaces, FDWs, and 
                                 * servers */ 
</span><a name="LN81"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_CREATE</span>      <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>9</span><span class='Parentheses'>)</span>  <span class='Comment_Single_Line'>/* for namespaces and databases */ 
</span><a name="LN82"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_CREATE_TEMP</span> <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>10</span><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* for databases */ 
</span><a name="LN83"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_CONNECT</span>     <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>&LT;&LT;</span><span class='Number'>11</span><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* for databases */ 
</span><a name="LN84"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>N_ACL_RIGHTS</span>    <span class='Number'>12</span>      <span class='Comment_Single_Line'>/* 1 plus the last 1&LT;&LT;x */ 
</span><a name="LN85"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_NO_RIGHTS</span>   <span class='Number'>0</span> 
<span class='Comment_Multi_Line'>/* Currently, SELECT ... FOR [KEY] UPDATE/SHARE requires UPDATE privileges */ 
</span><a name="LN87"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>ACL_SELECT_FOR_UPDATE</span>   <a href="parsenodes.h.html#LN73"><span class='Ref_to_Const'>ACL_UPDATE</span></a> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *  Query Tree 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Query - 
 *    Parse analysis turns all statements into a Query tree 
 *    for further processing by the rewriter and planner. 
 * 
 *    Utility statements (i.e. non-optimizable statements) have the 
 *    utilityStmt field set, and the rest of the Query is mostly dummy. 
 * 
 *    Planning converts a Query tree into a Plan tree headed by a PlannedStmt 
 *    node --- the Query structure is not used by the executor. 
 */ 
</span><a name="LN105"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Query</span> 
<span class='Delimiter'>{ 
</span><a name="LN107"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN109"></a>    <a href="nodes.h.html#LN647"><span class='Ref_to_Enum'>CmdType</span></a>     <span class='Declare_Member'>commandType</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* select|insert|update|delete|utility */ 
</span> 
<a name="LN111"></a>    <a href="parsenodes.h.html#LN37"><span class='Ref_to_Enum'>QuerySource</span></a> <span class='Declare_Member'>querySource</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* where did I come from? */ 
</span> 
<a name="LN113"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>queryId</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* query identifier (can be set by plugins) */ 
</span> 
<a name="LN115"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>canSetTag</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* do I set the command result tag? */ 
</span> 
<a name="LN117"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>utilityStmt</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* non-null if commandType == CMD_UTILITY */ 
</span> 
<a name="LN119"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>resultRelation</span><span class='Delimiter'>; </span><span class='Comment_Multi_Line'>/* rtable index of target relation for 
                                 * INSERT/UPDATE/DELETE; 0 for SELECT */ 
</span> 
<a name="LN122"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasAggs</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* has aggregates in tlist or havingQual */ 
</span><a name="LN123"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasWindowFuncs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* has window functions in tlist */ 
</span><a name="LN124"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasTargetSRFs</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* has set-returning functions in tlist */ 
</span><a name="LN125"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasSubLinks</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* has subquery SubLink */ 
</span><a name="LN126"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasDistinctOn</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* distinctClause is from DISTINCT ON */ 
</span><a name="LN127"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasRecursive</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* WITH RECURSIVE was specified */ 
</span><a name="LN128"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasModifyingCTE</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* has INSERT/UPDATE/DELETE in WITH */ 
</span><a name="LN129"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasForUpdate</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* FOR [KEY] UPDATE/SHARE was specified */ 
</span><a name="LN130"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasRowSecurity</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* rewriter has applied some RLS policy */ 
</span> 
<a name="LN132"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cteList</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* WITH list (of CommonTableExpr's) */ 
</span> 
<a name="LN134"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rtable</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* list of range table entries */ 
</span><a name="LN135"></a>    <a href="primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>jointree</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* table join tree (FROM and WHERE clauses) */ 
</span> 
<a name="LN137"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>targetList</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* target list (of TargetEntry) */ 
</span> 
<a name="LN139"></a>    <a href="parsenodes.h.html#LN29"><span class='Ref_to_Enum'>OverridingKind</span></a> <span class='Declare_Member'>override</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OVERRIDING clause */ 
</span> 
<a name="LN141"></a>    <a href="primnodes.h.html#LN1482"><span class='Ref_to_Struct'>OnConflictExpr</span></a> <span class='Operator'>*</span><span class='Declare_Member'>onConflict</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* ON CONFLICT DO [NOTHING | UPDATE] */ 
</span> 
<a name="LN143"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>returningList</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* return-values list (of TargetEntry) */ 
</span> 
<a name="LN145"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* a list of SortGroupClause's */ 
</span> 
<a name="LN147"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupingSets</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* a list of GroupingSet's if present */ 
</span> 
<a name="LN149"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>havingQual</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* qualifications applied to groups */ 
</span> 
<a name="LN151"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>windowClause</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* a list of WindowClause's */ 
</span> 
<a name="LN153"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>distinctClause</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* a list of SortGroupClause's */ 
</span> 
<a name="LN155"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>sortClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* a list of SortGroupClause's */ 
</span> 
<a name="LN157"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* # of result tuples to skip (int8 expr) */ 
</span><a name="LN158"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitCount</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* # of result tuples to return (int8 expr) */ 
</span> 
<a name="LN160"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowMarks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* a list of RowMarkClause's */ 
</span> 
<a name="LN162"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>setOperations</span><span class='Delimiter'>;</span>  <span class='Comment_Multi_Line'>/* set-operation tree if this is top level of 
                                 * a UNION/INTERSECT/EXCEPT query */ 
</span> 
<a name="LN165"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>constraintDeps</span><span class='Delimiter'>; </span><span class='Comment_Multi_Line'>/* a list of pg_constraint OIDs that the query 
                                 * depends on to be semantically valid */ 
</span> 
<a name="LN168"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>withCheckOptions</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* a list of WithCheckOption's, which 
                                         * are only added during rewrite and 
                                         * therefore are not written out as 
                                         * part of Query. */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The following two fields identify the portion of the source text string 
     * containing this query.  They are typically only populated in top-level 
     * Queries, not in sub-queries.  When not set, they might both be zero, or 
     * both be -1 meaning "unknown". 
     */ 
</span><a name="LN179"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>stmt_location</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* start location, or -1 if unknown */ 
</span><a name="LN180"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>stmt_len</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* length in bytes; 0 means "rest of string" */ 
</span><a name="LN181"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end Query &raquo; </span> <span class='Declare_Typedef'>Query</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/**************************************************************************** 
 *  Supporting data structures for Parse Trees 
 * 
 *  Most of these node types appear in raw parsetrees output by the grammar, 
 *  and get transformed to something else by the analyzer.  A few of them 
 *  are used as-is in transformed querytrees. 
 ****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TypeName - specifies a type in definitions 
 * 
 * For TypeName structures generated internally, it is often easier to 
 * specify the type by OID than by name.  If "names" is NIL then the 
 * actual type OID is given by typeOid, otherwise typeOid is unused. 
 * Similarly, if "typmods" is NIL then the actual typmod is expected to 
 * be prespecified in typemod, otherwise typemod is unused. 
 * 
 * If pct_type is TRUE, then names is actually a field name and we look up 
 * the type of that field.  Otherwise (the normal case), names is a type 
 * name possibly qualified with schema and database name. 
 */ 
</span><a name="LN205"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TypeName</span> 
<span class='Delimiter'>{ 
</span><a name="LN207"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN208"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>names</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN209"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>typeOid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* type identified by OID */ 
</span><a name="LN210"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>setof</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* is a set? */ 
</span><a name="LN211"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>pct_type</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* %TYPE specified? */ 
</span><a name="LN212"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>typmods</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* type modifier expression(s) */ 
</span><a name="LN213"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>typemod</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* prespecified type modifier */ 
</span><a name="LN214"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arrayBounds</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array bounds */ 
</span><a name="LN215"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN216"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TypeName</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ColumnRef - specifies a reference to a column, or possibly a whole tuple 
 * 
 * The "fields" list must be nonempty.  It can contain string Value nodes 
 * (representing names) and A_Star nodes (representing occurrence of a '*'). 
 * Currently, A_Star must appear only as the last list element --- the grammar 
 * is responsible for enforcing this! 
 * 
 * Note: any array subscripting or selection of fields from composite columns 
 * is represented by an A_Indirection node above the ColumnRef.  However, 
 * for simplicity in the normal case, initial field selection from a table 
 * name is represented within ColumnRef and not by adding A_Indirection. 
 */ 
</span><a name="LN231"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ColumnRef</span> 
<span class='Delimiter'>{ 
</span><a name="LN233"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN234"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fields</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* field names (Value strings) or A_Star */ 
</span><a name="LN235"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN236"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ColumnRef</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ParamRef - specifies a $n parameter reference 
 */ 
</span><a name="LN241"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ParamRef</span> 
<span class='Delimiter'>{ 
</span><a name="LN243"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN244"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>number</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the number of the parameter */ 
</span><a name="LN245"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN246"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ParamRef</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A_Expr - infix, prefix, and postfix expressions 
 */ 
</span><a name="LN251"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>A_Expr_Kind</span> 
<span class='Delimiter'>{ 
</span><a name="LN253"></a>    <span class='Declare_Enum_Const'>AEXPR_OP</span><span class='Delimiter'>,</span>                   <span class='Comment_Single_Line'>/* normal operator */ 
</span><a name="LN254"></a>    <span class='Declare_Enum_Const'>AEXPR_OP_ANY</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* scalar op ANY (array) */ 
</span><a name="LN255"></a>    <span class='Declare_Enum_Const'>AEXPR_OP_ALL</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* scalar op ALL (array) */ 
</span><a name="LN256"></a>    <span class='Declare_Enum_Const'>AEXPR_DISTINCT</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* IS DISTINCT FROM - name must be "=" */ 
</span><a name="LN257"></a>    <span class='Declare_Enum_Const'>AEXPR_NOT_DISTINCT</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* IS NOT DISTINCT FROM - name must be "=" */ 
</span><a name="LN258"></a>    <span class='Declare_Enum_Const'>AEXPR_NULLIF</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* NULLIF - name must be "=" */ 
</span><a name="LN259"></a>    <span class='Declare_Enum_Const'>AEXPR_OF</span><span class='Delimiter'>,</span>                   <span class='Comment_Single_Line'>/* IS [NOT] OF - name must be "=" or "&LT;&GT;" */ 
</span><a name="LN260"></a>    <span class='Declare_Enum_Const'>AEXPR_IN</span><span class='Delimiter'>,</span>                   <span class='Comment_Single_Line'>/* [NOT] IN - name must be "=" or "&LT;&GT;" */ 
</span><a name="LN261"></a>    <span class='Declare_Enum_Const'>AEXPR_LIKE</span><span class='Delimiter'>,</span>                 <span class='Comment_Single_Line'>/* [NOT] LIKE - name must be "~~" or "!~~" */ 
</span><a name="LN262"></a>    <span class='Declare_Enum_Const'>AEXPR_ILIKE</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* [NOT] ILIKE - name must be "~~*" or "!~~*" */ 
</span><a name="LN263"></a>    <span class='Declare_Enum_Const'>AEXPR_SIMILAR</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* [NOT] SIMILAR - name must be "~" or "!~" */ 
</span><a name="LN264"></a>    <span class='Declare_Enum_Const'>AEXPR_BETWEEN</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* name must be "BETWEEN" */ 
</span><a name="LN265"></a>    <span class='Declare_Enum_Const'>AEXPR_NOT_BETWEEN</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* name must be "NOT BETWEEN" */ 
</span><a name="LN266"></a>    <span class='Declare_Enum_Const'>AEXPR_BETWEEN_SYM</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* name must be "BETWEEN SYMMETRIC" */ 
</span><a name="LN267"></a>    <span class='Declare_Enum_Const'>AEXPR_NOT_BETWEEN_SYM</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* name must be "NOT BETWEEN SYMMETRIC" */ 
</span><a name="LN268"></a>    <span class='Declare_Enum_Const'>AEXPR_PAREN</span>                 <span class='Comment_Single_Line'>/* nameless dummy node for parentheses */ 
</span><a name="LN269"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>A_Expr_Kind</span><span class='Delimiter'>; 
</span> 
<a name="LN271"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>A_Expr</span> 
<span class='Delimiter'>{ 
</span><a name="LN273"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN274"></a>    <a href="parsenodes.h.html#LN251"><span class='Ref_to_Enum'>A_Expr_Kind</span></a> <span class='Declare_Member'>kind</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* see above */ 
</span><a name="LN275"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* possibly-qualified name of operator */ 
</span><a name="LN276"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>lexpr</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* left argument, or NULL if none */ 
</span><a name="LN277"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rexpr</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* right argument, or NULL if none */ 
</span><a name="LN278"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN279"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>A_Expr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A_Const - a literal constant 
 */ 
</span><a name="LN284"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>A_Const</span> 
<span class='Delimiter'>{ 
</span><a name="LN286"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN287"></a>    <a href="value.h.html#LN41"><span class='Ref_to_Struct'>Value</span></a>       <span class='Declare_Member'>val</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* value (includes type info, see value.h) */ 
</span><a name="LN288"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN289"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>A_Const</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TypeCast - a CAST expression 
 */ 
</span><a name="LN294"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TypeCast</span> 
<span class='Delimiter'>{ 
</span><a name="LN296"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN297"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* the expression being casted */ 
</span><a name="LN298"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the target type */ 
</span><a name="LN299"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN300"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TypeCast</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CollateClause - a COLLATE expression 
 */ 
</span><a name="LN305"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CollateClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN307"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN308"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN309"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>collname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* possibly-qualified collation name */ 
</span><a name="LN310"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN311"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CollateClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RoleSpec - a role name or one of a few special values. 
 */ 
</span><a name="LN316"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>RoleSpecType</span> 
<span class='Delimiter'>{ 
</span><a name="LN318"></a>    <span class='Declare_Enum_Const'>ROLESPEC_CSTRING</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* role name is stored as a C string */ 
</span><a name="LN319"></a>    <span class='Declare_Enum_Const'>ROLESPEC_CURRENT_USER</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* role spec is CURRENT_USER */ 
</span><a name="LN320"></a>    <span class='Declare_Enum_Const'>ROLESPEC_SESSION_USER</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* role spec is SESSION_USER */ 
</span><a name="LN321"></a>    <span class='Declare_Enum_Const'>ROLESPEC_PUBLIC</span>             <span class='Comment_Single_Line'>/* role name is "public" */ 
</span><a name="LN322"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RoleSpecType</span><span class='Delimiter'>; 
</span> 
<a name="LN324"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RoleSpec</span> 
<span class='Delimiter'>{ 
</span><a name="LN326"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN327"></a>    <a href="parsenodes.h.html#LN316"><span class='Ref_to_Enum'>RoleSpecType</span></a> <span class='Declare_Member'>roletype</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* Type of this rolespec */ 
</span><a name="LN328"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>rolename</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* filled only for ROLESPEC_CSTRING */ 
</span><a name="LN329"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN330"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RoleSpec</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * FuncCall - a function or aggregate invocation 
 * 
 * agg_order (if not NIL) indicates we saw 'foo(... ORDER BY ...)', or if 
 * agg_within_group is true, it was 'foo(...) WITHIN GROUP (ORDER BY ...)'. 
 * agg_star indicates we saw a 'foo(*)' construct, while agg_distinct 
 * indicates we saw 'foo(DISTINCT ...)'.  In any of these cases, the 
 * construct *must* be an aggregate call.  Otherwise, it might be either an 
 * aggregate or some other kind of function.  However, if FILTER or OVER is 
 * present it had better be an aggregate or window function. 
 * 
 * Normally, you'd initialize this via makeFuncCall() and then only change the 
 * parts of the struct its defaults don't match afterwards, as needed. 
 */ 
</span><a name="LN346"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FuncCall</span> 
<span class='Delimiter'>{ 
</span><a name="LN348"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN349"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funcname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name of function */ 
</span><a name="LN350"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the arguments (list of exprs) */ 
</span><a name="LN351"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>agg_order</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ORDER BY (list of SortBy) */ 
</span><a name="LN352"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>agg_filter</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* FILTER clause, if any */ 
</span><a name="LN353"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>agg_within_group</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ORDER BY appeared in WITHIN GROUP */ 
</span><a name="LN354"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>agg_star</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* argument was really '*' */ 
</span><a name="LN355"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>agg_distinct</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* arguments were labeled DISTINCT */ 
</span><a name="LN356"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>func_variadic</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* last argument was labeled VARIADIC */ 
</span><a name="LN357"></a>    <span class='Control'>struct</span> <a href="parsenodes.h.html#LN483"><span class='Ref_to_Struct'>WindowDef</span></a> <span class='Operator'>*</span><span class='Declare_Member'>over</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OVER clause, if any */ 
</span><a name="LN358"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN359"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FuncCall</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A_Star - '*' representing all columns of a table or compound field 
 * 
 * This can appear within ColumnRef.fields, A_Indirection.indirection, and 
 * ResTarget.indirection lists. 
 */ 
</span><a name="LN367"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>A_Star</span> 
<span class='Delimiter'>{ 
</span><a name="LN369"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN370"></a>} <span class='Declare_Typedef'>A_Star</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A_Indices - array subscript or slice bounds ([idx] or [lidx:uidx]) 
 * 
 * In slice case, either or both of lidx and uidx can be NULL (omitted). 
 * In non-slice case, uidx holds the single subscript and lidx is always NULL. 
 */ 
</span><a name="LN378"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>A_Indices</span> 
<span class='Delimiter'>{ 
</span><a name="LN380"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN381"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_slice</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true if slice (i.e., colon present) */ 
</span><a name="LN382"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>lidx</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* slice lower bound, if any */ 
</span><a name="LN383"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>uidx</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* subscript, or slice upper bound if any */ 
</span><a name="LN384"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>A_Indices</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A_Indirection - select a field and/or array element from an expression 
 * 
 * The indirection list can contain A_Indices nodes (representing 
 * subscripting), string Value nodes (representing field selection --- the 
 * string value is the name of the field to select), and A_Star nodes 
 * (representing selection of all fields of a composite type). 
 * For example, a complex selection operation like 
 *              (foo).field1[42][7].field2 
 * would be represented with a single A_Indirection node having a 4-element 
 * indirection list. 
 * 
 * Currently, A_Star must appear only as the last list element --- the grammar 
 * is responsible for enforcing this! 
 */ 
</span><a name="LN401"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>A_Indirection</span> 
<span class='Delimiter'>{ 
</span><a name="LN403"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN404"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* the thing being selected from */ 
</span><a name="LN405"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indirection</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* subscripts and/or field names and/or * */ 
</span><a name="LN406"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>A_Indirection</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A_ArrayExpr - an ARRAY[] construct 
 */ 
</span><a name="LN411"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>A_ArrayExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN413"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN414"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>elements</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* array element expressions */ 
</span><a name="LN415"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN416"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>A_ArrayExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ResTarget - 
 *    result target (used in target list of pre-transformed parse trees) 
 * 
 * In a SELECT target list, 'name' is the column label from an 
 * 'AS ColumnLabel' clause, or NULL if there was none, and 'val' is the 
 * value expression itself.  The 'indirection' field is not used. 
 * 
 * INSERT uses ResTarget in its target-column-names list.  Here, 'name' is 
 * the name of the destination column, 'indirection' stores any subscripts 
 * attached to the destination, and 'val' is not used. 
 * 
 * In an UPDATE target list, 'name' is the name of the destination column, 
 * 'indirection' stores any subscripts attached to the destination, and 
 * 'val' is the expression to assign. 
 * 
 * See A_Indirection for more info about what can appear in 'indirection'. 
 */ 
</span><a name="LN436"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ResTarget</span> 
<span class='Delimiter'>{ 
</span><a name="LN438"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN439"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* column name or NULL */ 
</span><a name="LN440"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indirection</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* subscripts, field names, and '*', or NIL */ 
</span><a name="LN441"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>val</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* the value expression to compute or assign */ 
</span><a name="LN442"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN443"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ResTarget</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * MultiAssignRef - element of a row source expression for UPDATE 
 * 
 * In an UPDATE target list, when we have SET (a,b,c) = row-valued-expression, 
 * we generate separate ResTarget items for each of a,b,c.  Their "val" trees 
 * are MultiAssignRef nodes numbered 1..n, linking to a common copy of the 
 * row-valued-expression (which parse analysis will process only once, when 
 * handling the MultiAssignRef with colno=1). 
 */ 
</span><a name="LN454"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MultiAssignRef</span> 
<span class='Delimiter'>{ 
</span><a name="LN456"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN457"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>source</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the row-valued expression */ 
</span><a name="LN458"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>colno</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* column number for this target (1..n) */ 
</span><a name="LN459"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ncolumns</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* number of targets in the construct */ 
</span><a name="LN460"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MultiAssignRef</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SortBy - for ORDER BY clause 
 */ 
</span><a name="LN465"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SortBy</span> 
<span class='Delimiter'>{ 
</span><a name="LN467"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN468"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>node</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expression to sort on */ 
</span><a name="LN469"></a>    <a href="parsenodes.h.html#LN47"><span class='Ref_to_Enum'>SortByDir</span></a>   <span class='Declare_Member'>sortby_dir</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* ASC/DESC/USING/default */ 
</span><a name="LN470"></a>    <a href="parsenodes.h.html#LN55"><span class='Ref_to_Enum'>SortByNulls</span></a> <span class='Declare_Member'>sortby_nulls</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* NULLS FIRST/LAST */ 
</span><a name="LN471"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>useOp</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* name of op to use, if SORTBY_USING */ 
</span><a name="LN472"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* operator location, or -1 if none/unknown */ 
</span><a name="LN473"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SortBy</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * WindowDef - raw representation of WINDOW and OVER clauses 
 * 
 * For entries in a WINDOW list, "name" is the window name being defined. 
 * For OVER clauses, we use "name" for the "OVER window" syntax, or "refname" 
 * for the "OVER (window)" syntax, which is subtly different --- the latter 
 * implies overriding the window frame clause. 
 */ 
</span><a name="LN483"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WindowDef</span> 
<span class='Delimiter'>{ 
</span><a name="LN485"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN486"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* window's own name */ 
</span><a name="LN487"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>refname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* referenced window name, if any */ 
</span><a name="LN488"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitionClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* PARTITION BY expression list */ 
</span><a name="LN489"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>orderClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* ORDER BY (list of SortBy) */ 
</span><a name="LN490"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>frameOptions</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* frame_clause options, see below */ 
</span><a name="LN491"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>startOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expression for starting bound, if any */ 
</span><a name="LN492"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>endOffset</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* expression for ending bound, if any */ 
</span><a name="LN493"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* parse location, or -1 if none/unknown */ 
</span><a name="LN494"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WindowDef</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * frameOptions is an OR of these bits.  The NONDEFAULT and BETWEEN bits are 
 * used so that ruleutils.c can tell which properties were specified and 
 * which were defaulted; the correct behavioral bits must be set either way. 
 * The START_foo and END_foo options must come in pairs of adjacent bits for 
 * the convenience of gram.y, even though some of them are useless/invalid. 
 * We will need more bits (and fields) to cover the full SQL:2008 option set. 
 */ 
</span><a name="LN504"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_NONDEFAULT</span>                  <span class='Number'>0x00001</span> <span class='Comment_Single_Line'>/* any specified? */ 
</span><a name="LN505"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_RANGE</span>                       <span class='Number'>0x00002</span> <span class='Comment_Single_Line'>/* RANGE behavior */ 
</span><a name="LN506"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_ROWS</span>                        <span class='Number'>0x00004</span> <span class='Comment_Single_Line'>/* ROWS behavior */ 
</span><a name="LN507"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_BETWEEN</span>                     <span class='Number'>0x00008</span> <span class='Comment_Single_Line'>/* BETWEEN given? */ 
</span><a name="LN508"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_START_UNBOUNDED_PRECEDING</span>   <span class='Number'>0x00010</span> <span class='Comment_Single_Line'>/* start is U. P. */ 
</span><a name="LN509"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_END_UNBOUNDED_PRECEDING</span>     <span class='Number'>0x00020</span> <span class='Comment_Single_Line'>/* (disallowed) */ 
</span><a name="LN510"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_START_UNBOUNDED_FOLLOWING</span>   <span class='Number'>0x00040</span> <span class='Comment_Single_Line'>/* (disallowed) */ 
</span><a name="LN511"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_END_UNBOUNDED_FOLLOWING</span>     <span class='Number'>0x00080</span> <span class='Comment_Single_Line'>/* end is U. F. */ 
</span><a name="LN512"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_START_CURRENT_ROW</span>           <span class='Number'>0x00100</span> <span class='Comment_Single_Line'>/* start is C. R. */ 
</span><a name="LN513"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_END_CURRENT_ROW</span>             <span class='Number'>0x00200</span> <span class='Comment_Single_Line'>/* end is C. R. */ 
</span><a name="LN514"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_START_VALUE_PRECEDING</span>       <span class='Number'>0x00400</span> <span class='Comment_Single_Line'>/* start is V. P. */ 
</span><a name="LN515"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_END_VALUE_PRECEDING</span>         <span class='Number'>0x00800</span> <span class='Comment_Single_Line'>/* end is V. P. */ 
</span><a name="LN516"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_START_VALUE_FOLLOWING</span>       <span class='Number'>0x01000</span> <span class='Comment_Single_Line'>/* start is V. F. */ 
</span><a name="LN517"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_END_VALUE_FOLLOWING</span>         <span class='Number'>0x02000</span> <span class='Comment_Single_Line'>/* end is V. F. */ 
</span> 
<a name="LN519"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_START_VALUE</span> <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="parsenodes.h.html#LN514"><span class='Ref_to_Const'>FRAMEOPTION_START_VALUE_PRECEDING</span></a> <span class='Operator'>| </span><a href="parsenodes.h.html#LN516"><span class='Ref_to_Const'>FRAMEOPTION_START_VALUE_FOLLOWING</span></a><span class='Parentheses'>) 
</span><a name="LN521"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_END_VALUE</span> <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="parsenodes.h.html#LN515"><span class='Ref_to_Const'>FRAMEOPTION_END_VALUE_PRECEDING</span></a> <span class='Operator'>| </span><a href="parsenodes.h.html#LN517"><span class='Ref_to_Const'>FRAMEOPTION_END_VALUE_FOLLOWING</span></a><span class='Parentheses'>) 
</span> 
<a name="LN524"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FRAMEOPTION_DEFAULTS</span> <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="parsenodes.h.html#LN505"><span class='Ref_to_Const'>FRAMEOPTION_RANGE</span></a> <span class='Operator'>| </span><a href="parsenodes.h.html#LN508"><span class='Ref_to_Const'>FRAMEOPTION_START_UNBOUNDED_PRECEDING</span></a> <span class='Operator'>| \ 
</span>     <a href="parsenodes.h.html#LN513"><span class='Ref_to_Const'>FRAMEOPTION_END_CURRENT_ROW</span></a><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeSubselect - subquery appearing in a FROM clause 
 */ 
</span><a name="LN531"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeSubselect</span> 
<span class='Delimiter'>{ 
</span><a name="LN533"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN534"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>lateral</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* does it have LATERAL prefix? */ 
</span><a name="LN535"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subquery</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the untransformed sub-select clause */ 
</span><a name="LN536"></a>    <a href="primnodes.h.html#LN38"><span class='Ref_to_Struct'>Alias</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>alias</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* table alias & optional column aliases */ 
</span><a name="LN537"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RangeSubselect</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeFunction - function call appearing in a FROM clause 
 * 
 * functions is a List because we use this to represent the construct 
 * ROWS FROM(func1(...), func2(...), ...).  Each element of this list is a 
 * two-element sublist, the first element being the untransformed function 
 * call tree, and the second element being a possibly-empty list of ColumnDef 
 * nodes representing any columndef list attached to that function within the 
 * ROWS FROM() syntax. 
 * 
 * alias and coldeflist represent any alias and/or columndef list attached 
 * at the top level.  (We disallow coldeflist appearing both here and 
 * per-function, but that's checked in parse analysis, not by the grammar.) 
 */ 
</span><a name="LN553"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeFunction</span> 
<span class='Delimiter'>{ 
</span><a name="LN555"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN556"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>lateral</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* does it have LATERAL prefix? */ 
</span><a name="LN557"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ordinality</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* does it have WITH ORDINALITY suffix? */ 
</span><a name="LN558"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_rowsfrom</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* is result of ROWS FROM() syntax? */ 
</span><a name="LN559"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>functions</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* per-function information, see above */ 
</span><a name="LN560"></a>    <a href="primnodes.h.html#LN38"><span class='Ref_to_Struct'>Alias</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>alias</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* table alias & optional column aliases */ 
</span><a name="LN561"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coldeflist</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* list of ColumnDef nodes to describe result 
                                 * of function returning RECORD */ 
</span><a name="LN563"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RangeFunction</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeTableFunc - raw form of "table functions" such as XMLTABLE 
 */ 
</span><a name="LN568"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeTableFunc</span> 
<span class='Delimiter'>{ 
</span><a name="LN570"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN571"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>lateral</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* does it have LATERAL prefix? */ 
</span><a name="LN572"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>docexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* document expression */ 
</span><a name="LN573"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* row generator expression */ 
</span><a name="LN574"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>namespaces</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of namespaces as ResTarget */ 
</span><a name="LN575"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>columns</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of RangeTableFuncCol */ 
</span><a name="LN576"></a>    <a href="primnodes.h.html#LN38"><span class='Ref_to_Struct'>Alias</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>alias</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* table alias & optional column aliases */ 
</span><a name="LN577"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN578"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RangeTableFunc</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeTableFuncCol - one column in a RangeTableFunc-&GT;columns 
 * 
 * If for_ordinality is true (FOR ORDINALITY), then the column is an int4 
 * column and the rest of the fields are ignored. 
 */ 
</span><a name="LN586"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeTableFuncCol</span> 
<span class='Delimiter'>{ 
</span><a name="LN588"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN589"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>colname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of generated column */ 
</span><a name="LN590"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* type of generated column */ 
</span><a name="LN591"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>for_ordinality</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* does it have FOR ORDINALITY? */ 
</span><a name="LN592"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_not_null</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* does it have NOT NULL? */ 
</span><a name="LN593"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* column filter expression */ 
</span><a name="LN594"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coldefexpr</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* column default value expression */ 
</span><a name="LN595"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN596"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RangeTableFuncCol</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeTableSample - TABLESAMPLE appearing in a raw FROM clause 
 * 
 * This node, appearing only in raw parse trees, represents 
 *      &LT;relation&GT; TABLESAMPLE &LT;method&GT; (&LT;params&GT;) REPEATABLE (&LT;num&GT;) 
 * Currently, the &LT;relation&GT; can only be a RangeVar, but we might in future 
 * allow RangeSubselect and other options.  Note that the RangeTableSample 
 * is wrapped around the node representing the &LT;relation&GT;, rather than being 
 * a subfield of it. 
 */ 
</span><a name="LN608"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeTableSample</span> 
<span class='Delimiter'>{ 
</span><a name="LN610"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN611"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation to be sampled */ 
</span><a name="LN612"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>method</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* sampling method name (possibly qualified) */ 
</span><a name="LN613"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* argument(s) for sampling method */ 
</span><a name="LN614"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>repeatable</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* REPEATABLE expression, or NULL if none */ 
</span><a name="LN615"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* method name location, or -1 if unknown */ 
</span><a name="LN616"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RangeTableSample</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ColumnDef - column definition (used in various creates) 
 * 
 * If the column has a default value, we may have the value expression 
 * in either "raw" form (an untransformed parse tree) or "cooked" form 
 * (a post-parse-analysis, executable expression tree), depending on 
 * how this ColumnDef node was created (by parsing, or by inheritance 
 * from an existing relation).  We should never have both in the same node! 
 * 
 * Similarly, we may have a COLLATE specification in either raw form 
 * (represented as a CollateClause with arg==NULL) or cooked form 
 * (the collation's OID). 
 * 
 * The constraints list may contain a CONSTR_DEFAULT item in a raw 
 * parsetree produced by gram.y, but transformCreateStmt will remove 
 * the item and set raw_default instead.  CONSTR_DEFAULT items 
 * should not appear in any subsequent processing. 
 */ 
</span><a name="LN636"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ColumnDef</span> 
<span class='Delimiter'>{ 
</span><a name="LN638"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN639"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>colname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of column */ 
</span><a name="LN640"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* type of column */ 
</span><a name="LN641"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>inhcount</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* number of times column is inherited */ 
</span><a name="LN642"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_local</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* column has local (non-inherited) def'n */ 
</span><a name="LN643"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_not_null</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* NOT NULL constraint specified? */ 
</span><a name="LN644"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_from_type</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* column definition came from table type */ 
</span><a name="LN645"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_from_parent</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* column def came from partition parent */ 
</span><a name="LN646"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>storage</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* attstorage setting, or 0 for default */ 
</span><a name="LN647"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>raw_default</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* default value (untransformed parse tree) */ 
</span><a name="LN648"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cooked_default</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* default value (transformed expr tree) */ 
</span><a name="LN649"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>identity</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* attidentity setting */ 
</span><a name="LN650"></a>    <a href="parsenodes.h.html#LN305"><span class='Ref_to_Struct'>CollateClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>collClause</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* untransformed COLLATE spec, if any */ 
</span><a name="LN651"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collOid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* collation OID (InvalidOid if not set) */ 
</span><a name="LN652"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>constraints</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* other constraints on column */ 
</span><a name="LN653"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdwoptions</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* per-column FDW options */ 
</span><a name="LN654"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* parse location, or -1 if none/unknown */ 
</span><a name="LN655"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ColumnDef &raquo; </span> <span class='Declare_Typedef'>ColumnDef</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TableLikeClause - CREATE TABLE ( ... LIKE ... ) clause 
 */ 
</span><a name="LN660"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TableLikeClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN662"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN663"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>; 
</span><a name="LN664"></a>    <a href="../c.h.html#LN276"><span class='Ref_to_Typedef'>bits32</span></a>      <span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OR of TableLikeOption flags */ 
</span><a name="LN665"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TableLikeClause</span><span class='Delimiter'>; 
</span> 
<a name="LN667"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>TableLikeOption</span> 
<span class='Delimiter'>{ 
</span><a name="LN669"></a>    <span class='Declare_Enum_Const'>CREATE_TABLE_LIKE_DEFAULTS</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN670"></a>    <span class='Declare_Enum_Const'>CREATE_TABLE_LIKE_CONSTRAINTS</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>1</span><span class='Delimiter'>, 
</span><a name="LN671"></a>    <span class='Declare_Enum_Const'>CREATE_TABLE_LIKE_IDENTITY</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>2</span><span class='Delimiter'>, 
</span><a name="LN672"></a>    <span class='Declare_Enum_Const'>CREATE_TABLE_LIKE_INDEXES</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>3</span><span class='Delimiter'>, 
</span><a name="LN673"></a>    <span class='Declare_Enum_Const'>CREATE_TABLE_LIKE_STORAGE</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>4</span><span class='Delimiter'>, 
</span><a name="LN674"></a>    <span class='Declare_Enum_Const'>CREATE_TABLE_LIKE_COMMENTS</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>5</span><span class='Delimiter'>, 
</span><a name="LN675"></a>    <span class='Declare_Enum_Const'>CREATE_TABLE_LIKE_ALL</span> <span class='Operator'>= </span><a href="../c.h.html#LN339"><span class='Ref_to_Const'>PG_INT32_MAX</span></a> 
<a name="LN676"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TableLikeOption</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IndexElem - index parameters (used in CREATE INDEX, and in ON CONFLICT) 
 * 
 * For a plain index attribute, 'name' is the name of the table column to 
 * index, and 'expr' is NULL.  For an index expression, 'name' is NULL and 
 * 'expr' is the expression tree. 
 */ 
</span><a name="LN685"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexElem</span> 
<span class='Delimiter'>{ 
</span><a name="LN687"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN688"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* name of attribute to index, or NULL */ 
</span><a name="LN689"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expression to index, or NULL */ 
</span><a name="LN690"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>indexcolname</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* name for index column; NULL = default */ 
</span><a name="LN691"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>collation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* name of collation; NIL = default */ 
</span><a name="LN692"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opclass</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of desired opclass; NIL = default */ 
</span><a name="LN693"></a>    <a href="parsenodes.h.html#LN47"><span class='Ref_to_Enum'>SortByDir</span></a>   <span class='Declare_Member'>ordering</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ASC/DESC/default */ 
</span><a name="LN694"></a>    <a href="parsenodes.h.html#LN55"><span class='Ref_to_Enum'>SortByNulls</span></a> <span class='Declare_Member'>nulls_ordering</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* FIRST/LAST/default */ 
</span><a name="LN695"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>IndexElem</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * DefElem - a generic "name = value" option definition 
 * 
 * In some contexts the name can be qualified.  Also, certain SQL commands 
 * allow a SET/ADD/DROP action to be attached to option settings, so it's 
 * convenient to carry a field for that too.  (Note: currently, it is our 
 * practice that the grammar allows namespace and action only in statements 
 * where they are relevant; C code can just ignore those fields in other 
 * statements.) 
 */ 
</span><a name="LN707"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>DefElemAction</span> 
<span class='Delimiter'>{ 
</span><a name="LN709"></a>    <span class='Declare_Enum_Const'>DEFELEM_UNSPEC</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* no action given */ 
</span><a name="LN710"></a>    <span class='Declare_Enum_Const'>DEFELEM_SET</span><span class='Delimiter'>, 
</span><a name="LN711"></a>    <span class='Declare_Enum_Const'>DEFELEM_ADD</span><span class='Delimiter'>, 
</span><a name="LN712"></a>    <span class='Declare_Enum_Const'>DEFELEM_DROP</span> 
<a name="LN713"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DefElemAction</span><span class='Delimiter'>; 
</span> 
<a name="LN715"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DefElem</span> 
<span class='Delimiter'>{ 
</span><a name="LN717"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN718"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>defnamespace</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* NULL if unqualified name */ 
</span><a name="LN719"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>defname</span><span class='Delimiter'>; 
</span><a name="LN720"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* a (Value *) or a (TypeName *) */ 
</span><a name="LN721"></a>    <a href="parsenodes.h.html#LN707"><span class='Ref_to_Enum'>DefElemAction</span></a> <span class='Declare_Member'>defaction</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* unspecified action, or SET/ADD/DROP */ 
</span><a name="LN722"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN723"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DefElem</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LockingClause - raw representation of FOR [NO KEY] UPDATE/[KEY] SHARE 
 *      options 
 * 
 * Note: lockedRels == NIL means "all relations in query".  Otherwise it 
 * is a list of RangeVar nodes.  (We use RangeVar mainly because it carries 
 * a location field --- currently, parse analysis insists on unqualified 
 * names in LockingClause.) 
 */ 
</span><a name="LN734"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LockingClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN736"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN737"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>lockedRels</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* FOR [KEY] UPDATE/SHARE relations */ 
</span><a name="LN738"></a>    <a href="lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Member'>strength</span><span class='Delimiter'>; 
</span><a name="LN739"></a>    <a href="lockoptions.h.html#LN35"><span class='Ref_to_Enum'>LockWaitPolicy</span></a> <span class='Declare_Member'>waitPolicy</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* NOWAIT and SKIP LOCKED */ 
</span><a name="LN740"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LockingClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * XMLSERIALIZE (in raw parse tree only) 
 */ 
</span><a name="LN745"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>XmlSerialize</span> 
<span class='Delimiter'>{ 
</span><a name="LN747"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN748"></a>    <a href="primnodes.h.html#LN1131"><span class='Ref_to_Typedef'>XmlOptionType</span></a> <span class='Declare_Member'>xmloption</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* DOCUMENT or CONTENT */ 
</span><a name="LN749"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>; 
</span><a name="LN750"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>; 
</span><a name="LN751"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN752"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>XmlSerialize</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Partitioning related definitions */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PartitionElem - parse-time representation of a single partition key 
 * 
 * expr can be either a raw expression tree or a parse-analyzed expression. 
 * We don't store these on-disk, though. 
 */ 
</span><a name="LN762"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PartitionElem</span> 
<span class='Delimiter'>{ 
</span><a name="LN764"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN765"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* name of column to partition on, or NULL */ 
</span><a name="LN766"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expression to partition on, or NULL */ 
</span><a name="LN767"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>collation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* name of collation; NIL = default */ 
</span><a name="LN768"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opclass</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of desired opclass; NIL = default */ 
</span><a name="LN769"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN770"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PartitionElem</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PartitionSpec - parse-time representation of a partition key specification 
 * 
 * This represents the key space we will be partitioning on. 
 */ 
</span><a name="LN777"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PartitionSpec</span> 
<span class='Delimiter'>{ 
</span><a name="LN779"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN780"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>strategy</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* partitioning strategy ('list' or 'range') */ 
</span><a name="LN781"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partParams</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* List of PartitionElems */ 
</span><a name="LN782"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN783"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PartitionSpec</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Internal codes for partitioning strategies */ 
</span><a name="LN786"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PARTITION_STRATEGY_LIST</span>     <span class='String'>'l'</span> 
<a name="LN787"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PARTITION_STRATEGY_RANGE</span>    <span class='String'>'r'</span> 
 
<span class='Comment_Multi_Line'>/* 
 * PartitionBoundSpec - a partition bound specification 
 * 
 * This represents the portion of the partition key space assigned to a 
 * particular partition.  These are stored on disk in pg_class.relpartbound. 
 */ 
</span><a name="LN795"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PartitionBoundSpec</span> 
<span class='Delimiter'>{ 
</span><a name="LN797"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN799"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>strategy</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* see PARTITION_STRATEGY codes above */ 
</span> 
    <span class='Comment_Multi_Line'>/* Partitioning info for LIST strategy: */ 
</span><a name="LN802"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>listdatums</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* List of Consts (or A_Consts in raw tree) */ 
</span> 
    <span class='Comment_Multi_Line'>/* Partitioning info for RANGE strategy: */ 
</span><a name="LN805"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>lowerdatums</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* List of PartitionRangeDatums */ 
</span><a name="LN806"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>upperdatums</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* List of PartitionRangeDatums */ 
</span> 
<a name="LN808"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN809"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PartitionBoundSpec</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PartitionRangeDatum - can be either a value or UNBOUNDED 
 * 
 * "value" is an A_Const in raw grammar output, a Const after analysis 
 */ 
</span><a name="LN816"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PartitionRangeDatum</span> 
<span class='Delimiter'>{ 
</span><a name="LN818"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN820"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>infinite</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true if UNBOUNDED */ 
</span><a name="LN821"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>value</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* null if UNBOUNDED */ 
</span> 
<a name="LN823"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN824"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PartitionRangeDatum</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PartitionCmd - info for ALTER TABLE ATTACH/DETACH PARTITION commands 
 */ 
</span><a name="LN829"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PartitionCmd</span> 
<span class='Delimiter'>{ 
</span><a name="LN831"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN832"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* name of partition to attach/detach */ 
</span><a name="LN833"></a>    <a href="parsenodes.h.html#LN795"><span class='Ref_to_Struct'>PartitionBoundSpec</span></a> <span class='Operator'>*</span><span class='Declare_Member'>bound</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* FOR VALUES, if attaching */ 
</span><a name="LN834"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PartitionCmd</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/**************************************************************************** 
 *  Nodes for a Query tree 
 ****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/*-------------------- 
 * RangeTblEntry - 
 *    A range table is a List of RangeTblEntry nodes. 
 * 
 *    A range table entry may represent a plain relation, a sub-select in 
 *    FROM, or the result of a JOIN clause.  (Only explicit JOIN syntax 
 *    produces an RTE, not the implicit join resulting from multiple FROM 
 *    items.  This is because we only need the RTE to deal with SQL features 
 *    like outer joins and join-output-column aliasing.)  Other special 
 *    RTE types also exist, as indicated by RTEKind. 
 * 
 *    Note that we consider RTE_RELATION to cover anything that has a pg_class 
 *    entry.  relkind distinguishes the sub-cases. 
 * 
 *    alias is an Alias node representing the AS alias-clause attached to the 
 *    FROM expression, or NULL if no clause. 
 * 
 *    eref is the table reference name and column reference names (either 
 *    real or aliases).  Note that system columns (OID etc) are not included 
 *    in the column list. 
 *    eref-&GT;aliasname is required to be present, and should generally be used 
 *    to identify the RTE for error messages etc. 
 * 
 *    In RELATION RTEs, the colnames in both alias and eref are indexed by 
 *    physical attribute number; this means there must be colname entries for 
 *    dropped columns.  When building an RTE we insert empty strings ("") for 
 *    dropped columns.  Note however that a stored rule may have nonempty 
 *    colnames for columns dropped since the rule was created (and for that 
 *    matter the colnames might be out of date due to column renamings). 
 *    The same comments apply to FUNCTION RTEs when a function's return type 
 *    is a named composite type. 
 * 
 *    In JOIN RTEs, the colnames in both alias and eref are one-to-one with 
 *    joinaliasvars entries.  A JOIN RTE will omit columns of its inputs when 
 *    those columns are known to be dropped at parse time.  Again, however, 
 *    a stored rule might contain entries for columns dropped since the rule 
 *    was created.  (This is only possible for columns not actually referenced 
 *    in the rule.)  When loading a stored rule, we replace the joinaliasvars 
 *    items for any such columns with null pointers.  (We can't simply delete 
 *    them from the joinaliasvars list, because that would affect the attnums 
 *    of Vars referencing the rest of the list.) 
 * 
 *    inh is TRUE for relation references that should be expanded to include 
 *    inheritance children, if the rel has any.  This *must* be FALSE for 
 *    RTEs other than RTE_RELATION entries. 
 * 
 *    inFromCl marks those range variables that are listed in the FROM clause. 
 *    It's false for RTEs that are added to a query behind the scenes, such 
 *    as the NEW and OLD variables for a rule, or the subqueries of a UNION. 
 *    This flag is not used anymore during parsing, since the parser now uses 
 *    a separate "namespace" data structure to control visibility, but it is 
 *    needed by ruleutils.c to determine whether RTEs should be shown in 
 *    decompiled queries. 
 * 
 *    requiredPerms and checkAsUser specify run-time access permissions 
 *    checks to be performed at query startup.  The user must have *all* 
 *    of the permissions that are OR'd together in requiredPerms (zero 
 *    indicates no permissions checking).  If checkAsUser is not zero, 
 *    then do the permissions checks using the access rights of that user, 
 *    not the current effective user ID.  (This allows rules to act as 
 *    setuid gateways.)  Permissions checks only apply to RELATION RTEs. 
 * 
 *    For SELECT/INSERT/UPDATE permissions, if the user doesn't have 
 *    table-wide permissions then it is sufficient to have the permissions 
 *    on all columns identified in selectedCols (for SELECT) and/or 
 *    insertedCols and/or updatedCols (INSERT with ON CONFLICT DO UPDATE may 
 *    have all 3).  selectedCols, insertedCols and updatedCols are bitmapsets, 
 *    which cannot have negative integer members, so we subtract 
 *    FirstLowInvalidHeapAttributeNumber from column numbers before storing 
 *    them in these fields.  A whole-row Var reference is represented by 
 *    setting the bit for InvalidAttrNumber. 
 * 
 *    securityQuals is a list of security barrier quals (boolean expressions), 
 *    to be tested in the listed order before returning a row from the 
 *    relation.  It is always NIL in parser output.  Entries are added by the 
 *    rewriter to implement security-barrier views and/or row-level security. 
 *    Note that the planner turns each boolean expression into an implicitly 
 *    AND'ed sublist, as is its usual habit with qualification expressions. 
 *-------------------- 
 */ 
</span><a name="LN920"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>RTEKind</span> 
<span class='Delimiter'>{ 
</span><a name="LN922"></a>    <span class='Declare_Enum_Const'>RTE_RELATION</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* ordinary relation reference */ 
</span><a name="LN923"></a>    <span class='Declare_Enum_Const'>RTE_SUBQUERY</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* subquery in FROM */ 
</span><a name="LN924"></a>    <span class='Declare_Enum_Const'>RTE_JOIN</span><span class='Delimiter'>,</span>                   <span class='Comment_Single_Line'>/* join */ 
</span><a name="LN925"></a>    <span class='Declare_Enum_Const'>RTE_FUNCTION</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* function in FROM */ 
</span><a name="LN926"></a>    <span class='Declare_Enum_Const'>RTE_TABLEFUNC</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* TableFunc(.., column list) */ 
</span><a name="LN927"></a>    <span class='Declare_Enum_Const'>RTE_VALUES</span><span class='Delimiter'>,</span>                 <span class='Comment_Single_Line'>/* VALUES (&LT;exprlist&GT;), (&LT;exprlist&GT;), ... */ 
</span><a name="LN928"></a>    <span class='Declare_Enum_Const'>RTE_CTE</span><span class='Delimiter'>,</span>                    <span class='Comment_Single_Line'>/* common table expr (WITH list element) */ 
</span><a name="LN929"></a>    <span class='Declare_Enum_Const'>RTE_NAMEDTUPLESTORE</span>         <span class='Comment_Single_Line'>/* tuplestore, e.g. for AFTER triggers */ 
</span><a name="LN930"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RTEKind</span><span class='Delimiter'>; 
</span> 
<a name="LN932"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeTblEntry</span> 
<span class='Delimiter'>{ 
</span><a name="LN934"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN936"></a>    <a href="parsenodes.h.html#LN920"><span class='Ref_to_Enum'>RTEKind</span></a>     <span class='Declare_Member'>rtekind</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* see above */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX the fields applicable to only some rte kinds should be merged into 
     * a union.  I didn't do this yet because the diffs would impact a lot of 
     * code that is being actively worked on.  FIXME someday. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for a plain relation RTE (else zero): 
     */ 
</span><a name="LN947"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>relid</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* OID of the relation */ 
</span><a name="LN948"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>relkind</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* relation kind (see pg_class.relkind) */ 
</span><a name="LN949"></a>    <span class='Control'>struct</span> <a href="parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tablesample</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* sampling info, or NULL */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for a subquery RTE (else NULL): 
     */ 
</span><a name="LN954"></a>    <a href="parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>subquery</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the sub-query */ 
</span><a name="LN955"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>security_barrier</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* is from security_barrier view? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for a join RTE (else NULL/zero): 
     * 
     * joinaliasvars is a list of (usually) Vars corresponding to the columns 
     * of the join result.  An alias Var referencing column K of the join 
     * result can be replaced by the K'th element of joinaliasvars --- but to 
     * simplify the task of reverse-listing aliases correctly, we do not do 
     * that until planning time.  In detail: an element of joinaliasvars can 
     * be a Var of one of the join's input relations, or such a Var with an 
     * implicit coercion to the join's output column type, or a COALESCE 
     * expression containing the two input column Vars (possibly coerced). 
     * Within a Query loaded from a stored rule, it is also possible for 
     * joinaliasvars items to be null pointers, which are placeholders for 
     * (necessarily unreferenced) columns dropped since the rule was made. 
     * Also, once planning begins, joinaliasvars items can be almost anything, 
     * as a result of subquery-flattening substitutions. 
     */ 
</span><a name="LN974"></a>    <a href="nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Member'>jointype</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* type of join */ 
</span><a name="LN975"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>joinaliasvars</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of alias-var expansions */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for a function RTE (else NIL/zero): 
     * 
     * When funcordinality is true, the eref-&GT;colnames list includes an alias 
     * for the ordinality column.  The ordinality column is otherwise 
     * implicit, and must be accounted for "by hand" in places such as 
     * expandRTE(). 
     */ 
</span><a name="LN985"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>functions</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of RangeTblFunction nodes */ 
</span><a name="LN986"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>funcordinality</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* is this called WITH ORDINALITY? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for a TableFunc RTE (else NULL): 
     */ 
</span><a name="LN991"></a>    <a href="primnodes.h.html#LN78"><span class='Ref_to_Struct'>TableFunc</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>tablefunc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for a values RTE (else NIL): 
     */ 
</span><a name="LN996"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>values_lists</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of expression lists */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for a CTE RTE (else NULL/zero): 
     */ 
</span><a name="LN1001"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>ctename</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of the WITH list item */ 
</span><a name="LN1002"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>ctelevelsup</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of query levels up */ 
</span><a name="LN1003"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>self_reference</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* is this a recursive self-reference? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid for values and CTE RTEs (else NIL): 
     * 
     * We need these for CTE RTEs so that the types of self-referential 
     * columns are well-defined.  For VALUES RTEs, storing these explicitly 
     * saves having to re-determine the info by scanning the values_lists. 
     */ 
</span><a name="LN1012"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coltypes</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OID list of column type OIDs */ 
</span><a name="LN1013"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coltypmods</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* integer list of column typmods */ 
</span><a name="LN1014"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colcollations</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OID list of column collation OIDs */ 
</span> 
<a name="LN1016"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>enrname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of ephemeral named relation */ 
</span><a name="LN1017"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>enrtuples</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* estimated or actual from caller */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fields valid in all RTEs: 
     */ 
</span><a name="LN1022"></a>    <a href="primnodes.h.html#LN38"><span class='Ref_to_Struct'>Alias</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>alias</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* user-written alias clause, if any */ 
</span><a name="LN1023"></a>    <a href="primnodes.h.html#LN38"><span class='Ref_to_Struct'>Alias</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>eref</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expanded reference names */ 
</span><a name="LN1024"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>lateral</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* subquery, function, or values is LATERAL? */ 
</span><a name="LN1025"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inh</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* inheritance requested? */ 
</span><a name="LN1026"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inFromCl</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* present in FROM clause? */ 
</span><a name="LN1027"></a>    <a href="parsenodes.h.html#LN69"><span class='Ref_to_Typedef'>AclMode</span></a>     <span class='Declare_Member'>requiredPerms</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* bitmask of required access permissions */ 
</span><a name="LN1028"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>checkAsUser</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* if valid, check access as this role */ 
</span><a name="LN1029"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>selectedCols</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* columns needing SELECT permission */ 
</span><a name="LN1030"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>insertedCols</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* columns needing INSERT permission */ 
</span><a name="LN1031"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>updatedCols</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* columns needing UPDATE permission */ 
</span><a name="LN1032"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>securityQuals</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* security barrier quals to apply, if any */ 
</span><a name="LN1033"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end RangeTblEntry &raquo; </span> <span class='Declare_Typedef'>RangeTblEntry</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeTblFunction - 
 *    RangeTblEntry subsidiary data for one function in a FUNCTION RTE. 
 * 
 * If the function had a column definition list (required for an 
 * otherwise-unspecified RECORD result), funccolnames lists the names given 
 * in the definition list, funccoltypes lists their declared column types, 
 * funccoltypmods lists their typmods, funccolcollations their collations. 
 * Otherwise, those fields are NIL. 
 * 
 * Notice we don't attempt to store info about the results of functions 
 * returning named composite types, because those can change from time to 
 * time.  We do however remember how many columns we thought the type had 
 * (including dropped columns!), so that we can successfully ignore any 
 * columns added after the query was parsed. 
 */ 
</span><a name="LN1051"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeTblFunction</span> 
<span class='Delimiter'>{ 
</span><a name="LN1053"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN1055"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funcexpr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* expression tree for func call */ 
</span><a name="LN1056"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>funccolcount</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* number of columns it contributes to RTE */ 
</span>    <span class='Comment_Multi_Line'>/* These fields record the contents of a column definition list, if any: */ 
</span><a name="LN1058"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funccolnames</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* column names (list of String) */ 
</span><a name="LN1059"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funccoltypes</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID list of column type OIDs */ 
</span><a name="LN1060"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funccoltypmods</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* integer list of column typmods */ 
</span><a name="LN1061"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funccolcollations</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OID list of column collation OIDs */ 
</span>    <span class='Comment_Multi_Line'>/* This is set during planning for use by the executor: */ 
</span><a name="LN1063"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>funcparams</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* PARAM_EXEC Param IDs affecting this func */ 
</span><a name="LN1064"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RangeTblFunction</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TableSampleClause - TABLESAMPLE appearing in a transformed FROM clause 
 * 
 * Unlike RangeTableSample, this is a subnode of the relevant RangeTblEntry. 
 */ 
</span><a name="LN1071"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TableSampleClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN1073"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1074"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>tsmhandler</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OID of the tablesample handler function */ 
</span><a name="LN1075"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* tablesample argument expression(s) */ 
</span><a name="LN1076"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>repeatable</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* REPEATABLE expression, or NULL if none */ 
</span><a name="LN1077"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TableSampleClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * WithCheckOption - 
 *      representation of WITH CHECK OPTION checks to be applied to new tuples 
 *      when inserting/updating an auto-updatable view, or RLS WITH CHECK 
 *      policies to be applied when inserting/updating a relation with RLS. 
 */ 
</span><a name="LN1085"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>WCOKind</span> 
<span class='Delimiter'>{ 
</span><a name="LN1087"></a>    <span class='Declare_Enum_Const'>WCO_VIEW_CHECK</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* WCO on an auto-updatable view */ 
</span><a name="LN1088"></a>    <span class='Declare_Enum_Const'>WCO_RLS_INSERT_CHECK</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* RLS INSERT WITH CHECK policy */ 
</span><a name="LN1089"></a>    <span class='Declare_Enum_Const'>WCO_RLS_UPDATE_CHECK</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* RLS UPDATE WITH CHECK policy */ 
</span><a name="LN1090"></a>    <span class='Declare_Enum_Const'>WCO_RLS_CONFLICT_CHECK</span>      <span class='Comment_Single_Line'>/* RLS ON CONFLICT DO UPDATE USING policy */ 
</span><a name="LN1091"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WCOKind</span><span class='Delimiter'>; 
</span> 
<a name="LN1093"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WithCheckOption</span> 
<span class='Delimiter'>{ 
</span><a name="LN1095"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1096"></a>    <a href="parsenodes.h.html#LN1085"><span class='Ref_to_Enum'>WCOKind</span></a>     <span class='Declare_Member'>kind</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* kind of WCO */ 
</span><a name="LN1097"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>relname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of relation that specified the WCO */ 
</span><a name="LN1098"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>polname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of RLS policy being checked */ 
</span><a name="LN1099"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* constraint qual to check */ 
</span><a name="LN1100"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>cascaded</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true for a cascaded WCO on a view */ 
</span><a name="LN1101"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WithCheckOption</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SortGroupClause - 
 *      representation of ORDER BY, GROUP BY, PARTITION BY, 
 *      DISTINCT, DISTINCT ON items 
 * 
 * You might think that ORDER BY is only interested in defining ordering, 
 * and GROUP/DISTINCT are only interested in defining equality.  However, 
 * one way to implement grouping is to sort and then apply a "uniq"-like 
 * filter.  So it's also interesting to keep track of possible sort operators 
 * for GROUP/DISTINCT, and in particular to try to sort for the grouping 
 * in a way that will also yield a requested ORDER BY ordering.  So we need 
 * to be able to compare ORDER BY and GROUP/DISTINCT lists, which motivates 
 * the decision to give them the same representation. 
 * 
 * tleSortGroupRef must match ressortgroupref of exactly one entry of the 
 *      query's targetlist; that is the expression to be sorted or grouped by. 
 * eqop is the OID of the equality operator. 
 * sortop is the OID of the ordering operator (a "&LT;" or "&GT;" operator), 
 *      or InvalidOid if not available. 
 * nulls_first means about what you'd expect.  If sortop is InvalidOid 
 *      then nulls_first is meaningless and should be set to false. 
 * hashable is TRUE if eqop is hashable (note this condition also depends 
 *      on the datatype of the input expression). 
 * 
 * In an ORDER BY item, all fields must be valid.  (The eqop isn't essential 
 * here, but it's cheap to get it along with the sortop, and requiring it 
 * to be valid eases comparisons to grouping items.)  Note that this isn't 
 * actually enough information to determine an ordering: if the sortop is 
 * collation-sensitive, a collation OID is needed too.  We don't store the 
 * collation in SortGroupClause because it's not available at the time the 
 * parser builds the SortGroupClause; instead, consult the exposed collation 
 * of the referenced targetlist expression to find out what it is. 
 * 
 * In a grouping item, eqop must be valid.  If the eqop is a btree equality 
 * operator, then sortop should be set to a compatible ordering operator. 
 * We prefer to set eqop/sortop/nulls_first to match any ORDER BY item that 
 * the query presents for the same tlist item.  If there is none, we just 
 * use the default ordering op for the datatype. 
 * 
 * If the tlist item's type has a hash opclass but no btree opclass, then 
 * we will set eqop to the hash equality operator, sortop to InvalidOid, 
 * and nulls_first to false.  A grouping item of this kind can only be 
 * implemented by hashing, and of course it'll never match an ORDER BY item. 
 * 
 * The hashable flag is provided since we generally have the requisite 
 * information readily available when the SortGroupClause is constructed, 
 * and it's relatively expensive to get it again later.  Note there is no 
 * need for a "sortable" flag since OidIsValid(sortop) serves the purpose. 
 * 
 * A query might have both ORDER BY and DISTINCT (or DISTINCT ON) clauses. 
 * In SELECT DISTINCT, the distinctClause list is as long or longer than the 
 * sortClause list, while in SELECT DISTINCT ON it's typically shorter. 
 * The two lists must match up to the end of the shorter one --- the parser 
 * rearranges the distinctClause if necessary to make this true.  (This 
 * restriction ensures that only one sort step is needed to both satisfy the 
 * ORDER BY and set up for the Unique step.  This is semantically necessary 
 * for DISTINCT ON, and presents no real drawback for DISTINCT.) 
 */ 
</span><a name="LN1161"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SortGroupClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN1163"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1164"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>tleSortGroupRef</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* reference into targetlist */ 
</span><a name="LN1165"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>eqop</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the equality operator ('=' op) */ 
</span><a name="LN1166"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>sortop</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the ordering operator ('&LT;' op), or 0 */ 
</span><a name="LN1167"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>nulls_first</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* do NULLs come before normal values? */ 
</span><a name="LN1168"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hashable</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* can eqop be implemented by hashing? */ 
</span><a name="LN1169"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SortGroupClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GroupingSet - 
 *      representation of CUBE, ROLLUP and GROUPING SETS clauses 
 * 
 * In a Query with grouping sets, the groupClause contains a flat list of 
 * SortGroupClause nodes for each distinct expression used.  The actual 
 * structure of the GROUP BY clause is given by the groupingSets tree. 
 * 
 * In the raw parser output, GroupingSet nodes (of all types except SIMPLE 
 * which is not used) are potentially mixed in with the expressions in the 
 * groupClause of the SelectStmt.  (An expression can't contain a GroupingSet, 
 * but a list may mix GroupingSet and expression nodes.)  At this stage, the 
 * content of each node is a list of expressions, some of which may be RowExprs 
 * which represent sublists rather than actual row constructors, and nested 
 * GroupingSet nodes where legal in the grammar.  The structure directly 
 * reflects the query syntax. 
 * 
 * In parse analysis, the transformed expressions are used to build the tlist 
 * and groupClause list (of SortGroupClause nodes), and the groupingSets tree 
 * is eventually reduced to a fixed format: 
 * 
 * EMPTY nodes represent (), and obviously have no content 
 * 
 * SIMPLE nodes represent a list of one or more expressions to be treated as an 
 * atom by the enclosing structure; the content is an integer list of 
 * ressortgroupref values (see SortGroupClause) 
 * 
 * CUBE and ROLLUP nodes contain a list of one or more SIMPLE nodes. 
 * 
 * SETS nodes contain a list of EMPTY, SIMPLE, CUBE or ROLLUP nodes, but after 
 * parse analysis they cannot contain more SETS nodes; enough of the syntactic 
 * transforms of the spec have been applied that we no longer have arbitrarily 
 * deep nesting (though we still preserve the use of cube/rollup). 
 * 
 * Note that if the groupingSets tree contains no SIMPLE nodes (only EMPTY 
 * nodes at the leaves), then the groupClause will be empty, but this is still 
 * an aggregation query (similar to using aggs or HAVING without GROUP BY). 
 * 
 * As an example, the following clause: 
 * 
 * GROUP BY GROUPING SETS ((a,b), CUBE(c,(d,e))) 
 * 
 * looks like this after raw parsing: 
 * 
 * SETS( RowExpr(a,b) , CUBE( c, RowExpr(d,e) ) ) 
 * 
 * and parse analysis converts it to: 
 * 
 * SETS( SIMPLE(1,2), CUBE( SIMPLE(3), SIMPLE(4,5) ) ) 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN1223"></a>    <span class='Declare_Enum_Const'>GROUPING_SET_EMPTY</span><span class='Delimiter'>, 
</span><a name="LN1224"></a>    <span class='Declare_Enum_Const'>GROUPING_SET_SIMPLE</span><span class='Delimiter'>, 
</span><a name="LN1225"></a>    <span class='Declare_Enum_Const'>GROUPING_SET_ROLLUP</span><span class='Delimiter'>, 
</span><a name="LN1226"></a>    <span class='Declare_Enum_Const'>GROUPING_SET_CUBE</span><span class='Delimiter'>, 
</span><a name="LN1227"></a>    <span class='Declare_Enum_Const'>GROUPING_SET_SETS</span> 
<a name="LN1228"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GroupingSetKind</span><span class='Delimiter'>; 
</span> 
<a name="LN1230"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GroupingSet</span> 
<span class='Delimiter'>{ 
</span><a name="LN1232"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1233"></a>    <a href="parsenodes.h.html#LN1221"><span class='Ref_to_Typedef'>GroupingSetKind</span></a> <span class='Declare_Member'>kind</span><span class='Delimiter'>; 
</span><a name="LN1234"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>content</span><span class='Delimiter'>; 
</span><a name="LN1235"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>; 
</span><a name="LN1236"></a>} <span class='Declare_Typedef'>GroupingSet</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * WindowClause - 
 *      transformed representation of WINDOW and OVER clauses 
 * 
 * A parsed Query's windowClause list contains these structs.  "name" is set 
 * if the clause originally came from WINDOW, and is NULL if it originally 
 * was an OVER clause (but note that we collapse out duplicate OVERs). 
 * partitionClause and orderClause are lists of SortGroupClause structs. 
 * winref is an ID number referenced by WindowFunc nodes; it must be unique 
 * among the members of a Query's windowClause list. 
 * When refname isn't null, the partitionClause is always copied from there; 
 * the orderClause might or might not be copied (see copiedOrder); the framing 
 * options are never copied, per spec. 
 */ 
</span><a name="LN1252"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WindowClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN1254"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1255"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* window name (NULL in an OVER clause) */ 
</span><a name="LN1256"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>refname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* referenced window name, if any */ 
</span><a name="LN1257"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitionClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* PARTITION BY list */ 
</span><a name="LN1258"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>orderClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* ORDER BY list */ 
</span><a name="LN1259"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>frameOptions</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* frame_clause options, see WindowDef */ 
</span><a name="LN1260"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>startOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expression for starting bound, if any */ 
</span><a name="LN1261"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>endOffset</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* expression for ending bound, if any */ 
</span><a name="LN1262"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>winref</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* ID referenced by window functions */ 
</span><a name="LN1263"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>copiedOrder</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* did we copy orderClause from refname? */ 
</span><a name="LN1264"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WindowClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RowMarkClause - 
 *     parser output representation of FOR [KEY] UPDATE/SHARE clauses 
 * 
 * Query.rowMarks contains a separate RowMarkClause node for each relation 
 * identified as a FOR [KEY] UPDATE/SHARE target.  If one of these clauses 
 * is applied to a subquery, we generate RowMarkClauses for all normal and 
 * subquery rels in the subquery, but they are marked pushedDown = true to 
 * distinguish them from clauses that were explicitly written at this query 
 * level.  Also, Query.hasForUpdate tells whether there were explicit FOR 
 * UPDATE/SHARE/KEY SHARE clauses in the current query level. 
 */ 
</span><a name="LN1278"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RowMarkClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN1280"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1281"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>rti</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* range table index of target relation */ 
</span><a name="LN1282"></a>    <a href="lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Member'>strength</span><span class='Delimiter'>; 
</span><a name="LN1283"></a>    <a href="lockoptions.h.html#LN35"><span class='Ref_to_Enum'>LockWaitPolicy</span></a> <span class='Declare_Member'>waitPolicy</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* NOWAIT and SKIP LOCKED */ 
</span><a name="LN1284"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>pushedDown</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* pushed down from higher query level? */ 
</span><a name="LN1285"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RowMarkClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * WithClause - 
 *     representation of WITH clause 
 * 
 * Note: WithClause does not propagate into the Query representation; 
 * but CommonTableExpr does. 
 */ 
</span><a name="LN1294"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WithClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN1296"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1297"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ctes</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* list of CommonTableExprs */ 
</span><a name="LN1298"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>recursive</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* true = WITH RECURSIVE */ 
</span><a name="LN1299"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1300"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WithClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * InferClause - 
 *      ON CONFLICT unique index inference clause 
 * 
 * Note: InferClause does not propagate into the Query representation. 
 */ 
</span><a name="LN1308"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>InferClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN1310"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1311"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexElems</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* IndexElems to infer unique index */ 
</span><a name="LN1312"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whereClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualification (partial-index predicate) */ 
</span><a name="LN1313"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>conname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Constraint name, or NULL if unnamed */ 
</span><a name="LN1314"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1315"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>InferClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * OnConflictClause - 
 *      representation of ON CONFLICT clause 
 * 
 * Note: OnConflictClause does not propagate into the Query representation. 
 */ 
</span><a name="LN1323"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>OnConflictClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN1325"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1326"></a>    <a href="nodes.h.html#LN797"><span class='Ref_to_Enum'>OnConflictAction</span></a> <span class='Declare_Member'>action</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* DO NOTHING or UPDATE? */ 
</span><a name="LN1327"></a>    <a href="parsenodes.h.html#LN1308"><span class='Ref_to_Struct'>InferClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>infer</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Optional index inference clause */ 
</span><a name="LN1328"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>targetList</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the target list (of ResTarget) */ 
</span><a name="LN1329"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whereClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualifications */ 
</span><a name="LN1330"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1331"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OnConflictClause</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CommonTableExpr - 
 *     representation of WITH list element 
 * 
 * We don't currently support the SEARCH or CYCLE clause. 
 */ 
</span><a name="LN1339"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CommonTableExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1341"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1342"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>ctename</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* query name (never qualified) */ 
</span><a name="LN1343"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aliascolnames</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* optional list of column names */ 
</span>    <span class='Comment_Multi_Line'>/* SelectStmt/InsertStmt/etc before parse analysis, Query afterwards: */ 
</span><a name="LN1345"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ctequery</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the CTE's subquery */ 
</span><a name="LN1346"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span>    <span class='Comment_Multi_Line'>/* These fields are set during parse analysis: */ 
</span><a name="LN1348"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>cterecursive</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* is this CTE actually recursive? */ 
</span><a name="LN1349"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>cterefcount</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* number of RTEs referencing this CTE 
                                 * (excluding internal self-references) */ 
</span><a name="LN1351"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ctecolnames</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* list of output column names */ 
</span><a name="LN1352"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ctecoltypes</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID list of output column type OIDs */ 
</span><a name="LN1353"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ctecoltypmods</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* integer list of output column typmods */ 
</span><a name="LN1354"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ctecolcollations</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OID list of column collation OIDs */ 
</span><a name="LN1355"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CommonTableExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Convenience macro to get the output tlist of a CTE's query */ 
</span><a name="LN1358"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>GetCTETargetList</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>cte</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="../c.h.html#LN675"><span class='Ref_to_Macro'>AssertMacro</span></a><span class='Parentheses'>(</span><a href="nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>((</span><a href="parsenodes.h.html#LN1358"><span class='Ref_to_Parameter'>cte</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ctequery<span class='Delimiter'>, </span><a href="parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>((</span><a href="parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="parsenodes.h.html#LN1358"><span class='Ref_to_Parameter'>cte</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ctequery<span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>commandType <span class='Operator'>== </span><a href="nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a> <span class='Operator'>? \ 
</span>     <span class='Parentheses'>((</span><a href="parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="parsenodes.h.html#LN1358"><span class='Ref_to_Parameter'>cte</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ctequery<span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>targetList <span class='Operator'>: \ 
</span>     <span class='Parentheses'>((</span><a href="parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="parsenodes.h.html#LN1358"><span class='Ref_to_Parameter'>cte</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ctequery<span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>returningList<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * TriggerTransition - 
 *     representation of transition row or table naming clause 
 * 
 * Only transition tables are initially supported in the syntax, and only for 
 * AFTER triggers, but other permutations are accepted by the parser so we can 
 * give a meaningful message from C code. 
 */ 
</span><a name="LN1372"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TriggerTransition</span> 
<span class='Delimiter'>{ 
</span><a name="LN1374"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1375"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>; 
</span><a name="LN1376"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isNew</span><span class='Delimiter'>; 
</span><a name="LN1377"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isTable</span><span class='Delimiter'>; 
</span><a name="LN1378"></a>} <span class='Declare_Typedef'>TriggerTransition</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Raw Grammar Output Statements 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      RawStmt --- container for any one statement's raw parse tree 
 * 
 * Parse analysis converts a raw parse tree headed by a RawStmt node into 
 * an analyzed statement headed by a Query node.  For optimizable statements, 
 * the conversion is complex.  For utility statements, the parser usually just 
 * transfers the raw parse tree (sans RawStmt) into the utilityStmt field of 
 * the Query node, and all the useful work happens at execution time. 
 * 
 * stmt_location/stmt_len identify the portion of the source text string 
 * containing this raw statement (useful for multi-statement strings). 
 */ 
</span><a name="LN1396"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RawStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1398"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1399"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>stmt</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* raw parse tree */ 
</span><a name="LN1400"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>stmt_location</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* start location, or -1 if unknown */ 
</span><a name="LN1401"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>stmt_len</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* length in bytes; 0 means "rest of string" */ 
</span><a name="LN1402"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RawStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Optimizable Statements 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Insert Statement 
 * 
 * The source expression is represented by SelectStmt for both the 
 * SELECT and VALUES cases.  If selectStmt is NULL, then the query 
 * is INSERT ... DEFAULT VALUES. 
 * ---------------------- 
 */ 
</span><a name="LN1416"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>InsertStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1418"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1419"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation to insert into */ 
</span><a name="LN1420"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cols</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* optional: names of the target columns */ 
</span><a name="LN1421"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>selectStmt</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the source SELECT/VALUES, or NULL */ 
</span><a name="LN1422"></a>    <a href="parsenodes.h.html#LN1323"><span class='Ref_to_Struct'>OnConflictClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>onConflictClause</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* ON CONFLICT clause */ 
</span><a name="LN1423"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>returningList</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of expressions to return */ 
</span><a name="LN1424"></a>    <a href="parsenodes.h.html#LN1294"><span class='Ref_to_Struct'>WithClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>withClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* WITH clause */ 
</span><a name="LN1425"></a>    <a href="parsenodes.h.html#LN29"><span class='Ref_to_Enum'>OverridingKind</span></a> <span class='Declare_Member'>override</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OVERRIDING clause */ 
</span><a name="LN1426"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>InsertStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Delete Statement 
 * ---------------------- 
 */ 
</span><a name="LN1432"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DeleteStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1434"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1435"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation to delete from */ 
</span><a name="LN1436"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>usingClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* optional using clause for more tables */ 
</span><a name="LN1437"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whereClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualifications */ 
</span><a name="LN1438"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>returningList</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of expressions to return */ 
</span><a name="LN1439"></a>    <a href="parsenodes.h.html#LN1294"><span class='Ref_to_Struct'>WithClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>withClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* WITH clause */ 
</span><a name="LN1440"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DeleteStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Update Statement 
 * ---------------------- 
 */ 
</span><a name="LN1446"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>UpdateStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1448"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1449"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation to update */ 
</span><a name="LN1450"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>targetList</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the target list (of ResTarget) */ 
</span><a name="LN1451"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whereClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualifications */ 
</span><a name="LN1452"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fromClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* optional from clause for more tables */ 
</span><a name="LN1453"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>returningList</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of expressions to return */ 
</span><a name="LN1454"></a>    <a href="parsenodes.h.html#LN1294"><span class='Ref_to_Struct'>WithClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>withClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* WITH clause */ 
</span><a name="LN1455"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UpdateStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Select Statement 
 * 
 * A "simple" SELECT is represented in the output of gram.y by a single 
 * SelectStmt node; so is a VALUES construct.  A query containing set 
 * operators (UNION, INTERSECT, EXCEPT) is represented by a tree of SelectStmt 
 * nodes, in which the leaf nodes are component SELECTs and the internal nodes 
 * represent UNION, INTERSECT, or EXCEPT operators.  Using the same node 
 * type for both leaf and internal nodes allows gram.y to stick ORDER BY, 
 * LIMIT, etc, clause values into a SELECT statement without worrying 
 * whether it is a simple or compound SELECT. 
 * ---------------------- 
 */ 
</span><a name="LN1470"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>SetOperation</span> 
<span class='Delimiter'>{ 
</span><a name="LN1472"></a>    <span class='Declare_Enum_Const'>SETOP_NONE</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN1473"></a>    <span class='Declare_Enum_Const'>SETOP_UNION</span><span class='Delimiter'>, 
</span><a name="LN1474"></a>    <span class='Declare_Enum_Const'>SETOP_INTERSECT</span><span class='Delimiter'>, 
</span><a name="LN1475"></a>    <span class='Declare_Enum_Const'>SETOP_EXCEPT</span> 
<a name="LN1476"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SetOperation</span><span class='Delimiter'>; 
</span> 
<a name="LN1478"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SelectStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1480"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These fields are used only in "leaf" SelectStmts. 
     */ 
</span><a name="LN1485"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>distinctClause</span><span class='Delimiter'>; </span><span class='Comment_Multi_Line'>/* NULL, list of DISTINCT ON exprs, or 
                                 * lcons(NIL,NIL) for all (SELECT DISTINCT) */ 
</span><a name="LN1487"></a>    <a href="primnodes.h.html#LN104"><span class='Ref_to_Struct'>IntoClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>intoClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* target for SELECT INTO */ 
</span><a name="LN1488"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>targetList</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the target list (of ResTarget) */ 
</span><a name="LN1489"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fromClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the FROM clause */ 
</span><a name="LN1490"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whereClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* WHERE qualification */ 
</span><a name="LN1491"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* GROUP BY clauses */ 
</span><a name="LN1492"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>havingClause</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* HAVING conditional-expression */ 
</span><a name="LN1493"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>windowClause</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* WINDOW window_name AS (...), ... */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In a "leaf" node representing a VALUES list, the above fields are all 
     * null, and instead this field is set.  Note that the elements of the 
     * sublists are just expressions, without ResTarget decoration. Also note 
     * that a list element can be DEFAULT (represented as a SetToDefault 
     * node), regardless of the context of the VALUES list. It's up to parse 
     * analysis to reject that where not valid. 
     */ 
</span><a name="LN1503"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>valuesLists</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* untransformed list of expression lists */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These fields are used in both "leaf" SelectStmts and upper-level 
     * SelectStmts. 
     */ 
</span><a name="LN1509"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>sortClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* sort clause (a list of SortBy's) */ 
</span><a name="LN1510"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* # of result tuples to skip */ 
</span><a name="LN1511"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitCount</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* # of result tuples to return */ 
</span><a name="LN1512"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>lockingClause</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* FOR UPDATE (list of LockingClause's) */ 
</span><a name="LN1513"></a>    <a href="parsenodes.h.html#LN1294"><span class='Ref_to_Struct'>WithClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>withClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* WITH clause */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These fields are used only in upper-level SelectStmts. 
     */ 
</span><a name="LN1518"></a>    <a href="parsenodes.h.html#LN1470"><span class='Ref_to_Enum'>SetOperation</span></a> <span class='Declare_Member'>op</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* type of set op */ 
</span><a name="LN1519"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>all</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* ALL specified? */ 
</span><a name="LN1520"></a>    <span class='Control'>struct</span> <a href="parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Member'>larg</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* left child */ 
</span><a name="LN1521"></a>    <span class='Control'>struct</span> <a href="parsenodes.h.html#LN1478"><span class='Ref_to_Struct'>SelectStmt</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rarg</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* right child */ 
</span>    <span class='Comment_Multi_Line'>/* Eventually add fields for CORRESPONDING spec here */ 
</span><a name="LN1523"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end SelectStmt &raquo; </span> <span class='Declare_Typedef'>SelectStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Set Operation node for post-analysis query trees 
 * 
 * After parse analysis, a SELECT with set operations is represented by a 
 * top-level Query node containing the leaf SELECTs as subqueries in its 
 * range table.  Its setOperations field shows the tree of set operations, 
 * with leaf SelectStmt nodes replaced by RangeTblRef nodes, and internal 
 * nodes replaced by SetOperationStmt nodes.  Information about the output 
 * column types is added, too.  (Note that the child nodes do not necessarily 
 * produce these types directly, but we've checked that their output types 
 * can be coerced to the output column type.)  Also, if it's not UNION ALL, 
 * information about the types' sort/group semantics is provided in the form 
 * of a SortGroupClause list (same representation as, eg, DISTINCT). 
 * The resolved common column collations are provided too; but note that if 
 * it's not UNION ALL, it's okay for a column to not have a common collation, 
 * so a member of the colCollations list could be InvalidOid even though the 
 * column has a collatable type. 
 * ---------------------- 
 */ 
</span><a name="LN1545"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SetOperationStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1547"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1548"></a>    <a href="parsenodes.h.html#LN1470"><span class='Ref_to_Enum'>SetOperation</span></a> <span class='Declare_Member'>op</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* type of set op */ 
</span><a name="LN1549"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>all</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* ALL specified? */ 
</span><a name="LN1550"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>larg</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* left child */ 
</span><a name="LN1551"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rarg</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* right child */ 
</span>    <span class='Comment_Multi_Line'>/* Eventually add fields for CORRESPONDING spec here */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields derived during parse analysis: */ 
</span><a name="LN1555"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colTypes</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OID list of output column type OIDs */ 
</span><a name="LN1556"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colTypmods</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* integer list of output column typmods */ 
</span><a name="LN1557"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colCollations</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OID list of output column collation OIDs */ 
</span><a name="LN1558"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClauses</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* a list of SortGroupClause's */ 
</span>    <span class='Comment_Multi_Line'>/* groupClauses is NIL if UNION ALL, but must be set otherwise */ 
</span><a name="LN1560"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SetOperationStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Other Statements (no optimizations required) 
 * 
 *      These are not touched by parser/analyze.c except to put them into 
 *      the utilityStmt field of a Query.  This is eventually passed to 
 *      ProcessUtility (by-passing rewriting and planning).  Some of the 
 *      statements do need attention from parse analysis, and this is 
 *      done by routines in parser/parse_utilcmd.c after ProcessUtility 
 *      receives the command for execution. 
 *      DECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are special cases: 
 *      they contain optimizable statements, which get processed normally 
 *      by parser/analyze.c. 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When a command can act on several kinds of objects with only one 
 * parse structure required, use these constants to designate the 
 * object type.  Note that commands typically don't support all the types. 
 */ 
</span> 
<a name="LN1583"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>ObjectType</span> 
<span class='Delimiter'>{ 
</span><a name="LN1585"></a>    <span class='Declare_Enum_Const'>OBJECT_ACCESS_METHOD</span><span class='Delimiter'>, 
</span><a name="LN1586"></a>    <span class='Declare_Enum_Const'>OBJECT_AGGREGATE</span><span class='Delimiter'>, 
</span><a name="LN1587"></a>    <span class='Declare_Enum_Const'>OBJECT_AMOP</span><span class='Delimiter'>, 
</span><a name="LN1588"></a>    <span class='Declare_Enum_Const'>OBJECT_AMPROC</span><span class='Delimiter'>, 
</span><a name="LN1589"></a>    <span class='Declare_Enum_Const'>OBJECT_ATTRIBUTE</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* type's attribute, when distinct from column */ 
</span><a name="LN1590"></a>    <span class='Declare_Enum_Const'>OBJECT_CAST</span><span class='Delimiter'>, 
</span><a name="LN1591"></a>    <span class='Declare_Enum_Const'>OBJECT_COLUMN</span><span class='Delimiter'>, 
</span><a name="LN1592"></a>    <span class='Declare_Enum_Const'>OBJECT_COLLATION</span><span class='Delimiter'>, 
</span><a name="LN1593"></a>    <span class='Declare_Enum_Const'>OBJECT_CONVERSION</span><span class='Delimiter'>, 
</span><a name="LN1594"></a>    <span class='Declare_Enum_Const'>OBJECT_DATABASE</span><span class='Delimiter'>, 
</span><a name="LN1595"></a>    <span class='Declare_Enum_Const'>OBJECT_DEFAULT</span><span class='Delimiter'>, 
</span><a name="LN1596"></a>    <span class='Declare_Enum_Const'>OBJECT_DEFACL</span><span class='Delimiter'>, 
</span><a name="LN1597"></a>    <span class='Declare_Enum_Const'>OBJECT_DOMAIN</span><span class='Delimiter'>, 
</span><a name="LN1598"></a>    <span class='Declare_Enum_Const'>OBJECT_DOMCONSTRAINT</span><span class='Delimiter'>, 
</span><a name="LN1599"></a>    <span class='Declare_Enum_Const'>OBJECT_EVENT_TRIGGER</span><span class='Delimiter'>, 
</span><a name="LN1600"></a>    <span class='Declare_Enum_Const'>OBJECT_EXTENSION</span><span class='Delimiter'>, 
</span><a name="LN1601"></a>    <span class='Declare_Enum_Const'>OBJECT_FDW</span><span class='Delimiter'>, 
</span><a name="LN1602"></a>    <span class='Declare_Enum_Const'>OBJECT_FOREIGN_SERVER</span><span class='Delimiter'>, 
</span><a name="LN1603"></a>    <span class='Declare_Enum_Const'>OBJECT_FOREIGN_TABLE</span><span class='Delimiter'>, 
</span><a name="LN1604"></a>    <span class='Declare_Enum_Const'>OBJECT_FUNCTION</span><span class='Delimiter'>, 
</span><a name="LN1605"></a>    <span class='Declare_Enum_Const'>OBJECT_INDEX</span><span class='Delimiter'>, 
</span><a name="LN1606"></a>    <span class='Declare_Enum_Const'>OBJECT_LANGUAGE</span><span class='Delimiter'>, 
</span><a name="LN1607"></a>    <span class='Declare_Enum_Const'>OBJECT_LARGEOBJECT</span><span class='Delimiter'>, 
</span><a name="LN1608"></a>    <span class='Declare_Enum_Const'>OBJECT_MATVIEW</span><span class='Delimiter'>, 
</span><a name="LN1609"></a>    <span class='Declare_Enum_Const'>OBJECT_OPCLASS</span><span class='Delimiter'>, 
</span><a name="LN1610"></a>    <span class='Declare_Enum_Const'>OBJECT_OPERATOR</span><span class='Delimiter'>, 
</span><a name="LN1611"></a>    <span class='Declare_Enum_Const'>OBJECT_OPFAMILY</span><span class='Delimiter'>, 
</span><a name="LN1612"></a>    <span class='Declare_Enum_Const'>OBJECT_POLICY</span><span class='Delimiter'>, 
</span><a name="LN1613"></a>    <span class='Declare_Enum_Const'>OBJECT_PUBLICATION</span><span class='Delimiter'>, 
</span><a name="LN1614"></a>    <span class='Declare_Enum_Const'>OBJECT_PUBLICATION_REL</span><span class='Delimiter'>, 
</span><a name="LN1615"></a>    <span class='Declare_Enum_Const'>OBJECT_ROLE</span><span class='Delimiter'>, 
</span><a name="LN1616"></a>    <span class='Declare_Enum_Const'>OBJECT_RULE</span><span class='Delimiter'>, 
</span><a name="LN1617"></a>    <span class='Declare_Enum_Const'>OBJECT_SCHEMA</span><span class='Delimiter'>, 
</span><a name="LN1618"></a>    <span class='Declare_Enum_Const'>OBJECT_SEQUENCE</span><span class='Delimiter'>, 
</span><a name="LN1619"></a>    <span class='Declare_Enum_Const'>OBJECT_SUBSCRIPTION</span><span class='Delimiter'>, 
</span><a name="LN1620"></a>    <span class='Declare_Enum_Const'>OBJECT_STATISTIC_EXT</span><span class='Delimiter'>, 
</span><a name="LN1621"></a>    <span class='Declare_Enum_Const'>OBJECT_TABCONSTRAINT</span><span class='Delimiter'>, 
</span><a name="LN1622"></a>    <span class='Declare_Enum_Const'>OBJECT_TABLE</span><span class='Delimiter'>, 
</span><a name="LN1623"></a>    <span class='Declare_Enum_Const'>OBJECT_TABLESPACE</span><span class='Delimiter'>, 
</span><a name="LN1624"></a>    <span class='Declare_Enum_Const'>OBJECT_TRANSFORM</span><span class='Delimiter'>, 
</span><a name="LN1625"></a>    <span class='Declare_Enum_Const'>OBJECT_TRIGGER</span><span class='Delimiter'>, 
</span><a name="LN1626"></a>    <span class='Declare_Enum_Const'>OBJECT_TSCONFIGURATION</span><span class='Delimiter'>, 
</span><a name="LN1627"></a>    <span class='Declare_Enum_Const'>OBJECT_TSDICTIONARY</span><span class='Delimiter'>, 
</span><a name="LN1628"></a>    <span class='Declare_Enum_Const'>OBJECT_TSPARSER</span><span class='Delimiter'>, 
</span><a name="LN1629"></a>    <span class='Declare_Enum_Const'>OBJECT_TSTEMPLATE</span><span class='Delimiter'>, 
</span><a name="LN1630"></a>    <span class='Declare_Enum_Const'>OBJECT_TYPE</span><span class='Delimiter'>, 
</span><a name="LN1631"></a>    <span class='Declare_Enum_Const'>OBJECT_USER_MAPPING</span><span class='Delimiter'>, 
</span><a name="LN1632"></a>    <span class='Declare_Enum_Const'>OBJECT_VIEW</span> 
<a name="LN1633"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ObjectType &raquo; </span> <span class='Declare_Typedef'>ObjectType</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Schema Statement 
 * 
 * NOTE: the schemaElts list contains raw parsetrees for component statements 
 * of the schema, such as CREATE TABLE, GRANT, etc.  These are analyzed and 
 * executed after the schema itself is created. 
 * ---------------------- 
 */ 
</span><a name="LN1643"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateSchemaStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1645"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1646"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>schemaname</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the name of the schema to create */ 
</span><a name="LN1647"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>authrole</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the owner of the created schema */ 
</span><a name="LN1648"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>schemaElts</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* schema components (list of parsenodes) */ 
</span><a name="LN1649"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if schema already exists? */ 
</span><a name="LN1650"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateSchemaStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN1652"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>DropBehavior</span> 
<span class='Delimiter'>{ 
</span><a name="LN1654"></a>    <span class='Declare_Enum_Const'>DROP_RESTRICT</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* drop fails if any dependent objects */ 
</span><a name="LN1655"></a>    <span class='Declare_Enum_Const'>DROP_CASCADE</span>                <span class='Comment_Single_Line'>/* remove dependent objects too */ 
</span><a name="LN1656"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DropBehavior</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *  Alter Table 
 * ---------------------- 
 */ 
</span><a name="LN1662"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterTableStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1664"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1665"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* table to work on */ 
</span><a name="LN1666"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cmds</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* list of subcommands */ 
</span><a name="LN1667"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>relkind</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* type of object */ 
</span><a name="LN1668"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if table missing */ 
</span><a name="LN1669"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterTableStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN1671"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>AlterTableType</span> 
<span class='Delimiter'>{ 
</span><a name="LN1673"></a>    <span class='Declare_Enum_Const'>AT_AddColumn</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* add column */ 
</span><a name="LN1674"></a>    <span class='Declare_Enum_Const'>AT_AddColumnRecurse</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1675"></a>    <span class='Declare_Enum_Const'>AT_AddColumnToView</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* implicitly via CREATE OR REPLACE VIEW */ 
</span><a name="LN1676"></a>    <span class='Declare_Enum_Const'>AT_ColumnDefault</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* alter column default */ 
</span><a name="LN1677"></a>    <span class='Declare_Enum_Const'>AT_DropNotNull</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* alter column drop not null */ 
</span><a name="LN1678"></a>    <span class='Declare_Enum_Const'>AT_SetNotNull</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* alter column set not null */ 
</span><a name="LN1679"></a>    <span class='Declare_Enum_Const'>AT_SetStatistics</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* alter column set statistics */ 
</span><a name="LN1680"></a>    <span class='Declare_Enum_Const'>AT_SetOptions</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* alter column set ( options ) */ 
</span><a name="LN1681"></a>    <span class='Declare_Enum_Const'>AT_ResetOptions</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* alter column reset ( options ) */ 
</span><a name="LN1682"></a>    <span class='Declare_Enum_Const'>AT_SetStorage</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* alter column set storage */ 
</span><a name="LN1683"></a>    <span class='Declare_Enum_Const'>AT_DropColumn</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* drop column */ 
</span><a name="LN1684"></a>    <span class='Declare_Enum_Const'>AT_DropColumnRecurse</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1685"></a>    <span class='Declare_Enum_Const'>AT_AddIndex</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* add index */ 
</span><a name="LN1686"></a>    <span class='Declare_Enum_Const'>AT_ReAddIndex</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1687"></a>    <span class='Declare_Enum_Const'>AT_AddConstraint</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* add constraint */ 
</span><a name="LN1688"></a>    <span class='Declare_Enum_Const'>AT_AddConstraintRecurse</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1689"></a>    <span class='Declare_Enum_Const'>AT_ReAddConstraint</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1690"></a>    <span class='Declare_Enum_Const'>AT_AlterConstraint</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* alter constraint */ 
</span><a name="LN1691"></a>    <span class='Declare_Enum_Const'>AT_ValidateConstraint</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* validate constraint */ 
</span><a name="LN1692"></a>    <span class='Declare_Enum_Const'>AT_ValidateConstraintRecurse</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1693"></a>    <span class='Declare_Enum_Const'>AT_ProcessedConstraint</span><span class='Delimiter'>,</span>     <span class='Comment_Multi_Line'>/* pre-processed add constraint (local in 
                                 * parser/parse_utilcmd.c) */ 
</span><a name="LN1695"></a>    <span class='Declare_Enum_Const'>AT_AddIndexConstraint</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* add constraint using existing index */ 
</span><a name="LN1696"></a>    <span class='Declare_Enum_Const'>AT_DropConstraint</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* drop constraint */ 
</span><a name="LN1697"></a>    <span class='Declare_Enum_Const'>AT_DropConstraintRecurse</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1698"></a>    <span class='Declare_Enum_Const'>AT_ReAddComment</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1699"></a>    <span class='Declare_Enum_Const'>AT_AlterColumnType</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* alter column type */ 
</span><a name="LN1700"></a>    <span class='Declare_Enum_Const'>AT_AlterColumnGenericOptions</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* alter column OPTIONS (...) */ 
</span><a name="LN1701"></a>    <span class='Declare_Enum_Const'>AT_ChangeOwner</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* change owner */ 
</span><a name="LN1702"></a>    <span class='Declare_Enum_Const'>AT_ClusterOn</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* CLUSTER ON */ 
</span><a name="LN1703"></a>    <span class='Declare_Enum_Const'>AT_DropCluster</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* SET WITHOUT CLUSTER */ 
</span><a name="LN1704"></a>    <span class='Declare_Enum_Const'>AT_SetLogged</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* SET LOGGED */ 
</span><a name="LN1705"></a>    <span class='Declare_Enum_Const'>AT_SetUnLogged</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* SET UNLOGGED */ 
</span><a name="LN1706"></a>    <span class='Declare_Enum_Const'>AT_AddOids</span><span class='Delimiter'>,</span>                 <span class='Comment_Single_Line'>/* SET WITH OIDS */ 
</span><a name="LN1707"></a>    <span class='Declare_Enum_Const'>AT_AddOidsRecurse</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* internal to commands/tablecmds.c */ 
</span><a name="LN1708"></a>    <span class='Declare_Enum_Const'>AT_DropOids</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* SET WITHOUT OIDS */ 
</span><a name="LN1709"></a>    <span class='Declare_Enum_Const'>AT_SetTableSpace</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* SET TABLESPACE */ 
</span><a name="LN1710"></a>    <span class='Declare_Enum_Const'>AT_SetRelOptions</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* SET (...) -- AM specific parameters */ 
</span><a name="LN1711"></a>    <span class='Declare_Enum_Const'>AT_ResetRelOptions</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* RESET (...) -- AM specific parameters */ 
</span><a name="LN1712"></a>    <span class='Declare_Enum_Const'>AT_ReplaceRelOptions</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* replace reloption list in its entirety */ 
</span><a name="LN1713"></a>    <span class='Declare_Enum_Const'>AT_EnableTrig</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* ENABLE TRIGGER name */ 
</span><a name="LN1714"></a>    <span class='Declare_Enum_Const'>AT_EnableAlwaysTrig</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* ENABLE ALWAYS TRIGGER name */ 
</span><a name="LN1715"></a>    <span class='Declare_Enum_Const'>AT_EnableReplicaTrig</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* ENABLE REPLICA TRIGGER name */ 
</span><a name="LN1716"></a>    <span class='Declare_Enum_Const'>AT_DisableTrig</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* DISABLE TRIGGER name */ 
</span><a name="LN1717"></a>    <span class='Declare_Enum_Const'>AT_EnableTrigAll</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* ENABLE TRIGGER ALL */ 
</span><a name="LN1718"></a>    <span class='Declare_Enum_Const'>AT_DisableTrigAll</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* DISABLE TRIGGER ALL */ 
</span><a name="LN1719"></a>    <span class='Declare_Enum_Const'>AT_EnableTrigUser</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* ENABLE TRIGGER USER */ 
</span><a name="LN1720"></a>    <span class='Declare_Enum_Const'>AT_DisableTrigUser</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* DISABLE TRIGGER USER */ 
</span><a name="LN1721"></a>    <span class='Declare_Enum_Const'>AT_EnableRule</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* ENABLE RULE name */ 
</span><a name="LN1722"></a>    <span class='Declare_Enum_Const'>AT_EnableAlwaysRule</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* ENABLE ALWAYS RULE name */ 
</span><a name="LN1723"></a>    <span class='Declare_Enum_Const'>AT_EnableReplicaRule</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* ENABLE REPLICA RULE name */ 
</span><a name="LN1724"></a>    <span class='Declare_Enum_Const'>AT_DisableRule</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* DISABLE RULE name */ 
</span><a name="LN1725"></a>    <span class='Declare_Enum_Const'>AT_AddInherit</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* INHERIT parent */ 
</span><a name="LN1726"></a>    <span class='Declare_Enum_Const'>AT_DropInherit</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* NO INHERIT parent */ 
</span><a name="LN1727"></a>    <span class='Declare_Enum_Const'>AT_AddOf</span><span class='Delimiter'>,</span>                   <span class='Comment_Single_Line'>/* OF &LT;type_name&GT; */ 
</span><a name="LN1728"></a>    <span class='Declare_Enum_Const'>AT_DropOf</span><span class='Delimiter'>,</span>                  <span class='Comment_Single_Line'>/* NOT OF */ 
</span><a name="LN1729"></a>    <span class='Declare_Enum_Const'>AT_ReplicaIdentity</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* REPLICA IDENTITY */ 
</span><a name="LN1730"></a>    <span class='Declare_Enum_Const'>AT_EnableRowSecurity</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* ENABLE ROW SECURITY */ 
</span><a name="LN1731"></a>    <span class='Declare_Enum_Const'>AT_DisableRowSecurity</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* DISABLE ROW SECURITY */ 
</span><a name="LN1732"></a>    <span class='Declare_Enum_Const'>AT_ForceRowSecurity</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* FORCE ROW SECURITY */ 
</span><a name="LN1733"></a>    <span class='Declare_Enum_Const'>AT_NoForceRowSecurity</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* NO FORCE ROW SECURITY */ 
</span><a name="LN1734"></a>    <span class='Declare_Enum_Const'>AT_GenericOptions</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* OPTIONS (...) */ 
</span><a name="LN1735"></a>    <span class='Declare_Enum_Const'>AT_AttachPartition</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* ATTACH PARTITION */ 
</span><a name="LN1736"></a>    <span class='Declare_Enum_Const'>AT_DetachPartition</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* DETACH PARTITION */ 
</span><a name="LN1737"></a>    <span class='Declare_Enum_Const'>AT_AddIdentity</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* ADD IDENTITY */ 
</span><a name="LN1738"></a>    <span class='Declare_Enum_Const'>AT_SetIdentity</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* SET identity column options */ 
</span><a name="LN1739"></a>    <span class='Declare_Enum_Const'>AT_DropIdentity</span>             <span class='Comment_Single_Line'>/* DROP IDENTITY */ 
</span><a name="LN1740"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end AlterTableType &raquo; </span> <span class='Declare_Typedef'>AlterTableType</span><span class='Delimiter'>; 
</span> 
<a name="LN1742"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ReplicaIdentityStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1744"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1745"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>identity_type</span><span class='Delimiter'>; 
</span><a name="LN1746"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>; 
</span><a name="LN1747"></a>} <span class='Declare_Typedef'>ReplicaIdentityStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN1749"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterTableCmd</span>    <span class='Comment_Single_Line'>/* one subcommand of an ALTER TABLE */ 
</span><span class='Delimiter'>{ 
</span><a name="LN1751"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1752"></a>    <a href="parsenodes.h.html#LN1671"><span class='Ref_to_Enum'>AlterTableType</span></a> <span class='Declare_Member'>subtype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* Type of table alteration to apply */ 
</span><a name="LN1753"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Multi_Line'>/* column, constraint, or trigger to act on, 
                                 * or tablespace */ 
</span><a name="LN1755"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>newowner</span><span class='Delimiter'>; 
</span><a name="LN1756"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>def</span><span class='Delimiter'>;</span>            <span class='Comment_Multi_Line'>/* definition of new column, index, 
                                 * constraint, or parent table */ 
</span><a name="LN1758"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RESTRICT or CASCADE for DROP cases */ 
</span><a name="LN1759"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if missing? */ 
</span><a name="LN1760"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterTableCmd</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 * Alter Collation 
 * ---------------------- 
 */ 
</span><a name="LN1767"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterCollationStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1769"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1770"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>collname</span><span class='Delimiter'>; 
</span><a name="LN1771"></a>} <span class='Declare_Typedef'>AlterCollationStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *  Alter Domain 
 * 
 * The fields are used in different ways by the different variants of 
 * this command. 
 * ---------------------- 
 */ 
</span><a name="LN1781"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterDomainStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1783"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1784"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>subtype</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/*------------ 
                                 *  T = alter column default 
                                 *  N = alter column drop not null 
                                 *  O = alter column set not null 
                                 *  C = add constraint 
                                 *  X = drop constraint 
                                 *------------ 
                                 */ 
</span><a name="LN1792"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* domain to work on */ 
</span><a name="LN1793"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* column or constraint name to act on */ 
</span><a name="LN1794"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>def</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* definition of default or constraint */ 
</span><a name="LN1795"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RESTRICT or CASCADE for DROP cases */ 
</span><a name="LN1796"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if missing? */ 
</span><a name="LN1797"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterDomainStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Grant|Revoke Statement 
 * ---------------------- 
 */ 
</span><a name="LN1804"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>GrantTargetType</span> 
<span class='Delimiter'>{ 
</span><a name="LN1806"></a>    <span class='Declare_Enum_Const'>ACL_TARGET_OBJECT</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* grant on specific named object(s) */ 
</span><a name="LN1807"></a>    <span class='Declare_Enum_Const'>ACL_TARGET_ALL_IN_SCHEMA</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* grant on all objects in given schema(s) */ 
</span><a name="LN1808"></a>    <span class='Declare_Enum_Const'>ACL_TARGET_DEFAULTS</span>         <span class='Comment_Single_Line'>/* ALTER DEFAULT PRIVILEGES */ 
</span><a name="LN1809"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GrantTargetType</span><span class='Delimiter'>; 
</span> 
<a name="LN1811"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>GrantObjectType</span> 
<span class='Delimiter'>{ 
</span><a name="LN1813"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_COLUMN</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* column */ 
</span><a name="LN1814"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_RELATION</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* table, view */ 
</span><a name="LN1815"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_SEQUENCE</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* sequence */ 
</span><a name="LN1816"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_DATABASE</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* database */ 
</span><a name="LN1817"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_DOMAIN</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* domain */ 
</span><a name="LN1818"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_FDW</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* foreign-data wrapper */ 
</span><a name="LN1819"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_FOREIGN_SERVER</span><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* foreign server */ 
</span><a name="LN1820"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_FUNCTION</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* function */ 
</span><a name="LN1821"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_LANGUAGE</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* procedural language */ 
</span><a name="LN1822"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_LARGEOBJECT</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* largeobject */ 
</span><a name="LN1823"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_NAMESPACE</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* namespace */ 
</span><a name="LN1824"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_TABLESPACE</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* tablespace */ 
</span><a name="LN1825"></a>    <span class='Declare_Enum_Const'>ACL_OBJECT_TYPE</span>             <span class='Comment_Single_Line'>/* type */ 
</span><a name="LN1826"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GrantObjectType</span><span class='Delimiter'>; 
</span> 
<a name="LN1828"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GrantStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1830"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1831"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_grant</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true = GRANT, false = REVOKE */ 
</span><a name="LN1832"></a>    <a href="parsenodes.h.html#LN1804"><span class='Ref_to_Enum'>GrantTargetType</span></a> <span class='Declare_Member'>targtype</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* type of the grant target */ 
</span><a name="LN1833"></a>    <a href="parsenodes.h.html#LN1811"><span class='Ref_to_Enum'>GrantObjectType</span></a> <span class='Declare_Member'>objtype</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* kind of object being operated on */ 
</span><a name="LN1834"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>objects</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* list of RangeVar nodes, ObjectWithArgs 
                                 * nodes, or plain names (as Value strings) */ 
</span><a name="LN1836"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>privileges</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of AccessPriv nodes */ 
</span>    <span class='Comment_Multi_Line'>/* privileges == NIL denotes ALL PRIVILEGES */ 
</span><a name="LN1838"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>grantees</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of RoleSpec nodes */ 
</span><a name="LN1839"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>grant_option</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* grant or revoke grant option */ 
</span><a name="LN1840"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* drop behavior (for REVOKE) */ 
</span><a name="LN1841"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GrantStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Note: ObjectWithArgs carries only the types of the input parameters of the 
 * function.  So it is sufficient to identify an existing function, but it 
 * is not enough info to define a function nor to call it. 
 */ 
</span><a name="LN1848"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ObjectWithArgs</span> 
<span class='Delimiter'>{ 
</span><a name="LN1850"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1851"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>objname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* qualified name of function/operator */ 
</span><a name="LN1852"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>objargs</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of Typename nodes */ 
</span><a name="LN1853"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>args_unspecified</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* argument list was omitted, so name 
                                         * must be unique (note that objargs 
                                         * == NIL means zero args) */ 
</span><a name="LN1856"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ObjectWithArgs</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * An access privilege, with optional list of column names 
 * priv_name == NULL denotes ALL PRIVILEGES (only used with a column list) 
 * cols == NIL denotes "all columns" 
 * Note that simple "ALL PRIVILEGES" is represented as a NIL list, not 
 * an AccessPriv with both fields null. 
 */ 
</span><a name="LN1865"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AccessPriv</span> 
<span class='Delimiter'>{ 
</span><a name="LN1867"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1868"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>priv_name</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* string name of privilege */ 
</span><a name="LN1869"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cols</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* list of Value strings */ 
</span><a name="LN1870"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AccessPriv</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Grant/Revoke Role Statement 
 * 
 * Note: because of the parsing ambiguity with the GRANT &LT;privileges&GT; 
 * statement, granted_roles is a list of AccessPriv; the execution code 
 * should complain if any column lists appear.  grantee_roles is a list 
 * of role names, as Value strings. 
 * ---------------------- 
 */ 
</span><a name="LN1881"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GrantRoleStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1883"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1884"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>granted_roles</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of roles to be granted/revoked */ 
</span><a name="LN1885"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>grantee_roles</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of member roles to add/delete */ 
</span><a name="LN1886"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_grant</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true = GRANT, false = REVOKE */ 
</span><a name="LN1887"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>admin_opt</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* with admin option */ 
</span><a name="LN1888"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>grantor</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* set grantor to other than current role */ 
</span><a name="LN1889"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* drop behavior (for REVOKE) */ 
</span><a name="LN1890"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GrantRoleStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *  Alter Default Privileges Statement 
 * ---------------------- 
 */ 
</span><a name="LN1896"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterDefaultPrivilegesStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1898"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1899"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of DefElem */ 
</span><a name="LN1900"></a>    <a href="parsenodes.h.html#LN1828"><span class='Ref_to_Struct'>GrantStmt</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>action</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* GRANT/REVOKE action (with objects=NIL) */ 
</span><a name="LN1901"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterDefaultPrivilegesStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Copy Statement 
 * 
 * We support "COPY relation FROM file", "COPY relation TO file", and 
 * "COPY (query) TO file".  In any given CopyStmt, exactly one of "relation" 
 * and "query" must be non-NULL. 
 * ---------------------- 
 */ 
</span><a name="LN1911"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CopyStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1913"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1914"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the relation to copy */ 
</span><a name="LN1915"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>query</span><span class='Delimiter'>;</span>          <span class='Comment_Multi_Line'>/* the query (SELECT or DML statement with 
                                 * RETURNING) to copy, as a raw parse tree */ 
</span><a name="LN1917"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>attlist</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* List of column names (as Strings), or NIL 
                                 * for all columns */ 
</span><a name="LN1919"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_from</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* TO or FROM */ 
</span><a name="LN1920"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_program</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* is 'filename' a program to popen? */ 
</span><a name="LN1921"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>filename</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* filename, or NULL for STDIN/STDOUT */ 
</span><a name="LN1922"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN1923"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CopyStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 * SET Statement (includes RESET) 
 * 
 * "SET var TO DEFAULT" and "RESET var" are semantically equivalent, but we 
 * preserve the distinction in VariableSetKind for CreateCommandTag(). 
 * ---------------------- 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN1934"></a>    <span class='Declare_Enum_Const'>VAR_SET_VALUE</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* SET var = value */ 
</span><a name="LN1935"></a>    <span class='Declare_Enum_Const'>VAR_SET_DEFAULT</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* SET var TO DEFAULT */ 
</span><a name="LN1936"></a>    <span class='Declare_Enum_Const'>VAR_SET_CURRENT</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* SET var FROM CURRENT */ 
</span><a name="LN1937"></a>    <span class='Declare_Enum_Const'>VAR_SET_MULTI</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* special case for SET TRANSACTION ... */ 
</span><a name="LN1938"></a>    <span class='Declare_Enum_Const'>VAR_RESET</span><span class='Delimiter'>,</span>                  <span class='Comment_Single_Line'>/* RESET var */ 
</span><a name="LN1939"></a>    <span class='Declare_Enum_Const'>VAR_RESET_ALL</span>               <span class='Comment_Single_Line'>/* RESET ALL */ 
</span><a name="LN1940"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>VariableSetKind</span><span class='Delimiter'>; 
</span> 
<a name="LN1942"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>VariableSetStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1944"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1945"></a>    <a href="parsenodes.h.html#LN1932"><span class='Ref_to_Typedef'>VariableSetKind</span></a> <span class='Declare_Member'>kind</span><span class='Delimiter'>; 
</span><a name="LN1946"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* variable to be set */ 
</span><a name="LN1947"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* List of A_Const nodes */ 
</span><a name="LN1948"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_local</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* SET LOCAL? */ 
</span><a name="LN1949"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>VariableSetStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 * Show Statement 
 * ---------------------- 
 */ 
</span><a name="LN1955"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>VariableShowStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1957"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1958"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>; 
</span><a name="LN1959"></a>} <span class='Declare_Typedef'>VariableShowStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Table Statement 
 * 
 * NOTE: in the raw gram.y output, ColumnDef and Constraint nodes are 
 * intermixed in tableElts, and constraints is NIL.  After parse analysis, 
 * tableElts contains just ColumnDefs, and constraints contains just 
 * Constraint nodes (in fact, only CONSTR_CHECK nodes, in the present 
 * implementation). 
 * ---------------------- 
 */ 
</span> 
<a name="LN1972"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN1974"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1975"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation to create */ 
</span><a name="LN1976"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tableElts</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* column definitions (list of ColumnDef) */ 
</span><a name="LN1977"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>inhRelations</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* relations to inherit from (list of 
                                 * inhRelation) */ 
</span><a name="LN1979"></a>    <a href="parsenodes.h.html#LN795"><span class='Ref_to_Struct'>PartitionBoundSpec</span></a> <span class='Operator'>*</span><span class='Declare_Member'>partbound</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* FOR VALUES clause */ 
</span><a name="LN1980"></a>    <a href="parsenodes.h.html#LN777"><span class='Ref_to_Struct'>PartitionSpec</span></a> <span class='Operator'>*</span><span class='Declare_Member'>partspec</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* PARTITION BY clause */ 
</span><a name="LN1981"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>ofTypename</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OF typename */ 
</span><a name="LN1982"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>constraints</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* constraints (list of Constraint nodes) */ 
</span><a name="LN1983"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* options from WITH clause */ 
</span><a name="LN1984"></a>    <a href="primnodes.h.html#LN46"><span class='Ref_to_Enum'>OnCommitAction</span></a> <span class='Declare_Member'>oncommit</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* what do we do at COMMIT? */ 
</span><a name="LN1985"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>tablespacename</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* table space to use, or NULL */ 
</span><a name="LN1986"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if it already exists? */ 
</span><a name="LN1987"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------- 
 * Definitions for constraints in CreateStmt 
 * 
 * Note that column defaults are treated as a type of constraint, 
 * even though that's a bit odd semantically. 
 * 
 * For constraints that use expressions (CONSTR_CHECK, CONSTR_DEFAULT) 
 * we may have the expression in either "raw" form (an untransformed 
 * parse tree) or "cooked" form (the nodeToString representation of 
 * an executable expression tree), depending on how this Constraint 
 * node was created (by parsing, or by inheritance from an existing 
 * relation).  We should never have both in the same node! 
 * 
 * FKCONSTR_ACTION_xxx values are stored into pg_constraint.confupdtype 
 * and pg_constraint.confdeltype columns; FKCONSTR_MATCH_xxx values are 
 * stored into pg_constraint.confmatchtype.  Changing the code values may 
 * require an initdb! 
 * 
 * If skip_validation is true then we skip checking that the existing rows 
 * in the table satisfy the constraint, and just install the catalog entries 
 * for the constraint.  A new FK constraint is marked as valid iff 
 * initially_valid is true.  (Usually skip_validation and initially_valid 
 * are inverses, but we can set both true if the table is known empty.) 
 * 
 * Constraint attributes (DEFERRABLE etc) are initially represented as 
 * separate Constraint nodes for simplicity of parsing.  parse_utilcmd.c makes 
 * a pass through the constraints list to insert the info into the appropriate 
 * Constraint node. 
 * ---------- 
 */ 
</span> 
<a name="LN2020"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>ConstrType</span>         <span class='Comment_Single_Line'>/* types of constraints */ 
</span><span class='Delimiter'>{ 
</span><a name="LN2022"></a>    <span class='Declare_Enum_Const'>CONSTR_NULL</span><span class='Delimiter'>,</span>                <span class='Comment_Multi_Line'>/* not standard SQL, but a lot of people 
                                 * expect it */ 
</span><a name="LN2024"></a>    <span class='Declare_Enum_Const'>CONSTR_NOTNULL</span><span class='Delimiter'>, 
</span><a name="LN2025"></a>    <span class='Declare_Enum_Const'>CONSTR_DEFAULT</span><span class='Delimiter'>, 
</span><a name="LN2026"></a>    <span class='Declare_Enum_Const'>CONSTR_IDENTITY</span><span class='Delimiter'>, 
</span><a name="LN2027"></a>    <span class='Declare_Enum_Const'>CONSTR_CHECK</span><span class='Delimiter'>, 
</span><a name="LN2028"></a>    <span class='Declare_Enum_Const'>CONSTR_PRIMARY</span><span class='Delimiter'>, 
</span><a name="LN2029"></a>    <span class='Declare_Enum_Const'>CONSTR_UNIQUE</span><span class='Delimiter'>, 
</span><a name="LN2030"></a>    <span class='Declare_Enum_Const'>CONSTR_EXCLUSION</span><span class='Delimiter'>, 
</span><a name="LN2031"></a>    <span class='Declare_Enum_Const'>CONSTR_FOREIGN</span><span class='Delimiter'>, 
</span><a name="LN2032"></a>    <span class='Declare_Enum_Const'>CONSTR_ATTR_DEFERRABLE</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* attributes for previous constraint node */ 
</span><a name="LN2033"></a>    <span class='Declare_Enum_Const'>CONSTR_ATTR_NOT_DEFERRABLE</span><span class='Delimiter'>, 
</span><a name="LN2034"></a>    <span class='Declare_Enum_Const'>CONSTR_ATTR_DEFERRED</span><span class='Delimiter'>, 
</span><a name="LN2035"></a>    <span class='Declare_Enum_Const'>CONSTR_ATTR_IMMEDIATE</span> 
<a name="LN2036"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ConstrType</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Foreign key action codes */ 
</span><a name="LN2039"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_ACTION_NOACTION</span>    <span class='String'>'a'</span> 
<a name="LN2040"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_ACTION_RESTRICT</span>    <span class='String'>'r'</span> 
<a name="LN2041"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_ACTION_CASCADE</span>     <span class='String'>'c'</span> 
<a name="LN2042"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_ACTION_SETNULL</span>     <span class='String'>'n'</span> 
<a name="LN2043"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_ACTION_SETDEFAULT</span>  <span class='String'>'d'</span> 
 
<span class='Comment_Multi_Line'>/* Foreign key matchtype codes */ 
</span><a name="LN2046"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_MATCH_FULL</span>         <span class='String'>'f'</span> 
<a name="LN2047"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_MATCH_PARTIAL</span>      <span class='String'>'p'</span> 
<a name="LN2048"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FKCONSTR_MATCH_SIMPLE</span>       <span class='String'>'s'</span> 
 
<a name="LN2050"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Constraint</span> 
<span class='Delimiter'>{ 
</span><a name="LN2052"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2053"></a>    <a href="parsenodes.h.html#LN2020"><span class='Ref_to_Enum'>ConstrType</span></a>  <span class='Declare_Member'>contype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* see above */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields used for most/all constraint types: */ 
</span><a name="LN2056"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>conname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Constraint name, or NULL if unnamed */ 
</span><a name="LN2057"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>deferrable</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* DEFERRABLE? */ 
</span><a name="LN2058"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initdeferred</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* INITIALLY DEFERRED? */ 
</span><a name="LN2059"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields used for constraints with expressions (CHECK and DEFAULT): */ 
</span><a name="LN2062"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_no_inherit</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* is constraint non-inheritable? */ 
</span><a name="LN2063"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>raw_expr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* expr, as untransformed parse tree */ 
</span><a name="LN2064"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>cooked_expr</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expr, as nodeToString representation */ 
</span><a name="LN2065"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>generated_when</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fields used for unique constraints (UNIQUE and PRIMARY KEY): */ 
</span><a name="LN2068"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>keys</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* String nodes naming referenced column(s) */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields used for EXCLUSION constraints: */ 
</span><a name="LN2071"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>exclusions</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of (IndexElem, operator name) pairs */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields used for index constraints (UNIQUE, PRIMARY KEY, EXCLUSION): */ 
</span><a name="LN2074"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* options from WITH clause */ 
</span><a name="LN2075"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>indexname</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* existing index to use; otherwise NULL */ 
</span><a name="LN2076"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>indexspace</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* index tablespace; NULL for default */ 
</span>    <span class='Comment_Multi_Line'>/* These could be, but currently are not, used for UNIQUE/PKEY: */ 
</span><a name="LN2078"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>access_method</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* index access method; NULL for default */ 
</span><a name="LN2079"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>where_clause</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* partial index predicate */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields used for FOREIGN KEY constraints: */ 
</span><a name="LN2082"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>pktable</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Primary key table */ 
</span><a name="LN2083"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fk_attrs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Attributes of foreign key */ 
</span><a name="LN2084"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>pk_attrs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Corresponding attrs in PK table */ 
</span><a name="LN2085"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>fk_matchtype</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* FULL, PARTIAL, SIMPLE */ 
</span><a name="LN2086"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>fk_upd_action</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ON UPDATE action */ 
</span><a name="LN2087"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>fk_del_action</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ON DELETE action */ 
</span><a name="LN2088"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>old_conpfeqop</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* pg_constraint.conpfeqop of my former self */ 
</span><a name="LN2089"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>old_pktable_oid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* pg_constraint.confrelid of my former self */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields used for constraints that allow a NOT VALID specification */ 
</span><a name="LN2092"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>skip_validation</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* skip validation of existing rows? */ 
</span><a name="LN2093"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initially_valid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* mark the new constraint as valid? */ 
</span><a name="LN2094"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end Constraint &raquo; </span> <span class='Declare_Typedef'>Constraint</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create/Drop Table Space Statements 
 * ---------------------- 
 */ 
</span> 
<a name="LN2101"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateTableSpaceStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2103"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2104"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>tablespacename</span><span class='Delimiter'>; 
</span><a name="LN2105"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>owner</span><span class='Delimiter'>; 
</span><a name="LN2106"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>location</span><span class='Delimiter'>; 
</span><a name="LN2107"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>; 
</span><a name="LN2108"></a>} <span class='Declare_Typedef'>CreateTableSpaceStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2110"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DropTableSpaceStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2112"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2113"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>tablespacename</span><span class='Delimiter'>; 
</span><a name="LN2114"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if missing? */ 
</span><a name="LN2115"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DropTableSpaceStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2117"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterTableSpaceOptionsStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2119"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2120"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>tablespacename</span><span class='Delimiter'>; 
</span><a name="LN2121"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>; 
</span><a name="LN2122"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isReset</span><span class='Delimiter'>; 
</span><a name="LN2123"></a>} <span class='Declare_Typedef'>AlterTableSpaceOptionsStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2125"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterTableMoveAllStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2127"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2128"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>orig_tablespacename</span><span class='Delimiter'>; 
</span><a name="LN2129"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>objtype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Object type to move */ 
</span><a name="LN2130"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>roles</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* List of roles to move objects of */ 
</span><a name="LN2131"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>new_tablespacename</span><span class='Delimiter'>; 
</span><a name="LN2132"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>nowait</span><span class='Delimiter'>; 
</span><a name="LN2133"></a>} <span class='Declare_Typedef'>AlterTableMoveAllStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create/Alter Extension Statements 
 * ---------------------- 
 */ 
</span> 
<a name="LN2140"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateExtensionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2142"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2143"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>extname</span><span class='Delimiter'>; 
</span><a name="LN2144"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if it already exists? */ 
</span><a name="LN2145"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN2146"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateExtensionStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Only used for ALTER EXTENSION UPDATE; later might need an action field */ 
</span><a name="LN2149"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterExtensionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2151"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2152"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>extname</span><span class='Delimiter'>; 
</span><a name="LN2153"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN2154"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterExtensionStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2156"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterExtensionContentsStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2158"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2159"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>extname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Extension's name */ 
</span><a name="LN2160"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>action</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* +1 = add object, -1 = drop object */ 
</span><a name="LN2161"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>objtype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Object's type */ 
</span><a name="LN2162"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>object</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Qualified name of the object */ 
</span><a name="LN2163"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterExtensionContentsStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create/Alter FOREIGN DATA WRAPPER Statements 
 * ---------------------- 
 */ 
</span> 
<a name="LN2170"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateFdwStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2172"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2173"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>fdwname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* foreign-data wrapper name */ 
</span><a name="LN2174"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>func_options</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* HANDLER/VALIDATOR options */ 
</span><a name="LN2175"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* generic options to FDW */ 
</span><a name="LN2176"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateFdwStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2178"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterFdwStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2180"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2181"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>fdwname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* foreign-data wrapper name */ 
</span><a name="LN2182"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>func_options</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* HANDLER/VALIDATOR options */ 
</span><a name="LN2183"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* generic options to FDW */ 
</span><a name="LN2184"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterFdwStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create/Alter FOREIGN SERVER Statements 
 * ---------------------- 
 */ 
</span> 
<a name="LN2191"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateForeignServerStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2193"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2194"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>servername</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* server name */ 
</span><a name="LN2195"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>servertype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* optional server type */ 
</span><a name="LN2196"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>version</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* optional server version */ 
</span><a name="LN2197"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>fdwname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* FDW name */ 
</span><a name="LN2198"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if it already exists? */ 
</span><a name="LN2199"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* generic options to server */ 
</span><a name="LN2200"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateForeignServerStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2202"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterForeignServerStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2204"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2205"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>servername</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* server name */ 
</span><a name="LN2206"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>version</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* optional server version */ 
</span><a name="LN2207"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* generic options to server */ 
</span><a name="LN2208"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>has_version</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* version specified */ 
</span><a name="LN2209"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterForeignServerStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create FOREIGN TABLE Statement 
 * ---------------------- 
 */ 
</span> 
<a name="LN2216"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateForeignTableStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2218"></a>    <a href="parsenodes.h.html#LN1972"><span class='Ref_to_Struct'>CreateStmt</span></a>  <span class='Declare_Member'>base</span><span class='Delimiter'>; 
</span><a name="LN2219"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>servername</span><span class='Delimiter'>; 
</span><a name="LN2220"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>; 
</span><a name="LN2221"></a>} <span class='Declare_Typedef'>CreateForeignTableStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create/Drop USER MAPPING Statements 
 * ---------------------- 
 */ 
</span> 
<a name="LN2228"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateUserMappingStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2230"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2231"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>user</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* user role */ 
</span><a name="LN2232"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>servername</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* server name */ 
</span><a name="LN2233"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if it already exists? */ 
</span><a name="LN2234"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* generic options to server */ 
</span><a name="LN2235"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateUserMappingStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2237"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterUserMappingStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2239"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2240"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>user</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* user role */ 
</span><a name="LN2241"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>servername</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* server name */ 
</span><a name="LN2242"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* generic options to server */ 
</span><a name="LN2243"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterUserMappingStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2245"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DropUserMappingStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2247"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2248"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>user</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* user role */ 
</span><a name="LN2249"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>servername</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* server name */ 
</span><a name="LN2250"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* ignore missing mappings */ 
</span><a name="LN2251"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DropUserMappingStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Import Foreign Schema Statement 
 * ---------------------- 
 */ 
</span> 
<a name="LN2258"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>ImportForeignSchemaType</span> 
<span class='Delimiter'>{ 
</span><a name="LN2260"></a>    <span class='Declare_Enum_Const'>FDW_IMPORT_SCHEMA_ALL</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* all relations wanted */ 
</span><a name="LN2261"></a>    <span class='Declare_Enum_Const'>FDW_IMPORT_SCHEMA_LIMIT_TO</span><span class='Delimiter'>, </span><span class='Comment_Single_Line'>/* include only listed tables in import */ 
</span><a name="LN2262"></a>    <span class='Declare_Enum_Const'>FDW_IMPORT_SCHEMA_EXCEPT</span>    <span class='Comment_Single_Line'>/* exclude listed tables from import */ 
</span><a name="LN2263"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ImportForeignSchemaType</span><span class='Delimiter'>; 
</span> 
<a name="LN2265"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ImportForeignSchemaStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2267"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2268"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>server_name</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* FDW server name */ 
</span><a name="LN2269"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>remote_schema</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* remote schema name to query */ 
</span><a name="LN2270"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>local_schema</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* local schema to create objects in */ 
</span><a name="LN2271"></a>    <a href="parsenodes.h.html#LN2258"><span class='Ref_to_Enum'>ImportForeignSchemaType</span></a> <span class='Declare_Member'>list_type</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* type of table list */ 
</span><a name="LN2272"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>table_list</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* List of RangeVar */ 
</span><a name="LN2273"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of options to pass to FDW */ 
</span><a name="LN2274"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ImportForeignSchemaStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------------------- 
 *      Create POLICY Statement 
 *---------------------- 
 */ 
</span><a name="LN2280"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreatePolicyStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2282"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2283"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>policy_name</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Policy's name */ 
</span><a name="LN2284"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>table</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the table name the policy applies to */ 
</span><a name="LN2285"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>cmd_name</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the command name the policy applies to */ 
</span><a name="LN2286"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>permissive</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* restrictive or permissive policy */ 
</span><a name="LN2287"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>roles</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the roles associated with the policy */ 
</span><a name="LN2288"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the policy's condition */ 
</span><a name="LN2289"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>with_check</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the policy's WITH CHECK condition. */ 
</span><a name="LN2290"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreatePolicyStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------------------- 
 *      Alter POLICY Statement 
 *---------------------- 
 */ 
</span><a name="LN2296"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterPolicyStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2298"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2299"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>policy_name</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Policy's name */ 
</span><a name="LN2300"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>table</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the table name the policy applies to */ 
</span><a name="LN2301"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>roles</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the roles associated with the policy */ 
</span><a name="LN2302"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the policy's condition */ 
</span><a name="LN2303"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>with_check</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the policy's WITH CHECK condition. */ 
</span><a name="LN2304"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterPolicyStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------------------- 
 *      Create ACCESS METHOD Statement 
 *---------------------- 
 */ 
</span><a name="LN2310"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateAmStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2312"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2313"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>amname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* access method name */ 
</span><a name="LN2314"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>handler_name</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* handler function name */ 
</span><a name="LN2315"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>amtype</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* type of access method */ 
</span><a name="LN2316"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateAmStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create TRIGGER Statement 
 * ---------------------- 
 */ 
</span><a name="LN2322"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateTrigStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2324"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2325"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>trigname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* TRIGGER's name */ 
</span><a name="LN2326"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation trigger is on */ 
</span><a name="LN2327"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funcname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qual. name of function to call */ 
</span><a name="LN2328"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* list of (T_String) Values or NIL */ 
</span><a name="LN2329"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>row</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* ROW/STATEMENT */ 
</span>    <span class='Comment_Multi_Line'>/* timing uses the TRIGGER_TYPE bits defined in catalog/pg_trigger.h */ 
</span><a name="LN2331"></a>    <a href="../c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Member'>timing</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* BEFORE, AFTER, or INSTEAD */ 
</span>    <span class='Comment_Multi_Line'>/* events uses the TRIGGER_TYPE bits defined in catalog/pg_trigger.h */ 
</span><a name="LN2333"></a>    <a href="../c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Member'>events</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* "OR" of INSERT/UPDATE/DELETE/TRUNCATE */ 
</span><a name="LN2334"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>columns</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* column names, or NIL for all columns */ 
</span><a name="LN2335"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whenClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* qual expression, or NULL if none */ 
</span><a name="LN2336"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isconstraint</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* This is a constraint trigger */ 
</span>    <span class='Comment_Multi_Line'>/* explicitly named transition data */ 
</span><a name="LN2338"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>transitionRels</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* TriggerTransition nodes, or NIL if none */ 
</span>    <span class='Comment_Multi_Line'>/* The remaining fields are only used for constraint triggers */ 
</span><a name="LN2340"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>deferrable</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* [NOT] DEFERRABLE */ 
</span><a name="LN2341"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initdeferred</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* INITIALLY {DEFERRED|IMMEDIATE} */ 
</span><a name="LN2342"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>constrrel</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* opposite relation, if RI trigger */ 
</span><a name="LN2343"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end CreateTrigStmt &raquo; </span> <span class='Declare_Typedef'>CreateTrigStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create EVENT TRIGGER Statement 
 * ---------------------- 
 */ 
</span><a name="LN2349"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateEventTrigStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2351"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2352"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>trigname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* TRIGGER's name */ 
</span><a name="LN2353"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>eventname</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* event's identifier */ 
</span><a name="LN2354"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whenclause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of DefElems indicating filtering */ 
</span><a name="LN2355"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funcname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qual. name of function to call */ 
</span><a name="LN2356"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateEventTrigStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Alter EVENT TRIGGER Statement 
 * ---------------------- 
 */ 
</span><a name="LN2362"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterEventTrigStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2364"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2365"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>trigname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* TRIGGER's name */ 
</span><a name="LN2366"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>tgenabled</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* trigger's firing configuration WRT 
                                 * session_replication_role */ 
</span><a name="LN2368"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterEventTrigStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create/Drop PROCEDURAL LANGUAGE Statements 
 *      Create PROCEDURAL LANGUAGE Statements 
 * ---------------------- 
 */ 
</span><a name="LN2375"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreatePLangStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2377"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2378"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>replace</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* T =&GT; replace if already exists */ 
</span><a name="LN2379"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>plname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* PL name */ 
</span><a name="LN2380"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>plhandler</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* PL call handler function (qual. name) */ 
</span><a name="LN2381"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>plinline</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* optional inline function (qual. name) */ 
</span><a name="LN2382"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>plvalidator</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* optional validator function (qual. name) */ 
</span><a name="LN2383"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>pltrusted</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* PL is trusted */ 
</span><a name="LN2384"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreatePLangStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *  Create/Alter/Drop Role Statements 
 * 
 * Note: these node types are also used for the backwards-compatible 
 * Create/Alter/Drop User/Group statements.  In the ALTER and DROP cases 
 * there's really no need to distinguish what the original spelling was, 
 * but for CREATE we mark the type because the defaults vary. 
 * ---------------------- 
 */ 
</span><a name="LN2395"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>RoleStmtType</span> 
<span class='Delimiter'>{ 
</span><a name="LN2397"></a>    <span class='Declare_Enum_Const'>ROLESTMT_ROLE</span><span class='Delimiter'>, 
</span><a name="LN2398"></a>    <span class='Declare_Enum_Const'>ROLESTMT_USER</span><span class='Delimiter'>, 
</span><a name="LN2399"></a>    <span class='Declare_Enum_Const'>ROLESTMT_GROUP</span> 
<a name="LN2400"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RoleStmtType</span><span class='Delimiter'>; 
</span> 
<a name="LN2402"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateRoleStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2404"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2405"></a>    <a href="parsenodes.h.html#LN2395"><span class='Ref_to_Enum'>RoleStmtType</span></a> <span class='Declare_Member'>stmt_type</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* ROLE/USER/GROUP */ 
</span><a name="LN2406"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>role</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* role name */ 
</span><a name="LN2407"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN2408"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateRoleStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2410"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterRoleStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2412"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2413"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>role</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* role */ 
</span><a name="LN2414"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN2415"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>action</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* +1 = add members, -1 = drop members */ 
</span><a name="LN2416"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterRoleStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2418"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterRoleSetStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2420"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2421"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>role</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* role */ 
</span><a name="LN2422"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>database</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* database name, or NULL */ 
</span><a name="LN2423"></a>    <a href="parsenodes.h.html#LN1942"><span class='Ref_to_Struct'>VariableSetStmt</span></a> <span class='Operator'>*</span><span class='Declare_Member'>setstmt</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* SET or RESET subcommand */ 
</span><a name="LN2424"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterRoleSetStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2426"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DropRoleStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2428"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2429"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>roles</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* List of roles to remove */ 
</span><a name="LN2430"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if a role is missing? */ 
</span><a name="LN2431"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DropRoleStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      {Create|Alter} SEQUENCE Statement 
 * ---------------------- 
 */ 
</span> 
<a name="LN2438"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateSeqStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2440"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2441"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>sequence</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the sequence to create */ 
</span><a name="LN2442"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>; 
</span><a name="LN2443"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>ownerId</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* ID of owner, or InvalidOid for default */ 
</span><a name="LN2444"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>for_identity</span><span class='Delimiter'>; 
</span><a name="LN2445"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if it already exists? */ 
</span><a name="LN2446"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateSeqStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2448"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterSeqStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2450"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2451"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>sequence</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the sequence to alter */ 
</span><a name="LN2452"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>; 
</span><a name="LN2453"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>for_identity</span><span class='Delimiter'>; 
</span><a name="LN2454"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if a role is missing? */ 
</span><a name="LN2455"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterSeqStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create {Aggregate|Operator|Type} Statement 
 * ---------------------- 
 */ 
</span><a name="LN2461"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DefineStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2463"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2464"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>kind</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* aggregate, operator, type */ 
</span><a name="LN2465"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>oldstyle</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* hack to signal old CREATE AGG syntax */ 
</span><a name="LN2466"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>defnames</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2467"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* a list of TypeName (if needed) */ 
</span><a name="LN2468"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>definition</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* a list of DefElem */ 
</span><a name="LN2469"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if it already exists? */ 
</span><a name="LN2470"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DefineStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Domain Statement 
 * ---------------------- 
 */ 
</span><a name="LN2476"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateDomainStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2478"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2479"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>domainname</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2480"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the base type */ 
</span><a name="LN2481"></a>    <a href="parsenodes.h.html#LN305"><span class='Ref_to_Struct'>CollateClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>collClause</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* untransformed COLLATE spec, if any */ 
</span><a name="LN2482"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>constraints</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* constraints (list of Constraint nodes) */ 
</span><a name="LN2483"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateDomainStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Operator Class Statement 
 * ---------------------- 
 */ 
</span><a name="LN2489"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateOpClassStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2491"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2492"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opclassname</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2493"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opfamilyname</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* qualified name (ditto); NIL if omitted */ 
</span><a name="LN2494"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>amname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* name of index AM opclass is for */ 
</span><a name="LN2495"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>datatype</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* datatype of indexed column */ 
</span><a name="LN2496"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>items</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* List of CreateOpClassItem nodes */ 
</span><a name="LN2497"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isDefault</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* Should be marked as default for type? */ 
</span><a name="LN2498"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateOpClassStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2500"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OPCLASS_ITEM_OPERATOR</span>       <span class='Number'>1</span> 
<a name="LN2501"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OPCLASS_ITEM_FUNCTION</span>       <span class='Number'>2</span> 
<a name="LN2502"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>OPCLASS_ITEM_STORAGETYPE</span>    <span class='Number'>3</span> 
 
<a name="LN2504"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateOpClassItem</span> 
<span class='Delimiter'>{ 
</span><a name="LN2506"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2507"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>itemtype</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* see codes above */ 
</span><a name="LN2508"></a>    <a href="parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* operator or function name and args */ 
</span><a name="LN2509"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>number</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* strategy num or support proc num */ 
</span><a name="LN2510"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>order_family</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* only used for ordering operators */ 
</span><a name="LN2511"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>class_args</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* amproclefttype/amprocrighttype or 
                                 * amoplefttype/amoprighttype */ 
</span>    <span class='Comment_Multi_Line'>/* fields used for a storagetype item: */ 
</span><a name="LN2514"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>storedtype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* datatype stored in index */ 
</span><a name="LN2515"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateOpClassItem</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Operator Family Statement 
 * ---------------------- 
 */ 
</span><a name="LN2521"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateOpFamilyStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2523"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2524"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opfamilyname</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2525"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>amname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* name of index AM opfamily is for */ 
</span><a name="LN2526"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateOpFamilyStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Alter Operator Family Statement 
 * ---------------------- 
 */ 
</span><a name="LN2532"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterOpFamilyStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2534"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2535"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opfamilyname</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2536"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>amname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* name of index AM opfamily is for */ 
</span><a name="LN2537"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isDrop</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* ADD or DROP the items? */ 
</span><a name="LN2538"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>items</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* List of CreateOpClassItem nodes */ 
</span><a name="LN2539"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterOpFamilyStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Drop Table|Sequence|View|Index|Type|Domain|Conversion|Schema Statement 
 * ---------------------- 
 */ 
</span> 
<a name="LN2546"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DropStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2548"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2549"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>objects</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of names */ 
</span><a name="LN2550"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>removeType</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* object type */ 
</span><a name="LN2551"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RESTRICT or CASCADE behavior */ 
</span><a name="LN2552"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if object is missing? */ 
</span><a name="LN2553"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>concurrent</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* drop index concurrently? */ 
</span><a name="LN2554"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DropStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *              Truncate Table Statement 
 * ---------------------- 
 */ 
</span><a name="LN2560"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TruncateStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2562"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2563"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>relations</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* relations (RangeVars) to be truncated */ 
</span><a name="LN2564"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>restart_seqs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* restart owned sequences? */ 
</span><a name="LN2565"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RESTRICT or CASCADE behavior */ 
</span><a name="LN2566"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TruncateStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *              Comment On Statement 
 * ---------------------- 
 */ 
</span><a name="LN2572"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CommentStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2574"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2575"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>objtype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Object's type */ 
</span><a name="LN2576"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>object</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Qualified name of the object */ 
</span><a name="LN2577"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>comment</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Comment to insert, or NULL to remove */ 
</span><a name="LN2578"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CommentStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *              SECURITY LABEL Statement 
 * ---------------------- 
 */ 
</span><a name="LN2584"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SecLabelStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2586"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2587"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>objtype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Object's type */ 
</span><a name="LN2588"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>object</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Qualified name of the object */ 
</span><a name="LN2589"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>provider</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Label provider (or NULL) */ 
</span><a name="LN2590"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>label</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* New security label to be assigned */ 
</span><a name="LN2591"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SecLabelStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Declare Cursor Statement 
 * 
 * The "query" field is initially a raw parse tree, and is converted to a 
 * Query node during parse analysis.  Note that rewriting and planning 
 * of the query are always postponed until execution. 
 * ---------------------- 
 */ 
</span><a name="LN2601"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_BINARY</span>       <span class='Number'>0x0001</span>  <span class='Comment_Single_Line'>/* BINARY */ 
</span><a name="LN2602"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_SCROLL</span>       <span class='Number'>0x0002</span>  <span class='Comment_Single_Line'>/* SCROLL explicitly given */ 
</span><a name="LN2603"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_NO_SCROLL</span>    <span class='Number'>0x0004</span>  <span class='Comment_Single_Line'>/* NO SCROLL explicitly given */ 
</span><a name="LN2604"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_INSENSITIVE</span>  <span class='Number'>0x0008</span>  <span class='Comment_Single_Line'>/* INSENSITIVE */ 
</span><a name="LN2605"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_HOLD</span>         <span class='Number'>0x0010</span>  <span class='Comment_Single_Line'>/* WITH HOLD */ 
</span><span class='Comment_Multi_Line'>/* these planner-control flags do not correspond to any SQL grammar: */ 
</span><a name="LN2607"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_FAST_PLAN</span>    <span class='Number'>0x0020</span>  <span class='Comment_Single_Line'>/* prefer fast-start plan */ 
</span><a name="LN2608"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_GENERIC_PLAN</span> <span class='Number'>0x0040</span>  <span class='Comment_Single_Line'>/* force use of generic plan */ 
</span><a name="LN2609"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_CUSTOM_PLAN</span>  <span class='Number'>0x0080</span>  <span class='Comment_Single_Line'>/* force use of custom plan */ 
</span><a name="LN2610"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>CURSOR_OPT_PARALLEL_OK</span>  <span class='Number'>0x0100</span>  <span class='Comment_Single_Line'>/* parallel mode OK */ 
</span> 
<a name="LN2612"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DeclareCursorStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2614"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2615"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>portalname</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* name of the portal (cursor) */ 
</span><a name="LN2616"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* bitmask of options (see above) */ 
</span><a name="LN2617"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>query</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the query (see comments above) */ 
</span><a name="LN2618"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DeclareCursorStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Close Portal Statement 
 * ---------------------- 
 */ 
</span><a name="LN2624"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ClosePortalStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2626"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2627"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>portalname</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* name of the portal (cursor) */ 
</span>    <span class='Comment_Multi_Line'>/* NULL means CLOSE ALL */ 
</span><a name="LN2629"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ClosePortalStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Fetch Statement (also Move) 
 * ---------------------- 
 */ 
</span><a name="LN2635"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>FetchDirection</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* for these, howMany is how many rows to fetch; FETCH_ALL means ALL */ 
</span><a name="LN2638"></a>    <span class='Declare_Enum_Const'>FETCH_FORWARD</span><span class='Delimiter'>, 
</span><a name="LN2639"></a>    <span class='Declare_Enum_Const'>FETCH_BACKWARD</span><span class='Delimiter'>, 
</span>    <span class='Comment_Multi_Line'>/* for these, howMany indicates a position; only one row is fetched */ 
</span><a name="LN2641"></a>    <span class='Declare_Enum_Const'>FETCH_ABSOLUTE</span><span class='Delimiter'>, 
</span><a name="LN2642"></a>    <span class='Declare_Enum_Const'>FETCH_RELATIVE</span> 
<a name="LN2643"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FetchDirection</span><span class='Delimiter'>; 
</span> 
<a name="LN2645"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FETCH_ALL</span>   LONG_MAX 
 
<a name="LN2647"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FetchStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2649"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2650"></a>    <a href="parsenodes.h.html#LN2635"><span class='Ref_to_Enum'>FetchDirection</span></a> <span class='Declare_Member'>direction</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* see above */ 
</span><a name="LN2651"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>howMany</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of rows, or position argument */ 
</span><a name="LN2652"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>portalname</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* name of portal (cursor) */ 
</span><a name="LN2653"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ismove</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* TRUE if MOVE */ 
</span><a name="LN2654"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FetchStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Index Statement 
 * 
 * This represents creation of an index and/or an associated constraint. 
 * If isconstraint is true, we should create a pg_constraint entry along 
 * with the index.  But if indexOid isn't InvalidOid, we are not creating an 
 * index, just a UNIQUE/PKEY constraint using an existing index.  isconstraint 
 * must always be true in this case, and the fields describing the index 
 * properties are empty. 
 * ---------------------- 
 */ 
</span><a name="LN2667"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2669"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2670"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>idxname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of new index, or NULL for default */ 
</span><a name="LN2671"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation to build index on */ 
</span><a name="LN2672"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>accessMethod</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* name of access method (eg. btree) */ 
</span><a name="LN2673"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>tableSpace</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* tablespace, or NULL for default */ 
</span><a name="LN2674"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexParams</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* columns to index: a list of IndexElem */ 
</span><a name="LN2675"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* WITH clause options: a list of DefElem */ 
</span><a name="LN2676"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whereClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualification (partial-index predicate) */ 
</span><a name="LN2677"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>excludeOpNames</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* exclusion operator names, or NIL if none */ 
</span><a name="LN2678"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>idxcomment</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* comment to apply to index, or NULL */ 
</span><a name="LN2679"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>indexOid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OID of an existing index, if any */ 
</span><a name="LN2680"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>oldNode</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* relfilenode of existing storage, if any */ 
</span><a name="LN2681"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>unique</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* is index unique? */ 
</span><a name="LN2682"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>primary</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* is index a primary key? */ 
</span><a name="LN2683"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isconstraint</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* is it for a pkey/unique constraint? */ 
</span><a name="LN2684"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>deferrable</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* is the constraint DEFERRABLE? */ 
</span><a name="LN2685"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initdeferred</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* is the constraint INITIALLY DEFERRED? */ 
</span><a name="LN2686"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>transformed</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* true when transformIndexStmt is finished */ 
</span><a name="LN2687"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>concurrent</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* should this be a concurrent index build? */ 
</span><a name="LN2688"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if index already exists? */ 
</span><a name="LN2689"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end IndexStmt &raquo; </span> <span class='Declare_Typedef'>IndexStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Statistics Statement 
 * ---------------------- 
 */ 
</span><a name="LN2695"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateStatsStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2697"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2698"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>defnames</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2699"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>stat_types</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* stat types (list of Value strings) */ 
</span><a name="LN2700"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>exprs</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* expressions to build statistics on */ 
</span><a name="LN2701"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>relations</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* rels to build stats on (list of RangeVar) */ 
</span><a name="LN2702"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* do nothing if stats name already exists */ 
</span><a name="LN2703"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateStatsStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Function Statement 
 * ---------------------- 
 */ 
</span><a name="LN2709"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateFunctionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2711"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2712"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>replace</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* T =&GT; replace if already exists */ 
</span><a name="LN2713"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>funcname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name of function to create */ 
</span><a name="LN2714"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>parameters</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* a list of FunctionParameter */ 
</span><a name="LN2715"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>returnType</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the return type */ 
</span><a name="LN2716"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* a list of DefElem */ 
</span><a name="LN2717"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>withClause</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* a list of DefElem */ 
</span><a name="LN2718"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateFunctionStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2720"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>FunctionParameterMode</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* the assigned enum values appear in pg_proc, don't change 'em! */ 
</span><a name="LN2723"></a>    <span class='Declare_Enum_Const'>FUNC_PARAM_IN</span> <span class='Operator'>= </span><span class='String'>'i'</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* input only */ 
</span><a name="LN2724"></a>    <span class='Declare_Enum_Const'>FUNC_PARAM_OUT</span> <span class='Operator'>= </span><span class='String'>'o'</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* output only */ 
</span><a name="LN2725"></a>    <span class='Declare_Enum_Const'>FUNC_PARAM_INOUT</span> <span class='Operator'>= </span><span class='String'>'b'</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* both */ 
</span><a name="LN2726"></a>    <span class='Declare_Enum_Const'>FUNC_PARAM_VARIADIC</span> <span class='Operator'>= </span><span class='String'>'v'</span><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* variadic (always input) */ 
</span><a name="LN2727"></a>    <span class='Declare_Enum_Const'>FUNC_PARAM_TABLE</span> <span class='Operator'>= </span><span class='String'>'t'</span>      <span class='Comment_Single_Line'>/* table function output column */ 
</span><a name="LN2728"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FunctionParameterMode</span><span class='Delimiter'>; 
</span> 
<a name="LN2730"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FunctionParameter</span> 
<span class='Delimiter'>{ 
</span><a name="LN2732"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2733"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* parameter name, or NULL if not given */ 
</span><a name="LN2734"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>argType</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* TypeName for parameter type */ 
</span><a name="LN2735"></a>    <a href="parsenodes.h.html#LN2720"><span class='Ref_to_Enum'>FunctionParameterMode</span></a> <span class='Declare_Member'>mode</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* IN/OUT/etc */ 
</span><a name="LN2736"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>defexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* raw default expr, or NULL if not given */ 
</span><a name="LN2737"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FunctionParameter</span><span class='Delimiter'>; 
</span> 
<a name="LN2739"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterFunctionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2741"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2742"></a>    <a href="parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Member'>func</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* name and args of function */ 
</span><a name="LN2743"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>actions</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of DefElem */ 
</span><a name="LN2744"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterFunctionStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      DO Statement 
 * 
 * DoStmt is the raw parser output, InlineCodeBlock is the execution-time API 
 * ---------------------- 
 */ 
</span><a name="LN2752"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DoStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2754"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2755"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN2756"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DoStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN2758"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>InlineCodeBlock</span> 
<span class='Delimiter'>{ 
</span><a name="LN2760"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2761"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>source_text</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* source text of anonymous code block */ 
</span><a name="LN2762"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>langOid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OID of selected language */ 
</span><a name="LN2763"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>langIsTrusted</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* trusted property of the language */ 
</span><a name="LN2764"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>InlineCodeBlock</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Alter Object Rename Statement 
 * ---------------------- 
 */ 
</span><a name="LN2770"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RenameStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2772"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2773"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>renameType</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OBJECT_TABLE, OBJECT_COLUMN, etc */ 
</span><a name="LN2774"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>relationType</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* if column name, associated relation type */ 
</span><a name="LN2775"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* in case it's a table */ 
</span><a name="LN2776"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>object</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* in case it's some other object */ 
</span><a name="LN2777"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>subname</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* name of contained object (column, rule, 
                                 * trigger, etc) */ 
</span><a name="LN2779"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>newname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* the new name */ 
</span><a name="LN2780"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RESTRICT or CASCADE behavior */ 
</span><a name="LN2781"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if missing? */ 
</span><a name="LN2782"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RenameStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 * ALTER object DEPENDS ON EXTENSION extname 
 * ---------------------- 
 */ 
</span><a name="LN2788"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterObjectDependsStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2790"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2791"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>objectType</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OBJECT_FUNCTION, OBJECT_TRIGGER, etc */ 
</span><a name="LN2792"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* in case a table is involved */ 
</span><a name="LN2793"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>object</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* name of the object */ 
</span><a name="LN2794"></a>    <a href="value.h.html#LN41"><span class='Ref_to_Struct'>Value</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>extname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* extension name */ 
</span><a name="LN2795"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterObjectDependsStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      ALTER object SET SCHEMA Statement 
 * ---------------------- 
 */ 
</span><a name="LN2801"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterObjectSchemaStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2803"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2804"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>objectType</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OBJECT_TABLE, OBJECT_TYPE, etc */ 
</span><a name="LN2805"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* in case it's a table */ 
</span><a name="LN2806"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>object</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* in case it's some other object */ 
</span><a name="LN2807"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>newschema</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* the new schema */ 
</span><a name="LN2808"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if missing? */ 
</span><a name="LN2809"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterObjectSchemaStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Alter Object Owner Statement 
 * ---------------------- 
 */ 
</span><a name="LN2815"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterOwnerStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2817"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2818"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>objectType</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OBJECT_TABLE, OBJECT_TYPE, etc */ 
</span><a name="LN2819"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* in case it's a table */ 
</span><a name="LN2820"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>object</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* in case it's some other object */ 
</span><a name="LN2821"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>newowner</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the new owner */ 
</span><a name="LN2822"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterOwnerStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Alter Operator Set Restrict, Join 
 * ---------------------- 
 */ 
</span><a name="LN2829"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterOperatorStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2831"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2832"></a>    <a href="parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Member'>opername</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* operator name and argument types */ 
</span><a name="LN2833"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN2834"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterOperatorStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Rule Statement 
 * ---------------------- 
 */ 
</span><a name="LN2841"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RuleStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2843"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2844"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation the rule is for */ 
</span><a name="LN2845"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>rulename</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* name of the rule */ 
</span><a name="LN2846"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>whereClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualifications */ 
</span><a name="LN2847"></a>    <a href="nodes.h.html#LN647"><span class='Ref_to_Enum'>CmdType</span></a>     <span class='Declare_Member'>event</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* SELECT, INSERT, etc */ 
</span><a name="LN2848"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>instead</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* is a 'do instead'? */ 
</span><a name="LN2849"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>actions</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* the action statements */ 
</span><a name="LN2850"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>replace</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OR REPLACE */ 
</span><a name="LN2851"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RuleStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Notify Statement 
 * ---------------------- 
 */ 
</span><a name="LN2857"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NotifyStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2859"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2860"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>conditionname</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* condition name to notify */ 
</span><a name="LN2861"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>payload</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* the payload string, or NULL if none */ 
</span><a name="LN2862"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NotifyStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Listen Statement 
 * ---------------------- 
 */ 
</span><a name="LN2868"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ListenStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2870"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2871"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>conditionname</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* condition name to listen on */ 
</span><a name="LN2872"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ListenStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Unlisten Statement 
 * ---------------------- 
 */ 
</span><a name="LN2878"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>UnlistenStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2880"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2881"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>conditionname</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* name to unlisten on, or NULL for all */ 
</span><a name="LN2882"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UnlistenStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      {Begin|Commit|Rollback} Transaction Statement 
 * ---------------------- 
 */ 
</span><a name="LN2888"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>TransactionStmtKind</span> 
<span class='Delimiter'>{ 
</span><a name="LN2890"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_BEGIN</span><span class='Delimiter'>, 
</span><a name="LN2891"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_START</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* semantically identical to BEGIN */ 
</span><a name="LN2892"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_COMMIT</span><span class='Delimiter'>, 
</span><a name="LN2893"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_ROLLBACK</span><span class='Delimiter'>, 
</span><a name="LN2894"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_SAVEPOINT</span><span class='Delimiter'>, 
</span><a name="LN2895"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_RELEASE</span><span class='Delimiter'>, 
</span><a name="LN2896"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_ROLLBACK_TO</span><span class='Delimiter'>, 
</span><a name="LN2897"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_PREPARE</span><span class='Delimiter'>, 
</span><a name="LN2898"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_COMMIT_PREPARED</span><span class='Delimiter'>, 
</span><a name="LN2899"></a>    <span class='Declare_Enum_Const'>TRANS_STMT_ROLLBACK_PREPARED</span> 
<a name="LN2900"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TransactionStmtKind</span><span class='Delimiter'>; 
</span> 
<a name="LN2902"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TransactionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2904"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2905"></a>    <a href="parsenodes.h.html#LN2888"><span class='Ref_to_Enum'>TransactionStmtKind</span></a> <span class='Declare_Member'>kind</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* see above */ 
</span><a name="LN2906"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* for BEGIN/START and savepoint commands */ 
</span><a name="LN2907"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>gid</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* for two-phase-commit related commands */ 
</span><a name="LN2908"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TransactionStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Type Statement, composite types 
 * ---------------------- 
 */ 
</span><a name="LN2914"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CompositeTypeStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2916"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2917"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>typevar</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* the composite type to be created */ 
</span><a name="LN2918"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coldeflist</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of ColumnDef nodes */ 
</span><a name="LN2919"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CompositeTypeStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Type Statement, enum types 
 * ---------------------- 
 */ 
</span><a name="LN2925"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateEnumStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2927"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2928"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2929"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>vals</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* enum values (list of Value strings) */ 
</span><a name="LN2930"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateEnumStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create Type Statement, range types 
 * ---------------------- 
 */ 
</span><a name="LN2936"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateRangeStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2938"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2939"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2940"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>params</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* range parameters (list of DefElem) */ 
</span><a name="LN2941"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateRangeStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Alter Type Statement, enum types 
 * ---------------------- 
 */ 
</span><a name="LN2947"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterEnumStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2949"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2950"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>typeName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN2951"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>oldVal</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* old enum value's name, if renaming */ 
</span><a name="LN2952"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>newVal</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* new enum value's name */ 
</span><a name="LN2953"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>newValNeighbor</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* neighboring enum value, if specified */ 
</span><a name="LN2954"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>newValIsAfter</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* place new enum value after neighbor? */ 
</span><a name="LN2955"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>skipIfNewValExists</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* no error if new already exists? */ 
</span><a name="LN2956"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterEnumStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Create View Statement 
 * ---------------------- 
 */ 
</span><a name="LN2962"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>ViewCheckOption</span> 
<span class='Delimiter'>{ 
</span><a name="LN2964"></a>    <span class='Declare_Enum_Const'>NO_CHECK_OPTION</span><span class='Delimiter'>, 
</span><a name="LN2965"></a>    <span class='Declare_Enum_Const'>LOCAL_CHECK_OPTION</span><span class='Delimiter'>, 
</span><a name="LN2966"></a>    <span class='Declare_Enum_Const'>CASCADED_CHECK_OPTION</span> 
<a name="LN2967"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ViewCheckOption</span><span class='Delimiter'>; 
</span> 
<a name="LN2969"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ViewStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2971"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2972"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>view</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the view to be created */ 
</span><a name="LN2973"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aliases</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* target column names */ 
</span><a name="LN2974"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>query</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the SELECT query (as a raw parse tree) */ 
</span><a name="LN2975"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>replace</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* replace an existing view? */ 
</span><a name="LN2976"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* options from WITH clause */ 
</span><a name="LN2977"></a>    <a href="parsenodes.h.html#LN2962"><span class='Ref_to_Enum'>ViewCheckOption</span></a> <span class='Declare_Member'>withCheckOption</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* WITH CHECK OPTION */ 
</span><a name="LN2978"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ViewStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Load Statement 
 * ---------------------- 
 */ 
</span><a name="LN2984"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LoadStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2986"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2987"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>filename</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* file to load */ 
</span><a name="LN2988"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LoadStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Createdb Statement 
 * ---------------------- 
 */ 
</span><a name="LN2994"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreatedbStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN2996"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN2997"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>dbname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* name of database to create */ 
</span><a name="LN2998"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN2999"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreatedbStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *  Alter Database 
 * ---------------------- 
 */ 
</span><a name="LN3005"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterDatabaseStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3007"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3008"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>dbname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* name of database to alter */ 
</span><a name="LN3009"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN3010"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterDatabaseStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN3012"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterDatabaseSetStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3014"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3015"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>dbname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* database name */ 
</span><a name="LN3016"></a>    <a href="parsenodes.h.html#LN1942"><span class='Ref_to_Struct'>VariableSetStmt</span></a> <span class='Operator'>*</span><span class='Declare_Member'>setstmt</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* SET or RESET subcommand */ 
</span><a name="LN3017"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterDatabaseSetStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Dropdb Statement 
 * ---------------------- 
 */ 
</span><a name="LN3023"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DropdbStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3025"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3026"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>dbname</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* database to drop */ 
</span><a name="LN3027"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* skip error if db is missing? */ 
</span><a name="LN3028"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DropdbStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Alter System Statement 
 * ---------------------- 
 */ 
</span><a name="LN3034"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterSystemStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3036"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3037"></a>    <a href="parsenodes.h.html#LN1942"><span class='Ref_to_Struct'>VariableSetStmt</span></a> <span class='Operator'>*</span><span class='Declare_Member'>setstmt</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* SET subcommand */ 
</span><a name="LN3038"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterSystemStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Cluster Statement (support pbrown's cluster index implementation) 
 * ---------------------- 
 */ 
</span><a name="LN3044"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ClusterStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3046"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3047"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation being indexed, or NULL if all */ 
</span><a name="LN3048"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>indexname</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* original index defined */ 
</span><a name="LN3049"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>verbose</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* print progress info */ 
</span><a name="LN3050"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ClusterStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Vacuum and Analyze Statements 
 * 
 * Even though these are nominally two statements, it's convenient to use 
 * just one node type for both.  Note that at least one of VACOPT_VACUUM 
 * and VACOPT_ANALYZE must be set in options. 
 * ---------------------- 
 */ 
</span><a name="LN3060"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>VacuumOption</span> 
<span class='Delimiter'>{ 
</span><a name="LN3062"></a>    <span class='Declare_Enum_Const'>VACOPT_VACUUM</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>0</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* do VACUUM */ 
</span><a name="LN3063"></a>    <span class='Declare_Enum_Const'>VACOPT_ANALYZE</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>1</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* do ANALYZE */ 
</span><a name="LN3064"></a>    <span class='Declare_Enum_Const'>VACOPT_VERBOSE</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>2</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* print progress info */ 
</span><a name="LN3065"></a>    <span class='Declare_Enum_Const'>VACOPT_FREEZE</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>3</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* FREEZE option */ 
</span><a name="LN3066"></a>    <span class='Declare_Enum_Const'>VACOPT_FULL</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>4</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* FULL (non-concurrent) vacuum */ 
</span><a name="LN3067"></a>    <span class='Declare_Enum_Const'>VACOPT_NOWAIT</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>5</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* don't wait to get lock (autovacuum only) */ 
</span><a name="LN3068"></a>    <span class='Declare_Enum_Const'>VACOPT_SKIPTOAST</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>6</span><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* don't process the TOAST table, if any */ 
</span><a name="LN3069"></a>    <span class='Declare_Enum_Const'>VACOPT_DISABLE_PAGE_SKIPPING</span> <span class='Operator'>= </span><span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>7</span>       <span class='Comment_Single_Line'>/* don't skip any pages */ 
</span><a name="LN3070"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>VacuumOption</span><span class='Delimiter'>; 
</span> 
<a name="LN3072"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>VacuumStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3074"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3075"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OR of VacuumOption flags */ 
</span><a name="LN3076"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* single table to process, or NULL */ 
</span><a name="LN3077"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>va_cols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of column names, or NIL for all */ 
</span><a name="LN3078"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>VacuumStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      Explain Statement 
 * 
 * The "query" field is initially a raw parse tree, and is converted to a 
 * Query node during parse analysis.  Note that rewriting and planning 
 * of the query are always postponed until execution. 
 * ---------------------- 
 */ 
</span><a name="LN3088"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ExplainStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3090"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3091"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>query</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the query (see comments above) */ 
</span><a name="LN3092"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of DefElem nodes */ 
</span><a name="LN3093"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ExplainStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      CREATE TABLE AS Statement (a/k/a SELECT INTO) 
 * 
 * A query written as CREATE TABLE AS will produce this node type natively. 
 * A query written as SELECT ... INTO will be transformed to this form during 
 * parse analysis. 
 * A query written as CREATE MATERIALIZED view will produce this node type, 
 * during parse analysis, since it needs all the same data. 
 * 
 * The "query" field is handled similarly to EXPLAIN, though note that it 
 * can be a SELECT or an EXECUTE, but not other DML statements. 
 * ---------------------- 
 */ 
</span><a name="LN3108"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateTableAsStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3110"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3111"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>query</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the query (see comments above) */ 
</span><a name="LN3112"></a>    <a href="primnodes.h.html#LN104"><span class='Ref_to_Struct'>IntoClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>into</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* destination table */ 
</span><a name="LN3113"></a>    <a href="parsenodes.h.html#LN1583"><span class='Ref_to_Enum'>ObjectType</span></a>  <span class='Declare_Member'>relkind</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OBJECT_TABLE or OBJECT_MATVIEW */ 
</span><a name="LN3114"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_select_into</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* it was written as SELECT INTO */ 
</span><a name="LN3115"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>if_not_exists</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* just do nothing if it already exists? */ 
</span><a name="LN3116"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateTableAsStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      REFRESH MATERIALIZED VIEW Statement 
 * ---------------------- 
 */ 
</span><a name="LN3122"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RefreshMatViewStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3124"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3125"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>concurrent</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* allow concurrent access? */ 
</span><a name="LN3126"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>skipData</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true for WITH NO DATA */ 
</span><a name="LN3127"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* relation to insert into */ 
</span><a name="LN3128"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RefreshMatViewStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 * Checkpoint Statement 
 * ---------------------- 
 */ 
</span><a name="LN3134"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CheckPointStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3136"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3137"></a>} <span class='Declare_Typedef'>CheckPointStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 * Discard Statement 
 * ---------------------- 
 */ 
</span> 
<a name="LN3144"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>DiscardMode</span> 
<span class='Delimiter'>{ 
</span><a name="LN3146"></a>    <span class='Declare_Enum_Const'>DISCARD_ALL</span><span class='Delimiter'>, 
</span><a name="LN3147"></a>    <span class='Declare_Enum_Const'>DISCARD_PLANS</span><span class='Delimiter'>, 
</span><a name="LN3148"></a>    <span class='Declare_Enum_Const'>DISCARD_SEQUENCES</span><span class='Delimiter'>, 
</span><a name="LN3149"></a>    <span class='Declare_Enum_Const'>DISCARD_TEMP</span> 
<a name="LN3150"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DiscardMode</span><span class='Delimiter'>; 
</span> 
<a name="LN3152"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DiscardStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3154"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3155"></a>    <a href="parsenodes.h.html#LN3144"><span class='Ref_to_Enum'>DiscardMode</span></a> <span class='Declare_Member'>target</span><span class='Delimiter'>; 
</span><a name="LN3156"></a>} <span class='Declare_Typedef'>DiscardStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      LOCK Statement 
 * ---------------------- 
 */ 
</span><a name="LN3162"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LockStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3164"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3165"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>relations</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* relations to lock */ 
</span><a name="LN3166"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>mode</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* lock mode */ 
</span><a name="LN3167"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>nowait</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* no wait mode */ 
</span><a name="LN3168"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LockStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      SET CONSTRAINTS Statement 
 * ---------------------- 
 */ 
</span><a name="LN3174"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ConstraintsSetStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3176"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3177"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>constraints</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* List of names as RangeVars */ 
</span><a name="LN3178"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>deferred</span><span class='Delimiter'>; 
</span><a name="LN3179"></a>} <span class='Declare_Typedef'>ConstraintsSetStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      REINDEX Statement 
 * ---------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* Reindex options */ 
</span><a name="LN3187"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>REINDEXOPT_VERBOSE</span> <span class='Number'>1</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>0</span>       <span class='Comment_Single_Line'>/* print progress info */ 
</span> 
<a name="LN3189"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>ReindexObjectType</span> 
<span class='Delimiter'>{ 
</span><a name="LN3191"></a>    <span class='Declare_Enum_Const'>REINDEX_OBJECT_INDEX</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* index */ 
</span><a name="LN3192"></a>    <span class='Declare_Enum_Const'>REINDEX_OBJECT_TABLE</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* table or materialized view */ 
</span><a name="LN3193"></a>    <span class='Declare_Enum_Const'>REINDEX_OBJECT_SCHEMA</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* schema */ 
</span><a name="LN3194"></a>    <span class='Declare_Enum_Const'>REINDEX_OBJECT_SYSTEM</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* system catalogs */ 
</span><a name="LN3195"></a>    <span class='Declare_Enum_Const'>REINDEX_OBJECT_DATABASE</span>     <span class='Comment_Single_Line'>/* database */ 
</span><a name="LN3196"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ReindexObjectType</span><span class='Delimiter'>; 
</span> 
<a name="LN3198"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ReindexStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3200"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3201"></a>    <a href="parsenodes.h.html#LN3189"><span class='Ref_to_Enum'>ReindexObjectType</span></a> <span class='Declare_Member'>kind</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* REINDEX_OBJECT_INDEX, REINDEX_OBJECT_TABLE, 
                                 * etc. */ 
</span><a name="LN3203"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>relation</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Table or index to reindex */ 
</span><a name="LN3204"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* name of database to reindex */ 
</span><a name="LN3205"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Reindex options flags */ 
</span><a name="LN3206"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ReindexStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      CREATE CONVERSION Statement 
 * ---------------------- 
 */ 
</span><a name="LN3212"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateConversionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3214"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3215"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>conversion_name</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Name of the conversion */ 
</span><a name="LN3216"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>for_encoding_name</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* source encoding name */ 
</span><a name="LN3217"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>to_encoding_name</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* destination encoding name */ 
</span><a name="LN3218"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>func_name</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* qualified conversion function name */ 
</span><a name="LN3219"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>def</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* is this a default conversion? */ 
</span><a name="LN3220"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateConversionStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *  CREATE CAST Statement 
 * ---------------------- 
 */ 
</span><a name="LN3226"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateCastStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3228"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3229"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>sourcetype</span><span class='Delimiter'>; 
</span><a name="LN3230"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>targettype</span><span class='Delimiter'>; 
</span><a name="LN3231"></a>    <a href="parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Member'>func</span><span class='Delimiter'>; 
</span><a name="LN3232"></a>    <a href="primnodes.h.html#LN418"><span class='Ref_to_Enum'>CoercionContext</span></a> <span class='Declare_Member'>context</span><span class='Delimiter'>; 
</span><a name="LN3233"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inout</span><span class='Delimiter'>; 
</span><a name="LN3234"></a>} <span class='Declare_Typedef'>CreateCastStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *  CREATE TRANSFORM Statement 
 * ---------------------- 
 */ 
</span><a name="LN3240"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateTransformStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3242"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3243"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>replace</span><span class='Delimiter'>; 
</span><a name="LN3244"></a>    <a href="parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>type_name</span><span class='Delimiter'>; 
</span><a name="LN3245"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>lang</span><span class='Delimiter'>; 
</span><a name="LN3246"></a>    <a href="parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Member'>fromsql</span><span class='Delimiter'>; 
</span><a name="LN3247"></a>    <a href="parsenodes.h.html#LN1848"><span class='Ref_to_Struct'>ObjectWithArgs</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tosql</span><span class='Delimiter'>; 
</span><a name="LN3248"></a>} <span class='Declare_Typedef'>CreateTransformStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      PREPARE Statement 
 * ---------------------- 
 */ 
</span><a name="LN3254"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PrepareStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3256"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3257"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* Name of plan, arbitrary */ 
</span><a name="LN3258"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>argtypes</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Types of parameters (List of TypeName) */ 
</span><a name="LN3259"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>query</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* The query itself (as a raw parsetree) */ 
</span><a name="LN3260"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PrepareStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      EXECUTE Statement 
 * ---------------------- 
 */ 
</span> 
<a name="LN3268"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ExecuteStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3270"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3271"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* The name of the plan to execute */ 
</span><a name="LN3272"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>params</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Values to assign to parameters */ 
</span><a name="LN3273"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ExecuteStmt</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------- 
 *      DEALLOCATE Statement 
 * ---------------------- 
 */ 
</span><a name="LN3280"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DeallocateStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3282"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3283"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* The name of the plan to remove */ 
</span>    <span class='Comment_Multi_Line'>/* NULL means DEALLOCATE ALL */ 
</span><a name="LN3285"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DeallocateStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      DROP OWNED statement 
 */ 
</span><a name="LN3290"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DropOwnedStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3292"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3293"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>roles</span><span class='Delimiter'>; 
</span><a name="LN3294"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>; 
</span><a name="LN3295"></a>} <span class='Declare_Typedef'>DropOwnedStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 *      REASSIGN OWNED statement 
 */ 
</span><a name="LN3300"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ReassignOwnedStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3302"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3303"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>roles</span><span class='Delimiter'>; 
</span><a name="LN3304"></a>    <a href="parsenodes.h.html#LN324"><span class='Ref_to_Struct'>RoleSpec</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>newrole</span><span class='Delimiter'>; 
</span><a name="LN3305"></a>} <span class='Declare_Typedef'>ReassignOwnedStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TS Dictionary stmts: DefineStmt, RenameStmt and DropStmt are default 
 */ 
</span><a name="LN3310"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterTSDictionaryStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3312"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3313"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>dictname</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span><a name="LN3314"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN3315"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterTSDictionaryStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TS Configuration stmts: DefineStmt, RenameStmt and DropStmt are default 
 */ 
</span><a name="LN3320"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>AlterTSConfigType</span> 
<span class='Delimiter'>{ 
</span><a name="LN3322"></a>    <span class='Declare_Enum_Const'>ALTER_TSCONFIG_ADD_MAPPING</span><span class='Delimiter'>, 
</span><a name="LN3323"></a>    <span class='Declare_Enum_Const'>ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN</span><span class='Delimiter'>, 
</span><a name="LN3324"></a>    <span class='Declare_Enum_Const'>ALTER_TSCONFIG_REPLACE_DICT</span><span class='Delimiter'>, 
</span><a name="LN3325"></a>    <span class='Declare_Enum_Const'>ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN</span><span class='Delimiter'>, 
</span><a name="LN3326"></a>    <span class='Declare_Enum_Const'>ALTER_TSCONFIG_DROP_MAPPING</span> 
<a name="LN3327"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterTSConfigType</span><span class='Delimiter'>; 
</span> 
<a name="LN3329"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterTSConfigurationStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3331"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3332"></a>    <a href="parsenodes.h.html#LN3320"><span class='Ref_to_Enum'>AlterTSConfigType</span></a> <span class='Declare_Member'>kind</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* ALTER_TSCONFIG_ADD_MAPPING, etc */ 
</span><a name="LN3333"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cfgname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* qualified name (list of Value strings) */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * dicts will be non-NIL if ADD/ALTER MAPPING was specified. If dicts is 
     * NIL, but tokentype isn't, DROP MAPPING was specified. 
     */ 
</span><a name="LN3339"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tokentype</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of Value strings */ 
</span><a name="LN3340"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>dicts</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* list of list of Value strings */ 
</span><a name="LN3341"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>override</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* if true - remove old variant */ 
</span><a name="LN3342"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>replace</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* if true - replace dictionary by another */ 
</span><a name="LN3343"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* for DROP - skip error if missing? */ 
</span><a name="LN3344"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterTSConfigurationStmt</span><span class='Delimiter'>; 
</span> 
 
<a name="LN3347"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreatePublicationStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3349"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3350"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>pubname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Name of of the publication */ 
</span><a name="LN3351"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN3352"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tables</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* Optional list of tables to add */ 
</span><a name="LN3353"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>for_all_tables</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* Special publication for all tables in db */ 
</span><a name="LN3354"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreatePublicationStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN3356"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterPublicationStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3358"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3359"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>pubname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Name of of the publication */ 
</span> 
    <span class='Comment_Multi_Line'>/* parameters used for ALTER PUBLICATION ... WITH */ 
</span><a name="LN3362"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span> 
    <span class='Comment_Multi_Line'>/* parameters used for ALTER PUBLICATION ... ADD/DROP TABLE */ 
</span><a name="LN3365"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tables</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* List of tables to add/drop */ 
</span><a name="LN3366"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>for_all_tables</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* Special publication for all tables in db */ 
</span><a name="LN3367"></a>    <a href="parsenodes.h.html#LN707"><span class='Ref_to_Enum'>DefElemAction</span></a> <span class='Declare_Member'>tableAction</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* What action to perform with the tables */ 
</span><a name="LN3368"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterPublicationStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN3370"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CreateSubscriptionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3372"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3373"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>subname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Name of of the subscription */ 
</span><a name="LN3374"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>conninfo</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Connection string to publisher */ 
</span><a name="LN3375"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>publication</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* One or more publication to subscribe to */ 
</span><a name="LN3376"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN3377"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CreateSubscriptionStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN3379"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>AlterSubscriptionType</span> 
<span class='Delimiter'>{ 
</span><a name="LN3381"></a>    <span class='Declare_Enum_Const'>ALTER_SUBSCRIPTION_OPTIONS</span><span class='Delimiter'>, 
</span><a name="LN3382"></a>    <span class='Declare_Enum_Const'>ALTER_SUBSCRIPTION_CONNECTION</span><span class='Delimiter'>, 
</span><a name="LN3383"></a>    <span class='Declare_Enum_Const'>ALTER_SUBSCRIPTION_PUBLICATION</span><span class='Delimiter'>, 
</span><a name="LN3384"></a>    <span class='Declare_Enum_Const'>ALTER_SUBSCRIPTION_REFRESH</span><span class='Delimiter'>, 
</span><a name="LN3385"></a>    <span class='Declare_Enum_Const'>ALTER_SUBSCRIPTION_ENABLED</span> 
<a name="LN3386"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterSubscriptionType</span><span class='Delimiter'>; 
</span> 
<a name="LN3388"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlterSubscriptionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3390"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3391"></a>    <a href="parsenodes.h.html#LN3379"><span class='Ref_to_Enum'>AlterSubscriptionType</span></a> <span class='Declare_Member'>kind</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* ALTER_SUBSCRIPTION_OPTIONS, etc */ 
</span><a name="LN3392"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>subname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Name of of the subscription */ 
</span><a name="LN3393"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>conninfo</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Connection string to publisher */ 
</span><a name="LN3394"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>publication</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* One or more publication to subscribe to */ 
</span><a name="LN3395"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* List of DefElem nodes */ 
</span><a name="LN3396"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlterSubscriptionStmt</span><span class='Delimiter'>; 
</span> 
<a name="LN3398"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>DropSubscriptionStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN3400"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN3401"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>subname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Name of of the subscription */ 
</span><a name="LN3402"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>missing_ok</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* Skip error if missing? */ 
</span><a name="LN3403"></a>    <a href="parsenodes.h.html#LN1652"><span class='Ref_to_Enum'>DropBehavior</span></a> <span class='Declare_Member'>behavior</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RESTRICT or CASCADE behavior */ 
</span><a name="LN3404"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>DropSubscriptionStmt</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* PARSENODES_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>