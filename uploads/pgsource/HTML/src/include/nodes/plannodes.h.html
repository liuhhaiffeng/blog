<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\nodes\plannodes.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\nodes\plannodes.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:07 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * plannodes.h 
 *    definitions for query plan nodes 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/nodes/plannodes.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="plannodes.h.html#LN14"><span class='Ref_to_Const'>PLANNODES_H</span></a> 
<a name="LN14"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PLANNODES_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/sdir.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/stringinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/bitmapset.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/lockoptions.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/primnodes.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *                      node definitions 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      PlannedStmt node 
 * 
 * The output of the planner is a Plan tree headed by a PlannedStmt node. 
 * PlannedStmt holds the "one time" information needed by the executor. 
 * 
 * For simplicity in APIs, we also wrap utility statements in PlannedStmt 
 * nodes; in such cases, commandType == CMD_UTILITY, the statement itself 
 * is in the utilityStmt field, and the rest of the struct is mostly dummy. 
 * (We do use canSetTag, stmt_location, stmt_len, and possibly queryId.) 
 * ---------------- 
 */ 
</span><a name="LN40"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlannedStmt</span> 
<span class='Delimiter'>{ 
</span><a name="LN42"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN44"></a>    <a href="nodes.h.html#LN647"><span class='Ref_to_Enum'>CmdType</span></a>     <span class='Declare_Member'>commandType</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* select|insert|update|delete|utility */ 
</span> 
<a name="LN46"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>queryId</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* query identifier (copied from Query) */ 
</span> 
<a name="LN48"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasReturning</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* is it insert|update|delete RETURNING? */ 
</span> 
<a name="LN50"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasModifyingCTE</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* has insert|update|delete in WITH? */ 
</span> 
<a name="LN52"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>canSetTag</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* do I set the command result tag? */ 
</span> 
<a name="LN54"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>transientPlan</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* redo plan when TransactionXmin changes? */ 
</span> 
<a name="LN56"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>dependsOnRole</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* is plan specific to current role? */ 
</span> 
<a name="LN58"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallelModeNeeded</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* parallel mode required to execute? */ 
</span> 
<a name="LN60"></a>    <span class='Control'>struct</span> <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Declare_Member'>planTree</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* tree of Plan nodes */ 
</span> 
<a name="LN62"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rtable</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* list of RangeTblEntry nodes */ 
</span> 
    <span class='Comment_Multi_Line'>/* rtable indexes of target relations for INSERT/UPDATE/DELETE */ 
</span><a name="LN65"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>resultRelations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* integer list of RT indexes, or NIL */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * rtable indexes of non-leaf target relations for UPDATE/DELETE on all 
     * the partitioned table mentioned in the query. 
     */ 
</span><a name="LN71"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>nonleafResultRelations</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * rtable indexes of root target relations for UPDATE/DELETE; this list 
     * maintains a subset of the RT indexes in nonleafResultRelations, 
     * indicating the roots of the respective partition hierarchies. 
     */ 
</span><a name="LN78"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rootResultRelations</span><span class='Delimiter'>; 
</span> 
<a name="LN80"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subplans</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* Plan trees for SubPlan expressions; note 
                                 * that some could be NULL */ 
</span> 
<a name="LN83"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>rewindPlanIDs</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* indices of subplans that require REWIND */ 
</span> 
<a name="LN85"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowMarks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* a list of PlanRowMark's */ 
</span> 
<a name="LN87"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>relationOids</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OIDs of relations the plan depends on */ 
</span> 
<a name="LN89"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>invalItems</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* other dependencies, as PlanInvalItems */ 
</span> 
<a name="LN91"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nParamExec</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* number of PARAM_EXEC Params used */ 
</span> 
<a name="LN93"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>utilityStmt</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* non-null if this is utility stmt */ 
</span> 
    <span class='Comment_Multi_Line'>/* statement location in source string (copied from Query) */ 
</span><a name="LN96"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>stmt_location</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* start location, or -1 if unknown */ 
</span><a name="LN97"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>stmt_len</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* length in bytes; 0 means "rest of string" */ 
</span><a name="LN98"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end PlannedStmt &raquo; </span> <span class='Declare_Typedef'>PlannedStmt</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* macro for fetching the Plan associated with a SubPlan node */ 
</span><a name="LN101"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>exec_subplan_get_plan</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>plannedstmt</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>subplan</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>((</span><a href="plannodes.h.html#LN101"><span class='Ref_to_Parameter'>plannedstmt</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subplans<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="plannodes.h.html#LN101"><span class='Ref_to_Parameter'>subplan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>plan_id <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      Plan node 
 * 
 * All plan nodes "derive" from the Plan structure by having the 
 * Plan structure as the first field.  This ensures that everything works 
 * when nodes are cast to Plan's.  (node pointers are frequently cast to Plan* 
 * when passed around generically in the executor) 
 * 
 * We never actually instantiate any Plan nodes; this is just the common 
 * abstract superclass for all Plan-type nodes. 
 * ---------------- 
 */ 
</span><a name="LN117"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Plan</span> 
<span class='Delimiter'>{ 
</span><a name="LN119"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * estimated execution costs for plan (see costsize.c for more info) 
     */ 
</span><a name="LN124"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>startup_cost</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* cost expended before fetching any tuples */ 
</span><a name="LN125"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>total_cost</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* total cost (assuming all tuples fetched) */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * planner's estimate of result size of this plan step 
     */ 
</span><a name="LN130"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>plan_rows</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* number of rows plan is expected to emit */ 
</span><a name="LN131"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>plan_width</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* average row width in bytes */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * information needed for parallel query 
     */ 
</span><a name="LN136"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallel_aware</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* engage parallel-aware logic? */ 
</span><a name="LN137"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallel_safe</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OK to use as part of parallel plan? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Common structural data for all Plan types. 
     */ 
</span><a name="LN142"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>plan_node_id</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* unique across entire final plan tree */ 
</span><a name="LN143"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>targetlist</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* target list to be computed at this node */ 
</span><a name="LN144"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* implicitly-ANDed qual conditions */ 
</span><a name="LN145"></a>    <span class='Control'>struct</span> <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Declare_Member'>lefttree</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* input plan tree(s) */ 
</span><a name="LN146"></a>    <span class='Control'>struct</span> <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Declare_Member'>righttree</span><span class='Delimiter'>; 
</span><a name="LN147"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>initPlan</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* Init Plan nodes (un-correlated expr 
                                 * subselects) */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Information for management of parameter-change-driven rescanning 
     * 
     * extParam includes the paramIDs of all external PARAM_EXEC params 
     * affecting this plan node or its children.  setParam params from the 
     * node's initPlans are not included, but their extParams are. 
     * 
     * allParam includes all the extParam paramIDs, plus the IDs of local 
     * params that affect the node (i.e., the setParams of its initplans). 
     * These are _all_ the PARAM_EXEC params that affect this node. 
     */ 
</span><a name="LN161"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>extParam</span><span class='Delimiter'>; 
</span><a name="LN162"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>allParam</span><span class='Delimiter'>; 
</span><a name="LN163"></a>}<span class='Auto_Annotations'> &laquo; end Plan &raquo; </span> <span class='Declare_Typedef'>Plan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *  these are defined to avoid confusion problems with "left" 
 *  and "right" and "inner" and "outer".  The convention is that 
 *  the "left" plan is the "outer" plan and the "right" plan is 
 *  the inner plan, but these make the code more readable. 
 * ---------------- 
 */ 
</span><a name="LN172"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>innerPlan</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span>         <span class='Parentheses'>(((</span><a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="plannodes.h.html#LN172"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>righttree<span class='Parentheses'>)</span> 
<a name="LN173"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>outerPlan</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span>         <span class='Parentheses'>(((</span><a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>)(</span><a href="plannodes.h.html#LN173"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>lefttree<span class='Parentheses'>)</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   Result node - 
 *      If no outer plan, evaluate a variable-free targetlist. 
 *      If outer plan, return tuples from outer plan (after a level of 
 *      projection as shown by targetlist). 
 * 
 * If resconstantqual isn't NULL, it represents a one-time qualification 
 * test (i.e., one that doesn't depend on any variables from the outer plan, 
 * so needs to be evaluated only once). 
 * ---------------- 
 */ 
</span><a name="LN187"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Result</span> 
<span class='Delimiter'>{ 
</span><a name="LN189"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN190"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>resconstantqual</span><span class='Delimiter'>; 
</span><a name="LN191"></a>} <span class='Declare_Typedef'>Result</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ProjectSet node - 
 *      Apply a projection that includes set-returning functions to the 
 *      output tuples of the outer plan. 
 * ---------------- 
 */ 
</span><a name="LN199"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ProjectSet</span> 
<span class='Delimiter'>{ 
</span><a name="LN201"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN202"></a>} <span class='Declare_Typedef'>ProjectSet</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   ModifyTable node - 
 *      Apply rows produced by subplan(s) to result table(s), 
 *      by inserting, updating, or deleting. 
 * 
 * Note that rowMarks and epqParam are presumed to be valid for all the 
 * subplan(s); they can't contain any info that varies across subplans. 
 * ---------------- 
 */ 
</span><a name="LN213"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ModifyTable</span> 
<span class='Delimiter'>{ 
</span><a name="LN215"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN216"></a>    <a href="nodes.h.html#LN647"><span class='Ref_to_Enum'>CmdType</span></a>     <span class='Declare_Member'>operation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* INSERT, UPDATE, or DELETE */ 
</span><a name="LN217"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>canSetTag</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* do we set the command tag/es_processed? */ 
</span><a name="LN218"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>nominalRelation</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Parent RT index for use of EXPLAIN */ 
</span>    <span class='Comment_Multi_Line'>/* RT indexes of non-leaf tables in a partition tree */ 
</span><a name="LN220"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitioned_rels</span><span class='Delimiter'>; 
</span><a name="LN221"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>resultRelations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* integer list of RT indexes */ 
</span><a name="LN222"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>resultRelIndex</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* index of first resultRel in plan's list */ 
</span><a name="LN223"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>rootResultRelIndex</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* index of the partitioned table root */ 
</span><a name="LN224"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>plans</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* plan(s) producing source data */ 
</span><a name="LN225"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>withCheckOptionLists</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* per-target-table WCO lists */ 
</span><a name="LN226"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>returningLists</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* per-target-table RETURNING tlists */ 
</span><a name="LN227"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdwPrivLists</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* per-target-table FDW private data lists */ 
</span><a name="LN228"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>fdwDirectModifyPlans</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* indices of FDW DM plans */ 
</span><a name="LN229"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowMarks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* PlanRowMarks (non-locking only) */ 
</span><a name="LN230"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>epqParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ID of Param for EvalPlanQual re-eval */ 
</span><a name="LN231"></a>    <a href="nodes.h.html#LN797"><span class='Ref_to_Enum'>OnConflictAction</span></a> <span class='Declare_Member'>onConflictAction</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* ON CONFLICT action */ 
</span><a name="LN232"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arbiterIndexes</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* List of ON CONFLICT arbiter index OIDs  */ 
</span><a name="LN233"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>onConflictSet</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* SET for INSERT ON CONFLICT DO UPDATE */ 
</span><a name="LN234"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>onConflictWhere</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* WHERE for ON CONFLICT UPDATE */ 
</span><a name="LN235"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>exclRelRTI</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* RTI of the EXCLUDED pseudo relation */ 
</span><a name="LN236"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>exclRelTlist</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* tlist of the EXCLUDED pseudo relation */ 
</span><a name="LN237"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ModifyTable &raquo; </span> <span class='Declare_Typedef'>ModifyTable</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   Append node - 
 *      Generate the concatenation of the results of sub-plans. 
 * ---------------- 
 */ 
</span><a name="LN244"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Append</span> 
<span class='Delimiter'>{ 
</span><a name="LN246"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* RT indexes of non-leaf tables in a partition tree */ 
</span><a name="LN248"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitioned_rels</span><span class='Delimiter'>; 
</span><a name="LN249"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>appendplans</span><span class='Delimiter'>; 
</span><a name="LN250"></a>} <span class='Declare_Typedef'>Append</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   MergeAppend node - 
 *      Merge the results of pre-sorted sub-plans to preserve the ordering. 
 * ---------------- 
 */ 
</span><a name="LN257"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MergeAppend</span> 
<span class='Delimiter'>{ 
</span><a name="LN259"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* RT indexes of non-leaf tables in a partition tree */ 
</span><a name="LN261"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitioned_rels</span><span class='Delimiter'>; 
</span><a name="LN262"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>mergeplans</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* remaining fields are just like the sort-key info in struct Sort */ 
</span><a name="LN264"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of sort-key columns */ 
</span><a name="LN265"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sortColIdx</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN266"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>sortOperators</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OIDs of operators to sort them by */ 
</span><a name="LN267"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>collations</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OIDs of collations */ 
</span><a name="LN268"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>nullsFirst</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* NULLS FIRST/LAST directions */ 
</span><a name="LN269"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MergeAppend</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *  RecursiveUnion node - 
 *      Generate a recursive union of two subplans. 
 * 
 * The "outer" subplan is always the non-recursive term, and the "inner" 
 * subplan is the recursive term. 
 * ---------------- 
 */ 
</span><a name="LN279"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RecursiveUnion</span> 
<span class='Delimiter'>{ 
</span><a name="LN281"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN282"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>wtParam</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* ID of Param representing work table */ 
</span>    <span class='Comment_Multi_Line'>/* Remaining fields are zero/null in UNION ALL case */ 
</span><a name="LN284"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* number of columns to check for 
                                 * duplicate-ness */ 
</span><a name="LN286"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>dupColIdx</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN287"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>dupOperators</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality operators to compare with */ 
</span><a name="LN288"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* estimated number of groups in input */ 
</span><a name="LN289"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RecursiveUnion</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   BitmapAnd node - 
 *      Generate the intersection of the results of sub-plans. 
 * 
 * The subplans must be of types that yield tuple bitmaps.  The targetlist 
 * and qual fields of the plan are unused and are always NIL. 
 * ---------------- 
 */ 
</span><a name="LN299"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapAnd</span> 
<span class='Delimiter'>{ 
</span><a name="LN301"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN302"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>bitmapplans</span><span class='Delimiter'>; 
</span><a name="LN303"></a>} <span class='Declare_Typedef'>BitmapAnd</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *   BitmapOr node - 
 *      Generate the union of the results of sub-plans. 
 * 
 * The subplans must be of types that yield tuple bitmaps.  The targetlist 
 * and qual fields of the plan are unused and are always NIL. 
 * ---------------- 
 */ 
</span><a name="LN313"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapOr</span> 
<span class='Delimiter'>{ 
</span><a name="LN315"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN316"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isshared</span><span class='Delimiter'>; 
</span><a name="LN317"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>bitmapplans</span><span class='Delimiter'>; 
</span><a name="LN318"></a>} <span class='Declare_Typedef'>BitmapOr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ========== 
 * Scan nodes 
 * ========== 
 */ 
</span><a name="LN325"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Scan</span> 
<span class='Delimiter'>{ 
</span><a name="LN327"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN328"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>scanrelid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* relid is index into the range table */ 
</span><a name="LN329"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Scan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      sequential scan node 
 * ---------------- 
 */ 
</span><a name="LN335"></a><span class='Control'>typedef</span> <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a> <span class='Declare_Typedef'>SeqScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      table sample scan node 
 * ---------------- 
 */ 
</span><a name="LN341"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SampleScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN343"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* use struct pointer to avoid including parsenodes.h here */ 
</span><a name="LN345"></a>    <span class='Control'>struct</span> <a href="parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tablesample</span><span class='Delimiter'>; 
</span><a name="LN346"></a>} <span class='Declare_Typedef'>SampleScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      index scan node 
 * 
 * indexqualorig is an implicitly-ANDed list of index qual expressions, each 
 * in the same form it appeared in the query WHERE condition.  Each should 
 * be of the form (indexkey OP comparisonval) or (comparisonval OP indexkey). 
 * The indexkey is a Var or expression referencing column(s) of the index's 
 * base table.  The comparisonval might be any expression, but it won't use 
 * any columns of the base table.  The expressions are ordered by index 
 * column position (but items referencing the same index column can appear 
 * in any order).  indexqualorig is used at runtime only if we have to recheck 
 * a lossy indexqual. 
 * 
 * indexqual has the same form, but the expressions have been commuted if 
 * necessary to put the indexkeys on the left, and the indexkeys are replaced 
 * by Var nodes identifying the index columns (their varno is INDEX_VAR and 
 * their varattno is the index column number). 
 * 
 * indexorderbyorig is similarly the original form of any ORDER BY expressions 
 * that are being implemented by the index, while indexorderby is modified to 
 * have index column Vars on the left-hand side.  Here, multiple expressions 
 * must appear in exactly the ORDER BY order, and this is not necessarily the 
 * index column order.  Only the expressions are provided, not the auxiliary 
 * sort-order information from the ORDER BY SortGroupClauses; it's assumed 
 * that the sort ordering is fully determinable from the top-level operators. 
 * indexorderbyorig is used at runtime to recheck the ordering, if the index 
 * cannot calculate an accurate ordering.  It is also needed for EXPLAIN. 
 * 
 * indexorderbyops is a list of the OIDs of the operators used to sort the 
 * ORDER BY expressions.  This is used together with indexorderbyorig to 
 * recheck ordering at run time.  (Note that indexorderby, indexorderbyorig, 
 * and indexorderbyops are used for amcanorderbyop cases, not amcanorder.) 
 * 
 * indexorderdir specifies the scan ordering, for indexscans on amcanorder 
 * indexes (for other indexes it should be "don't care"). 
 * ---------------- 
 */ 
</span><a name="LN385"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN387"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN388"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>indexid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OID of index to scan */ 
</span><a name="LN389"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexqual</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of index quals (usually OpExprs) */ 
</span><a name="LN390"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexqualorig</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* the same in original form */ 
</span><a name="LN391"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexorderby</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of index ORDER BY exprs */ 
</span><a name="LN392"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexorderbyorig</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the same in original form */ 
</span><a name="LN393"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexorderbyops</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OIDs of sort ops for ORDER BY exprs */ 
</span><a name="LN394"></a>    <a href="../access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Member'>indexorderdir</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* forward or backward or don't care */ 
</span><a name="LN395"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>IndexScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      index-only scan node 
 * 
 * IndexOnlyScan is very similar to IndexScan, but it specifies an 
 * index-only scan, in which the data comes from the index not the heap. 
 * Because of this, *all* Vars in the plan node's targetlist, qual, and 
 * index expressions reference index columns and have varno = INDEX_VAR. 
 * Hence we do not need separate indexqualorig and indexorderbyorig lists, 
 * since their contents would be equivalent to indexqual and indexorderby. 
 * 
 * To help EXPLAIN interpret the index Vars for display, we provide 
 * indextlist, which represents the contents of the index as a targetlist 
 * with one TLE per index column.  Vars appearing in this list reference 
 * the base table, and this is the only field in the plan node that may 
 * contain such Vars. 
 * ---------------- 
 */ 
</span><a name="LN414"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexOnlyScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN416"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN417"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>indexid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OID of index to scan */ 
</span><a name="LN418"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexqual</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of index quals (usually OpExprs) */ 
</span><a name="LN419"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexorderby</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of index ORDER BY exprs */ 
</span><a name="LN420"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indextlist</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* TargetEntry list describing index's cols */ 
</span><a name="LN421"></a>    <a href="../access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Member'>indexorderdir</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* forward or backward or don't care */ 
</span><a name="LN422"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>IndexOnlyScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      bitmap index scan node 
 * 
 * BitmapIndexScan delivers a bitmap of potential tuple locations; 
 * it does not access the heap itself.  The bitmap is used by an 
 * ancestor BitmapHeapScan node, possibly after passing through 
 * intermediate BitmapAnd and/or BitmapOr nodes to combine it with 
 * the results of other BitmapIndexScans. 
 * 
 * The fields have the same meanings as for IndexScan, except we don't 
 * store a direction flag because direction is uninteresting. 
 * 
 * In a BitmapIndexScan plan node, the targetlist and qual fields are 
 * not used and are always NIL.  The indexqualorig field is unused at 
 * run time too, but is saved for the benefit of EXPLAIN. 
 * ---------------- 
 */ 
</span><a name="LN441"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapIndexScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN443"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN444"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>indexid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OID of index to scan */ 
</span><a name="LN445"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isshared</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Create shared bitmap if set */ 
</span><a name="LN446"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexqual</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of index quals (OpExprs) */ 
</span><a name="LN447"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexqualorig</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* the same in original form */ 
</span><a name="LN448"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BitmapIndexScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      bitmap sequential scan node 
 * 
 * This needs a copy of the qual conditions being used by the input index 
 * scans because there are various cases where we need to recheck the quals; 
 * for example, when the bitmap is lossy about the specific rows on a page 
 * that meet the index condition. 
 * ---------------- 
 */ 
</span><a name="LN459"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapHeapScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN461"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN462"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>bitmapqualorig</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* index quals, in standard expr form */ 
</span><a name="LN463"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BitmapHeapScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      tid scan node 
 * 
 * tidquals is an implicitly OR'ed list of qual expressions of the form 
 * "CTID = pseudoconstant" or "CTID = ANY(pseudoconstant_array)". 
 * ---------------- 
 */ 
</span><a name="LN472"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TidScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN474"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN475"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tidquals</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qual(s) involving CTID = something */ 
</span><a name="LN476"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TidScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      subquery scan node 
 * 
 * SubqueryScan is for scanning the output of a sub-query in the range table. 
 * We often need an extra plan node above the sub-query's plan to perform 
 * expression evaluations (which we can't push into the sub-query without 
 * risking changing its semantics).  Although we are not scanning a physical 
 * relation, we make this a descendant of Scan anyway for code-sharing 
 * purposes. 
 * 
 * Note: we store the sub-plan in the type-specific subplan field, not in 
 * the generic lefttree field as you might expect.  This is because we do 
 * not want plan-tree-traversal routines to recurse into the subplan without 
 * knowing that they are changing Query contexts. 
 * ---------------- 
 */ 
</span><a name="LN494"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SubqueryScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN496"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN497"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subplan</span><span class='Delimiter'>; 
</span><a name="LN498"></a>} <span class='Declare_Typedef'>SubqueryScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      FunctionScan node 
 * ---------------- 
 */ 
</span><a name="LN504"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FunctionScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN506"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN507"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>functions</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of RangeTblFunction nodes */ 
</span><a name="LN508"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>funcordinality</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* WITH ORDINALITY */ 
</span><a name="LN509"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FunctionScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      ValuesScan node 
 * ---------------- 
 */ 
</span><a name="LN515"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ValuesScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN517"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN518"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>values_lists</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of expression lists */ 
</span><a name="LN519"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ValuesScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      TableFunc scan node 
 * ---------------- 
 */ 
</span><a name="LN525"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TableFuncScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN527"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN528"></a>    <a href="primnodes.h.html#LN78"><span class='Ref_to_Struct'>TableFunc</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>tablefunc</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* table function node */ 
</span><a name="LN529"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TableFuncScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      CteScan node 
 * ---------------- 
 */ 
</span><a name="LN535"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CteScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN537"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN538"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ctePlanId</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ID of init SubPlan for CTE */ 
</span><a name="LN539"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>cteParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ID of Param representing CTE output */ 
</span><a name="LN540"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CteScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      NamedTuplestoreScan node 
 * ---------------- 
 */ 
</span><a name="LN546"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NamedTuplestoreScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN548"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN549"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>enrname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Name given to Ephemeral Named Relation */ 
</span><a name="LN550"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NamedTuplestoreScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      WorkTableScan node 
 * ---------------- 
 */ 
</span><a name="LN556"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WorkTableScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN558"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN559"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>wtParam</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* ID of Param representing work table */ 
</span><a name="LN560"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WorkTableScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      ForeignScan node 
 * 
 * fdw_exprs and fdw_private are both under the control of the foreign-data 
 * wrapper, but fdw_exprs is presumed to contain expression trees and will 
 * be post-processed accordingly by the planner; fdw_private won't be. 
 * Note that everything in both lists must be copiable by copyObject(). 
 * One way to store an arbitrary blob of bytes is to represent it as a bytea 
 * Const.  Usually, though, you'll be better off choosing a representation 
 * that can be dumped usefully by nodeToString(). 
 * 
 * fdw_scan_tlist is a targetlist describing the contents of the scan tuple 
 * returned by the FDW; it can be NIL if the scan tuple matches the declared 
 * rowtype of the foreign table, which is the normal case for a simple foreign 
 * table scan.  (If the plan node represents a foreign join, fdw_scan_tlist 
 * is required since there is no rowtype available from the system catalogs.) 
 * When fdw_scan_tlist is provided, Vars in the node's tlist and quals must 
 * have varno INDEX_VAR, and their varattnos correspond to resnos in the 
 * fdw_scan_tlist (which are also column numbers in the actual scan tuple). 
 * fdw_scan_tlist is never actually executed; it just holds expression trees 
 * describing what is in the scan tuple's columns. 
 * 
 * fdw_recheck_quals should contain any quals which the core system passed to 
 * the FDW but which were not added to scan.plan.qual; that is, it should 
 * contain the quals being checked remotely.  This is needed for correct 
 * behavior during EvalPlanQual rechecks. 
 * 
 * When the plan node represents a foreign join, scan.scanrelid is zero and 
 * fs_relids must be consulted to identify the join relation.  (fs_relids 
 * is valid for simple scans as well, but will always match scan.scanrelid.) 
 * ---------------- 
 */ 
</span><a name="LN594"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ForeignScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN596"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN597"></a>    <a href="nodes.h.html#LN647"><span class='Ref_to_Enum'>CmdType</span></a>     <span class='Declare_Member'>operation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* SELECT/INSERT/UPDATE/DELETE */ 
</span><a name="LN598"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>fs_server</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OID of foreign server */ 
</span><a name="LN599"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_exprs</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* expressions that FDW may evaluate */ 
</span><a name="LN600"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_private</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* private data for FDW */ 
</span><a name="LN601"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_scan_tlist</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* optional tlist describing scan tuple */ 
</span><a name="LN602"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_recheck_quals</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* original quals not in 
                                         * scan.plan.qual */ 
</span><a name="LN604"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>fs_relids</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RTIs generated by this scan */ 
</span><a name="LN605"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>fsSystemCol</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* true if any "system column" is needed */ 
</span><a name="LN606"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ForeignScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *     CustomScan node 
 * 
 * The comments for ForeignScan's fdw_exprs, fdw_private, fdw_scan_tlist, 
 * and fs_relids fields apply equally to CustomScan's custom_exprs, 
 * custom_private, custom_scan_tlist, and custom_relids fields.  The 
 * convention of setting scan.scanrelid to zero for joins applies as well. 
 * 
 * Note that since Plan trees can be copied, custom scan providers *must* 
 * fit all plan data they need into those fields; embedding CustomScan in 
 * a larger struct will not work. 
 * ---------------- 
 */ 
</span><span class='Control'>struct</span> <a href="extensible.h.html#LN104"><span class='Ref_to_Struct'>CustomScanMethods</span></a><span class='Delimiter'>; 
</span> 
<a name="LN623"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CustomScan</span> 
<span class='Delimiter'>{ 
</span><a name="LN625"></a>    <a href="plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>        <span class='Declare_Member'>scan</span><span class='Delimiter'>; 
</span><a name="LN626"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>flags</span><span class='Delimiter'>;</span>          <span class='Comment_Multi_Line'>/* mask of CUSTOMPATH_* flags, see 
                                 * nodes/extensible.h */ 
</span><a name="LN628"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>custom_plans</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of Plan nodes, if any */ 
</span><a name="LN629"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>custom_exprs</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* expressions that custom code may evaluate */ 
</span><a name="LN630"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>custom_private</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* private data for custom code */ 
</span><a name="LN631"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>custom_scan_tlist</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* optional tlist describing scan 
                                         * tuple */ 
</span><a name="LN633"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>custom_relids</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* RTIs generated by this scan */ 
</span><a name="LN634"></a>    <span class='Keyword'>const </span><span class='Control'>struct</span> <a href="extensible.h.html#LN104"><span class='Ref_to_Struct'>CustomScanMethods</span></a> <span class='Operator'>*</span><span class='Declare_Member'>methods</span><span class='Delimiter'>; 
</span><a name="LN635"></a>} <span class='Declare_Typedef'>CustomScan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ========== 
 * Join nodes 
 * ========== 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      Join node 
 * 
 * jointype:    rule for joining tuples from left and right subtrees 
 * inner_unique each outer tuple can match to no more than one inner tuple 
 * joinqual:    qual conditions that came from JOIN/ON or JOIN/USING 
 *              (plan.qual contains conditions that came from WHERE) 
 * 
 * When jointype is INNER, joinqual and plan.qual are semantically 
 * interchangeable.  For OUTER jointypes, the two are *not* interchangeable; 
 * only joinqual is used to determine whether a match has been found for 
 * the purpose of deciding whether to generate null-extended tuples. 
 * (But plan.qual is still applied before actually returning a tuple.) 
 * For an outer join, only joinquals are allowed to be used as the merge 
 * or hash condition of a merge or hash join. 
 * 
 * inner_unique is set if the joinquals are such that no more than one inner 
 * tuple could match any given outer tuple.  This allows the executor to 
 * skip searching for additional matches.  (This must be provable from just 
 * the joinquals, ignoring plan.qual, due to where the executor tests it.) 
 * ---------------- 
 */ 
</span><a name="LN665"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Join</span> 
<span class='Delimiter'>{ 
</span><a name="LN667"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN668"></a>    <a href="nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Member'>jointype</span><span class='Delimiter'>; 
</span><a name="LN669"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inner_unique</span><span class='Delimiter'>; 
</span><a name="LN670"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>joinqual</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* JOIN quals (in addition to plan.qual) */ 
</span><a name="LN671"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Join</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      nest loop join node 
 * 
 * The nestParams list identifies any executor Params that must be passed 
 * into execution of the inner subplan carrying values from the current row 
 * of the outer subplan.  Currently we restrict these values to be simple 
 * Vars, but perhaps someday that'd be worth relaxing.  (Note: during plan 
 * creation, the paramval can actually be a PlaceHolderVar expression; but it 
 * must be a Var with varno OUTER_VAR by the time it gets to the executor.) 
 * ---------------- 
 */ 
</span><a name="LN684"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NestLoop</span> 
<span class='Delimiter'>{ 
</span><a name="LN686"></a>    <a href="plannodes.h.html#LN665"><span class='Ref_to_Struct'>Join</span></a>        <span class='Declare_Member'>join</span><span class='Delimiter'>; 
</span><a name="LN687"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>nestParams</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of NestLoopParam nodes */ 
</span><a name="LN688"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NestLoop</span><span class='Delimiter'>; 
</span> 
<a name="LN690"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NestLoopParam</span> 
<span class='Delimiter'>{ 
</span><a name="LN692"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN693"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>paramno</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of the PARAM_EXEC Param to set */ 
</span><a name="LN694"></a>    <a href="primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>paramval</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* outer-relation Var to assign to Param */ 
</span><a name="LN695"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NestLoopParam</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      merge join node 
 * 
 * The expected ordering of each mergeable column is described by a btree 
 * opfamily OID, a collation OID, a direction (BTLessStrategyNumber or 
 * BTGreaterStrategyNumber) and a nulls-first flag.  Note that the two sides 
 * of each mergeclause may be of different datatypes, but they are ordered the 
 * same way according to the common opfamily and collation.  The operator in 
 * each mergeclause must be an equality operator of the indicated opfamily. 
 * ---------------- 
 */ 
</span><a name="LN708"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MergeJoin</span> 
<span class='Delimiter'>{ 
</span><a name="LN710"></a>    <a href="plannodes.h.html#LN665"><span class='Ref_to_Struct'>Join</span></a>        <span class='Declare_Member'>join</span><span class='Delimiter'>; 
</span><a name="LN711"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>skip_mark_restore</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* Can we skip mark/restore calls? */ 
</span><a name="LN712"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>mergeclauses</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* mergeclauses as expression trees */ 
</span>    <span class='Comment_Multi_Line'>/* these are arrays, but have the same length as the mergeclauses list: */ 
</span><a name="LN714"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>mergeFamilies</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* per-clause OIDs of btree opfamilies */ 
</span><a name="LN715"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>mergeCollations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-clause OIDs of collations */ 
</span><a name="LN716"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>mergeStrategies</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-clause ordering (ASC or DESC) */ 
</span><a name="LN717"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>mergeNullsFirst</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-clause nulls ordering */ 
</span><a name="LN718"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MergeJoin</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      hash join node 
 * ---------------- 
 */ 
</span><a name="LN724"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>HashJoin</span> 
<span class='Delimiter'>{ 
</span><a name="LN726"></a>    <a href="plannodes.h.html#LN665"><span class='Ref_to_Struct'>Join</span></a>        <span class='Declare_Member'>join</span><span class='Delimiter'>; 
</span><a name="LN727"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>hashclauses</span><span class='Delimiter'>; 
</span><a name="LN728"></a>} <span class='Declare_Typedef'>HashJoin</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      materialization node 
 * ---------------- 
 */ 
</span><a name="LN734"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Material</span> 
<span class='Delimiter'>{ 
</span><a name="LN736"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN737"></a>} <span class='Declare_Typedef'>Material</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      sort node 
 * ---------------- 
 */ 
</span><a name="LN743"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Sort</span> 
<span class='Delimiter'>{ 
</span><a name="LN745"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN746"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of sort-key columns */ 
</span><a name="LN747"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sortColIdx</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN748"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>sortOperators</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OIDs of operators to sort them by */ 
</span><a name="LN749"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>collations</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OIDs of collations */ 
</span><a name="LN750"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>nullsFirst</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* NULLS FIRST/LAST directions */ 
</span><a name="LN751"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Sort</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* --------------- 
 *   group node - 
 *      Used for queries with GROUP BY (but no aggregates) specified. 
 *      The input must be presorted according to the grouping columns. 
 * --------------- 
 */ 
</span><a name="LN759"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Group</span> 
<span class='Delimiter'>{ 
</span><a name="LN761"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN762"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of grouping columns */ 
</span><a name="LN763"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>grpColIdx</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN764"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>grpOperators</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality operators to compare with */ 
</span><a name="LN765"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Group</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* --------------- 
 *      aggregate node 
 * 
 * An Agg node implements plain or grouped aggregation.  For grouped 
 * aggregation, we can work with presorted input or unsorted input; 
 * the latter strategy uses an internal hashtable. 
 * 
 * Notice the lack of any direct info about the aggregate functions to be 
 * computed.  They are found by scanning the node's tlist and quals during 
 * executor startup.  (It is possible that there are no aggregate functions; 
 * this could happen if they get optimized away by constant-folding, or if 
 * we are using the Agg node to implement hash-based grouping.) 
 * --------------- 
 */ 
</span><a name="LN781"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Agg</span> 
<span class='Delimiter'>{ 
</span><a name="LN783"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN784"></a>    <a href="nodes.h.html#LN733"><span class='Ref_to_Enum'>AggStrategy</span></a> <span class='Declare_Member'>aggstrategy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* basic strategy, see nodes.h */ 
</span><a name="LN785"></a>    <a href="nodes.h.html#LN755"><span class='Ref_to_Enum'>AggSplit</span></a>    <span class='Declare_Member'>aggsplit</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* agg-splitting mode, see nodes.h */ 
</span><a name="LN786"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of grouping columns */ 
</span><a name="LN787"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>grpColIdx</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN788"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>grpOperators</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality operators to compare with */ 
</span><a name="LN789"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* estimated number of groups in input */ 
</span><a name="LN790"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>aggParams</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* IDs of Params used in Aggref inputs */ 
</span>    <span class='Comment_Multi_Line'>/* Note: planner provides numGroups & aggParams only in HASHED/MIXED case */ 
</span><a name="LN792"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupingSets</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* grouping sets to use */ 
</span><a name="LN793"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>chain</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* chained Agg/Sort nodes */ 
</span><a name="LN794"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Agg</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      window aggregate node 
 * ---------------- 
 */ 
</span><a name="LN800"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WindowAgg</span> 
<span class='Delimiter'>{ 
</span><a name="LN802"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN803"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>winref</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* ID referenced by window functions */ 
</span><a name="LN804"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>partNumCols</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of columns in partition clause */ 
</span><a name="LN805"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>partColIdx</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN806"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>partOperators</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* equality operators for partition columns */ 
</span><a name="LN807"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ordNumCols</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* number of columns in ordering clause */ 
</span><a name="LN808"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ordColIdx</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN809"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>ordOperators</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality operators for ordering columns */ 
</span><a name="LN810"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>frameOptions</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* frame_clause options, see WindowDef */ 
</span><a name="LN811"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>startOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expression for starting bound, if any */ 
</span><a name="LN812"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>endOffset</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* expression for ending bound, if any */ 
</span><a name="LN813"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WindowAgg</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      unique node 
 * ---------------- 
 */ 
</span><a name="LN819"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Unique</span> 
<span class='Delimiter'>{ 
</span><a name="LN821"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN822"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of columns to check for uniqueness */ 
</span><a name="LN823"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>uniqColIdx</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN824"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>uniqOperators</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* equality operators to compare with */ 
</span><a name="LN825"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Unique</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ------------ 
 *      gather node 
 * ------------ 
 */ 
</span><a name="LN831"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Gather</span> 
<span class='Delimiter'>{ 
</span><a name="LN833"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN834"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_workers</span><span class='Delimiter'>; 
</span><a name="LN835"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>single_copy</span><span class='Delimiter'>; 
</span><a name="LN836"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>invisible</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* suppress EXPLAIN display (for testing)? */ 
</span><a name="LN837"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Gather</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ------------ 
 *      gather merge node 
 * ------------ 
 */ 
</span><a name="LN843"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GatherMerge</span> 
<span class='Delimiter'>{ 
</span><a name="LN845"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN846"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_workers</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* remaining fields are just like the sort-key info in struct Sort */ 
</span><a name="LN848"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of sort-key columns */ 
</span><a name="LN849"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sortColIdx</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN850"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>sortOperators</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OIDs of operators to sort them by */ 
</span><a name="LN851"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>collations</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OIDs of collations */ 
</span><a name="LN852"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>nullsFirst</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* NULLS FIRST/LAST directions */ 
</span><a name="LN853"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GatherMerge</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      hash build node 
 * 
 * If the executor is supposed to try to apply skew join optimization, then 
 * skewTable/skewColumn/skewInherit identify the outer relation's join key 
 * column, from which the relevant MCV statistics can be fetched. 
 * ---------------- 
 */ 
</span><a name="LN863"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Hash</span> 
<span class='Delimiter'>{ 
</span><a name="LN865"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN866"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>skewTable</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* outer join key's table OID, or InvalidOid */ 
</span><a name="LN867"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>skewColumn</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* outer join key's column #, or zero */ 
</span><a name="LN868"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>skewInherit</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* is outer join rel an inheritance tree? */ 
</span>    <span class='Comment_Multi_Line'>/* all other info is in the parent HashJoin node */ 
</span><a name="LN870"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Hash</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      setop node 
 * ---------------- 
 */ 
</span><a name="LN876"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SetOp</span> 
<span class='Delimiter'>{ 
</span><a name="LN878"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN879"></a>    <a href="nodes.h.html#LN777"><span class='Ref_to_Enum'>SetOpCmd</span></a>    <span class='Declare_Member'>cmd</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* what to do, see nodes.h */ 
</span><a name="LN880"></a>    <a href="nodes.h.html#LN785"><span class='Ref_to_Enum'>SetOpStrategy</span></a> <span class='Declare_Member'>strategy</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* how to do it, see nodes.h */ 
</span><a name="LN881"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* number of columns to check for 
                                 * duplicate-ness */ 
</span><a name="LN883"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>dupColIdx</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* their indexes in the target list */ 
</span><a name="LN884"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>dupOperators</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality operators to compare with */ 
</span><a name="LN885"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>flagColIdx</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* where is the flag column, if any */ 
</span><a name="LN886"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>firstFlag</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* flag value for first input relation */ 
</span><a name="LN887"></a>    <span class='Keyword'>long</span>        <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* estimated number of groups in input */ 
</span><a name="LN888"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SetOp</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      lock-rows node 
 * 
 * rowMarks identifies the rels to be locked by this node; it should be 
 * a subset of the rowMarks listed in the top-level PlannedStmt. 
 * epqParam is a Param that all scan nodes below this one must depend on. 
 * It is used to force re-evaluation of the plan during EvalPlanQual. 
 * ---------------- 
 */ 
</span><a name="LN899"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LockRows</span> 
<span class='Delimiter'>{ 
</span><a name="LN901"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN902"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowMarks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* a list of PlanRowMark's */ 
</span><a name="LN903"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>epqParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ID of Param for EvalPlanQual re-eval */ 
</span><a name="LN904"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LockRows</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      limit node 
 * 
 * Note: as of Postgres 8.2, the offset and count expressions are expected 
 * to yield int8, rather than int4 as before. 
 * ---------------- 
 */ 
</span><a name="LN913"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Limit</span> 
<span class='Delimiter'>{ 
</span><a name="LN915"></a>    <a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>        <span class='Declare_Member'>plan</span><span class='Delimiter'>; 
</span><a name="LN916"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OFFSET parameter, or NULL if none */ 
</span><a name="LN917"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitCount</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* COUNT parameter, or NULL if none */ 
</span><a name="LN918"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Limit</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * RowMarkType - 
 *    enums for types of row-marking operations 
 * 
 * The first four of these values represent different lock strengths that 
 * we can take on tuples according to SELECT FOR [KEY] UPDATE/SHARE requests. 
 * We support these on regular tables, as well as on foreign tables whose FDWs 
 * report support for late locking.  For other foreign tables, any locking 
 * that might be done for such requests must happen during the initial row 
 * fetch; their FDWs provide no mechanism for going back to lock a row later. 
 * This means that the semantics will be a bit different than for a local 
 * table; in particular we are likely to lock more rows than would be locked 
 * locally, since remote rows will be locked even if they then fail 
 * locally-checked restriction or join quals.  However, the prospect of 
 * doing a separate remote query to lock each selected row is usually pretty 
 * unappealing, so early locking remains a credible design choice for FDWs. 
 * 
 * When doing UPDATE, DELETE, or SELECT FOR UPDATE/SHARE, we have to uniquely 
 * identify all the source rows, not only those from the target relations, so 
 * that we can perform EvalPlanQual rechecking at need.  For plain tables we 
 * can just fetch the TID, much as for a target relation; this case is 
 * represented by ROW_MARK_REFERENCE.  Otherwise (for example for VALUES or 
 * FUNCTION scans) we have to copy the whole row value.  ROW_MARK_COPY is 
 * pretty inefficient, since most of the time we'll never need the data; but 
 * fortunately the overhead is usually not performance-critical in practice. 
 * By default we use ROW_MARK_COPY for foreign tables, but if the FDW has 
 * a concept of rowid it can request to use ROW_MARK_REFERENCE instead. 
 * (Again, this probably doesn't make sense if a physical remote fetch is 
 * needed, but for FDWs that map to local storage it might be credible.) 
 */ 
</span><a name="LN951"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>RowMarkType</span> 
<span class='Delimiter'>{ 
</span><a name="LN953"></a>    <span class='Declare_Enum_Const'>ROW_MARK_EXCLUSIVE</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* obtain exclusive tuple lock */ 
</span><a name="LN954"></a>    <span class='Declare_Enum_Const'>ROW_MARK_NOKEYEXCLUSIVE</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* obtain no-key exclusive tuple lock */ 
</span><a name="LN955"></a>    <span class='Declare_Enum_Const'>ROW_MARK_SHARE</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* obtain shared tuple lock */ 
</span><a name="LN956"></a>    <span class='Declare_Enum_Const'>ROW_MARK_KEYSHARE</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* obtain keyshare tuple lock */ 
</span><a name="LN957"></a>    <span class='Declare_Enum_Const'>ROW_MARK_REFERENCE</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* just fetch the TID, don't lock it */ 
</span><a name="LN958"></a>    <span class='Declare_Enum_Const'>ROW_MARK_COPY</span>               <span class='Comment_Single_Line'>/* physically copy the row value */ 
</span><a name="LN959"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RowMarkType</span><span class='Delimiter'>; 
</span> 
<a name="LN961"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>RowMarkRequiresRowShareLock</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>marktype</span><span class='Parentheses'>)</span>  <span class='Parentheses'>((</span><a href="plannodes.h.html#LN961"><span class='Ref_to_Parameter'>marktype</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><a href="plannodes.h.html#LN956"><span class='Ref_to_EnumConst'>ROW_MARK_KEYSHARE</span></a><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * PlanRowMark - 
 *     plan-time representation of FOR [KEY] UPDATE/SHARE clauses 
 * 
 * When doing UPDATE, DELETE, or SELECT FOR UPDATE/SHARE, we create a separate 
 * PlanRowMark node for each non-target relation in the query.  Relations that 
 * are not specified as FOR UPDATE/SHARE are marked ROW_MARK_REFERENCE (if 
 * regular tables or supported foreign tables) or ROW_MARK_COPY (if not). 
 * 
 * Initially all PlanRowMarks have rti == prti and isParent == false. 
 * When the planner discovers that a relation is the root of an inheritance 
 * tree, it sets isParent true, and adds an additional PlanRowMark to the 
 * list for each child relation (including the target rel itself in its role 
 * as a child).  isParent is also set to true for the partitioned child 
 * relations, which are not scanned just like the root parent.  The child 
 * entries have rti == child rel's RT index and prti == parent's RT index, 
 * and can therefore be recognized as children by the fact that prti != rti. 
 * The parent's allMarkTypes field gets the OR of (1&LT;&LT;markType) across all 
 * its children (this definition allows children to use different markTypes). 
 * 
 * The planner also adds resjunk output columns to the plan that carry 
 * information sufficient to identify the locked or fetched rows.  When 
 * markType != ROW_MARK_COPY, these columns are named 
 *      tableoid%u          OID of table 
 *      ctid%u              TID of row 
 * The tableoid column is only present for an inheritance hierarchy. 
 * When markType == ROW_MARK_COPY, there is instead a single column named 
 *      wholerow%u          whole-row value of relation 
 * (An inheritance hierarchy could have all three resjunk output columns, 
 * if some children use a different markType than others.) 
 * In all three cases, %u represents the rowmark ID number (rowmarkId). 
 * This number is unique within a plan tree, except that child relation 
 * entries copy their parent's rowmarkId.  (Assigning unique numbers 
 * means we needn't renumber rowmarkIds when flattening subqueries, which 
 * would require finding and renaming the resjunk columns as well.) 
 * Note this means that all tables in an inheritance hierarchy share the 
 * same resjunk column names.  However, in an inherited UPDATE/DELETE the 
 * columns could have different physical column numbers in each subplan. 
 */ 
</span><a name="LN1002"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlanRowMark</span> 
<span class='Delimiter'>{ 
</span><a name="LN1004"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1005"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>rti</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* range table index of markable relation */ 
</span><a name="LN1006"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>prti</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* range table index of parent relation */ 
</span><a name="LN1007"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>rowmarkId</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* unique identifier for resjunk columns */ 
</span><a name="LN1008"></a>    <a href="plannodes.h.html#LN951"><span class='Ref_to_Enum'>RowMarkType</span></a> <span class='Declare_Member'>markType</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* see enum above */ 
</span><a name="LN1009"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>allMarkTypes</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OR of (1&LT;&LT;markType) for all children */ 
</span><a name="LN1010"></a>    <a href="lockoptions.h.html#LN20"><span class='Ref_to_Enum'>LockClauseStrength</span></a> <span class='Declare_Member'>strength</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* LockingClause's strength, or LCS_NONE */ 
</span><a name="LN1011"></a>    <a href="lockoptions.h.html#LN35"><span class='Ref_to_Enum'>LockWaitPolicy</span></a> <span class='Declare_Member'>waitPolicy</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* NOWAIT and SKIP LOCKED options */ 
</span><a name="LN1012"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isParent</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true if this is a "dummy" parent entry */ 
</span><a name="LN1013"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PlanRowMark</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Plan invalidation info 
 * 
 * We track the objects on which a PlannedStmt depends in two ways: 
 * relations are recorded as a simple list of OIDs, and everything else 
 * is represented as a list of PlanInvalItems.  A PlanInvalItem is designed 
 * to be used with the syscache invalidation mechanism, so it identifies a 
 * system catalog entry by cache ID and hash value. 
 */ 
</span><a name="LN1025"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlanInvalItem</span> 
<span class='Delimiter'>{ 
</span><a name="LN1027"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1028"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>cacheId</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* a syscache ID, see utils/syscache.h */ 
</span><a name="LN1029"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>hashValue</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* hash value of object's cache lookup key */ 
</span><a name="LN1030"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PlanInvalItem</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* PLANNODES_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>