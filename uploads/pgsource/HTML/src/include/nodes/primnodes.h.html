<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\nodes\primnodes.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\nodes\primnodes.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:07 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * primnodes.h 
 *    Definitions for "primitive" node types, those that are used in more 
 *    than one of the parse/plan/execute stages of the query pipeline. 
 *    Currently, these are mostly nodes for executable expressions 
 *    and join trees. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/nodes/primnodes.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="primnodes.h.html#LN17"><span class='Ref_to_Const'>PRIMNODES_H</span></a> 
<a name="LN17"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PRIMNODES_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/attnum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/bitmapset.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/pg_list.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *                      node definitions 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Alias - 
 *    specifies an alias for a range variable; the alias might also 
 *    specify renaming of columns within the table. 
 * 
 * Note: colnames is a list of Value nodes (always strings).  In Alias structs 
 * associated with RTEs, there may be entries corresponding to dropped 
 * columns; these are normally empty strings ("").  See parsenodes.h for info. 
 */ 
</span><a name="LN38"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Alias</span> 
<span class='Delimiter'>{ 
</span><a name="LN40"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN41"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>aliasname</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* aliased rel name (never qualified) */ 
</span><a name="LN42"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colnames</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* optional list of column aliases */ 
</span><a name="LN43"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Alias</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* What to do at commit time for temporary relations */ 
</span><a name="LN46"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>OnCommitAction</span> 
<span class='Delimiter'>{ 
</span><a name="LN48"></a>    <span class='Declare_Enum_Const'>ONCOMMIT_NOOP</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* No ON COMMIT clause (do nothing) */ 
</span><a name="LN49"></a>    <span class='Declare_Enum_Const'>ONCOMMIT_PRESERVE_ROWS</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* ON COMMIT PRESERVE ROWS (do nothing) */ 
</span><a name="LN50"></a>    <span class='Declare_Enum_Const'>ONCOMMIT_DELETE_ROWS</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* ON COMMIT DELETE ROWS */ 
</span><a name="LN51"></a>    <span class='Declare_Enum_Const'>ONCOMMIT_DROP</span>               <span class='Comment_Single_Line'>/* ON COMMIT DROP */ 
</span><a name="LN52"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OnCommitAction</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeVar - range variable, used in FROM clauses 
 * 
 * Also used to represent table names in utility statements; there, the alias 
 * field is not used, and inh tells whether to apply the operation 
 * recursively to child tables.  In some contexts it is also useful to carry 
 * a TEMP table indication here. 
 */ 
</span><a name="LN62"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeVar</span> 
<span class='Delimiter'>{ 
</span><a name="LN64"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN65"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>catalogname</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* the catalog (database) name, or NULL */ 
</span><a name="LN66"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>schemaname</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the schema name, or NULL */ 
</span><a name="LN67"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>relname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* the relation/sequence name */ 
</span><a name="LN68"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inh</span><span class='Delimiter'>;</span>            <span class='Comment_Multi_Line'>/* expand rel by inheritance? recursively act 
                                 * on children? */ 
</span><a name="LN70"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>relpersistence</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* see RELPERSISTENCE_* in pg_class.h */ 
</span><a name="LN71"></a>    <a href="primnodes.h.html#LN38"><span class='Ref_to_Struct'>Alias</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>alias</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* table alias & optional column aliases */ 
</span><a name="LN72"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN73"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RangeVar</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TableFunc - node for a table function, such as XMLTABLE. 
 */ 
</span><a name="LN78"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TableFunc</span> 
<span class='Delimiter'>{ 
</span><a name="LN80"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN81"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ns_uris</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of namespace uri */ 
</span><a name="LN82"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ns_names</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of namespace names */ 
</span><a name="LN83"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>docexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* input document expression */ 
</span><a name="LN84"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* row filter expression */ 
</span><a name="LN85"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colnames</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* column names (list of String) */ 
</span><a name="LN86"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coltypes</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OID list of column type OIDs */ 
</span><a name="LN87"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coltypmods</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* integer list of column typmods */ 
</span><a name="LN88"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colcollations</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OID list of column collation OIDs */ 
</span><a name="LN89"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colexprs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of column filter expressions */ 
</span><a name="LN90"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>coldefexprs</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* list of column default expressions */ 
</span><a name="LN91"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>notnulls</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* nullability flag for each output column */ 
</span><a name="LN92"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ordinalitycol</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* counts from 0; -1 if none specified */ 
</span><a name="LN93"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN94"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TableFunc</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IntoClause - target information for SELECT INTO, CREATE TABLE AS, and 
 * CREATE MATERIALIZED VIEW 
 * 
 * For CREATE MATERIALIZED VIEW, viewQuery is the parsed-but-not-rewritten 
 * SELECT Query for the view; otherwise it's NULL.  (Although it's actually 
 * Query*, we declare it as Node* to avoid a forward reference.) 
 */ 
</span><a name="LN104"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IntoClause</span> 
<span class='Delimiter'>{ 
</span><a name="LN106"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN108"></a>    <a href="primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>rel</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* target relation name */ 
</span><a name="LN109"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colNames</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* column names to assign, or NIL */ 
</span><a name="LN110"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>options</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* options from WITH clause */ 
</span><a name="LN111"></a>    <a href="primnodes.h.html#LN46"><span class='Ref_to_Enum'>OnCommitAction</span></a> <span class='Declare_Member'>onCommit</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* what do we do at COMMIT? */ 
</span><a name="LN112"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>tableSpaceName</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* table space to use, or NULL */ 
</span><a name="LN113"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>viewQuery</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* materialized view's SELECT query */ 
</span><a name="LN114"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>skipData</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true for WITH NO DATA */ 
</span><a name="LN115"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>IntoClause</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *                  node types for executable expressions 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Expr - generic superclass for executable-expression nodes 
 * 
 * All node types that are used in executable expression trees should derive 
 * from Expr (that is, have Expr as their first field).  Since Expr only 
 * contains NodeTag, this is a formality, but it is an easy form of 
 * documentation.  See also the ExprState node types in execnodes.h. 
 */ 
</span><a name="LN131"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Expr</span> 
<span class='Delimiter'>{ 
</span><a name="LN133"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN134"></a>} <span class='Declare_Typedef'>Expr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Var - expression node representing a variable (ie, a table column) 
 * 
 * Note: during parsing/planning, varnoold/varoattno are always just copies 
 * of varno/varattno.  At the tail end of planning, Var nodes appearing in 
 * upper-level plan nodes are reassigned to point to the outputs of their 
 * subplans; for example, in a join node varno becomes INNER_VAR or OUTER_VAR 
 * and varattno becomes the index of the proper element of that subplan's 
 * target list.  Similarly, INDEX_VAR is used to identify Vars that reference 
 * an index column rather than a heap column.  (In ForeignScan and CustomScan 
 * plan nodes, INDEX_VAR is abused to signify references to columns of a 
 * custom scan tuple type.)  In all these cases, varnoold/varoattno hold the 
 * original values.  The code doesn't really need varnoold/varoattno, but they 
 * are very useful for debugging and interpreting completed plans, so we keep 
 * them around. 
 */ 
</span><a name="LN152"></a><span class='Keyword'>#define</span>    <span class='Declare_Constant'>INNER_VAR</span>        <span class='Number'>65000</span>       <span class='Comment_Single_Line'>/* reference to inner subplan */ 
</span><a name="LN153"></a><span class='Keyword'>#define</span>    <span class='Declare_Constant'>OUTER_VAR</span>        <span class='Number'>65001</span>       <span class='Comment_Single_Line'>/* reference to outer subplan */ 
</span><a name="LN154"></a><span class='Keyword'>#define</span>    <span class='Declare_Constant'>INDEX_VAR</span>        <span class='Number'>65002</span>       <span class='Comment_Single_Line'>/* reference to index column */ 
</span> 
<a name="LN156"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_SPECIAL_VARNO</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>varno</span><span class='Parentheses'>)</span>     <span class='Parentheses'>((</span><a href="primnodes.h.html#LN156"><span class='Ref_to_Parameter'>varno</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><a href="primnodes.h.html#LN152"><span class='Ref_to_Const'>INNER_VAR</span></a><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* Symbols for the indexes of the special RTE entries in rules */ 
</span><a name="LN159"></a><span class='Keyword'>#define</span>    <span class='Declare_Constant'>PRS2_OLD_VARNO</span>           <span class='Number'>1</span> 
<a name="LN160"></a><span class='Keyword'>#define</span>    <span class='Declare_Constant'>PRS2_NEW_VARNO</span>           <span class='Number'>2</span> 
 
<a name="LN162"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Var</span> 
<span class='Delimiter'>{ 
</span><a name="LN164"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN165"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>varno</span><span class='Delimiter'>;</span>          <span class='Comment_Multi_Line'>/* index of this var's relation in the range 
                                 * table, or INNER_VAR/OUTER_VAR/INDEX_VAR */ 
</span><a name="LN167"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>varattno</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* attribute number of this var, or zero for 
                                 * all */ 
</span><a name="LN169"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>vartype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* pg_type OID for the type of this var */ 
</span><a name="LN170"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>vartypmod</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* pg_attribute typmod value */ 
</span><a name="LN171"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>varcollid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN172"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>varlevelsup</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* for subquery variables referencing outer 
                                 * relations; 0 in a normal var, &GT;0 means N 
                                 * levels up */ 
</span><a name="LN175"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>varnoold</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* original value of varno, for debugging */ 
</span><a name="LN176"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>varoattno</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* original value of varattno */ 
</span><a name="LN177"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN178"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Var</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Const 
 * 
 * Note: for varlena data types, we make a rule that a Const node's value 
 * must be in non-extended form (4-byte header, no compression or external 
 * references).  This ensures that the Const node is self-contained and makes 
 * it more likely that equal() will see logically identical values as equal. 
 */ 
</span><a name="LN188"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Const</span> 
<span class='Delimiter'>{ 
</span><a name="LN190"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN191"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>consttype</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* pg_type OID of the constant's datatype */ 
</span><a name="LN192"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>consttypmod</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* typmod value, if any */ 
</span><a name="LN193"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>constcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN194"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>constlen</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* typlen of the constant's datatype */ 
</span><a name="LN195"></a>    <a href="../postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>constvalue</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* the constant's value */ 
</span><a name="LN196"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>constisnull</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* whether the constant is null (if true, 
                                 * constvalue is undefined) */ 
</span><a name="LN198"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>constbyval</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* whether this datatype is passed by value. 
                                 * If true, then all the information is stored 
                                 * in the Datum. If false, then the Datum 
                                 * contains a pointer to the information. */ 
</span><a name="LN202"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN203"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Const</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Param 
 * 
 *      paramkind specifies the kind of parameter. The possible values 
 *      for this field are: 
 * 
 *      PARAM_EXTERN:  The parameter value is supplied from outside the plan. 
 *              Such parameters are numbered from 1 to n. 
 * 
 *      PARAM_EXEC:  The parameter is an internal executor parameter, used 
 *              for passing values into and out of sub-queries or from 
 *              nestloop joins to their inner scans. 
 *              For historical reasons, such parameters are numbered from 0. 
 *              These numbers are independent of PARAM_EXTERN numbers. 
 * 
 *      PARAM_SUBLINK:  The parameter represents an output column of a SubLink 
 *              node's sub-select.  The column number is contained in the 
 *              `paramid' field.  (This type of Param is converted to 
 *              PARAM_EXEC during planning.) 
 * 
 *      PARAM_MULTIEXPR:  Like PARAM_SUBLINK, the parameter represents an 
 *              output column of a SubLink node's sub-select, but here, the 
 *              SubLink is always a MULTIEXPR SubLink.  The high-order 16 bits 
 *              of the `paramid' field contain the SubLink's subLinkId, and 
 *              the low-order 16 bits contain the column number.  (This type 
 *              of Param is also converted to PARAM_EXEC during planning.) 
 */ 
</span><a name="LN232"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>ParamKind</span> 
<span class='Delimiter'>{ 
</span><a name="LN234"></a>    <span class='Declare_Enum_Const'>PARAM_EXTERN</span><span class='Delimiter'>, 
</span><a name="LN235"></a>    <span class='Declare_Enum_Const'>PARAM_EXEC</span><span class='Delimiter'>, 
</span><a name="LN236"></a>    <span class='Declare_Enum_Const'>PARAM_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN237"></a>    <span class='Declare_Enum_Const'>PARAM_MULTIEXPR</span> 
<a name="LN238"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ParamKind</span><span class='Delimiter'>; 
</span> 
<a name="LN240"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Param</span> 
<span class='Delimiter'>{ 
</span><a name="LN242"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN243"></a>    <a href="primnodes.h.html#LN232"><span class='Ref_to_Enum'>ParamKind</span></a>   <span class='Declare_Member'>paramkind</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* kind of parameter. See above */ 
</span><a name="LN244"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>paramid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* numeric ID for parameter */ 
</span><a name="LN245"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>paramtype</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* pg_type OID of parameter's datatype */ 
</span><a name="LN246"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>paramtypmod</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* typmod value, if known */ 
</span><a name="LN247"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>paramcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN248"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN249"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Param</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Aggref 
 * 
 * The aggregate's args list is a targetlist, ie, a list of TargetEntry nodes. 
 * 
 * For a normal (non-ordered-set) aggregate, the non-resjunk TargetEntries 
 * represent the aggregate's regular arguments (if any) and resjunk TLEs can 
 * be added at the end to represent ORDER BY expressions that are not also 
 * arguments.  As in a top-level Query, the TLEs can be marked with 
 * ressortgroupref indexes to let them be referenced by SortGroupClause 
 * entries in the aggorder and/or aggdistinct lists.  This represents ORDER BY 
 * and DISTINCT operations to be applied to the aggregate input rows before 
 * they are passed to the transition function.  The grammar only allows a 
 * simple "DISTINCT" specifier for the arguments, but we use the full 
 * query-level representation to allow more code sharing. 
 * 
 * For an ordered-set aggregate, the args list represents the WITHIN GROUP 
 * (aggregated) arguments, all of which will be listed in the aggorder list. 
 * DISTINCT is not supported in this case, so aggdistinct will be NIL. 
 * The direct arguments appear in aggdirectargs (as a list of plain 
 * expressions, not TargetEntry nodes). 
 * 
 * aggtranstype is the data type of the state transition values for this 
 * aggregate (resolved to an actual type, if agg's transtype is polymorphic). 
 * This is determined during planning and is InvalidOid before that. 
 * 
 * aggargtypes is an OID list of the data types of the direct and regular 
 * arguments.  Normally it's redundant with the aggdirectargs and args lists, 
 * but in a combining aggregate, it's not because the args list has been 
 * replaced with a single argument representing the partial-aggregate 
 * transition values. 
 * 
 * aggsplit indicates the expected partial-aggregation mode for the Aggref's 
 * parent plan node.  It's always set to AGGSPLIT_SIMPLE in the parser, but 
 * the planner might change it to something else.  We use this mainly as 
 * a crosscheck that the Aggrefs match the plan; but note that when aggsplit 
 * indicates a non-final mode, aggtype reflects the transition data type 
 * not the SQL-level output type of the aggregate. 
 */ 
</span><a name="LN290"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Aggref</span> 
<span class='Delimiter'>{ 
</span><a name="LN292"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN293"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggfnoid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* pg_proc Oid of the aggregate */ 
</span><a name="LN294"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggtype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* type Oid of result of the aggregate */ 
</span><a name="LN295"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggcollid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OID of collation of result */ 
</span><a name="LN296"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>inputcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation that function should use */ 
</span><a name="LN297"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggtranstype</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* type Oid of aggregate's transition value */ 
</span><a name="LN298"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggargtypes</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* type Oids of direct and aggregated args */ 
</span><a name="LN299"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggdirectargs</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* direct arguments, if an ordered-set agg */ 
</span><a name="LN300"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* aggregated arguments and sort expressions */ 
</span><a name="LN301"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggorder</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ORDER BY (list of SortGroupClause) */ 
</span><a name="LN302"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggdistinct</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* DISTINCT (list of SortGroupClause) */ 
</span><a name="LN303"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggfilter</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* FILTER expression, if any */ 
</span><a name="LN304"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>aggstar</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* TRUE if argument list was really '*' */ 
</span><a name="LN305"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>aggvariadic</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* true if variadic arguments have been 
                                 * combined into an array last argument */ 
</span><a name="LN307"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>aggkind</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* aggregate kind (see pg_aggregate.h) */ 
</span><a name="LN308"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>agglevelsup</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* &GT; 0 if agg belongs to outer query */ 
</span><a name="LN309"></a>    <a href="nodes.h.html#LN755"><span class='Ref_to_Enum'>AggSplit</span></a>    <span class='Declare_Member'>aggsplit</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* expected agg-splitting mode of parent Agg */ 
</span><a name="LN310"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN311"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end Aggref &raquo; </span> <span class='Declare_Typedef'>Aggref</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GroupingFunc 
 * 
 * A GroupingFunc is a GROUPING(...) expression, which behaves in many ways 
 * like an aggregate function (e.g. it "belongs" to a specific query level, 
 * which might not be the one immediately containing it), but also differs in 
 * an important respect: it never evaluates its arguments, they merely 
 * designate expressions from the GROUP BY clause of the query level to which 
 * it belongs. 
 * 
 * The spec defines the evaluation of GROUPING() purely by syntactic 
 * replacement, but we make it a real expression for optimization purposes so 
 * that one Agg node can handle multiple grouping sets at once.  Evaluating the 
 * result only needs the column positions to check against the grouping set 
 * being projected.  However, for EXPLAIN to produce meaningful output, we have 
 * to keep the original expressions around, since expression deparse does not 
 * give us any feasible way to get at the GROUP BY clause. 
 * 
 * Also, we treat two GroupingFunc nodes as equal if they have equal arguments 
 * lists and agglevelsup, without comparing the refs and cols annotations. 
 * 
 * In raw parse output we have only the args list; parse analysis fills in the 
 * refs list, and the planner fills in the cols list. 
 */ 
</span><a name="LN337"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GroupingFunc</span> 
<span class='Delimiter'>{ 
</span><a name="LN339"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN340"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Multi_Line'>/* arguments, not evaluated but kept for 
                                 * benefit of EXPLAIN etc. */ 
</span><a name="LN342"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>refs</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ressortgrouprefs of arguments */ 
</span><a name="LN343"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cols</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* actual column positions set by planner */ 
</span><a name="LN344"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>agglevelsup</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* same as Aggref.agglevelsup */ 
</span><a name="LN345"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location */ 
</span><a name="LN346"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GroupingFunc</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * WindowFunc 
 */ 
</span><a name="LN351"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WindowFunc</span> 
<span class='Delimiter'>{ 
</span><a name="LN353"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN354"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>winfnoid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* pg_proc Oid of the function */ 
</span><a name="LN355"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>wintype</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* type Oid of result of the window function */ 
</span><a name="LN356"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>wincollid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OID of collation of result */ 
</span><a name="LN357"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>inputcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation that function should use */ 
</span><a name="LN358"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* arguments to the window function */ 
</span><a name="LN359"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggfilter</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* FILTER expression, if any */ 
</span><a name="LN360"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>winref</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* index of associated WindowClause */ 
</span><a name="LN361"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>winstar</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* TRUE if argument list was really '*' */ 
</span><a name="LN362"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>winagg</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* is function a simple aggregate? */ 
</span><a name="LN363"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN364"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WindowFunc</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *  ArrayRef: describes an array subscripting operation 
 * 
 * An ArrayRef can describe fetching a single element from an array, 
 * fetching a subarray (array slice), storing a single element into 
 * an array, or storing a slice.  The "store" cases work with an 
 * initial array value and a source value that is inserted into the 
 * appropriate part of the array; the result of the operation is an 
 * entire new modified array value. 
 * 
 * If reflowerindexpr = NIL, then we are fetching or storing a single array 
 * element at the subscripts given by refupperindexpr.  Otherwise we are 
 * fetching or storing an array slice, that is a rectangular subarray 
 * with lower and upper bounds given by the index expressions. 
 * reflowerindexpr must be the same length as refupperindexpr when it 
 * is not NIL. 
 * 
 * In the slice case, individual expressions in the subscript lists can be 
 * NULL, meaning "substitute the array's current lower or upper bound". 
 * 
 * Note: the result datatype is the element type when fetching a single 
 * element; but it is the array type when doing subarray fetch or either 
 * type of store. 
 * 
 * Note: for the cases where an array is returned, if refexpr yields a R/W 
 * expanded array, then the implementation is allowed to modify that object 
 * in-place and return the same object.) 
 * ---------------- 
 */ 
</span><a name="LN395"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ArrayRef</span> 
<span class='Delimiter'>{ 
</span><a name="LN397"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN398"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>refarraytype</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* type of the array proper */ 
</span><a name="LN399"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>refelemtype</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* type of the array elements */ 
</span><a name="LN400"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>reftypmod</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* typmod of the array (and elements too) */ 
</span><a name="LN401"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>refcollid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN402"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>refupperindexpr</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* expressions that evaluate to upper array 
                                 * indexes */ 
</span><a name="LN404"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>reflowerindexpr</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* expressions that evaluate to lower array 
                                 * indexes, or NIL for single array element */ 
</span><a name="LN406"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>refexpr</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* the expression that evaluates to an array 
                                 * value */ 
</span><a name="LN408"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>refassgnexpr</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* expression for the source value, or NULL if 
                                 * fetch */ 
</span><a name="LN410"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ArrayRef</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CoercionContext - distinguishes the allowed set of type casts 
 * 
 * NB: ordering of the alternatives is significant; later (larger) values 
 * allow more casts than earlier ones. 
 */ 
</span><a name="LN418"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>CoercionContext</span> 
<span class='Delimiter'>{ 
</span><a name="LN420"></a>    <span class='Declare_Enum_Const'>COERCION_IMPLICIT</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* coercion in context of expression */ 
</span><a name="LN421"></a>    <span class='Declare_Enum_Const'>COERCION_ASSIGNMENT</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* coercion in context of assignment */ 
</span><a name="LN422"></a>    <span class='Declare_Enum_Const'>COERCION_EXPLICIT</span>           <span class='Comment_Single_Line'>/* explicit cast operation */ 
</span><a name="LN423"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CoercionContext</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CoercionForm - how to display a node that could have come from a cast 
 * 
 * NB: equal() ignores CoercionForm fields, therefore this *must* not carry 
 * any semantically significant information.  We need that behavior so that 
 * the planner will consider equivalent implicit and explicit casts to be 
 * equivalent.  In cases where those actually behave differently, the coercion 
 * function's arguments will be different. 
 */ 
</span><a name="LN434"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>CoercionForm</span> 
<span class='Delimiter'>{ 
</span><a name="LN436"></a>    <span class='Declare_Enum_Const'>COERCE_EXPLICIT_CALL</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* display as a function call */ 
</span><a name="LN437"></a>    <span class='Declare_Enum_Const'>COERCE_EXPLICIT_CAST</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* display as an explicit cast */ 
</span><a name="LN438"></a>    <span class='Declare_Enum_Const'>COERCE_IMPLICIT_CAST</span>        <span class='Comment_Single_Line'>/* implicit cast, so hide it */ 
</span><a name="LN439"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CoercionForm</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * FuncExpr - expression node for a function call 
 */ 
</span><a name="LN444"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FuncExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN446"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN447"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>funcid</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* PG_PROC OID of the function */ 
</span><a name="LN448"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>funcresulttype</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* PG_TYPE OID of result value */ 
</span><a name="LN449"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>funcretset</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* true if function returns set */ 
</span><a name="LN450"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>funcvariadic</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* true if variadic arguments have been 
                                 * combined into an array last argument */ 
</span><a name="LN452"></a>    <a href="primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Member'>funcformat</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* how to display this function call */ 
</span><a name="LN453"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>funccollid</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OID of collation of result */ 
</span><a name="LN454"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>inputcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation that function should use */ 
</span><a name="LN455"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* arguments to the function */ 
</span><a name="LN456"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN457"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FuncExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * NamedArgExpr - a named argument of a function 
 * 
 * This node type can only appear in the args list of a FuncCall or FuncExpr 
 * node.  We support pure positional call notation (no named arguments), 
 * named notation (all arguments are named), and mixed notation (unnamed 
 * arguments followed by named ones). 
 * 
 * Parse analysis sets argnumber to the positional index of the argument, 
 * but doesn't rearrange the argument list. 
 * 
 * The planner will convert argument lists to pure positional notation 
 * during expression preprocessing, so execution never sees a NamedArgExpr. 
 */ 
</span><a name="LN473"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NamedArgExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN475"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN476"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* the argument expression */ 
</span><a name="LN477"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the name */ 
</span><a name="LN478"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>argnumber</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* argument's number in positional notation */ 
</span><a name="LN479"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* argument name location, or -1 if unknown */ 
</span><a name="LN480"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NamedArgExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * OpExpr - expression node for an operator invocation 
 * 
 * Semantically, this is essentially the same as a function call. 
 * 
 * Note that opfuncid is not necessarily filled in immediately on creation 
 * of the node.  The planner makes sure it is valid before passing the node 
 * tree to the executor, but during parsing/planning opfuncid can be 0. 
 */ 
</span><a name="LN491"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>OpExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN493"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN494"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>opno</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* PG_OPERATOR OID of the operator */ 
</span><a name="LN495"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>opfuncid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* PG_PROC OID of underlying function */ 
</span><a name="LN496"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>opresulttype</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* PG_TYPE OID of result value */ 
</span><a name="LN497"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>opretset</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* true if operator returns set */ 
</span><a name="LN498"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>opcollid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OID of collation of result */ 
</span><a name="LN499"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>inputcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation that operator should use */ 
</span><a name="LN500"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* arguments to the operator (1 or 2) */ 
</span><a name="LN501"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN502"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OpExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * DistinctExpr - expression node for "x IS DISTINCT FROM y" 
 * 
 * Except for the nodetag, this is represented identically to an OpExpr 
 * referencing the "=" operator for x and y. 
 * We use "=", not the more obvious "&LT;&GT;", because more datatypes have "=" 
 * than "&LT;&GT;".  This means the executor must invert the operator result. 
 * Note that the operator function won't be called at all if either input 
 * is NULL, since then the result can be determined directly. 
 */ 
</span><a name="LN514"></a><span class='Control'>typedef</span> <a href="primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Declare_Typedef'>DistinctExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * NullIfExpr - a NULLIF expression 
 * 
 * Like DistinctExpr, this is represented the same as an OpExpr referencing 
 * the "=" operator for x and y. 
 */ 
</span><a name="LN522"></a><span class='Control'>typedef</span> <a href="primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Declare_Typedef'>NullIfExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ScalarArrayOpExpr - expression node for "scalar op ANY/ALL (array)" 
 * 
 * The operator must yield boolean.  It is applied to the left operand 
 * and each element of the righthand array, and the results are combined 
 * with OR or AND (for ANY or ALL respectively).  The node representation 
 * is almost the same as for the underlying operator, but we need a useOr 
 * flag to remember whether it's ANY or ALL, and we don't have to store 
 * the result type (or the collation) because it must be boolean. 
 */ 
</span><a name="LN534"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ScalarArrayOpExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN536"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN537"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>opno</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* PG_OPERATOR OID of the operator */ 
</span><a name="LN538"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>opfuncid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* PG_PROC OID of underlying function */ 
</span><a name="LN539"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>useOr</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* true for ANY, false for ALL */ 
</span><a name="LN540"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>inputcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation that operator should use */ 
</span><a name="LN541"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the scalar and array operands */ 
</span><a name="LN542"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN543"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ScalarArrayOpExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BoolExpr - expression node for the basic Boolean operators AND, OR, NOT 
 * 
 * Notice the arguments are given as a List.  For NOT, of course the list 
 * must always have exactly one element.  For AND and OR, there can be two 
 * or more arguments. 
 */ 
</span><a name="LN552"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>BoolExprType</span> 
<span class='Delimiter'>{ 
</span><a name="LN554"></a>    <span class='Declare_Enum_Const'>AND_EXPR</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>OR_EXPR</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>NOT_EXPR</span> 
<a name="LN555"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BoolExprType</span><span class='Delimiter'>; 
</span> 
<a name="LN557"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BoolExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN559"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN560"></a>    <a href="primnodes.h.html#LN552"><span class='Ref_to_Enum'>BoolExprType</span></a> <span class='Declare_Member'>boolop</span><span class='Delimiter'>; 
</span><a name="LN561"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* arguments to this expression */ 
</span><a name="LN562"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN563"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BoolExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SubLink 
 * 
 * A SubLink represents a subselect appearing in an expression, and in some 
 * cases also the combining operator(s) just above it.  The subLinkType 
 * indicates the form of the expression represented: 
 *  EXISTS_SUBLINK      EXISTS(SELECT ...) 
 *  ALL_SUBLINK         (lefthand) op ALL (SELECT ...) 
 *  ANY_SUBLINK         (lefthand) op ANY (SELECT ...) 
 *  ROWCOMPARE_SUBLINK  (lefthand) op (SELECT ...) 
 *  EXPR_SUBLINK        (SELECT with single targetlist item ...) 
 *  MULTIEXPR_SUBLINK   (SELECT with multiple targetlist items ...) 
 *  ARRAY_SUBLINK       ARRAY(SELECT with single targetlist item ...) 
 *  CTE_SUBLINK         WITH query (never actually part of an expression) 
 * For ALL, ANY, and ROWCOMPARE, the lefthand is a list of expressions of the 
 * same length as the subselect's targetlist.  ROWCOMPARE will *always* have 
 * a list with more than one entry; if the subselect has just one target 
 * then the parser will create an EXPR_SUBLINK instead (and any operator 
 * above the subselect will be represented separately). 
 * ROWCOMPARE, EXPR, and MULTIEXPR require the subselect to deliver at most 
 * one row (if it returns no rows, the result is NULL). 
 * ALL, ANY, and ROWCOMPARE require the combining operators to deliver boolean 
 * results.  ALL and ANY combine the per-row results using AND and OR 
 * semantics respectively. 
 * ARRAY requires just one target column, and creates an array of the target 
 * column's type using any number of rows resulting from the subselect. 
 * 
 * SubLink is classed as an Expr node, but it is not actually executable; 
 * it must be replaced in the expression tree by a SubPlan node during 
 * planning. 
 * 
 * NOTE: in the raw output of gram.y, testexpr contains just the raw form 
 * of the lefthand expression (if any), and operName is the String name of 
 * the combining operator.  Also, subselect is a raw parsetree.  During parse 
 * analysis, the parser transforms testexpr into a complete boolean expression 
 * that compares the lefthand value(s) to PARAM_SUBLINK nodes representing the 
 * output columns of the subselect.  And subselect is transformed to a Query. 
 * This is the representation seen in saved rules and in the rewriter. 
 * 
 * In EXISTS, EXPR, MULTIEXPR, and ARRAY SubLinks, testexpr and operName 
 * are unused and are always null. 
 * 
 * subLinkId is currently used only for MULTIEXPR SubLinks, and is zero in 
 * other SubLinks.  This number identifies different multiple-assignment 
 * subqueries within an UPDATE statement's SET list.  It is unique only 
 * within a particular targetlist.  The output column(s) of the MULTIEXPR 
 * are referenced by PARAM_MULTIEXPR Params appearing elsewhere in the tlist. 
 * 
 * The CTE_SUBLINK case never occurs in actual SubLink nodes, but it is used 
 * in SubPlans generated for WITH subqueries. 
 */ 
</span><a name="LN616"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>SubLinkType</span> 
<span class='Delimiter'>{ 
</span><a name="LN618"></a>    <span class='Declare_Enum_Const'>EXISTS_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN619"></a>    <span class='Declare_Enum_Const'>ALL_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN620"></a>    <span class='Declare_Enum_Const'>ANY_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN621"></a>    <span class='Declare_Enum_Const'>ROWCOMPARE_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN622"></a>    <span class='Declare_Enum_Const'>EXPR_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN623"></a>    <span class='Declare_Enum_Const'>MULTIEXPR_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN624"></a>    <span class='Declare_Enum_Const'>ARRAY_SUBLINK</span><span class='Delimiter'>, 
</span><a name="LN625"></a>    <span class='Declare_Enum_Const'>CTE_SUBLINK</span>                 <span class='Comment_Single_Line'>/* for SubPlans only */ 
</span><a name="LN626"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SubLinkType</span><span class='Delimiter'>; 
</span> 
 
<a name="LN629"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SubLink</span> 
<span class='Delimiter'>{ 
</span><a name="LN631"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN632"></a>    <a href="primnodes.h.html#LN616"><span class='Ref_to_Enum'>SubLinkType</span></a> <span class='Declare_Member'>subLinkType</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* see above */ 
</span><a name="LN633"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>subLinkId</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* ID (1..n); 0 if not MULTIEXPR */ 
</span><a name="LN634"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>testexpr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* outer-query test for ALL/ANY/ROWCOMPARE */ 
</span><a name="LN635"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>operName</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* originally specified operator name */ 
</span><a name="LN636"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subselect</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* subselect as Query* or raw parsetree */ 
</span><a name="LN637"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN638"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SubLink</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SubPlan - executable expression node for a subplan (sub-SELECT) 
 * 
 * The planner replaces SubLink nodes in expression trees with SubPlan 
 * nodes after it has finished planning the subquery.  SubPlan references 
 * a sub-plantree stored in the subplans list of the toplevel PlannedStmt. 
 * (We avoid a direct link to make it easier to copy expression trees 
 * without causing multiple processing of the subplan.) 
 * 
 * In an ordinary subplan, testexpr points to an executable expression 
 * (OpExpr, an AND/OR tree of OpExprs, or RowCompareExpr) for the combining 
 * operator(s); the left-hand arguments are the original lefthand expressions, 
 * and the right-hand arguments are PARAM_EXEC Param nodes representing the 
 * outputs of the sub-select.  (NOTE: runtime coercion functions may be 
 * inserted as well.)  This is just the same expression tree as testexpr in 
 * the original SubLink node, but the PARAM_SUBLINK nodes are replaced by 
 * suitably numbered PARAM_EXEC nodes. 
 * 
 * If the sub-select becomes an initplan rather than a subplan, the executable 
 * expression is part of the outer plan's expression tree (and the SubPlan 
 * node itself is not, but rather is found in the outer plan's initPlan 
 * list).  In this case testexpr is NULL to avoid duplication. 
 * 
 * The planner also derives lists of the values that need to be passed into 
 * and out of the subplan.  Input values are represented as a list "args" of 
 * expressions to be evaluated in the outer-query context (currently these 
 * args are always just Vars, but in principle they could be any expression). 
 * The values are assigned to the global PARAM_EXEC params indexed by parParam 
 * (the parParam and args lists must have the same ordering).  setParam is a 
 * list of the PARAM_EXEC params that are computed by the sub-select, if it 
 * is an initplan; they are listed in order by sub-select output column 
 * position.  (parParam and setParam are integer Lists, not Bitmapsets, 
 * because their ordering is significant.) 
 * 
 * Also, the planner computes startup and per-call costs for use of the 
 * SubPlan.  Note that these include the cost of the subquery proper, 
 * evaluation of the testexpr if any, and any hashtable management overhead. 
 */ 
</span><a name="LN678"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SubPlan</span> 
<span class='Delimiter'>{ 
</span><a name="LN680"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Fields copied from original SubLink: */ 
</span><a name="LN682"></a>    <a href="primnodes.h.html#LN616"><span class='Ref_to_Enum'>SubLinkType</span></a> <span class='Declare_Member'>subLinkType</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* see above */ 
</span>    <span class='Comment_Multi_Line'>/* The combining operators, transformed to an executable expression: */ 
</span><a name="LN684"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>testexpr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OpExpr or RowCompareExpr expression tree */ 
</span><a name="LN685"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>paramIds</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* IDs of Params embedded in the above */ 
</span>    <span class='Comment_Multi_Line'>/* Identification of the Plan tree to use: */ 
</span><a name="LN687"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>plan_id</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Index (from 1) in PlannedStmt.subplans */ 
</span>    <span class='Comment_Multi_Line'>/* Identification of the SubPlan for EXPLAIN and debugging purposes: */ 
</span><a name="LN689"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>plan_name</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* A name assigned during planning */ 
</span>    <span class='Comment_Multi_Line'>/* Extra data useful for determining subplan's output type: */ 
</span><a name="LN691"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>firstColType</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* Type of first column of subplan result */ 
</span><a name="LN692"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>firstColTypmod</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* Typmod of first column of subplan result */ 
</span><a name="LN693"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>firstColCollation</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* Collation of first column of 
                                         * subplan result */ 
</span>    <span class='Comment_Multi_Line'>/* Information about execution strategy: */ 
</span><a name="LN696"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>useHashTable</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* TRUE to store subselect output in a hash 
                                 * table (implies we are doing "IN") */ 
</span><a name="LN698"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>unknownEqFalse</span><span class='Delimiter'>; </span><span class='Comment_Multi_Line'>/* TRUE if it's okay to return FALSE when the 
                                 * spec result is UNKNOWN; this allows much 
                                 * simpler handling of null values */ 
</span><a name="LN701"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallel_safe</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* is the subplan parallel-safe? */ 
</span>    <span class='Comment_Multi_Line'>/* Note: parallel_safe does not consider contents of testexpr or args */ 
</span>    <span class='Comment_Multi_Line'>/* Information for passing params into and out of the subselect: */ 
</span>    <span class='Comment_Multi_Line'>/* setParam and parParam are lists of integers (param IDs) */ 
</span><a name="LN705"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>setParam</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* initplan subqueries have to set these 
                                 * Params for parent plan */ 
</span><a name="LN707"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>parParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* indices of input Params from parent plan */ 
</span><a name="LN708"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* exprs to pass as parParam values */ 
</span>    <span class='Comment_Multi_Line'>/* Estimated execution costs: */ 
</span><a name="LN710"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>startup_cost</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* one-time setup cost */ 
</span><a name="LN711"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>per_call_cost</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* cost for each subplan evaluation */ 
</span><a name="LN712"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end SubPlan &raquo; </span> <span class='Declare_Typedef'>SubPlan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AlternativeSubPlan - expression node for a choice among SubPlans 
 * 
 * The subplans are given as a List so that the node definition need not 
 * change if there's ever more than two alternatives.  For the moment, 
 * though, there are always exactly two; and the first one is the fast-start 
 * plan. 
 */ 
</span><a name="LN722"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AlternativeSubPlan</span> 
<span class='Delimiter'>{ 
</span><a name="LN724"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN725"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subplans</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* SubPlan(s) with equivalent results */ 
</span><a name="LN726"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AlternativeSubPlan</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * FieldSelect 
 * 
 * FieldSelect represents the operation of extracting one field from a tuple 
 * value.  At runtime, the input expression is expected to yield a rowtype 
 * Datum.  The specified field number is extracted and returned as a Datum. 
 * ---------------- 
 */ 
</span> 
<a name="LN737"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FieldSelect</span> 
<span class='Delimiter'>{ 
</span><a name="LN739"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN740"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN741"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>fieldnum</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* attribute number of field to extract */ 
</span><a name="LN742"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resulttype</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* type of the field (result type of this 
                                 * node) */ 
</span><a name="LN744"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>resulttypmod</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* output typmod (usually -1) */ 
</span><a name="LN745"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resultcollid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of collation of the field */ 
</span><a name="LN746"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FieldSelect</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * FieldStore 
 * 
 * FieldStore represents the operation of modifying one field in a tuple 
 * value, yielding a new tuple value (the input is not touched!).  Like 
 * the assign case of ArrayRef, this is used to implement UPDATE of a 
 * portion of a column. 
 * 
 * A single FieldStore can actually represent updates of several different 
 * fields.  The parser only generates FieldStores with single-element lists, 
 * but the planner will collapse multiple updates of the same base column 
 * into one FieldStore. 
 * ---------------- 
 */ 
</span> 
<a name="LN763"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FieldStore</span> 
<span class='Delimiter'>{ 
</span><a name="LN765"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN766"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input tuple value */ 
</span><a name="LN767"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>newvals</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* new value(s) for field(s) */ 
</span><a name="LN768"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fieldnums</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* integer list of field attnums */ 
</span><a name="LN769"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resulttype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* type of result (same as type of arg) */ 
</span>    <span class='Comment_Multi_Line'>/* Like RowExpr, we deliberately omit a typmod and collation here */ 
</span><a name="LN771"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FieldStore</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * RelabelType 
 * 
 * RelabelType represents a "dummy" type coercion between two binary- 
 * compatible datatypes, such as reinterpreting the result of an OID 
 * expression as an int4.  It is a no-op at runtime; we only need it 
 * to provide a place to store the correct type to be attributed to 
 * the expression result during type resolution.  (We can't get away 
 * with just overwriting the type field of the input expression node, 
 * so we need a separate node to show the coercion's result type.) 
 * ---------------- 
 */ 
</span> 
<a name="LN786"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RelabelType</span> 
<span class='Delimiter'>{ 
</span><a name="LN788"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN789"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN790"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resulttype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* output type of coercion expression */ 
</span><a name="LN791"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>resulttypmod</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* output typmod (usually -1) */ 
</span><a name="LN792"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resultcollid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN793"></a>    <a href="primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Member'>relabelformat</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* how to display this node */ 
</span><a name="LN794"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN795"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RelabelType</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * CoerceViaIO 
 * 
 * CoerceViaIO represents a type coercion between two types whose textual 
 * representations are compatible, implemented by invoking the source type's 
 * typoutput function then the destination type's typinput function. 
 * ---------------- 
 */ 
</span> 
<a name="LN806"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CoerceViaIO</span> 
<span class='Delimiter'>{ 
</span><a name="LN808"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN809"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN810"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resulttype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* output type of coercion */ 
</span>    <span class='Comment_Multi_Line'>/* output typmod is not stored, but is presumed -1 */ 
</span><a name="LN812"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resultcollid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN813"></a>    <a href="primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Member'>coerceformat</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* how to display this node */ 
</span><a name="LN814"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN815"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CoerceViaIO</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * ArrayCoerceExpr 
 * 
 * ArrayCoerceExpr represents a type coercion from one array type to another, 
 * which is implemented by applying the indicated element-type coercion 
 * function to each element of the source array.  If elemfuncid is InvalidOid 
 * then the element types are binary-compatible, but the coercion still 
 * requires some effort (we have to fix the element type ID stored in the 
 * array header). 
 * ---------------- 
 */ 
</span> 
<a name="LN829"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ArrayCoerceExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN831"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN832"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression (yields an array) */ 
</span><a name="LN833"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>elemfuncid</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OID of element coercion function, or 0 */ 
</span><a name="LN834"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resulttype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* output type of coercion (an array type) */ 
</span><a name="LN835"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>resulttypmod</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* output typmod (also element typmod) */ 
</span><a name="LN836"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resultcollid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN837"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isExplicit</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* conversion semantics flag to pass to func */ 
</span><a name="LN838"></a>    <a href="primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Member'>coerceformat</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* how to display this node */ 
</span><a name="LN839"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN840"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ArrayCoerceExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * ConvertRowtypeExpr 
 * 
 * ConvertRowtypeExpr represents a type coercion from one composite type 
 * to another, where the source type is guaranteed to contain all the columns 
 * needed for the destination type plus possibly others; the columns need not 
 * be in the same positions, but are matched up by name.  This is primarily 
 * used to convert a whole-row value of an inheritance child table into a 
 * valid whole-row value of its parent table's rowtype. 
 * ---------------- 
 */ 
</span> 
<a name="LN854"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ConvertRowtypeExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN856"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN857"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN858"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resulttype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* output type (always a composite type) */ 
</span>    <span class='Comment_Multi_Line'>/* Like RowExpr, we deliberately omit a typmod and collation here */ 
</span><a name="LN860"></a>    <a href="primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Member'>convertformat</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* how to display this node */ 
</span><a name="LN861"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN862"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ConvertRowtypeExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------- 
 * CollateExpr - COLLATE 
 * 
 * The planner replaces CollateExpr with RelabelType during expression 
 * preprocessing, so execution never sees a CollateExpr. 
 *---------- 
 */ 
</span><a name="LN871"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CollateExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN873"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN874"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN875"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collOid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* collation's OID */ 
</span><a name="LN876"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN877"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CollateExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------- 
 * CaseExpr - a CASE expression 
 * 
 * We support two distinct forms of CASE expression: 
 *      CASE WHEN boolexpr THEN expr [ WHEN boolexpr THEN expr ... ] 
 *      CASE testexpr WHEN compexpr THEN expr [ WHEN compexpr THEN expr ... ] 
 * These are distinguishable by the "arg" field being NULL in the first case 
 * and the testexpr in the second case. 
 * 
 * In the raw grammar output for the second form, the condition expressions 
 * of the WHEN clauses are just the comparison values.  Parse analysis 
 * converts these to valid boolean expressions of the form 
 *      CaseTestExpr '=' compexpr 
 * where the CaseTestExpr node is a placeholder that emits the correct 
 * value at runtime.  This structure is used so that the testexpr need be 
 * evaluated only once.  Note that after parse analysis, the condition 
 * expressions always yield boolean. 
 * 
 * Note: we can test whether a CaseExpr has been through parse analysis 
 * yet by checking whether casetype is InvalidOid or not. 
 *---------- 
 */ 
</span><a name="LN901"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CaseExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN903"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN904"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>casetype</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* type of expression result */ 
</span><a name="LN905"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>casecollid</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN906"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* implicit equality comparison argument */ 
</span><a name="LN907"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the arguments (list of WHEN clauses) */ 
</span><a name="LN908"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>defresult</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* the default result (ELSE clause) */ 
</span><a name="LN909"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN910"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CaseExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CaseWhen - one arm of a CASE expression 
 */ 
</span><a name="LN915"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CaseWhen</span> 
<span class='Delimiter'>{ 
</span><a name="LN917"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN918"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* condition expression */ 
</span><a name="LN919"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>result</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* substitution result */ 
</span><a name="LN920"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN921"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CaseWhen</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Placeholder node for the test value to be processed by a CASE expression. 
 * This is effectively like a Param, but can be implemented more simply 
 * since we need only one replacement value at a time. 
 * 
 * We also use this in nested UPDATE expressions. 
 * See transformAssignmentIndirection(). 
 */ 
</span><a name="LN931"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CaseTestExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN933"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN934"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>typeId</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* type for substituted value */ 
</span><a name="LN935"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>typeMod</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* typemod for substituted value */ 
</span><a name="LN936"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* collation for the substituted value */ 
</span><a name="LN937"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CaseTestExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ArrayExpr - an ARRAY[] expression 
 * 
 * Note: if multidims is false, the constituent expressions all yield the 
 * scalar type identified by element_typeid.  If multidims is true, the 
 * constituent expressions all yield arrays of element_typeid (ie, the same 
 * type as array_typeid); at runtime we must check for compatible subscripts. 
 */ 
</span><a name="LN947"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ArrayExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN949"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN950"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>array_typeid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* type of expression result */ 
</span><a name="LN951"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>array_collid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN952"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>element_typeid</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* common type of array elements */ 
</span><a name="LN953"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>elements</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* the array elements or sub-arrays */ 
</span><a name="LN954"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>multidims</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* true if elements are sub-arrays */ 
</span><a name="LN955"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN956"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ArrayExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RowExpr - a ROW() expression 
 * 
 * Note: the list of fields must have a one-for-one correspondence with 
 * physical fields of the associated rowtype, although it is okay for it 
 * to be shorter than the rowtype.  That is, the N'th list element must 
 * match up with the N'th physical field.  When the N'th physical field 
 * is a dropped column (attisdropped) then the N'th list element can just 
 * be a NULL constant.  (This case can only occur for named composite types, 
 * not RECORD types, since those are built from the RowExpr itself rather 
 * than vice versa.)  It is important not to assume that length(args) is 
 * the same as the number of columns logically present in the rowtype. 
 * 
 * colnames provides field names in cases where the names can't easily be 
 * obtained otherwise.  Names *must* be provided if row_typeid is RECORDOID. 
 * If row_typeid identifies a known composite type, colnames can be NIL to 
 * indicate the type's cataloged field names apply.  Note that colnames can 
 * be non-NIL even for a composite type, and typically is when the RowExpr 
 * was created by expanding a whole-row Var.  This is so that we can retain 
 * the column alias names of the RTE that the Var referenced (which would 
 * otherwise be very difficult to extract from the parsetree).  Like the 
 * args list, colnames is one-for-one with physical fields of the rowtype. 
 */ 
</span><a name="LN981"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RowExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN983"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN984"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the fields */ 
</span><a name="LN985"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>row_typeid</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* RECORDOID or a composite type's ID */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: we deliberately do NOT store a typmod.  Although a typmod will be 
     * associated with specific RECORD types at runtime, it will differ for 
     * different backends, and so cannot safely be stored in stored 
     * parsetrees.  We must assume typmod -1 for a RowExpr node. 
     * 
     * We don't need to store a collation either.  The result type is 
     * necessarily composite, and composite types never have a collation. 
     */ 
</span><a name="LN996"></a>    <a href="primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Member'>row_format</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* how to display this node */ 
</span><a name="LN997"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>colnames</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of String, or NIL */ 
</span><a name="LN998"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN999"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RowExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RowCompareExpr - row-wise comparison, such as (a, b) &LT;= (1, 2) 
 * 
 * We support row comparison for any operator that can be determined to 
 * act like =, &LT;&GT;, &LT;, &LT;=, &GT;, or &GT;= (we determine this by looking for the 
 * operator in btree opfamilies).  Note that the same operator name might 
 * map to a different operator for each pair of row elements, since the 
 * element datatypes can vary. 
 * 
 * A RowCompareExpr node is only generated for the &LT; &LT;= &GT; &GT;= cases; 
 * the = and &LT;&GT; cases are translated to simple AND or OR combinations 
 * of the pairwise comparisons.  However, we include = and &LT;&GT; in the 
 * RowCompareType enum for the convenience of parser logic. 
 */ 
</span><a name="LN1015"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>RowCompareType</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Values of this enum are chosen to match btree strategy numbers */ 
</span><a name="LN1018"></a>    <span class='Declare_Enum_Const'>ROWCOMPARE_LT</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* BTLessStrategyNumber */ 
</span><a name="LN1019"></a>    <span class='Declare_Enum_Const'>ROWCOMPARE_LE</span> <span class='Operator'>= </span><span class='Number'>2</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* BTLessEqualStrategyNumber */ 
</span><a name="LN1020"></a>    <span class='Declare_Enum_Const'>ROWCOMPARE_EQ</span> <span class='Operator'>= </span><span class='Number'>3</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* BTEqualStrategyNumber */ 
</span><a name="LN1021"></a>    <span class='Declare_Enum_Const'>ROWCOMPARE_GE</span> <span class='Operator'>= </span><span class='Number'>4</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* BTGreaterEqualStrategyNumber */ 
</span><a name="LN1022"></a>    <span class='Declare_Enum_Const'>ROWCOMPARE_GT</span> <span class='Operator'>= </span><span class='Number'>5</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* BTGreaterStrategyNumber */ 
</span><a name="LN1023"></a>    <span class='Declare_Enum_Const'>ROWCOMPARE_NE</span> <span class='Operator'>= </span><span class='Number'>6</span>           <span class='Comment_Single_Line'>/* no such btree strategy */ 
</span><a name="LN1024"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RowCompareType</span><span class='Delimiter'>; 
</span> 
<a name="LN1026"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RowCompareExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1028"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1029"></a>    <a href="primnodes.h.html#LN1015"><span class='Ref_to_Enum'>RowCompareType</span></a> <span class='Declare_Member'>rctype</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* LT LE GE or GT, never EQ or NE */ 
</span><a name="LN1030"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opnos</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* OID list of pairwise comparison ops */ 
</span><a name="LN1031"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>opfamilies</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OID list of containing operator families */ 
</span><a name="LN1032"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>inputcollids</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID list of collations for comparisons */ 
</span><a name="LN1033"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>largs</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the left-hand input arguments */ 
</span><a name="LN1034"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rargs</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the right-hand input arguments */ 
</span><a name="LN1035"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RowCompareExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CoalesceExpr - a COALESCE expression 
 */ 
</span><a name="LN1040"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CoalesceExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1042"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1043"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>coalescetype</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* type of expression result */ 
</span><a name="LN1044"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>coalescecollid</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN1045"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the arguments */ 
</span><a name="LN1046"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1047"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CoalesceExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * MinMaxExpr - a GREATEST or LEAST function 
 */ 
</span><a name="LN1052"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>MinMaxOp</span> 
<span class='Delimiter'>{ 
</span><a name="LN1054"></a>    <span class='Declare_Enum_Const'>IS_GREATEST</span><span class='Delimiter'>, 
</span><a name="LN1055"></a>    <span class='Declare_Enum_Const'>IS_LEAST</span> 
<a name="LN1056"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MinMaxOp</span><span class='Delimiter'>; 
</span> 
<a name="LN1058"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MinMaxExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1060"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1061"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>minmaxtype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* common type of arguments and result */ 
</span><a name="LN1062"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>minmaxcollid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of collation of result */ 
</span><a name="LN1063"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>inputcollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation that function should use */ 
</span><a name="LN1064"></a>    <a href="primnodes.h.html#LN1052"><span class='Ref_to_Enum'>MinMaxOp</span></a>    <span class='Declare_Member'>op</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* function to execute */ 
</span><a name="LN1065"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the arguments */ 
</span><a name="LN1066"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1067"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MinMaxExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SQLValueFunction - parameterless functions with special grammar productions 
 * 
 * The SQL standard categorizes some of these as &LT;datetime value function&GT; 
 * and others as &LT;general value specification&GT;.  We call 'em SQLValueFunctions 
 * for lack of a better term.  We store type and typmod of the result so that 
 * some code doesn't need to know each function individually, and because 
 * we would need to store typmod anyway for some of the datetime functions. 
 * Note that currently, all variants return non-collating datatypes, so we do 
 * not need a collation field; also, all these functions are stable. 
 */ 
</span><a name="LN1080"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>SQLValueFunctionOp</span> 
<span class='Delimiter'>{ 
</span><a name="LN1082"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_DATE</span><span class='Delimiter'>, 
</span><a name="LN1083"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_TIME</span><span class='Delimiter'>, 
</span><a name="LN1084"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_TIME_N</span><span class='Delimiter'>, 
</span><a name="LN1085"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_TIMESTAMP</span><span class='Delimiter'>, 
</span><a name="LN1086"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_TIMESTAMP_N</span><span class='Delimiter'>, 
</span><a name="LN1087"></a>    <span class='Declare_Enum_Const'>SVFOP_LOCALTIME</span><span class='Delimiter'>, 
</span><a name="LN1088"></a>    <span class='Declare_Enum_Const'>SVFOP_LOCALTIME_N</span><span class='Delimiter'>, 
</span><a name="LN1089"></a>    <span class='Declare_Enum_Const'>SVFOP_LOCALTIMESTAMP</span><span class='Delimiter'>, 
</span><a name="LN1090"></a>    <span class='Declare_Enum_Const'>SVFOP_LOCALTIMESTAMP_N</span><span class='Delimiter'>, 
</span><a name="LN1091"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_ROLE</span><span class='Delimiter'>, 
</span><a name="LN1092"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_USER</span><span class='Delimiter'>, 
</span><a name="LN1093"></a>    <span class='Declare_Enum_Const'>SVFOP_USER</span><span class='Delimiter'>, 
</span><a name="LN1094"></a>    <span class='Declare_Enum_Const'>SVFOP_SESSION_USER</span><span class='Delimiter'>, 
</span><a name="LN1095"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_CATALOG</span><span class='Delimiter'>, 
</span><a name="LN1096"></a>    <span class='Declare_Enum_Const'>SVFOP_CURRENT_SCHEMA</span> 
<a name="LN1097"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SQLValueFunctionOp</span><span class='Delimiter'>; 
</span> 
<a name="LN1099"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SQLValueFunction</span> 
<span class='Delimiter'>{ 
</span><a name="LN1101"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1102"></a>    <a href="primnodes.h.html#LN1080"><span class='Ref_to_Enum'>SQLValueFunctionOp</span></a> <span class='Declare_Member'>op</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* which function this is */ 
</span><a name="LN1103"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>type</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* result type/typmod */ 
</span><a name="LN1104"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>typmod</span><span class='Delimiter'>; 
</span><a name="LN1105"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1106"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SQLValueFunction</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * XmlExpr - various SQL/XML functions requiring special grammar productions 
 * 
 * 'name' carries the "NAME foo" argument (already XML-escaped). 
 * 'named_args' and 'arg_names' represent an xml_attribute list. 
 * 'args' carries all other arguments. 
 * 
 * Note: result type/typmod/collation are not stored, but can be deduced 
 * from the XmlExprOp.  The type/typmod fields are just used for display 
 * purposes, and are NOT necessarily the true result type of the node. 
 */ 
</span><a name="LN1119"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>XmlExprOp</span> 
<span class='Delimiter'>{ 
</span><a name="LN1121"></a>    <span class='Declare_Enum_Const'>IS_XMLCONCAT</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* XMLCONCAT(args) */ 
</span><a name="LN1122"></a>    <span class='Declare_Enum_Const'>IS_XMLELEMENT</span><span class='Delimiter'>,</span>              <span class='Comment_Single_Line'>/* XMLELEMENT(name, xml_attributes, args) */ 
</span><a name="LN1123"></a>    <span class='Declare_Enum_Const'>IS_XMLFOREST</span><span class='Delimiter'>,</span>               <span class='Comment_Single_Line'>/* XMLFOREST(xml_attributes) */ 
</span><a name="LN1124"></a>    <span class='Declare_Enum_Const'>IS_XMLPARSE</span><span class='Delimiter'>,</span>                <span class='Comment_Single_Line'>/* XMLPARSE(text, is_doc, preserve_ws) */ 
</span><a name="LN1125"></a>    <span class='Declare_Enum_Const'>IS_XMLPI</span><span class='Delimiter'>,</span>                   <span class='Comment_Single_Line'>/* XMLPI(name [, args]) */ 
</span><a name="LN1126"></a>    <span class='Declare_Enum_Const'>IS_XMLROOT</span><span class='Delimiter'>,</span>                 <span class='Comment_Single_Line'>/* XMLROOT(xml, version, standalone) */ 
</span><a name="LN1127"></a>    <span class='Declare_Enum_Const'>IS_XMLSERIALIZE</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* XMLSERIALIZE(is_document, xmlval) */ 
</span><a name="LN1128"></a>    <span class='Declare_Enum_Const'>IS_DOCUMENT</span>                 <span class='Comment_Single_Line'>/* xmlval IS DOCUMENT */ 
</span><a name="LN1129"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>XmlExprOp</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN1133"></a>    <span class='Declare_Enum_Const'>XMLOPTION_DOCUMENT</span><span class='Delimiter'>, 
</span><a name="LN1134"></a>    <span class='Declare_Enum_Const'>XMLOPTION_CONTENT</span> 
<a name="LN1135"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>XmlOptionType</span><span class='Delimiter'>; 
</span> 
<a name="LN1137"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>XmlExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1139"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1140"></a>    <a href="primnodes.h.html#LN1119"><span class='Ref_to_Enum'>XmlExprOp</span></a>   <span class='Declare_Member'>op</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* xml function ID */ 
</span><a name="LN1141"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>name</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* name in xml(NAME foo ...) syntaxes */ 
</span><a name="LN1142"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>named_args</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* non-XML expressions for xml_attributes */ 
</span><a name="LN1143"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg_names</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* parallel list of Value strings */ 
</span><a name="LN1144"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>args</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* list of expressions */ 
</span><a name="LN1145"></a>    <a href="primnodes.h.html#LN1131"><span class='Ref_to_Typedef'>XmlOptionType</span></a> <span class='Declare_Member'>xmloption</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* DOCUMENT or CONTENT */ 
</span><a name="LN1146"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>type</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* target type/typmod for XMLSERIALIZE */ 
</span><a name="LN1147"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>typmod</span><span class='Delimiter'>; 
</span><a name="LN1148"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1149"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>XmlExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 * NullTest 
 * 
 * NullTest represents the operation of testing a value for NULLness. 
 * The appropriate test is performed and returned as a boolean Datum. 
 * 
 * When argisrow is false, this simply represents a test for the null value. 
 * 
 * When argisrow is true, the input expression must yield a rowtype, and 
 * the node implements "row IS [NOT] NULL" per the SQL standard.  This 
 * includes checking individual fields for NULLness when the row datum 
 * itself isn't NULL. 
 * 
 * NOTE: the combination of a rowtype input and argisrow==false does NOT 
 * correspond to the SQL notation "row IS [NOT] NULL"; instead, this case 
 * represents the SQL notation "row IS [NOT] DISTINCT FROM NULL". 
 * ---------------- 
 */ 
</span> 
<a name="LN1170"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>NullTestType</span> 
<span class='Delimiter'>{ 
</span><a name="LN1172"></a>    <span class='Declare_Enum_Const'>IS_NULL</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>IS_NOT_NULL</span> 
<a name="LN1173"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NullTestType</span><span class='Delimiter'>; 
</span> 
<a name="LN1175"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NullTest</span> 
<span class='Delimiter'>{ 
</span><a name="LN1177"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1178"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN1179"></a>    <a href="primnodes.h.html#LN1170"><span class='Ref_to_Enum'>NullTestType</span></a> <span class='Declare_Member'>nulltesttype</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* IS NULL, IS NOT NULL */ 
</span><a name="LN1180"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>argisrow</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* T to perform field-by-field null checks */ 
</span><a name="LN1181"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1182"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>NullTest</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BooleanTest 
 * 
 * BooleanTest represents the operation of determining whether a boolean 
 * is TRUE, FALSE, or UNKNOWN (ie, NULL).  All six meaningful combinations 
 * are supported.  Note that a NULL input does *not* cause a NULL result. 
 * The appropriate test is performed and returned as a boolean Datum. 
 */ 
</span> 
<a name="LN1193"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>BoolTestType</span> 
<span class='Delimiter'>{ 
</span><a name="LN1195"></a>    <span class='Declare_Enum_Const'>IS_TRUE</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>IS_NOT_TRUE</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>IS_FALSE</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>IS_NOT_FALSE</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>IS_UNKNOWN</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>IS_NOT_UNKNOWN</span> 
<a name="LN1196"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BoolTestType</span><span class='Delimiter'>; 
</span> 
<a name="LN1198"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BooleanTest</span> 
<span class='Delimiter'>{ 
</span><a name="LN1200"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1201"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN1202"></a>    <a href="primnodes.h.html#LN1193"><span class='Ref_to_Enum'>BoolTestType</span></a> <span class='Declare_Member'>booltesttype</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* test type */ 
</span><a name="LN1203"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1204"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BooleanTest</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CoerceToDomain 
 * 
 * CoerceToDomain represents the operation of coercing a value to a domain 
 * type.  At runtime (and not before) the precise set of constraints to be 
 * checked will be determined.  If the value passes, it is returned as the 
 * result; if not, an error is raised.  Note that this is equivalent to 
 * RelabelType in the scenario where no constraints are applied. 
 */ 
</span><a name="LN1215"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CoerceToDomain</span> 
<span class='Delimiter'>{ 
</span><a name="LN1217"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1218"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arg</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* input expression */ 
</span><a name="LN1219"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resulttype</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* domain type ID (result type) */ 
</span><a name="LN1220"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>resulttypmod</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* output typmod (currently always -1) */ 
</span><a name="LN1221"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resultcollid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid if none */ 
</span><a name="LN1222"></a>    <a href="primnodes.h.html#LN434"><span class='Ref_to_Enum'>CoercionForm</span></a> <span class='Declare_Member'>coercionformat</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* how to display this node */ 
</span><a name="LN1223"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1224"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CoerceToDomain</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Placeholder node for the value to be processed by a domain's check 
 * constraint.  This is effectively like a Param, but can be implemented more 
 * simply since we need only one replacement value at a time. 
 * 
 * Note: the typeId/typeMod/collation will be set from the domain's base type, 
 * not the domain itself.  This is because we shouldn't consider the value 
 * to be a member of the domain if we haven't yet checked its constraints. 
 */ 
</span><a name="LN1235"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CoerceToDomainValue</span> 
<span class='Delimiter'>{ 
</span><a name="LN1237"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1238"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>typeId</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* type for substituted value */ 
</span><a name="LN1239"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>typeMod</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* typemod for substituted value */ 
</span><a name="LN1240"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* collation for the substituted value */ 
</span><a name="LN1241"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1242"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CoerceToDomainValue</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Placeholder node for a DEFAULT marker in an INSERT or UPDATE command. 
 * 
 * This is not an executable expression: it must be replaced by the actual 
 * column default expression during rewriting.  But it is convenient to 
 * treat it as an expression node during parsing and rewriting. 
 */ 
</span><a name="LN1251"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SetToDefault</span> 
<span class='Delimiter'>{ 
</span><a name="LN1253"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1254"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>typeId</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* type for substituted value */ 
</span><a name="LN1255"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>typeMod</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* typemod for substituted value */ 
</span><a name="LN1256"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* collation for the substituted value */ 
</span><a name="LN1257"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>location</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* token location, or -1 if unknown */ 
</span><a name="LN1258"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SetToDefault</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Node representing [WHERE] CURRENT OF cursor_name 
 * 
 * CURRENT OF is a bit like a Var, in that it carries the rangetable index 
 * of the target relation being constrained; this aids placing the expression 
 * correctly during planning.  We can assume however that its "levelsup" is 
 * always zero, due to the syntactic constraints on where it can appear. 
 * 
 * The referenced cursor can be represented either as a hardwired string 
 * or as a reference to a run-time parameter of type REFCURSOR.  The latter 
 * case is for the convenience of plpgsql. 
 */ 
</span><a name="LN1272"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CurrentOfExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1274"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1275"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>cvarno</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* RT index of target relation */ 
</span><a name="LN1276"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>cursor_name</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* name of referenced cursor, or NULL */ 
</span><a name="LN1277"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>cursor_param</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* refcursor parameter number, or 0 */ 
</span><a name="LN1278"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CurrentOfExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * InferenceElem - an element of a unique index inference specification 
 * 
 * This mostly matches the structure of IndexElems, but having a dedicated 
 * primnode allows for a clean separation between the use of index parameters 
 * by utility commands, and this node. 
 */ 
</span><a name="LN1287"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>InferenceElem</span> 
<span class='Delimiter'>{ 
</span><a name="LN1289"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1290"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expression to infer from, or NULL */ 
</span><a name="LN1291"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>infercollid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OID of collation, or InvalidOid */ 
</span><a name="LN1292"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>inferopclass</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OID of att opclass, or InvalidOid */ 
</span><a name="LN1293"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>InferenceElem</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * NextValueExpr - get next value from sequence 
 * 
 * This has the same effect as calling the nextval() function, but it does not 
 * check permissions on the sequence.  This is used for identity columns, 
 * where the sequence is an implicit dependency without its own permissions. 
 */ 
</span><a name="LN1302"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>NextValueExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1304"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1305"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>seqid</span><span class='Delimiter'>; 
</span><a name="LN1306"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>typeId</span><span class='Delimiter'>; 
</span><a name="LN1307"></a>} <span class='Declare_Typedef'>NextValueExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*-------------------- 
 * TargetEntry - 
 *     a target entry (used in query target lists) 
 * 
 * Strictly speaking, a TargetEntry isn't an expression node (since it can't 
 * be evaluated by ExecEvalExpr).  But we treat it as one anyway, since in 
 * very many places it's convenient to process a whole query targetlist as a 
 * single expression tree. 
 * 
 * In a SELECT's targetlist, resno should always be equal to the item's 
 * ordinal position (counting from 1).  However, in an INSERT or UPDATE 
 * targetlist, resno represents the attribute number of the destination 
 * column for the item; so there may be missing or out-of-order resnos. 
 * It is even legal to have duplicated resnos; consider 
 *      UPDATE table SET arraycol[1] = ..., arraycol[2] = ..., ... 
 * The two meanings come together in the executor, because the planner 
 * transforms INSERT/UPDATE tlists into a normalized form with exactly 
 * one entry for each column of the destination table.  Before that's 
 * happened, however, it is risky to assume that resno == position. 
 * Generally get_tle_by_resno() should be used rather than list_nth() 
 * to fetch tlist entries by resno, and only in SELECT should you assume 
 * that resno is a unique identifier. 
 * 
 * resname is required to represent the correct column name in non-resjunk 
 * entries of top-level SELECT targetlists, since it will be used as the 
 * column title sent to the frontend.  In most other contexts it is only 
 * a debugging aid, and may be wrong or even NULL.  (In particular, it may 
 * be wrong in a tlist from a stored rule, if the referenced column has been 
 * renamed by ALTER TABLE since the rule was made.  Also, the planner tends 
 * to store NULL rather than look up a valid name for tlist entries in 
 * non-toplevel plan nodes.)  In resjunk entries, resname should be either 
 * a specific system-generated name (such as "ctid") or NULL; anything else 
 * risks confusing ExecGetJunkAttribute! 
 * 
 * ressortgroupref is used in the representation of ORDER BY, GROUP BY, and 
 * DISTINCT items.  Targetlist entries with ressortgroupref=0 are not 
 * sort/group items.  If ressortgroupref&GT;0, then this item is an ORDER BY, 
 * GROUP BY, and/or DISTINCT target value.  No two entries in a targetlist 
 * may have the same nonzero ressortgroupref --- but there is no particular 
 * meaning to the nonzero values, except as tags.  (For example, one must 
 * not assume that lower ressortgroupref means a more significant sort key.) 
 * The order of the associated SortGroupClause lists determine the semantics. 
 * 
 * resorigtbl/resorigcol identify the source of the column, if it is a 
 * simple reference to a column of a base table (or view).  If it is not 
 * a simple reference, these fields are zeroes. 
 * 
 * If resjunk is true then the column is a working column (such as a sort key) 
 * that should be removed from the final output of the query.  Resjunk columns 
 * must have resnos that cannot duplicate any regular column's resno.  Also 
 * note that there are places that assume resjunk columns come after non-junk 
 * columns. 
 *-------------------- 
 */ 
</span><a name="LN1363"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TargetEntry</span> 
<span class='Delimiter'>{ 
</span><a name="LN1365"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1366"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>expr</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* expression to evaluate */ 
</span><a name="LN1367"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>resno</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* attribute number (see notes above) */ 
</span><a name="LN1368"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>resname</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* name of the column (could be NULL) */ 
</span><a name="LN1369"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>ressortgroupref</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* nonzero if referenced by a sort/group 
                                 * clause */ 
</span><a name="LN1371"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>resorigtbl</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* OID of column's source table */ 
</span><a name="LN1372"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>resorigcol</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* column's number in source table */ 
</span><a name="LN1373"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>resjunk</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* set to true to eliminate the attribute from 
                                 * final target list */ 
</span><a name="LN1375"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TargetEntry</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *                  node types for join trees 
 * 
 * The leaves of a join tree structure are RangeTblRef nodes.  Above 
 * these, JoinExpr nodes can appear to denote a specific kind of join 
 * or qualified join.  Also, FromExpr nodes can appear to denote an 
 * ordinary cross-product join ("FROM foo, bar, baz WHERE ..."). 
 * FromExpr is like a JoinExpr of jointype JOIN_INNER, except that it 
 * may have any number of child nodes, not just two. 
 * 
 * NOTE: the top level of a Query's jointree is always a FromExpr. 
 * Even if the jointree contains no rels, there will be a FromExpr. 
 * 
 * NOTE: the qualification expressions present in JoinExpr nodes are 
 * *in addition to* the query's main WHERE clause, which appears as the 
 * qual of the top-level FromExpr.  The reason for associating quals with 
 * specific nodes in the jointree is that the position of a qual is critical 
 * when outer joins are present.  (If we enforce a qual too soon or too late, 
 * that may cause the outer join to produce the wrong set of NULL-extended 
 * rows.)  If all joins are inner joins then all the qual positions are 
 * semantically interchangeable. 
 * 
 * NOTE: in the raw output of gram.y, a join tree contains RangeVar, 
 * RangeSubselect, and RangeFunction nodes, which are all replaced by 
 * RangeTblRef nodes during the parse analysis phase.  Also, the top-level 
 * FromExpr is added during parse analysis; the grammar regards FROM and 
 * WHERE as separate. 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RangeTblRef - reference to an entry in the query's rangetable 
 * 
 * We could use direct pointers to the RT entries and skip having these 
 * nodes, but multiple pointers to the same node in a querytree cause 
 * lots of headaches, so it seems better to store an index into the RT. 
 */ 
</span><a name="LN1415"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RangeTblRef</span> 
<span class='Delimiter'>{ 
</span><a name="LN1417"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1418"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>rtindex</span><span class='Delimiter'>; 
</span><a name="LN1419"></a>} <span class='Declare_Typedef'>RangeTblRef</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------- 
 * JoinExpr - for SQL JOIN expressions 
 * 
 * isNatural, usingClause, and quals are interdependent.  The user can write 
 * only one of NATURAL, USING(), or ON() (this is enforced by the grammar). 
 * If he writes NATURAL then parse analysis generates the equivalent USING() 
 * list, and from that fills in "quals" with the right equality comparisons. 
 * If he writes USING() then "quals" is filled with equality comparisons. 
 * If he writes ON() then only "quals" is set.  Note that NATURAL/USING 
 * are not equivalent to ON() since they also affect the output column list. 
 * 
 * alias is an Alias node representing the AS alias-clause attached to the 
 * join expression, or NULL if no clause.  NB: presence or absence of the 
 * alias has a critical impact on semantics, because a join with an alias 
 * restricts visibility of the tables/columns inside it. 
 * 
 * During parse analysis, an RTE is created for the Join, and its index 
 * is filled into rtindex.  This RTE is present mainly so that Vars can 
 * be created that refer to the outputs of the join.  The planner sometimes 
 * generates JoinExprs internally; these can have rtindex = 0 if there are 
 * no join alias variables referencing such joins. 
 *---------- 
 */ 
</span><a name="LN1444"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>JoinExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1446"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1447"></a>    <a href="nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Member'>jointype</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* type of join */ 
</span><a name="LN1448"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isNatural</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* Natural join? Will need to shape table */ 
</span><a name="LN1449"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>larg</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* left subtree */ 
</span><a name="LN1450"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rarg</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* right subtree */ 
</span><a name="LN1451"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>usingClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* USING clause, if any (list of String) */ 
</span><a name="LN1452"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>quals</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* qualifiers on join, if any */ 
</span><a name="LN1453"></a>    <a href="primnodes.h.html#LN38"><span class='Ref_to_Struct'>Alias</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>alias</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* user-written alias clause, if any */ 
</span><a name="LN1454"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>rtindex</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* RT index assigned for join, or 0 */ 
</span><a name="LN1455"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>JoinExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------- 
 * FromExpr - represents a FROM ... WHERE ... construct 
 * 
 * This is both more flexible than a JoinExpr (it can have any number of 
 * children, including zero) and less so --- we don't need to deal with 
 * aliases and so on.  The output column set is implicitly just the union 
 * of the outputs of the children. 
 *---------- 
 */ 
</span><a name="LN1466"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>FromExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1468"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1469"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fromlist</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* List of join subtrees */ 
</span><a name="LN1470"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>quals</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* qualifiers on join, if any */ 
</span><a name="LN1471"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>FromExpr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------- 
 * OnConflictExpr - represents an ON CONFLICT DO ... expression 
 * 
 * The optimizer requires a list of inference elements, and optionally a WHERE 
 * clause to infer a unique index.  The unique index (or, occasionally, 
 * indexes) inferred are used to arbitrate whether or not the alternative ON 
 * CONFLICT path is taken. 
 *---------- 
 */ 
</span><a name="LN1482"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>OnConflictExpr</span> 
<span class='Delimiter'>{ 
</span><a name="LN1484"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1485"></a>    <a href="nodes.h.html#LN797"><span class='Ref_to_Enum'>OnConflictAction</span></a> <span class='Declare_Member'>action</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* DO NOTHING or UPDATE? */ 
</span> 
    <span class='Comment_Multi_Line'>/* Arbiter */ 
</span><a name="LN1488"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arbiterElems</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* unique index arbiter list (of 
                                 * InferenceElem's) */ 
</span><a name="LN1490"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>arbiterWhere</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* unique index arbiter WHERE clause */ 
</span><a name="LN1491"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>constraint</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* pg_constraint OID for arbiter */ 
</span> 
    <span class='Comment_Multi_Line'>/* ON CONFLICT UPDATE */ 
</span><a name="LN1494"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>onConflictSet</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* List of ON CONFLICT SET TargetEntrys */ 
</span><a name="LN1495"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>onConflictWhere</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* qualifiers to restrict UPDATE to */ 
</span><a name="LN1496"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>exclRelIndex</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* RT index of 'excluded' relation */ 
</span><a name="LN1497"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>exclRelTlist</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* tlist of the EXCLUDED pseudo relation */ 
</span><a name="LN1498"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OnConflictExpr</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* PRIMNODES_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>