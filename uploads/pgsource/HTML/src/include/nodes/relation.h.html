<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\nodes\relation.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\nodes\relation.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:07 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * relation.h 
 *    Definitions for planner's internal data structures. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/nodes/relation.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="relation.h.html#LN14"><span class='Ref_to_Const'>RELATION_H</span></a> 
<a name="LN14"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RELATION_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/sdir.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/stringinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/params.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/parsenodes.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/block.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Relids 
 *      Set of relation identifiers (indexes into the rangetable). 
 */ 
</span><a name="LN27"></a><span class='Control'>typedef</span> <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>Relids</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When looking for a "cheapest path", this enum specifies whether we want 
 * cheapest startup cost or cheapest total cost. 
 */ 
</span><a name="LN33"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>CostSelector</span> 
<span class='Delimiter'>{ 
</span><a name="LN35"></a>    <span class='Declare_Enum_Const'>STARTUP_COST</span><span class='Delimiter'>, </span><span class='Declare_Enum_Const'>TOTAL_COST</span> 
<a name="LN36"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>CostSelector</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The cost estimate produced by cost_qual_eval() includes both a one-time 
 * (startup) cost, and a per-tuple cost. 
 */ 
</span><a name="LN42"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>QualCost</span> 
<span class='Delimiter'>{ 
</span><a name="LN44"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>startup</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* one-time cost */ 
</span><a name="LN45"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>per_tuple</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* per-evaluation cost */ 
</span><a name="LN46"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>QualCost</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Costing aggregate function execution requires these statistics about 
 * the aggregates to be executed by a given Agg node.  Note that the costs 
 * include the execution costs of the aggregates' argument expressions as 
 * well as the aggregate functions themselves.  Also, the fields must be 
 * defined so that initializing the struct to zeroes with memset is correct. 
 */ 
</span><a name="LN55"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggClauseCosts</span> 
<span class='Delimiter'>{ 
</span><a name="LN57"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numAggs</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* total number of aggregate functions */ 
</span><a name="LN58"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numOrderedAggs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* number w/ DISTINCT/ORDER BY/WITHIN GROUP */ 
</span><a name="LN59"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasNonPartial</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* does any agg not support partial mode? */ 
</span><a name="LN60"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasNonSerial</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* is any partial agg non-serializable? */ 
</span><a name="LN61"></a>    <a href="relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Member'>transCost</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* total per-input-row execution costs */ 
</span><a name="LN62"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>finalCost</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* total per-aggregated-row costs */ 
</span><a name="LN63"></a>    <a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Member'>transitionSpace</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* space for pass-by-ref transition data */ 
</span><a name="LN64"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AggClauseCosts</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This enum identifies the different types of "upper" (post-scan/join) 
 * relations that we might deal with during planning. 
 */ 
</span><a name="LN70"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>UpperRelationKind</span> 
<span class='Delimiter'>{ 
</span><a name="LN72"></a>    <span class='Declare_Enum_Const'>UPPERREL_SETOP</span><span class='Delimiter'>,</span>             <span class='Comment_Single_Line'>/* result of UNION/INTERSECT/EXCEPT, if any */ 
</span><a name="LN73"></a>    <span class='Declare_Enum_Const'>UPPERREL_GROUP_AGG</span><span class='Delimiter'>,</span>         <span class='Comment_Single_Line'>/* result of grouping/aggregation, if any */ 
</span><a name="LN74"></a>    <span class='Declare_Enum_Const'>UPPERREL_WINDOW</span><span class='Delimiter'>,</span>            <span class='Comment_Single_Line'>/* result of window functions, if any */ 
</span><a name="LN75"></a>    <span class='Declare_Enum_Const'>UPPERREL_DISTINCT</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* result of "SELECT DISTINCT", if any */ 
</span><a name="LN76"></a>    <span class='Declare_Enum_Const'>UPPERREL_ORDERED</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* result of ORDER BY, if any */ 
</span><a name="LN77"></a>    <span class='Declare_Enum_Const'>UPPERREL_FINAL</span>              <span class='Comment_Single_Line'>/* result of any remaining top-level actions */ 
</span>    <span class='Comment_Multi_Line'>/* NB: UPPERREL_FINAL must be last enum entry; it's used to size arrays */ 
</span><a name="LN79"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UpperRelationKind</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/*---------- 
 * PlannerGlobal 
 *      Global information for planning/optimization 
 * 
 * PlannerGlobal holds state for an entire planner invocation; this state 
 * is shared across all levels of sub-Queries that exist in the command being 
 * planned. 
 *---------- 
 */ 
</span><a name="LN91"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlannerGlobal</span> 
<span class='Delimiter'>{ 
</span><a name="LN93"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN95"></a>    <a href="params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Member'>boundParams</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* Param values provided to planner() */ 
</span> 
<a name="LN97"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subplans</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Plans for SubPlan nodes */ 
</span> 
<a name="LN99"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subroots</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* PlannerInfos for SubPlan nodes */ 
</span> 
<a name="LN101"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>rewindPlanIDs</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* indices of subplans that require REWIND */ 
</span> 
<a name="LN103"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>finalrtable</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* "flat" rangetable for executor */ 
</span> 
<a name="LN105"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>finalrowmarks</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* "flat" list of PlanRowMarks */ 
</span> 
<a name="LN107"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>resultRelations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* "flat" list of integer RT indexes */ 
</span> 
<a name="LN109"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>nonleafResultRelations</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* "flat" list of integer RT indexes */ 
</span><a name="LN110"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rootResultRelations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* "flat" list of integer RT indexes */ 
</span> 
<a name="LN112"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>relationOids</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OIDs of relations the plan depends on */ 
</span> 
<a name="LN114"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>invalItems</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* other dependencies, as PlanInvalItems */ 
</span> 
<a name="LN116"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nParamExec</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* number of PARAM_EXEC Params used */ 
</span> 
<a name="LN118"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>lastPHId</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* highest PlaceHolderVar ID assigned */ 
</span> 
<a name="LN120"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>lastRowMarkId</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* highest PlanRowMark ID assigned */ 
</span> 
<a name="LN122"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>lastPlanNodeId</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* highest plan node ID assigned */ 
</span> 
<a name="LN124"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>transientPlan</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* redo plan when TransactionXmin changes? */ 
</span> 
<a name="LN126"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>dependsOnRole</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* is plan specific to current role? */ 
</span> 
<a name="LN128"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallelModeOK</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* parallel mode potentially OK? */ 
</span> 
<a name="LN130"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallelModeNeeded</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* parallel mode actually required? */ 
</span> 
<a name="LN132"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>maxParallelHazard</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* worst PROPARALLEL hazard level */ 
</span><a name="LN133"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end PlannerGlobal &raquo; </span> <span class='Declare_Typedef'>PlannerGlobal</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* macro for fetching the Plan associated with a SubPlan node */ 
</span><a name="LN136"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>planner_subplan_get_plan</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>subplan</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>((</span><a href="relation.h.html#LN136"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>glob<span class='Operator'>-&GT;</span>subplans<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="relation.h.html#LN136"><span class='Ref_to_Parameter'>subplan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>plan_id <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
 
 
<span class='Comment_Multi_Line'>/*---------- 
 * PlannerInfo 
 *      Per-query information for planning/optimization 
 * 
 * This struct is conventionally called "root" in all the planner routines. 
 * It holds links to all of the planner's working state, in addition to the 
 * original Query.  Note that at present the planner extensively modifies 
 * the passed-in Query data structure; someday that should stop. 
 *---------- 
 */ 
</span><a name="LN150"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlannerInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN152"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN154"></a>    <a href="parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>parse</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* the Query being planned */ 
</span> 
<a name="LN156"></a>    <a href="relation.h.html#LN91"><span class='Ref_to_Struct'>PlannerGlobal</span></a> <span class='Operator'>*</span><span class='Declare_Member'>glob</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* global info for current planner run */ 
</span> 
<a name="LN158"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>query_level</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* 1 at the outermost Query */ 
</span> 
<a name="LN160"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>parent_root</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* NULL at outermost Query */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * plan_params contains the expressions that this query level needs to 
     * make available to a lower query level that is currently being planned. 
     * outer_params contains the paramIds of PARAM_EXEC Params that outer 
     * query levels will make available to this query level. 
     */ 
</span><a name="LN168"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>plan_params</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* list of PlannerParamItems, see below */ 
</span><a name="LN169"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>outer_params</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * simple_rel_array holds pointers to "base rels" and "other rels" (see 
     * comments for RelOptInfo for more info).  It is indexed by rangetable 
     * index (so entry 0 is always wasted).  Entries can be NULL when an RTE 
     * does not correspond to a base relation, such as a join RTE or an 
     * unreferenced view RTE; or if the RelOptInfo hasn't been made yet. 
     */ 
</span><a name="LN178"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>**</span><span class='Declare_Member'>simple_rel_array</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* All 1-rel RelOptInfos */ 
</span><a name="LN179"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>simple_rel_array_size</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* allocated size of array */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * simple_rte_array is the same length as simple_rel_array and holds 
     * pointers to the associated rangetable entries.  This lets us avoid 
     * rt_fetch(), which can be a bit slow once large inheritance sets have 
     * been expanded. 
     */ 
</span><a name="LN187"></a>    <a href="parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>**</span><span class='Declare_Member'>simple_rte_array</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* rangetable as an array */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * all_baserels is a Relids set of all base relids (but not "other" 
     * relids) in the query; that is, the Relids identifier of the final join 
     * we need to form.  This is computed in make_one_rel, just before we 
     * start making Paths. 
     */ 
</span><a name="LN195"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>all_baserels</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * nullable_baserels is a Relids set of base relids that are nullable by 
     * some outer join in the jointree; these are rels that are potentially 
     * nullable below the WHERE clause, SELECT targetlist, etc.  This is 
     * computed in deconstruct_jointree. 
     */ 
</span><a name="LN203"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>nullable_baserels</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * join_rel_list is a list of all join-relation RelOptInfos we have 
     * considered in this planning run.  For small problems we just scan the 
     * list to do lookups, but when there are many join relations we build a 
     * hash table for faster lookups.  The hash table is present and valid 
     * when join_rel_hash is not NULL.  Note that we still maintain the list 
     * even when using the hash table for lookups; this simplifies life for 
     * GEQO. 
     */ 
</span><a name="LN214"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>join_rel_list</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of join-relation RelOptInfos */ 
</span><a name="LN215"></a>    <span class='Control'>struct</span> <a href="../../backend/utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Member'>join_rel_hash</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* optional hashtable for join relations */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When doing a dynamic-programming-style join search, join_rel_level[k] 
     * is a list of all join-relation RelOptInfos of level k, and 
     * join_cur_level is the current level.  New join-relation RelOptInfos are 
     * automatically added to the join_rel_level[join_cur_level] list. 
     * join_rel_level is NULL if not in use. 
     */ 
</span><a name="LN224"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Member'>join_rel_level</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* lists of join-relation RelOptInfos */ 
</span><a name="LN225"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>join_cur_level</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* index of list being extended */ 
</span> 
<a name="LN227"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>init_plans</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* init SubPlans for query */ 
</span> 
<a name="LN229"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cte_plan_ids</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* per-CTE-item list of subplan IDs */ 
</span> 
<a name="LN231"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>multiexpr_params</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* List of Lists of Params for 
                                         * MULTIEXPR subquery outputs */ 
</span> 
<a name="LN234"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>eq_classes</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of active EquivalenceClasses */ 
</span> 
<a name="LN236"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>canon_pathkeys</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* list of "canonical" PathKeys */ 
</span> 
<a name="LN238"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>left_join_clauses</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* list of RestrictInfos for 
                                         * mergejoinable outer join clauses 
                                         * w/nonnullable var on left */ 
</span> 
<a name="LN242"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>right_join_clauses</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* list of RestrictInfos for 
                                         * mergejoinable outer join clauses 
                                         * w/nonnullable var on right */ 
</span> 
<a name="LN246"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>full_join_clauses</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* list of RestrictInfos for 
                                         * mergejoinable full join clauses */ 
</span> 
<a name="LN249"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>join_info_list</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* list of SpecialJoinInfos */ 
</span> 
<a name="LN251"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>append_rel_list</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* list of AppendRelInfos */ 
</span> 
<a name="LN253"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>pcinfo_list</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* list of PartitionedChildRelInfos */ 
</span> 
<a name="LN255"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowMarks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of PlanRowMarks */ 
</span> 
<a name="LN257"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>placeholder_list</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of PlaceHolderInfos */ 
</span> 
<a name="LN259"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fkey_list</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of ForeignKeyOptInfos */ 
</span> 
<a name="LN261"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>query_pathkeys</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* desired pathkeys for query_planner() */ 
</span> 
<a name="LN263"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>group_pathkeys</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* groupClause pathkeys, if any */ 
</span><a name="LN264"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>window_pathkeys</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* pathkeys of bottom window, if any */ 
</span><a name="LN265"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>distinct_pathkeys</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* distinctClause pathkeys, if any */ 
</span><a name="LN266"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>sort_pathkeys</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* sortClause pathkeys, if any */ 
</span> 
<a name="LN268"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>initial_rels</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* RelOptInfos we are now trying to join */ 
</span> 
    <span class='Comment_Multi_Line'>/* Use fetch_upper_rel() to get any particular upper rel */ 
</span><a name="LN271"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>upper_rels</span><span class='Delimiter'>[</span><a href="relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; </span><span class='Comment_Single_Line'>/* upper-rel RelOptInfos */ 
</span> 
    <span class='Comment_Multi_Line'>/* Result tlists chosen by grouping_planner for upper-stage processing */ 
</span><a name="LN274"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Member'>upper_targets</span><span class='Delimiter'>[</span><a href="relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * grouping_planner passes back its final processed targetlist here, for 
     * use in relabeling the topmost tlist of the finished Plan. 
     */ 
</span><a name="LN280"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>processed_tlist</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fields filled during create_plan() for use in setrefs.c */ 
</span><a name="LN283"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>grouping_map</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* for GroupingFunc fixup */ 
</span><a name="LN284"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>minmax_aggs</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* List of MinMaxAggInfos */ 
</span> 
<a name="LN286"></a>    <a href="../utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>planner_cxt</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* context holding PlannerInfo */ 
</span> 
<a name="LN288"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>total_table_pages</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* # of pages in all tables of query */ 
</span> 
<a name="LN290"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>tuple_fraction</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* tuple_fraction passed to query_planner */ 
</span><a name="LN291"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>limit_tuples</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* limit_tuples passed to query_planner */ 
</span> 
<a name="LN293"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>qual_security_level</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* minimum security_level for quals */ 
</span>    <span class='Comment_Multi_Line'>/* Note: qual_security_level is zero if there are no securityQuals */ 
</span> 
<a name="LN296"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasInheritedTarget</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* true if parse-&GT;resultRelation is an 
                                         * inheritance child rel */ 
</span><a name="LN298"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasJoinRTEs</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* true if any RTEs are RTE_JOIN kind */ 
</span><a name="LN299"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasLateralRTEs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* true if any RTEs are marked LATERAL */ 
</span><a name="LN300"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasDeletedRTEs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* true if any RTE was deleted from jointree */ 
</span><a name="LN301"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasHavingQual</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* true if havingQual was non-null */ 
</span><a name="LN302"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasPseudoConstantQuals</span><span class='Delimiter'>; </span><span class='Comment_Multi_Line'>/* true if any RestrictInfo has 
                                         * pseudoconstant = true */ 
</span><a name="LN304"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hasRecursion</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* true if planning a recursive WITH item */ 
</span> 
    <span class='Comment_Multi_Line'>/* These fields are used only when hasRecursion is true: */ 
</span><a name="LN307"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>wt_param_id</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* PARAM_EXEC ID for the work table */ 
</span><a name="LN308"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Member'>non_recursive_path</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* a path for non-recursive term */ 
</span> 
    <span class='Comment_Multi_Line'>/* These fields are workspace for createplan.c */ 
</span><a name="LN311"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>curOuterRels</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* outer rels above current node */ 
</span><a name="LN312"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>curOuterParams</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* not-yet-assigned NestLoopParams */ 
</span> 
    <span class='Comment_Multi_Line'>/* optional private data for join_search_hook, e.g., GEQO */ 
</span><a name="LN315"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>join_search_private</span><span class='Delimiter'>; 
</span><a name="LN316"></a>}<span class='Auto_Annotations'> &laquo; end PlannerInfo &raquo; </span> <span class='Declare_Typedef'>PlannerInfo</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * In places where it's known that simple_rte_array[] must have been prepared 
 * already, we just index into it to fetch RTEs.  In code that might be 
 * executed before or after entering query_planner(), use this macro. 
 */ 
</span><a name="LN324"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>planner_rt_fetch</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="relation.h.html#LN324"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>simple_rte_array <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="relation.h.html#LN324"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>simple_rte_array<span class='Delimiter'>[</span><a href="relation.h.html#LN324"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>] </span><span class='Operator'>: \ 
</span>     <a href="../parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="relation.h.html#LN324"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="relation.h.html#LN324"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>parse<span class='Operator'>-&GT;</span>rtable<span class='Parentheses'>))</span> 
 
 
<span class='Comment_Multi_Line'>/*---------- 
 * RelOptInfo 
 *      Per-relation information for planning/optimization 
 * 
 * For planning purposes, a "base rel" is either a plain relation (a table) 
 * or the output of a sub-SELECT or function that appears in the range table. 
 * In either case it is uniquely identified by an RT index.  A "joinrel" 
 * is the joining of two or more base rels.  A joinrel is identified by 
 * the set of RT indexes for its component baserels.  We create RelOptInfo 
 * nodes for each baserel and joinrel, and store them in the PlannerInfo's 
 * simple_rel_array and join_rel_list respectively. 
 * 
 * Note that there is only one joinrel for any given set of component 
 * baserels, no matter what order we assemble them in; so an unordered 
 * set is the right datatype to identify it with. 
 * 
 * We also have "other rels", which are like base rels in that they refer to 
 * single RT indexes; but they are not part of the join tree, and are given 
 * a different RelOptKind to identify them. 
 * Currently the only kind of otherrels are those made for member relations 
 * of an "append relation", that is an inheritance set or UNION ALL subquery. 
 * An append relation has a parent RTE that is a base rel, which represents 
 * the entire append relation.  The member RTEs are otherrels.  The parent 
 * is present in the query join tree but the members are not.  The member 
 * RTEs and otherrels are used to plan the scans of the individual tables or 
 * subqueries of the append set; then the parent baserel is given Append 
 * and/or MergeAppend paths comprising the best paths for the individual 
 * member rels.  (See comments for AppendRelInfo for more information.) 
 * 
 * At one time we also made otherrels to represent join RTEs, for use in 
 * handling join alias Vars.  Currently this is not needed because all join 
 * alias Vars are expanded to non-aliased form during preprocess_expression. 
 * 
 * There is also a RelOptKind for "upper" relations, which are RelOptInfos 
 * that describe post-scan/join processing steps, such as aggregation. 
 * Many of the fields in these RelOptInfos are meaningless, but their Path 
 * fields always hold Paths showing ways to do that processing step. 
 * 
 * Lastly, there is a RelOptKind for "dead" relations, which are base rels 
 * that we have proven we don't need to join after all. 
 * 
 * Parts of this data structure are specific to various scan and join 
 * mechanisms.  It didn't seem worth creating new node types for them. 
 * 
 *      relids - Set of base-relation identifiers; it is a base relation 
 *              if there is just one, a join relation if more than one 
 *      rows - estimated number of tuples in the relation after restriction 
 *             clauses have been applied (ie, output rows of a plan for it) 
 *      consider_startup - true if there is any value in keeping plain paths for 
 *                         this rel on the basis of having cheap startup cost 
 *      consider_param_startup - the same for parameterized paths 
 *      reltarget - Default Path output tlist for this rel; normally contains 
 *                  Var and PlaceHolderVar nodes for the values we need to 
 *                  output from this relation. 
 *                  List is in no particular order, but all rels of an 
 *                  appendrel set must use corresponding orders. 
 *                  NOTE: in an appendrel child relation, may contain 
 *                  arbitrary expressions pulled up from a subquery! 
 *      pathlist - List of Path nodes, one for each potentially useful 
 *                 method of generating the relation 
 *      ppilist - ParamPathInfo nodes for parameterized Paths, if any 
 *      cheapest_startup_path - the pathlist member with lowest startup cost 
 *          (regardless of ordering) among the unparameterized paths; 
 *          or NULL if there is no unparameterized path 
 *      cheapest_total_path - the pathlist member with lowest total cost 
 *          (regardless of ordering) among the unparameterized paths; 
 *          or if there is no unparameterized path, the path with lowest 
 *          total cost among the paths with minimum parameterization 
 *      cheapest_unique_path - for caching cheapest path to produce unique 
 *          (no duplicates) output from relation; NULL if not yet requested 
 *      cheapest_parameterized_paths - best paths for their parameterizations; 
 *          always includes cheapest_total_path, even if that's unparameterized 
 *      direct_lateral_relids - rels this rel has direct LATERAL references to 
 *      lateral_relids - required outer rels for LATERAL, as a Relids set 
 *          (includes both direct and indirect lateral references) 
 * 
 * If the relation is a base relation it will have these fields set: 
 * 
 *      relid - RTE index (this is redundant with the relids field, but 
 *              is provided for convenience of access) 
 *      rtekind - distinguishes plain relation, subquery, or function RTE 
 *      min_attr, max_attr - range of valid AttrNumbers for rel 
 *      attr_needed - array of bitmapsets indicating the highest joinrel 
 *              in which each attribute is needed; if bit 0 is set then 
 *              the attribute is needed as part of final targetlist 
 *      attr_widths - cache space for per-attribute width estimates; 
 *                    zero means not computed yet 
 *      lateral_vars - lateral cross-references of rel, if any (list of 
 *                     Vars and PlaceHolderVars) 
 *      lateral_referencers - relids of rels that reference this one laterally 
 *              (includes both direct and indirect lateral references) 
 *      indexlist - list of IndexOptInfo nodes for relation's indexes 
 *                  (always NIL if it's not a table) 
 *      pages - number of disk pages in relation (zero if not a table) 
 *      tuples - number of tuples in relation (not considering restrictions) 
 *      allvisfrac - fraction of disk pages that are marked all-visible 
 *      subroot - PlannerInfo for subquery (NULL if it's not a subquery) 
 *      subplan_params - list of PlannerParamItems to be passed to subquery 
 * 
 *      Note: for a subquery, tuples and subroot are not set immediately 
 *      upon creation of the RelOptInfo object; they are filled in when 
 *      set_subquery_pathlist processes the object. 
 * 
 *      For otherrels that are appendrel members, these fields are filled 
 *      in just as for a baserel, except we don't bother with lateral_vars. 
 * 
 * If the relation is either a foreign table or a join of foreign tables that 
 * all belong to the same foreign server and are assigned to the same user to 
 * check access permissions as (cf checkAsUser), these fields will be set: 
 * 
 *      serverid - OID of foreign server, if foreign table (else InvalidOid) 
 *      userid - OID of user to check access as (InvalidOid means current user) 
 *      useridiscurrent - we've assumed that userid equals current user 
 *      fdwroutine - function hooks for FDW, if foreign table (else NULL) 
 *      fdw_private - private state for FDW, if foreign table (else NULL) 
 * 
 * Two fields are used to cache knowledge acquired during the join search 
 * about whether this rel is provably unique when being joined to given other 
 * relation(s), ie, it can have at most one row matching any given row from 
 * that join relation.  Currently we only attempt such proofs, and thus only 
 * populate these fields, for base rels; but someday they might be used for 
 * join rels too: 
 * 
 *      unique_for_rels - list of Relid sets, each one being a set of other 
 *                  rels for which this one has been proven unique 
 *      non_unique_for_rels - list of Relid sets, each one being a set of 
 *                  other rels for which we have tried and failed to prove 
 *                  this one unique 
 * 
 * The presence of the remaining fields depends on the restrictions 
 * and joins that the relation participates in: 
 * 
 *      baserestrictinfo - List of RestrictInfo nodes, containing info about 
 *                  each non-join qualification clause in which this relation 
 *                  participates (only used for base rels) 
 *      baserestrictcost - Estimated cost of evaluating the baserestrictinfo 
 *                  clauses at a single tuple (only used for base rels) 
 *      baserestrict_min_security - Smallest security_level found among 
 *                  clauses in baserestrictinfo 
 *      joininfo  - List of RestrictInfo nodes, containing info about each 
 *                  join clause in which this relation participates (but 
 *                  note this excludes clauses that might be derivable from 
 *                  EquivalenceClasses) 
 *      has_eclass_joins - flag that EquivalenceClass joins are possible 
 * 
 * Note: Keeping a restrictinfo list in the RelOptInfo is useful only for 
 * base rels, because for a join rel the set of clauses that are treated as 
 * restrict clauses varies depending on which sub-relations we choose to join. 
 * (For example, in a 3-base-rel join, a clause relating rels 1 and 2 must be 
 * treated as a restrictclause if we join {1} and {2 3} to make {1 2 3}; but 
 * if we join {1 2} and {3} then that clause will be a restrictclause in {1 2} 
 * and should not be processed again at the level of {1 2 3}.)  Therefore, 
 * the restrictinfo list in the join case appears in individual JoinPaths 
 * (field joinrestrictinfo), not in the parent relation.  But it's OK for 
 * the RelOptInfo to store the joininfo list, because that is the same 
 * for a given rel no matter how we form it. 
 * 
 * We store baserestrictcost in the RelOptInfo (for base relations) because 
 * we know we will need it at least once (to price the sequential scan) 
 * and may need it multiple times to price index scans. 
 *---------- 
 */ 
</span><a name="LN491"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>RelOptKind</span> 
<span class='Delimiter'>{ 
</span><a name="LN493"></a>    <span class='Declare_Enum_Const'>RELOPT_BASEREL</span><span class='Delimiter'>, 
</span><a name="LN494"></a>    <span class='Declare_Enum_Const'>RELOPT_JOINREL</span><span class='Delimiter'>, 
</span><a name="LN495"></a>    <span class='Declare_Enum_Const'>RELOPT_OTHER_MEMBER_REL</span><span class='Delimiter'>, 
</span><a name="LN496"></a>    <span class='Declare_Enum_Const'>RELOPT_UPPER_REL</span><span class='Delimiter'>, 
</span><a name="LN497"></a>    <span class='Declare_Enum_Const'>RELOPT_DEADREL</span> 
<a name="LN498"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RelOptKind</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Is the given relation a simple relation i.e a base or "other" member 
 * relation? 
 */ 
</span><a name="LN504"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_SIMPLE_REL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="relation.h.html#LN504"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>reloptkind <span class='Operator'>== </span><a href="relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a> <span class='Operator'>|| \ 
</span>     <span class='Parentheses'>(</span><a href="relation.h.html#LN504"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>reloptkind <span class='Operator'>== </span><a href="relation.h.html#LN495"><span class='Ref_to_EnumConst'>RELOPT_OTHER_MEMBER_REL</span></a><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* Is the given relation a join relation? */ 
</span><a name="LN509"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_JOIN_REL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) ((</span><a href="relation.h.html#LN509"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>reloptkind <span class='Operator'>== </span><a href="relation.h.html#LN494"><span class='Ref_to_EnumConst'>RELOPT_JOINREL</span></a><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* Is the given relation an upper relation? */ 
</span><a name="LN512"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_UPPER_REL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) ((</span><a href="relation.h.html#LN512"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>reloptkind <span class='Operator'>== </span><a href="relation.h.html#LN496"><span class='Ref_to_EnumConst'>RELOPT_UPPER_REL</span></a><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* Is the given relation an "other" relation? */ 
</span><a name="LN515"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_OTHER_REL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) ((</span><a href="relation.h.html#LN515"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>reloptkind <span class='Operator'>== </span><a href="relation.h.html#LN495"><span class='Ref_to_EnumConst'>RELOPT_OTHER_MEMBER_REL</span></a><span class='Parentheses'>)</span> 
 
<a name="LN517"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RelOptInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN519"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN521"></a>    <a href="relation.h.html#LN491"><span class='Ref_to_Enum'>RelOptKind</span></a>  <span class='Declare_Member'>reloptkind</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* all relations included in this RelOptInfo */ 
</span><a name="LN524"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>relids</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* set of base relids (rangetable indexes) */ 
</span> 
    <span class='Comment_Multi_Line'>/* size estimates generated by planner */ 
</span><a name="LN527"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>rows</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* estimated number of result tuples */ 
</span> 
    <span class='Comment_Multi_Line'>/* per-relation planner control flags */ 
</span><a name="LN530"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>consider_startup</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* keep cheap-startup-cost paths? */ 
</span><a name="LN531"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>consider_param_startup</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* ditto, for parameterized paths? */ 
</span><a name="LN532"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>consider_parallel</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* consider parallel paths? */ 
</span> 
    <span class='Comment_Multi_Line'>/* default result targetlist for Paths scanning this relation */ 
</span><a name="LN535"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Member'>reltarget</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of Vars/Exprs, cost, width */ 
</span> 
    <span class='Comment_Multi_Line'>/* materialization information */ 
</span><a name="LN538"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>pathlist</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Path structures */ 
</span><a name="LN539"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ppilist</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* ParamPathInfos used in pathlist */ 
</span><a name="LN540"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partial_pathlist</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* partial Paths */ 
</span><a name="LN541"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cheapest_startup_path</span><span class='Delimiter'>; 
</span><a name="LN542"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cheapest_total_path</span><span class='Delimiter'>; 
</span><a name="LN543"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Member'>cheapest_unique_path</span><span class='Delimiter'>; 
</span><a name="LN544"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>cheapest_parameterized_paths</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* parameterization information needed for both base rels and join rels */ 
</span>    <span class='Comment_Multi_Line'>/* (see also lateral_vars and lateral_referencers) */ 
</span><a name="LN548"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>direct_lateral_relids</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* rels directly laterally referenced */ 
</span><a name="LN549"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>lateral_relids</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* minimum parameterization of rel */ 
</span> 
    <span class='Comment_Multi_Line'>/* information about a base rel (not set for join rels!) */ 
</span><a name="LN552"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>relid</span><span class='Delimiter'>; 
</span><a name="LN553"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>reltablespace</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* containing tablespace */ 
</span><a name="LN554"></a>    <a href="parsenodes.h.html#LN920"><span class='Ref_to_Enum'>RTEKind</span></a>     <span class='Declare_Member'>rtekind</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* RELATION, SUBQUERY, or FUNCTION */ 
</span><a name="LN555"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>min_attr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* smallest attrno of rel (often &LT;0) */ 
</span><a name="LN556"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>max_attr</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* largest attrno of rel */ 
</span><a name="LN557"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>attr_needed</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array indexed [min_attr .. max_attr] */ 
</span><a name="LN558"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>attr_widths</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* array indexed [min_attr .. max_attr] */ 
</span><a name="LN559"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>lateral_vars</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* LATERAL Vars and PHVs referenced by rel */ 
</span><a name="LN560"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>lateral_referencers</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* rels that reference me laterally */ 
</span><a name="LN561"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexlist</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of IndexOptInfo */ 
</span><a name="LN562"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>statlist</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of StatisticExtInfo */ 
</span><a name="LN563"></a>    <a href="../storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Member'>pages</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* size estimates derived from pg_class */ 
</span><a name="LN564"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>tuples</span><span class='Delimiter'>; 
</span><a name="LN565"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>allvisfrac</span><span class='Delimiter'>; 
</span><a name="LN566"></a>    <a href="relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>subroot</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* if subquery */ 
</span><a name="LN567"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subplan_params</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* if subquery */ 
</span><a name="LN568"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>rel_parallel_workers</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* wanted number of parallel workers */ 
</span> 
    <span class='Comment_Multi_Line'>/* Information about foreign tables and foreign joins */ 
</span><a name="LN571"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>serverid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* identifies server for the table or join */ 
</span><a name="LN572"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>userid</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* identifies user to check access as */ 
</span><a name="LN573"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>useridiscurrent</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* join is only valid for current user */ 
</span>    <span class='Comment_Multi_Line'>/* use "struct FdwRoutine" to avoid including fdwapi.h here */ 
</span><a name="LN575"></a>    <span class='Control'>struct</span> <a href="../foreign/fdwapi.h.html#LN168"><span class='Ref_to_Struct'>FdwRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Member'>fdwroutine</span><span class='Delimiter'>; 
</span><a name="LN576"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_private</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cache space for remembering if we have proven this relation unique */ 
</span><a name="LN579"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>unique_for_rels</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* known unique for these other relid set(s) */ 
</span><a name="LN580"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>non_unique_for_rels</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* known not unique for these set(s) */ 
</span> 
    <span class='Comment_Multi_Line'>/* used by various scans and joins: */ 
</span><a name="LN583"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>baserestrictinfo</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* RestrictInfo structures (if base 
                                         * rel) */ 
</span><a name="LN585"></a>    <a href="relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Member'>baserestrictcost</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* cost of evaluating the above */ 
</span><a name="LN586"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>baserestrict_min_security</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* min security_level found in 
                                                 * baserestrictinfo */ 
</span><a name="LN588"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>joininfo</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* RestrictInfo structures for join clauses 
                                 * involving this rel */ 
</span><a name="LN590"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>has_eclass_joins</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* T means joininfo is incomplete */ 
</span> 
    <span class='Comment_Multi_Line'>/* used by "other" relations */ 
</span><a name="LN593"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>top_parent_relids</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* Relids of topmost parents */ 
</span><a name="LN594"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end RelOptInfo &raquo; </span> <span class='Declare_Typedef'>RelOptInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IndexOptInfo 
 *      Per-index information for planning/optimization 
 * 
 *      indexkeys[], indexcollations[], opfamily[], and opcintype[] 
 *      each have ncolumns entries. 
 * 
 *      sortopfamily[], reverse_sort[], and nulls_first[] likewise have 
 *      ncolumns entries, if the index is ordered; but if it is unordered, 
 *      those pointers are NULL. 
 * 
 *      Zeroes in the indexkeys[] array indicate index columns that are 
 *      expressions; there is one element in indexprs for each such column. 
 * 
 *      For an ordered index, reverse_sort[] and nulls_first[] describe the 
 *      sort ordering of a forward indexscan; we can also consider a backward 
 *      indexscan, which will generate the reverse ordering. 
 * 
 *      The indexprs and indpred expressions have been run through 
 *      prepqual.c and eval_const_expressions() for ease of matching to 
 *      WHERE clauses. indpred is in implicit-AND form. 
 * 
 *      indextlist is a TargetEntry list representing the index columns. 
 *      It provides an equivalent base-relation Var for each simple column, 
 *      and links to the matching indexprs element for each expression column. 
 * 
 *      While most of these fields are filled when the IndexOptInfo is created 
 *      (by plancat.c), indrestrictinfo and predOK are set later, in 
 *      check_index_predicates(). 
 */ 
</span><a name="LN626"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexOptInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN628"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN630"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>indexoid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OID of the index relation */ 
</span><a name="LN631"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>reltablespace</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* tablespace of index (not table) */ 
</span><a name="LN632"></a>    <a href="relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rel</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* back-link to index's table */ 
</span> 
    <span class='Comment_Multi_Line'>/* index-size statistics (from pg_class and elsewhere) */ 
</span><a name="LN635"></a>    <a href="../storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Member'>pages</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* number of disk pages in index */ 
</span><a name="LN636"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>tuples</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* number of index tuples in index */ 
</span><a name="LN637"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>tree_height</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* index tree height, or -1 if unknown */ 
</span> 
    <span class='Comment_Multi_Line'>/* index descriptor information */ 
</span><a name="LN640"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ncolumns</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* number of columns in index */ 
</span><a name="LN641"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>indexkeys</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* column numbers of index's keys, or 0 */ 
</span><a name="LN642"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>indexcollations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OIDs of collations of index columns */ 
</span><a name="LN643"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>opfamily</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* OIDs of operator families for columns */ 
</span><a name="LN644"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>opcintype</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* OIDs of opclass declared input data types */ 
</span><a name="LN645"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>sortopfamily</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* OIDs of btree opfamilies, if orderable */ 
</span><a name="LN646"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>reverse_sort</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* is sort order descending? */ 
</span><a name="LN647"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>nulls_first</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* do NULLs come first in the sort order? */ 
</span><a name="LN648"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>canreturn</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* which index cols can be returned in an 
                                 * index-only scan? */ 
</span><a name="LN650"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>relam</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* OID of the access method (in pg_am) */ 
</span> 
<a name="LN652"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexprs</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* expressions for non-simple index columns */ 
</span><a name="LN653"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indpred</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* predicate if a partial index, else NIL */ 
</span> 
<a name="LN655"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indextlist</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* targetlist representing index columns */ 
</span> 
<a name="LN657"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indrestrictinfo</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* parent relation's baserestrictinfo list, 
                                 * less any conditions implied by the index's 
                                 * predicate (unless it's a target rel, see 
                                 * comments in check_index_predicates()) */ 
</span> 
<a name="LN662"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>predOK</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* true if index predicate matches query */ 
</span><a name="LN663"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>unique</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* true if a unique index */ 
</span><a name="LN664"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>immediate</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* is uniqueness enforced immediately? */ 
</span><a name="LN665"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hypothetical</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* true if index doesn't really exist */ 
</span> 
    <span class='Comment_Multi_Line'>/* Remaining fields are copied from the index AM's API struct: */ 
</span><a name="LN668"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>amcanorderbyop</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* does AM support order by operator result? */ 
</span><a name="LN669"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>amoptionalkey</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* can query omit key for the first column? */ 
</span><a name="LN670"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>amsearcharray</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* can AM handle ScalarArrayOpExpr quals? */ 
</span><a name="LN671"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>amsearchnulls</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* can AM search for NULL/NOT NULL entries? */ 
</span><a name="LN672"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>amhasgettuple</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* does AM have amgettuple interface? */ 
</span><a name="LN673"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>amhasgetbitmap</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* does AM have amgetbitmap interface? */ 
</span><a name="LN674"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>amcanparallel</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* does AM support parallel scan? */ 
</span>    <span class='Comment_Multi_Line'>/* Rather than include amapi.h here, we declare amcostestimate like this */ 
</span><a name="LN676"></a>    <span class='Keyword'>void</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><span class='Declare_Member'>amcostestimate</span><span class='Parentheses'>) ()</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* AM's cost estimator */ 
</span><a name="LN677"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end IndexOptInfo &raquo; </span> <span class='Declare_Typedef'>IndexOptInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ForeignKeyOptInfo 
 *      Per-foreign-key information for planning/optimization 
 * 
 * The per-FK-column arrays can be fixed-size because we allow at most 
 * INDEX_MAX_KEYS columns in a foreign key constraint.  Each array has 
 * nkeys valid entries. 
 */ 
</span><a name="LN687"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ForeignKeyOptInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN689"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Basic data about the foreign key (fetched from catalogs): */ 
</span><a name="LN692"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>con_relid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RT index of the referencing table */ 
</span><a name="LN693"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>ref_relid</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* RT index of the referenced table */ 
</span><a name="LN694"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nkeys</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* number of columns in the foreign key */ 
</span><a name="LN695"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>conkey</span><span class='Delimiter'>[</span><a href="../pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; </span><span class='Comment_Single_Line'>/* cols in referencing table */ 
</span><a name="LN696"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>confkey</span><span class='Delimiter'>[</span><a href="../pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>];</span>        <span class='Comment_Single_Line'>/* cols in referenced table */ 
</span><a name="LN697"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>conpfeqop</span><span class='Delimiter'>[</span><a href="../pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>];</span>      <span class='Comment_Single_Line'>/* PK = FK operator OIDs */ 
</span> 
    <span class='Comment_Multi_Line'>/* Derived info about whether FK's equality conditions match the query: */ 
</span><a name="LN700"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nmatched_ec</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* # of FK cols matched by ECs */ 
</span><a name="LN701"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nmatched_rcols</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* # of FK cols matched by non-EC rinfos */ 
</span><a name="LN702"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nmatched_ri</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* total # of non-EC rinfos matched to FK */ 
</span>    <span class='Comment_Multi_Line'>/* Pointer to eclass matching each column's condition, if there is one */ 
</span><a name="LN704"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN766"><span class='Ref_to_Struct'>EquivalenceClass</span></a> <span class='Operator'>*</span><span class='Declare_Member'>eclass</span><span class='Delimiter'>[</span><a href="../pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span>    <span class='Comment_Multi_Line'>/* List of non-EC RestrictInfos matching each column's condition */ 
</span><a name="LN706"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rinfos</span><span class='Delimiter'>[</span><a href="../pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN707"></a>}<span class='Auto_Annotations'> &laquo; end ForeignKeyOptInfo &raquo; </span> <span class='Declare_Typedef'>ForeignKeyOptInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * StatisticExtInfo 
 *      Information about extended statistics for planning/optimization 
 * 
 * Each pg_statistic_ext row is represented by one or more nodes of this 
 * type, or even zero if ANALYZE has not computed them. 
 */ 
</span><a name="LN716"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>StatisticExtInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN718"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN720"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>statOid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* OID of the statistics row */ 
</span><a name="LN721"></a>    <a href="relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>rel</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* back-link to statistic's table */ 
</span><a name="LN722"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>kind</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* statistic kind of this entry */ 
</span><a name="LN723"></a>    <a href="bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>keys</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* attnums of the columns covered */ 
</span><a name="LN724"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>StatisticExtInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * EquivalenceClasses 
 * 
 * Whenever we can determine that a mergejoinable equality clause A = B is 
 * not delayed by any outer join, we create an EquivalenceClass containing 
 * the expressions A and B to record this knowledge.  If we later find another 
 * equivalence B = C, we add C to the existing EquivalenceClass; this may 
 * require merging two existing EquivalenceClasses.  At the end of the qual 
 * distribution process, we have sets of values that are known all transitively 
 * equal to each other, where "equal" is according to the rules of the btree 
 * operator family(s) shown in ec_opfamilies, as well as the collation shown 
 * by ec_collation.  (We restrict an EC to contain only equalities whose 
 * operators belong to the same set of opfamilies.  This could probably be 
 * relaxed, but for now it's not worth the trouble, since nearly all equality 
 * operators belong to only one btree opclass anyway.  Similarly, we suppose 
 * that all or none of the input datatypes are collatable, so that a single 
 * collation value is sufficient.) 
 * 
 * We also use EquivalenceClasses as the base structure for PathKeys, letting 
 * us represent knowledge about different sort orderings being equivalent. 
 * Since every PathKey must reference an EquivalenceClass, we will end up 
 * with single-member EquivalenceClasses whenever a sort key expression has 
 * not been equivalenced to anything else.  It is also possible that such an 
 * EquivalenceClass will contain a volatile expression ("ORDER BY random()"), 
 * which is a case that can't arise otherwise since clauses containing 
 * volatile functions are never considered mergejoinable.  We mark such 
 * EquivalenceClasses specially to prevent them from being merged with 
 * ordinary EquivalenceClasses.  Also, for volatile expressions we have 
 * to be careful to match the EquivalenceClass to the correct targetlist 
 * entry: consider SELECT random() AS a, random() AS b ... ORDER BY b,a. 
 * So we record the SortGroupRef of the originating sort clause. 
 * 
 * We allow equality clauses appearing below the nullable side of an outer join 
 * to form EquivalenceClasses, but these have a slightly different meaning: 
 * the included values might be all NULL rather than all the same non-null 
 * values.  See src/backend/optimizer/README for more on that point. 
 * 
 * NB: if ec_merged isn't NULL, this class has been merged into another, and 
 * should be ignored in favor of using the pointed-to class. 
 */ 
</span><a name="LN766"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>EquivalenceClass</span> 
<span class='Delimiter'>{ 
</span><a name="LN768"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN770"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ec_opfamilies</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* btree operator family OIDs */ 
</span><a name="LN771"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>ec_collation</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* collation, if datatypes are collatable */ 
</span><a name="LN772"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ec_members</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of EquivalenceMembers */ 
</span><a name="LN773"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ec_sources</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of generating RestrictInfos */ 
</span><a name="LN774"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ec_derives</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of derived RestrictInfos */ 
</span><a name="LN775"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>ec_relids</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* all relids appearing in ec_members, except 
                                 * for child members (see below) */ 
</span><a name="LN777"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ec_has_const</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* any pseudoconstants in ec_members? */ 
</span><a name="LN778"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ec_has_volatile</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* the (sole) member is a volatile expr */ 
</span><a name="LN779"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ec_below_outer_join</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* equivalence applies below an OJ */ 
</span><a name="LN780"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>ec_broken</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* failed to generate needed clauses? */ 
</span><a name="LN781"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>ec_sortref</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* originating sortclause label, or 0 */ 
</span><a name="LN782"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>ec_min_security</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* minimum security_level in ec_sources */ 
</span><a name="LN783"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>ec_max_security</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* maximum security_level in ec_sources */ 
</span><a name="LN784"></a>    <span class='Control'>struct</span> <a href="relation.h.html#LN766"><span class='Ref_to_Struct'>EquivalenceClass</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ec_merged</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* set if merged into another EC */ 
</span><a name="LN785"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end EquivalenceClass &raquo; </span> <span class='Declare_Typedef'>EquivalenceClass</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * If an EC contains a const and isn't below-outer-join, any PathKey depending 
 * on it must be redundant, since there's only one possible value of the key. 
 */ 
</span><a name="LN791"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>EC_MUST_BE_REDUNDANT</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>eclass</span><span class='Parentheses'>)</span>  <span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="relation.h.html#LN791"><span class='Ref_to_Parameter'>eclass</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ec_has_const <span class='Operator'>&& !</span><span class='Parentheses'>(</span><a href="relation.h.html#LN791"><span class='Ref_to_Parameter'>eclass</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ec_below_outer_join<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * EquivalenceMember - one member expression of an EquivalenceClass 
 * 
 * em_is_child signifies that this element was built by transposing a member 
 * for an appendrel parent relation to represent the corresponding expression 
 * for an appendrel child.  These members are used for determining the 
 * pathkeys of scans on the child relation and for explicitly sorting the 
 * child when necessary to build a MergeAppend path for the whole appendrel 
 * tree.  An em_is_child member has no impact on the properties of the EC as a 
 * whole; in particular the EC's ec_relids field does NOT include the child 
 * relation.  An em_is_child member should never be marked em_is_const nor 
 * cause ec_has_const or ec_has_volatile to be set, either.  Thus, em_is_child 
 * members are not really full-fledged members of the EC, but just reflections 
 * or doppelgangers of real members.  Most operations on EquivalenceClasses 
 * should ignore em_is_child members, and those that don't should test 
 * em_relids to make sure they only consider relevant members. 
 * 
 * em_datatype is usually the same as exprType(em_expr), but can be 
 * different when dealing with a binary-compatible opfamily; in particular 
 * anyarray_ops would never work without this.  Use em_datatype when 
 * looking up a specific btree operator to work with this expression. 
 */ 
</span><a name="LN816"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>EquivalenceMember</span> 
<span class='Delimiter'>{ 
</span><a name="LN818"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN820"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>em_expr</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* the expression represented */ 
</span><a name="LN821"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>em_relids</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* all relids appearing in em_expr */ 
</span><a name="LN822"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>em_nullable_relids</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* nullable by lower outer joins */ 
</span><a name="LN823"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>em_is_const</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expression is pseudoconstant? */ 
</span><a name="LN824"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>em_is_child</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* derived version for a child relation? */ 
</span><a name="LN825"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>em_datatype</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* the "nominal type" used by the opfamily */ 
</span><a name="LN826"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>EquivalenceMember</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PathKeys 
 * 
 * The sort ordering of a path is represented by a list of PathKey nodes. 
 * An empty list implies no known ordering.  Otherwise the first item 
 * represents the primary sort key, the second the first secondary sort key, 
 * etc.  The value being sorted is represented by linking to an 
 * EquivalenceClass containing that value and including pk_opfamily among its 
 * ec_opfamilies.  The EquivalenceClass tells which collation to use, too. 
 * This is a convenient method because it makes it trivial to detect 
 * equivalent and closely-related orderings. (See optimizer/README for more 
 * information.) 
 * 
 * Note: pk_strategy is either BTLessStrategyNumber (for ASC) or 
 * BTGreaterStrategyNumber (for DESC).  We assume that all ordering-capable 
 * index types will use btree-compatible strategy numbers. 
 */ 
</span><a name="LN845"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PathKey</span> 
<span class='Delimiter'>{ 
</span><a name="LN847"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN849"></a>    <a href="relation.h.html#LN766"><span class='Ref_to_Struct'>EquivalenceClass</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pk_eclass</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* the value that is ordered */ 
</span><a name="LN850"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>pk_opfamily</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* btree opfamily defining the ordering */ 
</span><a name="LN851"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>pk_strategy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* sort direction (ASC or DESC) */ 
</span><a name="LN852"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>pk_nulls_first</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* do NULLs come before normal values? */ 
</span><a name="LN853"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PathKey</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * PathTarget 
 * 
 * This struct contains what we need to know during planning about the 
 * targetlist (output columns) that a Path will compute.  Each RelOptInfo 
 * includes a default PathTarget, which its individual Paths may simply 
 * reference.  However, in some cases a Path may compute outputs different 
 * from other Paths, and in that case we make a custom PathTarget for it. 
 * For example, an indexscan might return index expressions that would 
 * otherwise need to be explicitly calculated.  (Note also that "upper" 
 * relations generally don't have useful default PathTargets.) 
 * 
 * exprs contains bare expressions; they do not have TargetEntry nodes on top, 
 * though those will appear in finished Plans. 
 * 
 * sortgrouprefs[] is an array of the same length as exprs, containing the 
 * corresponding sort/group refnos, or zeroes for expressions not referenced 
 * by sort/group clauses.  If sortgrouprefs is NULL (which it generally is in 
 * RelOptInfo.reltarget targets; only upper-level Paths contain this info), 
 * we have not identified sort/group columns in this tlist.  This allows us to 
 * deal with sort/group refnos when needed with less expense than including 
 * TargetEntry nodes in the exprs list. 
 */ 
</span><a name="LN879"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PathTarget</span> 
<span class='Delimiter'>{ 
</span><a name="LN881"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN882"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>exprs</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* list of expressions to be computed */ 
</span><a name="LN883"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>sortgrouprefs</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* corresponding sort/group refnos, or 0 */ 
</span><a name="LN884"></a>    <a href="relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Member'>cost</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* cost of evaluating the expressions */ 
</span><a name="LN885"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>width</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* estimated avg width of result tuples */ 
</span><a name="LN886"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PathTarget</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Convenience macro to get a sort/group refno from a PathTarget */ 
</span><a name="LN889"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>get_pathtarget_sortgroupref</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>target</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>colno</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="relation.h.html#LN889"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>sortgrouprefs <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="relation.h.html#LN889"><span class='Ref_to_Parameter'>target</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>sortgrouprefs<span class='Delimiter'>[</span><a href="relation.h.html#LN889"><span class='Ref_to_Parameter'>colno</span></a><span class='Delimiter'>] </span><span class='Operator'>: </span><span class='Parentheses'>(</span><a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ParamPathInfo 
 * 
 * All parameterized paths for a given relation with given required outer rels 
 * link to a single ParamPathInfo, which stores common information such as 
 * the estimated rowcount for this parameterization.  We do this partly to 
 * avoid recalculations, but mostly to ensure that the estimated rowcount 
 * is in fact the same for every such path. 
 * 
 * Note: ppi_clauses is only used in ParamPathInfos for base relation paths; 
 * in join cases it's NIL because the set of relevant clauses varies depending 
 * on how the join is formed.  The relevant clauses will appear in each 
 * parameterized join path's joinrestrictinfo list, instead. 
 */ 
</span><a name="LN907"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ParamPathInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN909"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN911"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>ppi_req_outer</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* rels supplying parameters used by path */ 
</span><a name="LN912"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>ppi_rows</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* estimated number of result tuples */ 
</span><a name="LN913"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>ppi_clauses</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* join clauses available from outer rels */ 
</span><a name="LN914"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ParamPathInfo</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Type "Path" is used as-is for sequential-scan paths, as well as some other 
 * simple plan types that we don't need any extra information in the path for. 
 * For other path types it is the first component of a larger struct. 
 * 
 * "pathtype" is the NodeTag of the Plan node we could build from this Path. 
 * It is partially redundant with the Path's NodeTag, but allows us to use 
 * the same Path type for multiple Plan types when there is no need to 
 * distinguish the Plan type during path processing. 
 * 
 * "parent" identifies the relation this Path scans, and "pathtarget" 
 * describes the precise set of output columns the Path would compute. 
 * In simple cases all Paths for a given rel share the same targetlist, 
 * which we represent by having path-&GT;pathtarget equal to parent-&GT;reltarget. 
 * 
 * "param_info", if not NULL, links to a ParamPathInfo that identifies outer 
 * relation(s) that provide parameter values to each scan of this path. 
 * That means this path can only be joined to those rels by means of nestloop 
 * joins with this path on the inside.  Also note that a parameterized path 
 * is responsible for testing all "movable" joinclauses involving this rel 
 * and the specified outer rel(s). 
 * 
 * "rows" is the same as parent-&GT;rows in simple paths, but in parameterized 
 * paths and UniquePaths it can be less than parent-&GT;rows, reflecting the 
 * fact that we've filtered by extra join conditions or removed duplicates. 
 * 
 * "pathkeys" is a List of PathKey nodes (see above), describing the sort 
 * ordering of the path's output rows. 
 */ 
</span><a name="LN946"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Path</span> 
<span class='Delimiter'>{ 
</span><a name="LN948"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN950"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>pathtype</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* tag identifying scan/join method */ 
</span> 
<a name="LN952"></a>    <a href="relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>parent</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the relation this path can build */ 
</span><a name="LN953"></a>    <a href="relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Member'>pathtarget</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of Vars/Exprs, cost, width */ 
</span> 
<a name="LN955"></a>    <a href="relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>param_info</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* parameterization info, or NULL if none */ 
</span> 
<a name="LN957"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallel_aware</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* engage parallel-aware logic? */ 
</span><a name="LN958"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>parallel_safe</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OK to use as part of parallel plan? */ 
</span><a name="LN959"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>parallel_workers</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* desired # of workers; 0 = not 
                                         * parallel */ 
</span> 
    <span class='Comment_Multi_Line'>/* estimated size/costs for path (see costsize.c for more info) */ 
</span><a name="LN963"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>rows</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* estimated number of result tuples */ 
</span><a name="LN964"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>startup_cost</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* cost expended before fetching any tuples */ 
</span><a name="LN965"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>total_cost</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* total cost (assuming all tuples fetched) */ 
</span> 
<a name="LN967"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>pathkeys</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* sort ordering of path's output */ 
</span>    <span class='Comment_Multi_Line'>/* pathkeys is a List of PathKey nodes; see above */ 
</span><a name="LN969"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end Path &raquo; </span> <span class='Declare_Typedef'>Path</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Macro for extracting a path's parameterization relids; beware double eval */ 
</span><a name="LN972"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>PATH_REQ_OUTER</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>path</span><span class='Parentheses'>)</span>  <span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="relation.h.html#LN972"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>param_info <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="relation.h.html#LN972"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>param_info<span class='Operator'>-&GT;</span>ppi_req_outer <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/*---------- 
 * IndexPath represents an index scan over a single index. 
 * 
 * This struct is used for both regular indexscans and index-only scans; 
 * path.pathtype is T_IndexScan or T_IndexOnlyScan to show which is meant. 
 * 
 * 'indexinfo' is the index to be scanned. 
 * 
 * 'indexclauses' is a list of index qualification clauses, with implicit 
 * AND semantics across the list.  Each clause is a RestrictInfo node from 
 * the query's WHERE or JOIN conditions.  An empty list implies a full 
 * index scan. 
 * 
 * 'indexquals' has the same structure as 'indexclauses', but it contains 
 * the actual index qual conditions that can be used with the index. 
 * In simple cases this is identical to 'indexclauses', but when special 
 * indexable operators appear in 'indexclauses', they are replaced by the 
 * derived indexscannable conditions in 'indexquals'. 
 * 
 * 'indexqualcols' is an integer list of index column numbers (zero-based) 
 * of the same length as 'indexquals', showing which index column each qual 
 * is meant to be used with.  'indexquals' is required to be ordered by 
 * index column, so 'indexqualcols' must form a nondecreasing sequence. 
 * (The order of multiple quals for the same index column is unspecified.) 
 * 
 * 'indexorderbys', if not NIL, is a list of ORDER BY expressions that have 
 * been found to be usable as ordering operators for an amcanorderbyop index. 
 * The list must match the path's pathkeys, ie, one expression per pathkey 
 * in the same order.  These are not RestrictInfos, just bare expressions, 
 * since they generally won't yield booleans.  Also, unlike the case for 
 * quals, it's guaranteed that each expression has the index key on the left 
 * side of the operator. 
 * 
 * 'indexorderbycols' is an integer list of index column numbers (zero-based) 
 * of the same length as 'indexorderbys', showing which index column each 
 * ORDER BY expression is meant to be used with.  (There is no restriction 
 * on which index column each ORDER BY can be used with.) 
 * 
 * 'indexscandir' is one of: 
 *      ForwardScanDirection: forward scan of an ordered index 
 *      BackwardScanDirection: backward scan of an ordered index 
 *      NoMovementScanDirection: scan of an unordered index, or don't care 
 * (The executor doesn't care whether it gets ForwardScanDirection or 
 * NoMovementScanDirection for an indexscan, but the planner wants to 
 * distinguish ordered from unordered indexes for building pathkeys.) 
 * 
 * 'indextotalcost' and 'indexselectivity' are saved in the IndexPath so that 
 * we need not recompute them when considering using the same index in a 
 * bitmap index/heap scan (see BitmapHeapPath).  The costs of the IndexPath 
 * itself represent the costs of an IndexScan or IndexOnlyScan plan type. 
 *---------- 
 */ 
</span><a name="LN1027"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>IndexPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1029"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1030"></a>    <a href="relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>indexinfo</span><span class='Delimiter'>; 
</span><a name="LN1031"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexclauses</span><span class='Delimiter'>; 
</span><a name="LN1032"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexquals</span><span class='Delimiter'>; 
</span><a name="LN1033"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexqualcols</span><span class='Delimiter'>; 
</span><a name="LN1034"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexorderbys</span><span class='Delimiter'>; 
</span><a name="LN1035"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>indexorderbycols</span><span class='Delimiter'>; 
</span><a name="LN1036"></a>    <a href="../access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Member'>indexscandir</span><span class='Delimiter'>; 
</span><a name="LN1037"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>indextotalcost</span><span class='Delimiter'>; 
</span><a name="LN1038"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>indexselectivity</span><span class='Delimiter'>; 
</span><a name="LN1039"></a>} <span class='Declare_Typedef'>IndexPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BitmapHeapPath represents one or more indexscans that generate TID bitmaps 
 * instead of directly accessing the heap, followed by AND/OR combinations 
 * to produce a single bitmap, followed by a heap scan that uses the bitmap. 
 * Note that the output is always considered unordered, since it will come 
 * out in physical heap order no matter what the underlying indexes did. 
 * 
 * The individual indexscans are represented by IndexPath nodes, and any 
 * logic on top of them is represented by a tree of BitmapAndPath and 
 * BitmapOrPath nodes.  Notice that we can use the same IndexPath node both 
 * to represent a regular (or index-only) index scan plan, and as the child 
 * of a BitmapHeapPath that represents scanning the same index using a 
 * BitmapIndexScan.  The startup_cost and total_cost figures of an IndexPath 
 * always represent the costs to use it as a regular (or index-only) 
 * IndexScan.  The costs of a BitmapIndexScan can be computed using the 
 * IndexPath's indextotalcost and indexselectivity. 
 */ 
</span><a name="LN1058"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapHeapPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1060"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1061"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>bitmapqual</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* IndexPath, BitmapAndPath, BitmapOrPath */ 
</span><a name="LN1062"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BitmapHeapPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BitmapAndPath represents a BitmapAnd plan node; it can only appear as 
 * part of the substructure of a BitmapHeapPath.  The Path structure is 
 * a bit more heavyweight than we really need for this, but for simplicity 
 * we make it a derivative of Path anyway. 
 */ 
</span><a name="LN1070"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapAndPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1072"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1073"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>bitmapquals</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* IndexPaths and BitmapOrPaths */ 
</span><a name="LN1074"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>bitmapselectivity</span><span class='Delimiter'>; 
</span><a name="LN1075"></a>} <span class='Declare_Typedef'>BitmapAndPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BitmapOrPath represents a BitmapOr plan node; it can only appear as 
 * part of the substructure of a BitmapHeapPath.  The Path structure is 
 * a bit more heavyweight than we really need for this, but for simplicity 
 * we make it a derivative of Path anyway. 
 */ 
</span><a name="LN1083"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BitmapOrPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1085"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1086"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>bitmapquals</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* IndexPaths and BitmapAndPaths */ 
</span><a name="LN1087"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>bitmapselectivity</span><span class='Delimiter'>; 
</span><a name="LN1088"></a>} <span class='Declare_Typedef'>BitmapOrPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * TidPath represents a scan by TID 
 * 
 * tidquals is an implicitly OR'ed list of qual expressions of the form 
 * "CTID = pseudoconstant" or "CTID = ANY(pseudoconstant_array)". 
 * Note they are bare expressions, not RestrictInfos. 
 */ 
</span><a name="LN1097"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TidPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1099"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1100"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>tidquals</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* qual(s) involving CTID = something */ 
</span><a name="LN1101"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TidPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SubqueryScanPath represents a scan of an unflattened subquery-in-FROM 
 * 
 * Note that the subpath comes from a different planning domain; for example 
 * RTE indexes within it mean something different from those known to the 
 * SubqueryScanPath.  path.parent-&GT;subroot is the planning context needed to 
 * interpret the subpath. 
 */ 
</span><a name="LN1111"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SubqueryScanPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1113"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1114"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing subquery execution */ 
</span><a name="LN1115"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SubqueryScanPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ForeignPath represents a potential scan of a foreign table, foreign join 
 * or foreign upper-relation. 
 * 
 * fdw_private stores FDW private data about the scan.  While fdw_private is 
 * not actually touched by the core code during normal operations, it's 
 * generally a good idea to use a representation that can be dumped by 
 * nodeToString(), so that you can examine the structure during debugging 
 * with tools like pprint(). 
 */ 
</span><a name="LN1127"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ForeignPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1129"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1130"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_outerpath</span><span class='Delimiter'>; 
</span><a name="LN1131"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>fdw_private</span><span class='Delimiter'>; 
</span><a name="LN1132"></a>} <span class='Declare_Typedef'>ForeignPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CustomPath represents a table scan done by some out-of-core extension. 
 * 
 * We provide a set of hooks here - which the provider must take care to set 
 * up correctly - to allow extensions to supply their own methods of scanning 
 * a relation.  For example, a provider might provide GPU acceleration, a 
 * cache-based scan, or some other kind of logic we haven't dreamed up yet. 
 * 
 * CustomPaths can be injected into the planning process for a relation by 
 * set_rel_pathlist_hook functions. 
 * 
 * Core code must avoid assuming that the CustomPath is only as large as 
 * the structure declared here; providers are allowed to make it the first 
 * element in a larger structure.  (Since the planner never copies Paths, 
 * this doesn't add any complication.)  However, for consistency with the 
 * FDW case, we provide a "custom_private" field in CustomPath; providers 
 * may prefer to use that rather than define another struct type. 
 */ 
</span> 
<span class='Control'>struct</span> <a href="extensible.h.html#LN87"><span class='Ref_to_Struct'>CustomPathMethods</span></a><span class='Delimiter'>; 
</span> 
<a name="LN1155"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>CustomPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1157"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1158"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>flags</span><span class='Delimiter'>;</span>          <span class='Comment_Multi_Line'>/* mask of CUSTOMPATH_* flags, see 
                                 * nodes/extensible.h */ 
</span><a name="LN1160"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>custom_paths</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of child Path nodes, if any */ 
</span><a name="LN1161"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>custom_private</span><span class='Delimiter'>; 
</span><a name="LN1162"></a>    <span class='Keyword'>const </span><span class='Control'>struct</span> <a href="extensible.h.html#LN87"><span class='Ref_to_Struct'>CustomPathMethods</span></a> <span class='Operator'>*</span><span class='Declare_Member'>methods</span><span class='Delimiter'>; 
</span><a name="LN1163"></a>} <span class='Declare_Typedef'>CustomPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AppendPath represents an Append plan, ie, successive execution of 
 * several member plans. 
 * 
 * Note: it is possible for "subpaths" to contain only one, or even no, 
 * elements.  These cases are optimized during create_append_plan. 
 * In particular, an AppendPath with no subpaths is a "dummy" path that 
 * is created to represent the case that a relation is provably empty. 
 */ 
</span><a name="LN1174"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AppendPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1176"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* RT indexes of non-leaf tables in a partition tree */ 
</span><a name="LN1178"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitioned_rels</span><span class='Delimiter'>; 
</span><a name="LN1179"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpaths</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of component Paths */ 
</span><a name="LN1180"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AppendPath</span><span class='Delimiter'>; 
</span> 
<a name="LN1182"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_DUMMY_PATH</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>p</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>((</span><a href="relation.h.html#LN1182"><span class='Ref_to_Parameter'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="relation.h.html#LN1174"><span class='Ref_to_Struct'>AppendPath</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& </span><span class='Parentheses'>((</span><a href="relation.h.html#LN1174"><span class='Ref_to_Struct'>AppendPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="relation.h.html#LN1182"><span class='Ref_to_Parameter'>p</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>subpaths <span class='Operator'>== </span><a href="pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* A relation that's been proven empty will have one path that is dummy */ 
</span><a name="LN1186"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IS_DUMMY_REL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="relation.h.html#LN1186"><span class='Ref_to_Parameter'>r</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>cheapest_total_path <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& \ 
</span>     <a href="relation.h.html#LN1182"><span class='Ref_to_Macro'>IS_DUMMY_PATH</span></a><span class='Parentheses'>((</span><a href="relation.h.html#LN1186"><span class='Ref_to_Parameter'>r</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>cheapest_total_path<span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * MergeAppendPath represents a MergeAppend plan, ie, the merging of sorted 
 * results from several member plans to produce similarly-sorted output. 
 */ 
</span><a name="LN1194"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MergeAppendPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1196"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* RT indexes of non-leaf tables in a partition tree */ 
</span><a name="LN1198"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitioned_rels</span><span class='Delimiter'>; 
</span><a name="LN1199"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpaths</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of component Paths */ 
</span><a name="LN1200"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>limit_tuples</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hard limit on output tuples, or -1 */ 
</span><a name="LN1201"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MergeAppendPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ResultPath represents use of a Result plan node to compute a variable-free 
 * targetlist with no underlying tables (a "SELECT expressions" query). 
 * The query could have a WHERE clause, too, represented by "quals". 
 * 
 * Note that quals is a list of bare clauses, not RestrictInfos. 
 */ 
</span><a name="LN1210"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ResultPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1212"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1213"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>quals</span><span class='Delimiter'>; 
</span><a name="LN1214"></a>} <span class='Declare_Typedef'>ResultPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * MaterialPath represents use of a Material plan node, i.e., caching of 
 * the output of its subpath.  This is used when the subpath is expensive 
 * and needs to be scanned repeatedly, or when we need mark/restore ability 
 * and the subpath doesn't have it. 
 */ 
</span><a name="LN1222"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MaterialPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1224"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1225"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>; 
</span><a name="LN1226"></a>} <span class='Declare_Typedef'>MaterialPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * UniquePath represents elimination of distinct rows from the output of 
 * its subpath. 
 * 
 * This can represent significantly different plans: either hash-based or 
 * sort-based implementation, or a no-op if the input path can be proven 
 * distinct already.  The decision is sufficiently localized that it's not 
 * worth having separate Path node types.  (Note: in the no-op case, we could 
 * eliminate the UniquePath node entirely and just return the subpath; but 
 * it's convenient to have a UniquePath in the path tree to signal upper-level 
 * routines that the input is known distinct.) 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN1242"></a>    <span class='Declare_Enum_Const'>UNIQUE_PATH_NOOP</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* input is known unique already */ 
</span><a name="LN1243"></a>    <span class='Declare_Enum_Const'>UNIQUE_PATH_HASH</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* use hashing */ 
</span><a name="LN1244"></a>    <span class='Declare_Enum_Const'>UNIQUE_PATH_SORT</span>            <span class='Comment_Single_Line'>/* use sorting */ 
</span><a name="LN1245"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UniquePathMethod</span><span class='Delimiter'>; 
</span> 
<a name="LN1247"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>UniquePath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1249"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1250"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>; 
</span><a name="LN1251"></a>    <a href="relation.h.html#LN1240"><span class='Ref_to_Typedef'>UniquePathMethod</span></a> <span class='Declare_Member'>umethod</span><span class='Delimiter'>; 
</span><a name="LN1252"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>in_operators</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* equality operators of the IN clause */ 
</span><a name="LN1253"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>uniq_exprs</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* expressions to be made unique */ 
</span><a name="LN1254"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UniquePath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GatherPath runs several copies of a plan in parallel and collects the 
 * results.  The parallel leader may also execute the plan, unless the 
 * single_copy flag is set. 
 */ 
</span><a name="LN1261"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GatherPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1263"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1264"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path for each worker */ 
</span><a name="LN1265"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>single_copy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* don't execute path more than once */ 
</span><a name="LN1266"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_workers</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of workers sought to help */ 
</span><a name="LN1267"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GatherPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GatherMergePath runs several copies of a plan in parallel and 
 * collects the results. For gather merge parallel leader always execute the 
 * plan. 
 */ 
</span><a name="LN1274"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GatherMergePath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1276"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1277"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path for each worker */ 
</span><a name="LN1278"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_workers</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of workers sought to help */ 
</span><a name="LN1279"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GatherMergePath</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * All join-type paths share these fields. 
 */ 
</span> 
<a name="LN1286"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>JoinPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1288"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span> 
<a name="LN1290"></a>    <a href="nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Member'>jointype</span><span class='Delimiter'>; 
</span> 
<a name="LN1292"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inner_unique</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* each outer tuple provably matches no more 
                                 * than one inner tuple */ 
</span> 
<a name="LN1295"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>outerjoinpath</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* path for the outer side of the join */ 
</span><a name="LN1296"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>innerjoinpath</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* path for the inner side of the join */ 
</span> 
<a name="LN1298"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>joinrestrictinfo</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* RestrictInfos to apply to join */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See the notes for RelOptInfo and ParamPathInfo to understand why 
     * joinrestrictinfo is needed in JoinPath, and can't be merged into the 
     * parent RelOptInfo. 
     */ 
</span><a name="LN1305"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end JoinPath &raquo; </span> <span class='Declare_Typedef'>JoinPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A nested-loop path needs no special fields. 
 */ 
</span> 
<a name="LN1311"></a><span class='Control'>typedef</span> <a href="relation.h.html#LN1286"><span class='Ref_to_Struct'>JoinPath</span></a> <span class='Declare_Typedef'>NestPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A mergejoin path has these fields. 
 * 
 * Unlike other path types, a MergePath node doesn't represent just a single 
 * run-time plan node: it can represent up to four.  Aside from the MergeJoin 
 * node itself, there can be a Sort node for the outer input, a Sort node 
 * for the inner input, and/or a Material node for the inner input.  We could 
 * represent these nodes by separate path nodes, but considering how many 
 * different merge paths are investigated during a complex join problem, 
 * it seems better to avoid unnecessary palloc overhead. 
 * 
 * path_mergeclauses lists the clauses (in the form of RestrictInfos) 
 * that will be used in the merge. 
 * 
 * Note that the mergeclauses are a subset of the parent relation's 
 * restriction-clause list.  Any join clauses that are not mergejoinable 
 * appear only in the parent's restrict list, and must be checked by a 
 * qpqual at execution time. 
 * 
 * outersortkeys (resp. innersortkeys) is NIL if the outer path 
 * (resp. inner path) is already ordered appropriately for the 
 * mergejoin.  If it is not NIL then it is a PathKeys list describing 
 * the ordering that must be created by an explicit Sort node. 
 * 
 * skip_mark_restore is TRUE if the executor need not do mark/restore calls. 
 * Mark/restore overhead is usually required, but can be skipped if we know 
 * that the executor need find only one match per outer tuple, and that the 
 * mergeclauses are sufficient to identify a match.  In such cases the 
 * executor can immediately advance the outer relation after processing a 
 * match, and therefoere it need never back up the inner relation. 
 * 
 * materialize_inner is TRUE if a Material node should be placed atop the 
 * inner input.  This may appear with or without an inner Sort step. 
 */ 
</span> 
<a name="LN1348"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MergePath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1350"></a>    <a href="relation.h.html#LN1286"><span class='Ref_to_Struct'>JoinPath</span></a>    <span class='Declare_Member'>jpath</span><span class='Delimiter'>; 
</span><a name="LN1351"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>path_mergeclauses</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* join clauses to be used for merge */ 
</span><a name="LN1352"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>outersortkeys</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* keys for explicit sort, if any */ 
</span><a name="LN1353"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>innersortkeys</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* keys for explicit sort, if any */ 
</span><a name="LN1354"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>skip_mark_restore</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* can executor skip mark/restore? */ 
</span><a name="LN1355"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>materialize_inner</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* add Materialize to inner? */ 
</span><a name="LN1356"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MergePath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A hashjoin path has these fields. 
 * 
 * The remarks above for mergeclauses apply for hashclauses as well. 
 * 
 * Hashjoin does not care what order its inputs appear in, so we have 
 * no need for sortkeys. 
 */ 
</span> 
<a name="LN1367"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>HashPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1369"></a>    <a href="relation.h.html#LN1286"><span class='Ref_to_Struct'>JoinPath</span></a>    <span class='Declare_Member'>jpath</span><span class='Delimiter'>; 
</span><a name="LN1370"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>path_hashclauses</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* join clauses used for hashing */ 
</span><a name="LN1371"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_batches</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of batches expected */ 
</span><a name="LN1372"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>HashPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProjectionPath represents a projection (that is, targetlist computation) 
 * 
 * Nominally, this path node represents using a Result plan node to do a 
 * projection step.  However, if the input plan node supports projection, 
 * we can just modify its output targetlist to do the required calculations 
 * directly, and not need a Result.  In some places in the planner we can just 
 * jam the desired PathTarget into the input path node (and adjust its cost 
 * accordingly), so we don't need a ProjectionPath.  But in other places 
 * it's necessary to not modify the input path node, so we need a separate 
 * ProjectionPath node, which is marked dummy to indicate that we intend to 
 * assign the work to the input plan node.  The estimated cost for the 
 * ProjectionPath node will account for whether a Result will be used or not. 
 */ 
</span><a name="LN1388"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ProjectionPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1390"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1391"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1392"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>dummypp</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* true if no separate Result is needed */ 
</span><a name="LN1393"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ProjectionPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProjectSetPath represents evaluation of a targetlist that includes 
 * set-returning function(s), which will need to be implemented by a 
 * ProjectSet plan node. 
 */ 
</span><a name="LN1400"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ProjectSetPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1402"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1403"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1404"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ProjectSetPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SortPath represents an explicit sort step 
 * 
 * The sort keys are, by definition, the same as path.pathkeys. 
 * 
 * Note: the Sort plan node cannot project, so path.pathtarget must be the 
 * same as the input's pathtarget. 
 */ 
</span><a name="LN1414"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SortPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1416"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1417"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1418"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SortPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GroupPath represents grouping (of presorted input) 
 * 
 * groupClause represents the columns to be grouped on; the input path 
 * must be at least that well sorted. 
 * 
 * We can also apply a qual to the grouped rows (equivalent of HAVING) 
 */ 
</span><a name="LN1428"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GroupPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1430"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1431"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1432"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* a list of SortGroupClause's */ 
</span><a name="LN1433"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* quals (HAVING quals), if any */ 
</span><a name="LN1434"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GroupPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * UpperUniquePath represents adjacent-duplicate removal (in presorted input) 
 * 
 * The columns to be compared are the first numkeys columns of the path's 
 * pathkeys.  The input is presumed already sorted that way. 
 */ 
</span><a name="LN1442"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>UpperUniquePath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1444"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1445"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1446"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numkeys</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of pathkey columns to compare */ 
</span><a name="LN1447"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UpperUniquePath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AggPath represents generic computation of aggregate functions 
 * 
 * This may involve plain grouping (but not grouping sets), using either 
 * sorted or hashed grouping; for the AGG_SORTED case, the input must be 
 * appropriately presorted. 
 */ 
</span><a name="LN1456"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1458"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1459"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1460"></a>    <a href="nodes.h.html#LN733"><span class='Ref_to_Enum'>AggStrategy</span></a> <span class='Declare_Member'>aggstrategy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* basic strategy, see nodes.h */ 
</span><a name="LN1461"></a>    <a href="nodes.h.html#LN755"><span class='Ref_to_Enum'>AggSplit</span></a>    <span class='Declare_Member'>aggsplit</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* agg-splitting mode, see nodes.h */ 
</span><a name="LN1462"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* estimated number of groups in input */ 
</span><a name="LN1463"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* a list of SortGroupClause's */ 
</span><a name="LN1464"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* quals (HAVING quals), if any */ 
</span><a name="LN1465"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AggPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Various annotations used for grouping sets in the planner. 
 */ 
</span> 
<a name="LN1471"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GroupingSetData</span> 
<span class='Delimiter'>{ 
</span><a name="LN1473"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1474"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>set</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* grouping set as list of sortgrouprefs */ 
</span><a name="LN1475"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* est. number of result groups */ 
</span><a name="LN1476"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GroupingSetData</span><span class='Delimiter'>; 
</span> 
<a name="LN1478"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RollupData</span> 
<span class='Delimiter'>{ 
</span><a name="LN1480"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1481"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>groupClause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* applicable subset of parse-&GT;groupClause */ 
</span><a name="LN1482"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>gsets</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* lists of integer indexes into groupClause */ 
</span><a name="LN1483"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>gsets_data</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of GroupingSetData */ 
</span><a name="LN1484"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* est. number of result groups */ 
</span><a name="LN1485"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>hashable</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* can be hashed */ 
</span><a name="LN1486"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_hashed</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* to be implemented as a hashagg */ 
</span><a name="LN1487"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RollupData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GroupingSetsPath represents a GROUPING SETS aggregation 
 */ 
</span> 
<a name="LN1493"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>GroupingSetsPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1495"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1496"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1497"></a>    <a href="nodes.h.html#LN733"><span class='Ref_to_Enum'>AggStrategy</span></a> <span class='Declare_Member'>aggstrategy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* basic strategy */ 
</span><a name="LN1498"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rollups</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of RollupData */ 
</span><a name="LN1499"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* quals (HAVING quals), if any */ 
</span><a name="LN1500"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>GroupingSetsPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * MinMaxAggPath represents computation of MIN/MAX aggregates from indexes 
 */ 
</span><a name="LN1505"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MinMaxAggPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1507"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1508"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>mmaggregates</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* list of MinMaxAggInfo */ 
</span><a name="LN1509"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>quals</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* HAVING quals, if any */ 
</span><a name="LN1510"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MinMaxAggPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * WindowAggPath represents generic computation of window functions 
 * 
 * Note: winpathkeys is separate from path.pathkeys because the actual sort 
 * order might be an extension of winpathkeys; but createplan.c needs to 
 * know exactly how many pathkeys match the window clause. 
 */ 
</span><a name="LN1519"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>WindowAggPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1521"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1522"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1523"></a>    <a href="parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Member'>winclause</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* WindowClause we'll be using */ 
</span><a name="LN1524"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>winpathkeys</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* PathKeys for PARTITION keys + ORDER keys */ 
</span><a name="LN1525"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>WindowAggPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SetOpPath represents a set-operation, that is INTERSECT or EXCEPT 
 */ 
</span><a name="LN1530"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SetOpPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1532"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1533"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1534"></a>    <a href="nodes.h.html#LN777"><span class='Ref_to_Enum'>SetOpCmd</span></a>    <span class='Declare_Member'>cmd</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* what to do, see nodes.h */ 
</span><a name="LN1535"></a>    <a href="nodes.h.html#LN785"><span class='Ref_to_Enum'>SetOpStrategy</span></a> <span class='Declare_Member'>strategy</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* how to do it, see nodes.h */ 
</span><a name="LN1536"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>distinctList</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* SortGroupClauses identifying target cols */ 
</span><a name="LN1537"></a>    <a href="../access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Member'>flagColIdx</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* where is the flag column, if any */ 
</span><a name="LN1538"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>firstFlag</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* flag value for first input relation */ 
</span><a name="LN1539"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* estimated number of groups in input */ 
</span><a name="LN1540"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SetOpPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RecursiveUnionPath represents a recursive UNION node 
 */ 
</span><a name="LN1545"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RecursiveUnionPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1547"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1548"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>leftpath</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* paths representing input sources */ 
</span><a name="LN1549"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rightpath</span><span class='Delimiter'>; 
</span><a name="LN1550"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>distinctList</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* SortGroupClauses identifying target cols */ 
</span><a name="LN1551"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>wtParam</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* ID of Param representing work table */ 
</span><a name="LN1552"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>numGroups</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* estimated number of groups in input */ 
</span><a name="LN1553"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RecursiveUnionPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LockRowsPath represents acquiring row locks for SELECT FOR UPDATE/SHARE 
 */ 
</span><a name="LN1558"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LockRowsPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1560"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1561"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1562"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowMarks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* a list of PlanRowMark's */ 
</span><a name="LN1563"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>epqParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ID of Param for EvalPlanQual re-eval */ 
</span><a name="LN1564"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LockRowsPath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ModifyTablePath represents performing INSERT/UPDATE/DELETE modifications 
 * 
 * We represent most things that will be in the ModifyTable plan node 
 * literally, except we have child Path(s) not Plan(s).  But analysis of the 
 * OnConflictExpr is deferred to createplan.c, as is collection of FDW data. 
 */ 
</span><a name="LN1573"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>ModifyTablePath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1575"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1576"></a>    <a href="nodes.h.html#LN647"><span class='Ref_to_Enum'>CmdType</span></a>     <span class='Declare_Member'>operation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* INSERT, UPDATE, or DELETE */ 
</span><a name="LN1577"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>canSetTag</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* do we set the command tag/es_processed? */ 
</span><a name="LN1578"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>nominalRelation</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Parent RT index for use of EXPLAIN */ 
</span>    <span class='Comment_Multi_Line'>/* RT indexes of non-leaf tables in a partition tree */ 
</span><a name="LN1580"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>partitioned_rels</span><span class='Delimiter'>; 
</span><a name="LN1581"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>resultRelations</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* integer list of RT indexes */ 
</span><a name="LN1582"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpaths</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Path(s) producing source data */ 
</span><a name="LN1583"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subroots</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* per-target-table PlannerInfos */ 
</span><a name="LN1584"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>withCheckOptionLists</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* per-target-table WCO lists */ 
</span><a name="LN1585"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>returningLists</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* per-target-table RETURNING tlists */ 
</span><a name="LN1586"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rowMarks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* PlanRowMarks (non-locking only) */ 
</span><a name="LN1587"></a>    <a href="primnodes.h.html#LN1482"><span class='Ref_to_Struct'>OnConflictExpr</span></a> <span class='Operator'>*</span><span class='Declare_Member'>onconflict</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* ON CONFLICT clause, or NULL */ 
</span><a name="LN1588"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>epqParam</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ID of Param for EvalPlanQual re-eval */ 
</span><a name="LN1589"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ModifyTablePath</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * LimitPath represents applying LIMIT/OFFSET restrictions 
 */ 
</span><a name="LN1594"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LimitPath</span> 
<span class='Delimiter'>{ 
</span><a name="LN1596"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Member'>path</span><span class='Delimiter'>; 
</span><a name="LN1597"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>subpath</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* path representing input source */ 
</span><a name="LN1598"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitOffset</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* OFFSET parameter, or NULL if none */ 
</span><a name="LN1599"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>limitCount</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* COUNT parameter, or NULL if none */ 
</span><a name="LN1600"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LimitPath</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Restriction clause info. 
 * 
 * We create one of these for each AND sub-clause of a restriction condition 
 * (WHERE or JOIN/ON clause).  Since the restriction clauses are logically 
 * ANDed, we can use any one of them or any subset of them to filter out 
 * tuples, without having to evaluate the rest.  The RestrictInfo node itself 
 * stores data used by the optimizer while choosing the best query plan. 
 * 
 * If a restriction clause references a single base relation, it will appear 
 * in the baserestrictinfo list of the RelOptInfo for that base rel. 
 * 
 * If a restriction clause references more than one base rel, it will 
 * appear in the joininfo list of every RelOptInfo that describes a strict 
 * subset of the base rels mentioned in the clause.  The joininfo lists are 
 * used to drive join tree building by selecting plausible join candidates. 
 * The clause cannot actually be applied until we have built a join rel 
 * containing all the base rels it references, however. 
 * 
 * When we construct a join rel that includes all the base rels referenced 
 * in a multi-relation restriction clause, we place that clause into the 
 * joinrestrictinfo lists of paths for the join rel, if neither left nor 
 * right sub-path includes all base rels referenced in the clause.  The clause 
 * will be applied at that join level, and will not propagate any further up 
 * the join tree.  (Note: the "predicate migration" code was once intended to 
 * push restriction clauses up and down the plan tree based on evaluation 
 * costs, but it's dead code and is unlikely to be resurrected in the 
 * foreseeable future.) 
 * 
 * Note that in the presence of more than two rels, a multi-rel restriction 
 * might reach different heights in the join tree depending on the join 
 * sequence we use.  So, these clauses cannot be associated directly with 
 * the join RelOptInfo, but must be kept track of on a per-join-path basis. 
 * 
 * RestrictInfos that represent equivalence conditions (i.e., mergejoinable 
 * equalities that are not outerjoin-delayed) are handled a bit differently. 
 * Initially we attach them to the EquivalenceClasses that are derived from 
 * them.  When we construct a scan or join path, we look through all the 
 * EquivalenceClasses and generate derived RestrictInfos representing the 
 * minimal set of conditions that need to be checked for this particular scan 
 * or join to enforce that all members of each EquivalenceClass are in fact 
 * equal in all rows emitted by the scan or join. 
 * 
 * When dealing with outer joins we have to be very careful about pushing qual 
 * clauses up and down the tree.  An outer join's own JOIN/ON conditions must 
 * be evaluated exactly at that join node, unless they are "degenerate" 
 * conditions that reference only Vars from the nullable side of the join. 
 * Quals appearing in WHERE or in a JOIN above the outer join cannot be pushed 
 * down below the outer join, if they reference any nullable Vars. 
 * RestrictInfo nodes contain a flag to indicate whether a qual has been 
 * pushed down to a lower level than its original syntactic placement in the 
 * join tree would suggest.  If an outer join prevents us from pushing a qual 
 * down to its "natural" semantic level (the level associated with just the 
 * base rels used in the qual) then we mark the qual with a "required_relids" 
 * value including more than just the base rels it actually uses.  By 
 * pretending that the qual references all the rels required to form the outer 
 * join, we prevent it from being evaluated below the outer join's joinrel. 
 * When we do form the outer join's joinrel, we still need to distinguish 
 * those quals that are actually in that join's JOIN/ON condition from those 
 * that appeared elsewhere in the tree and were pushed down to the join rel 
 * because they used no other rels.  That's what the is_pushed_down flag is 
 * for; it tells us that a qual is not an OUTER JOIN qual for the set of base 
 * rels listed in required_relids.  A clause that originally came from WHERE 
 * or an INNER JOIN condition will *always* have its is_pushed_down flag set. 
 * It's possible for an OUTER JOIN clause to be marked is_pushed_down too, 
 * if we decide that it can be pushed down into the nullable side of the join. 
 * In that case it acts as a plain filter qual for wherever it gets evaluated. 
 * (In short, is_pushed_down is only false for non-degenerate outer join 
 * conditions.  Possibly we should rename it to reflect that meaning?) 
 * 
 * RestrictInfo nodes also contain an outerjoin_delayed flag, which is true 
 * if the clause's applicability must be delayed due to any outer joins 
 * appearing below it (ie, it has to be postponed to some join level higher 
 * than the set of relations it actually references). 
 * 
 * There is also an outer_relids field, which is NULL except for outer join 
 * clauses; for those, it is the set of relids on the outer side of the 
 * clause's outer join.  (These are rels that the clause cannot be applied to 
 * in parameterized scans, since pushing it into the join's outer side would 
 * lead to wrong answers.) 
 * 
 * There is also a nullable_relids field, which is the set of rels the clause 
 * references that can be forced null by some outer join below the clause. 
 * 
 * outerjoin_delayed = true is subtly different from nullable_relids != NULL: 
 * a clause might reference some nullable rels and yet not be 
 * outerjoin_delayed because it also references all the other rels of the 
 * outer join(s). A clause that is not outerjoin_delayed can be enforced 
 * anywhere it is computable. 
 * 
 * To handle security-barrier conditions efficiently, we mark RestrictInfo 
 * nodes with a security_level field, in which higher values identify clauses 
 * coming from less-trusted sources.  The exact semantics are that a clause 
 * cannot be evaluated before another clause with a lower security_level value 
 * unless the first clause is leakproof.  As with outer-join clauses, this 
 * creates a reason for clauses to sometimes need to be evaluated higher in 
 * the join tree than their contents would suggest; and even at a single plan 
 * node, this rule constrains the order of application of clauses. 
 * 
 * In general, the referenced clause might be arbitrarily complex.  The 
 * kinds of clauses we can handle as indexscan quals, mergejoin clauses, 
 * or hashjoin clauses are limited (e.g., no volatile functions).  The code 
 * for each kind of path is responsible for identifying the restrict clauses 
 * it can use and ignoring the rest.  Clauses not implemented by an indexscan, 
 * mergejoin, or hashjoin will be placed in the plan qual or joinqual field 
 * of the finished Plan node, where they will be enforced by general-purpose 
 * qual-expression-evaluation code.  (But we are still entitled to count 
 * their selectivity when estimating the result tuple count, if we 
 * can guess what it is...) 
 * 
 * When the referenced clause is an OR clause, we generate a modified copy 
 * in which additional RestrictInfo nodes are inserted below the top-level 
 * OR/AND structure.  This is a convenience for OR indexscan processing: 
 * indexquals taken from either the top level or an OR subclause will have 
 * associated RestrictInfo nodes. 
 * 
 * The can_join flag is set true if the clause looks potentially useful as 
 * a merge or hash join clause, that is if it is a binary opclause with 
 * nonoverlapping sets of relids referenced in the left and right sides. 
 * (Whether the operator is actually merge or hash joinable isn't checked, 
 * however.) 
 * 
 * The pseudoconstant flag is set true if the clause contains no Vars of 
 * the current query level and no volatile functions.  Such a clause can be 
 * pulled out and used as a one-time qual in a gating Result node.  We keep 
 * pseudoconstant clauses in the same lists as other RestrictInfos so that 
 * the regular clause-pushing machinery can assign them to the correct join 
 * level, but they need to be treated specially for cost and selectivity 
 * estimates.  Note that a pseudoconstant clause can never be an indexqual 
 * or merge or hash join clause, so it's of no interest to large parts of 
 * the planner. 
 * 
 * When join clauses are generated from EquivalenceClasses, there may be 
 * several equally valid ways to enforce join equivalence, of which we need 
 * apply only one.  We mark clauses of this kind by setting parent_ec to 
 * point to the generating EquivalenceClass.  Multiple clauses with the same 
 * parent_ec in the same join are redundant. 
 */ 
</span> 
<a name="LN1742"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RestrictInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN1744"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN1746"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>clause</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the represented clause of WHERE or JOIN */ 
</span> 
<a name="LN1748"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>is_pushed_down</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* TRUE if clause was pushed down in level */ 
</span> 
<a name="LN1750"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>outerjoin_delayed</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* TRUE if delayed by lower outer join */ 
</span> 
<a name="LN1752"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>can_join</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* see comment above */ 
</span> 
<a name="LN1754"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>pseudoconstant</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* see comment above */ 
</span> 
<a name="LN1756"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>leakproof</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* TRUE if known to contain no leaked Vars */ 
</span> 
<a name="LN1758"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>security_level</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* see comment above */ 
</span> 
    <span class='Comment_Multi_Line'>/* The set of relids (varnos) actually referenced in the clause: */ 
</span><a name="LN1761"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>clause_relids</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* The set of relids required to evaluate the clause: */ 
</span><a name="LN1764"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>required_relids</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If an outer-join clause, the outer-side relations, else NULL: */ 
</span><a name="LN1767"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>outer_relids</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* The relids used in the clause that are nullable by lower outer joins: */ 
</span><a name="LN1770"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>nullable_relids</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* These fields are set for any binary opclause: */ 
</span><a name="LN1773"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>left_relids</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* relids in left side of clause */ 
</span><a name="LN1774"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>right_relids</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* relids in right side of clause */ 
</span> 
    <span class='Comment_Multi_Line'>/* This field is NULL unless clause is an OR clause: */ 
</span><a name="LN1777"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>orclause</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* modified clause with RestrictInfos */ 
</span> 
    <span class='Comment_Multi_Line'>/* This field is NULL unless clause is potentially redundant: */ 
</span><a name="LN1780"></a>    <a href="relation.h.html#LN766"><span class='Ref_to_Struct'>EquivalenceClass</span></a> <span class='Operator'>*</span><span class='Declare_Member'>parent_ec</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* generating EquivalenceClass */ 
</span> 
    <span class='Comment_Multi_Line'>/* cache space for cost and selectivity */ 
</span><a name="LN1783"></a>    <a href="relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Member'>eval_cost</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* eval cost of clause; -1 if not yet set */ 
</span><a name="LN1784"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>norm_selec</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* selectivity for "normal" (JOIN_INNER) 
                                 * semantics; -1 if not yet set; &GT;1 means a 
                                 * redundant clause */ 
</span><a name="LN1787"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>outer_selec</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* selectivity for outer join semantics; -1 if 
                                 * not yet set */ 
</span> 
    <span class='Comment_Multi_Line'>/* valid if clause is mergejoinable, else NIL */ 
</span><a name="LN1791"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>mergeopfamilies</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* opfamilies containing clause operator */ 
</span> 
    <span class='Comment_Multi_Line'>/* cache space for mergeclause processing; NULL if not yet set */ 
</span><a name="LN1794"></a>    <a href="relation.h.html#LN766"><span class='Ref_to_Struct'>EquivalenceClass</span></a> <span class='Operator'>*</span><span class='Declare_Member'>left_ec</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* EquivalenceClass containing lefthand */ 
</span><a name="LN1795"></a>    <a href="relation.h.html#LN766"><span class='Ref_to_Struct'>EquivalenceClass</span></a> <span class='Operator'>*</span><span class='Declare_Member'>right_ec</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* EquivalenceClass containing righthand */ 
</span><a name="LN1796"></a>    <a href="relation.h.html#LN816"><span class='Ref_to_Struct'>EquivalenceMember</span></a> <span class='Operator'>*</span><span class='Declare_Member'>left_em</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* EquivalenceMember for lefthand */ 
</span><a name="LN1797"></a>    <a href="relation.h.html#LN816"><span class='Ref_to_Struct'>EquivalenceMember</span></a> <span class='Operator'>*</span><span class='Declare_Member'>right_em</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* EquivalenceMember for righthand */ 
</span><a name="LN1798"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>scansel_cache</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* list of MergeScanSelCache structs */ 
</span> 
    <span class='Comment_Multi_Line'>/* transient workspace for use while considering a specific join path */ 
</span><a name="LN1801"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>outer_is_left</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* T = outer var on left, F = on right */ 
</span> 
    <span class='Comment_Multi_Line'>/* valid if clause is hashjoinable, else InvalidOid: */ 
</span><a name="LN1804"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>hashjoinoperator</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* copy of clause operator */ 
</span> 
    <span class='Comment_Multi_Line'>/* cache space for hashclause processing; -1 if not yet set */ 
</span><a name="LN1807"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>left_bucketsize</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* avg bucketsize of left side */ 
</span><a name="LN1808"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>right_bucketsize</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* avg bucketsize of right side */ 
</span><a name="LN1809"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end RestrictInfo &raquo; </span> <span class='Declare_Typedef'>RestrictInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Since mergejoinscansel() is a relatively expensive function, and would 
 * otherwise be invoked many times while planning a large join tree, 
 * we go out of our way to cache its results.  Each mergejoinable 
 * RestrictInfo carries a list of the specific sort orderings that have 
 * been considered for use with it, and the resulting selectivities. 
 */ 
</span><a name="LN1818"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MergeScanSelCache</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Ordering details (cache lookup key) */ 
</span><a name="LN1821"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>opfamily</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* btree opfamily defining the ordering */ 
</span><a name="LN1822"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collation</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* collation for the ordering */ 
</span><a name="LN1823"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>strategy</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* sort direction (ASC or DESC) */ 
</span><a name="LN1824"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>nulls_first</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* do NULLs come before normal values? */ 
</span>    <span class='Comment_Multi_Line'>/* Results */ 
</span><a name="LN1826"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>leftstartsel</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* first-join fraction for clause left side */ 
</span><a name="LN1827"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>leftendsel</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* last-join fraction for clause left side */ 
</span><a name="LN1828"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>rightstartsel</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* first-join fraction for clause right side */ 
</span><a name="LN1829"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>rightendsel</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* last-join fraction for clause right side */ 
</span><a name="LN1830"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MergeScanSelCache</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Placeholder node for an expression to be evaluated below the top level 
 * of a plan tree.  This is used during planning to represent the contained 
 * expression.  At the end of the planning process it is replaced by either 
 * the contained expression or a Var referring to a lower-level evaluation of 
 * the contained expression.  Typically the evaluation occurs below an outer 
 * join, and Var references above the outer join might thereby yield NULL 
 * instead of the expression value. 
 * 
 * Although the planner treats this as an expression node type, it is not 
 * recognized by the parser or executor, so we declare it here rather than 
 * in primnodes.h. 
 */ 
</span> 
<a name="LN1846"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlaceHolderVar</span> 
<span class='Delimiter'>{ 
</span><a name="LN1848"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>        <span class='Declare_Member'>xpr</span><span class='Delimiter'>; 
</span><a name="LN1849"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>phexpr</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the represented expression */ 
</span><a name="LN1850"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>phrels</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* base relids syntactically within expr src */ 
</span><a name="LN1851"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>phid</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ID for PHV (unique within planner run) */ 
</span><a name="LN1852"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>phlevelsup</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* &GT; 0 if PHV belongs to outer query */ 
</span><a name="LN1853"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PlaceHolderVar</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * "Special join" info. 
 * 
 * One-sided outer joins constrain the order of joining partially but not 
 * completely.  We flatten such joins into the planner's top-level list of 
 * relations to join, but record information about each outer join in a 
 * SpecialJoinInfo struct.  These structs are kept in the PlannerInfo node's 
 * join_info_list. 
 * 
 * Similarly, semijoins and antijoins created by flattening IN (subselect) 
 * and EXISTS(subselect) clauses create partial constraints on join order. 
 * These are likewise recorded in SpecialJoinInfo structs. 
 * 
 * We make SpecialJoinInfos for FULL JOINs even though there is no flexibility 
 * of planning for them, because this simplifies make_join_rel()'s API. 
 * 
 * min_lefthand and min_righthand are the sets of base relids that must be 
 * available on each side when performing the special join.  lhs_strict is 
 * true if the special join's condition cannot succeed when the LHS variables 
 * are all NULL (this means that an outer join can commute with upper-level 
 * outer joins even if it appears in their RHS).  We don't bother to set 
 * lhs_strict for FULL JOINs, however. 
 * 
 * It is not valid for either min_lefthand or min_righthand to be empty sets; 
 * if they were, this would break the logic that enforces join order. 
 * 
 * syn_lefthand and syn_righthand are the sets of base relids that are 
 * syntactically below this special join.  (These are needed to help compute 
 * min_lefthand and min_righthand for higher joins.) 
 * 
 * delay_upper_joins is set TRUE if we detect a pushed-down clause that has 
 * to be evaluated after this join is formed (because it references the RHS). 
 * Any outer joins that have such a clause and this join in their RHS cannot 
 * commute with this join, because that would leave noplace to check the 
 * pushed-down clause.  (We don't track this for FULL JOINs, either.) 
 * 
 * For a semijoin, we also extract the join operators and their RHS arguments 
 * and set semi_operators, semi_rhs_exprs, semi_can_btree, and semi_can_hash. 
 * This is done in support of possibly unique-ifying the RHS, so we don't 
 * bother unless at least one of semi_can_btree and semi_can_hash can be set 
 * true.  (You might expect that this information would be computed during 
 * join planning; but it's helpful to have it available during planning of 
 * parameterized table scans, so we store it in the SpecialJoinInfo structs.) 
 * 
 * jointype is never JOIN_RIGHT; a RIGHT JOIN is handled by switching 
 * the inputs to make it a LEFT JOIN.  So the allowed values of jointype 
 * in a join_info_list member are only LEFT, FULL, SEMI, or ANTI. 
 * 
 * For purposes of join selectivity estimation, we create transient 
 * SpecialJoinInfo structures for regular inner joins; so it is possible 
 * to have jointype == JOIN_INNER in such a structure, even though this is 
 * not allowed within join_info_list.  We also create transient 
 * SpecialJoinInfos with jointype == JOIN_INNER for outer joins, since for 
 * cost estimation purposes it is sometimes useful to know the join size under 
 * plain innerjoin semantics.  Note that lhs_strict, delay_upper_joins, and 
 * of course the semi_xxx fields are not set meaningfully within such structs. 
 */ 
</span> 
<a name="LN1913"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SpecialJoinInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN1915"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span><a name="LN1916"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>min_lefthand</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* base relids in minimum LHS for join */ 
</span><a name="LN1917"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>min_righthand</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* base relids in minimum RHS for join */ 
</span><a name="LN1918"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>syn_lefthand</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* base relids syntactically within LHS */ 
</span><a name="LN1919"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>syn_righthand</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* base relids syntactically within RHS */ 
</span><a name="LN1920"></a>    <a href="nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Member'>jointype</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* always INNER, LEFT, FULL, SEMI, or ANTI */ 
</span><a name="LN1921"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>lhs_strict</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* joinclause is strict for some LHS rel */ 
</span><a name="LN1922"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>delay_upper_joins</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* can't commute with upper RHS */ 
</span>    <span class='Comment_Multi_Line'>/* Remaining fields are set only for JOIN_SEMI jointype: */ 
</span><a name="LN1924"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>semi_can_btree</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* true if semi_operators are all btree */ 
</span><a name="LN1925"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>semi_can_hash</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* true if semi_operators are all hash */ 
</span><a name="LN1926"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>semi_operators</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* OIDs of equality join operators */ 
</span><a name="LN1927"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>semi_rhs_exprs</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* righthand-side expressions of these ops */ 
</span><a name="LN1928"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SpecialJoinInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Append-relation info. 
 * 
 * When we expand an inheritable table or a UNION-ALL subselect into an 
 * "append relation" (essentially, a list of child RTEs), we build an 
 * AppendRelInfo for each non-partitioned child RTE.  The list of 
 * AppendRelInfos indicates which child RTEs must be included when expanding 
 * the parent, and each node carries information needed to translate Vars 
 * referencing the parent into Vars referencing that child. 
 * 
 * These structs are kept in the PlannerInfo node's append_rel_list. 
 * Note that we just throw all the structs into one list, and scan the 
 * whole list when desiring to expand any one parent.  We could have used 
 * a more complex data structure (eg, one list per parent), but this would 
 * be harder to update during operations such as pulling up subqueries, 
 * and not really any easier to scan.  Considering that typical queries 
 * will not have many different append parents, it doesn't seem worthwhile 
 * to complicate things. 
 * 
 * Note: after completion of the planner prep phase, any given RTE is an 
 * append parent having entries in append_rel_list if and only if its 
 * "inh" flag is set.  We clear "inh" for plain tables that turn out not 
 * to have inheritance children, and (in an abuse of the original meaning 
 * of the flag) we set "inh" for subquery RTEs that turn out to be 
 * flattenable UNION ALL queries.  This lets us avoid useless searches 
 * of append_rel_list. 
 * 
 * Note: the data structure assumes that append-rel members are single 
 * baserels.  This is OK for inheritance, but it prevents us from pulling 
 * up a UNION ALL member subquery if it contains a join.  While that could 
 * be fixed with a more complex data structure, at present there's not much 
 * point because no improvement in the plan could result. 
 */ 
</span> 
<a name="LN1964"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AppendRelInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN1966"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These fields uniquely identify this append relationship.  There can be 
     * (in fact, always should be) multiple AppendRelInfos for the same 
     * parent_relid, but never more than one per child_relid, since a given 
     * RTE cannot be a child of more than one append parent. 
     */ 
</span><a name="LN1974"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>parent_relid</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* RT index of append parent rel */ 
</span><a name="LN1975"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>child_relid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* RT index of append child rel */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For an inheritance appendrel, the parent and child are both regular 
     * relations, and we store their rowtype OIDs here for use in translating 
     * whole-row Vars.  For a UNION-ALL appendrel, the parent and child are 
     * both subqueries with no named rowtype, and we store InvalidOid here. 
     */ 
</span><a name="LN1983"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>parent_reltype</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* OID of parent's composite type */ 
</span><a name="LN1984"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>child_reltype</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OID of child's composite type */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The N'th element of this list is a Var or expression representing the 
     * child column corresponding to the N'th column of the parent. This is 
     * used to translate Vars referencing the parent rel into references to 
     * the child.  A list element is NULL if it corresponds to a dropped 
     * column of the parent (this is only possible for inheritance cases, not 
     * UNION ALL).  The list elements are always simple Vars for inheritance 
     * cases, but can be arbitrary expressions in UNION ALL cases. 
     * 
     * Notice we only store entries for user columns (attno &GT; 0).  Whole-row 
     * Vars are special-cased, and system columns (attno &LT; 0) need no special 
     * translation since their attnos are the same for all tables. 
     * 
     * Caution: the Vars have varlevelsup = 0.  Be careful to adjust as needed 
     * when copying into a subquery. 
     */ 
</span><a name="LN2002"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>translated_vars</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* Expressions in the child's Vars */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We store the parent table's OID here for inheritance, or InvalidOid for 
     * UNION ALL.  This is only needed to help in generating error messages if 
     * an attempt is made to reference a dropped parent column. 
     */ 
</span><a name="LN2009"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>parent_reloid</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* OID of parent relation */ 
</span><a name="LN2010"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end AppendRelInfo &raquo; </span> <span class='Declare_Typedef'>AppendRelInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * For a partitioned table, this maps its RT index to the list of RT indexes 
 * of the partitioned child tables in the partition tree.  We need to 
 * separately store this information, because we do not create AppendRelInfos 
 * for the partitioned child tables of a parent table, since AppendRelInfos 
 * contain information that is unnecessary for the partitioned child tables. 
 * The child_rels list must contain at least one element, because the parent 
 * partitioned table is itself counted as a child. 
 * 
 * These structs are kept in the PlannerInfo node's pcinfo_list. 
 */ 
</span><a name="LN2023"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PartitionedChildRelInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN2025"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN2027"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>parent_relid</span><span class='Delimiter'>; 
</span><a name="LN2028"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>child_rels</span><span class='Delimiter'>; 
</span><a name="LN2029"></a>} <span class='Declare_Typedef'>PartitionedChildRelInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * For each distinct placeholder expression generated during planning, we 
 * store a PlaceHolderInfo node in the PlannerInfo node's placeholder_list. 
 * This stores info that is needed centrally rather than in each copy of the 
 * PlaceHolderVar.  The phid fields identify which PlaceHolderInfo goes with 
 * each PlaceHolderVar.  Note that phid is unique throughout a planner run, 
 * not just within a query level --- this is so that we need not reassign ID's 
 * when pulling a subquery into its parent. 
 * 
 * The idea is to evaluate the expression at (only) the ph_eval_at join level, 
 * then allow it to bubble up like a Var until the ph_needed join level. 
 * ph_needed has the same definition as attr_needed for a regular Var. 
 * 
 * The PlaceHolderVar's expression might contain LATERAL references to vars 
 * coming from outside its syntactic scope.  If so, those rels are *not* 
 * included in ph_eval_at, but they are recorded in ph_lateral. 
 * 
 * Notice that when ph_eval_at is a join rather than a single baserel, the 
 * PlaceHolderInfo may create constraints on join order: the ph_eval_at join 
 * has to be formed below any outer joins that should null the PlaceHolderVar. 
 * 
 * We create a PlaceHolderInfo only after determining that the PlaceHolderVar 
 * is actually referenced in the plan tree, so that unreferenced placeholders 
 * don't result in unnecessary constraints on join order. 
 */ 
</span> 
<a name="LN2057"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlaceHolderInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN2059"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN2061"></a>    <a href="../c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Member'>phid</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ID for PH (unique within planner run) */ 
</span><a name="LN2062"></a>    <a href="relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Member'>ph_var</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* copy of PlaceHolderVar tree */ 
</span><a name="LN2063"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>ph_eval_at</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* lowest level we can evaluate value at */ 
</span><a name="LN2064"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>ph_lateral</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* relids of contained lateral refs, if any */ 
</span><a name="LN2065"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>ph_needed</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* highest level the value is needed at */ 
</span><a name="LN2066"></a>    <a href="../c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>ph_width</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* estimated attribute width */ 
</span><a name="LN2067"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PlaceHolderInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This struct describes one potentially index-optimizable MIN/MAX aggregate 
 * function.  MinMaxAggPath contains a list of these, and if we accept that 
 * path, the list is stored into root-&GT;minmax_aggs for use during setrefs.c. 
 */ 
</span><a name="LN2074"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>MinMaxAggInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN2076"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN2078"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggfnoid</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* pg_proc Oid of the aggregate */ 
</span><a name="LN2079"></a>    <a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggsortop</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* Oid of its sort operator */ 
</span><a name="LN2080"></a>    <a href="primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>target</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* expression we are aggregating on */ 
</span><a name="LN2081"></a>    <a href="relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>subroot</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* modified "root" for planning the subquery */ 
</span><a name="LN2082"></a>    <a href="relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>path</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* access path for subquery */ 
</span><a name="LN2083"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>pathcost</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* estimated cost to fetch first row */ 
</span><a name="LN2084"></a>    <a href="primnodes.h.html#LN240"><span class='Ref_to_Struct'>Param</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>param</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* param for subplan's output */ 
</span><a name="LN2085"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>MinMaxAggInfo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * At runtime, PARAM_EXEC slots are used to pass values around from one plan 
 * node to another.  They can be used to pass values down into subqueries (for 
 * outer references in subqueries), or up out of subqueries (for the results 
 * of a subplan), or from a NestLoop plan node into its inner relation (when 
 * the inner scan is parameterized with values from the outer relation). 
 * The planner is responsible for assigning nonconflicting PARAM_EXEC IDs to 
 * the PARAM_EXEC Params it generates. 
 * 
 * Outer references are managed via root-&GT;plan_params, which is a list of 
 * PlannerParamItems.  While planning a subquery, each parent query level's 
 * plan_params contains the values required from it by the current subquery. 
 * During create_plan(), we use plan_params to track values that must be 
 * passed from outer to inner sides of NestLoop plan nodes. 
 * 
 * The item a PlannerParamItem represents can be one of three kinds: 
 * 
 * A Var: the slot represents a variable of this level that must be passed 
 * down because subqueries have outer references to it, or must be passed 
 * from a NestLoop node to its inner scan.  The varlevelsup value in the Var 
 * will always be zero. 
 * 
 * A PlaceHolderVar: this works much like the Var case, except that the 
 * entry is a PlaceHolderVar node with a contained expression.  The PHV 
 * will have phlevelsup = 0, and the contained expression is adjusted 
 * to match in level. 
 * 
 * An Aggref (with an expression tree representing its argument): the slot 
 * represents an aggregate expression that is an outer reference for some 
 * subquery.  The Aggref itself has agglevelsup = 0, and its argument tree 
 * is adjusted to match in level. 
 * 
 * Note: we detect duplicate Var and PlaceHolderVar parameters and coalesce 
 * them into one slot, but we do not bother to do that for Aggrefs. 
 * The scope of duplicate-elimination only extends across the set of 
 * parameters passed from one query level into a single subquery, or for 
 * nestloop parameters across the set of nestloop parameters used in a single 
 * query level.  So there is no possibility of a PARAM_EXEC slot being used 
 * for conflicting purposes. 
 * 
 * In addition, PARAM_EXEC slots are assigned for Params representing outputs 
 * from subplans (values that are setParam items for those subplans).  These 
 * IDs need not be tracked via PlannerParamItems, since we do not need any 
 * duplicate-elimination nor later processing of the represented expressions. 
 * Instead, we just record the assignment of the slot number by incrementing 
 * root-&GT;glob-&GT;nParamExec. 
 */ 
</span><a name="LN2134"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PlannerParamItem</span> 
<span class='Delimiter'>{ 
</span><a name="LN2136"></a>    <a href="nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a>     <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span> 
<a name="LN2138"></a>    <a href="nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>item</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* the Var, PlaceHolderVar, or Aggref */ 
</span><a name="LN2139"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>paramId</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* its assigned PARAM_EXEC slot number */ 
</span><a name="LN2140"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PlannerParamItem</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When making cost estimates for a SEMI/ANTI/inner_unique join, there are 
 * some correction factors that are needed in both nestloop and hash joins 
 * to account for the fact that the executor can stop scanning inner rows 
 * as soon as it finds a match to the current outer row.  These numbers 
 * depend only on the selected outer and inner join relations, not on the 
 * particular paths used for them, so it's worthwhile to calculate them 
 * just once per relation pair not once per considered path.  This struct 
 * is filled by compute_semi_anti_join_factors and must be passed along 
 * to the join cost estimation functions. 
 * 
 * outer_match_frac is the fraction of the outer tuples that are 
 *      expected to have at least one match. 
 * match_count is the average number of matches expected for 
 *      outer tuples that have at least one match. 
 */ 
</span><a name="LN2158"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SemiAntiJoinFactors</span> 
<span class='Delimiter'>{ 
</span><a name="LN2160"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>outer_match_frac</span><span class='Delimiter'>; 
</span><a name="LN2161"></a>    <a href="nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Member'>match_count</span><span class='Delimiter'>; 
</span><a name="LN2162"></a>} <span class='Declare_Typedef'>SemiAntiJoinFactors</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Struct for extra information passed to subroutines of add_paths_to_joinrel 
 * 
 * restrictlist contains all of the RestrictInfo nodes for restriction 
 *      clauses that apply to this join 
 * mergeclause_list is a list of RestrictInfo nodes for available 
 *      mergejoin clauses in this join 
 * inner_unique is true if each outer tuple provably matches no more 
 *      than one inner tuple 
 * sjinfo is extra info about special joins for selectivity estimation 
 * semifactors is as shown above (only valid for SEMI/ANTI/inner_unique joins) 
 * param_source_rels are OK targets for parameterization of result paths 
 */ 
</span><a name="LN2177"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>JoinPathExtraData</span> 
<span class='Delimiter'>{ 
</span><a name="LN2179"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>restrictlist</span><span class='Delimiter'>; 
</span><a name="LN2180"></a>    <a href="pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>mergeclause_list</span><span class='Delimiter'>; 
</span><a name="LN2181"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inner_unique</span><span class='Delimiter'>; 
</span><a name="LN2182"></a>    <a href="relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sjinfo</span><span class='Delimiter'>; 
</span><a name="LN2183"></a>    <a href="relation.h.html#LN2158"><span class='Ref_to_Struct'>SemiAntiJoinFactors</span></a> <span class='Declare_Member'>semifactors</span><span class='Delimiter'>; 
</span><a name="LN2184"></a>    <a href="relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>param_source_rels</span><span class='Delimiter'>; 
</span><a name="LN2185"></a>} <span class='Declare_Typedef'>JoinPathExtraData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * For speed reasons, cost estimation for join paths is performed in two 
 * phases: the first phase tries to quickly derive a lower bound for the 
 * join cost, and then we check if that's sufficient to reject the path. 
 * If not, we come back for a more refined cost estimate.  The first phase 
 * fills a JoinCostWorkspace struct with its preliminary cost estimates 
 * and possibly additional intermediate values.  The second phase takes 
 * these values as inputs to avoid repeating work. 
 * 
 * (Ideally we'd declare this in cost.h, but it's also needed in pathnode.h, 
 * so seems best to put it here.) 
 */ 
</span><a name="LN2199"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>JoinCostWorkspace</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Preliminary cost estimates --- must not be larger than final ones! */ 
</span><a name="LN2202"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>startup_cost</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* cost expended before fetching any tuples */ 
</span><a name="LN2203"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>total_cost</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* total cost (assuming all tuples fetched) */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fields below here should be treated as private to costsize.c */ 
</span><a name="LN2206"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>run_cost</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* non-startup cost components */ 
</span> 
    <span class='Comment_Multi_Line'>/* private for cost_nestloop code */ 
</span><a name="LN2209"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>inner_run_cost</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* also used by cost_mergejoin code */ 
</span><a name="LN2210"></a>    <a href="nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Member'>inner_rescan_run_cost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* private for cost_mergejoin code */ 
</span><a name="LN2213"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>outer_rows</span><span class='Delimiter'>; 
</span><a name="LN2214"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>inner_rows</span><span class='Delimiter'>; 
</span><a name="LN2215"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>outer_skip_rows</span><span class='Delimiter'>; 
</span><a name="LN2216"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>inner_skip_rows</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* private for cost_hashjoin code */ 
</span><a name="LN2219"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numbuckets</span><span class='Delimiter'>; 
</span><a name="LN2220"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numbatches</span><span class='Delimiter'>; 
</span><a name="LN2221"></a>}<span class='Auto_Annotations'> &laquo; end JoinCostWorkspace &raquo; </span> <span class='Declare_Typedef'>JoinCostWorkspace</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* RELATION_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>