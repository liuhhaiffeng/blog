<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\include\storage\predicate_internals.h</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\include\storage\predicate_internals.h</b></p></td>
<td align='right'>
Wed Jun 14 08:26:08 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * predicate_internals.h 
 *    POSTGRES internal predicate locking definitions. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/include/storage/predicate_internals.h 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Directive'>#ifndef</span> <a href="predicate_internals.h.html#LN14"><span class='Ref_to_Const'>PREDICATE_INTERNALS_H</span></a> 
<a name="LN14"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PREDICATE_INTERNALS_H</span> 
 
<span class='Keyword'>#include </span><span class='String'>"storage/lock.h"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Commit number. 
 */ 
</span><a name="LN21"></a><span class='Control'>typedef</span> <a href="../c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Typedef'>SerCommitSeqNo</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Reserved commit sequence numbers: 
 *  - 0 is reserved to indicate a non-existent SLRU entry; it cannot be 
 *    used as a SerCommitSeqNo, even an invalid one 
 *  - InvalidSerCommitSeqNo is used to indicate a transaction that 
 *    hasn't committed yet, so use a number greater than all valid 
 *    ones to make comparison do the expected thing 
 *  - RecoverySerCommitSeqNo is used to refer to transactions that 
 *    happened before a crash/recovery, since we restart the sequence 
 *    at that point.  It's earlier than all normal sequence numbers, 
 *    and is only used by recovered prepared transactions 
 */ 
</span><a name="LN35"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>InvalidSerCommitSeqNo</span>       <span class='Parentheses'>((</span><a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a><span class='Parentheses'>) </span><a href="../c.h.html#LN343"><span class='Ref_to_Const'>PG_UINT64_MAX</span></a><span class='Parentheses'>)</span> 
<a name="LN36"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RecoverySerCommitSeqNo</span>      <span class='Parentheses'>((</span><a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
<a name="LN37"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FirstNormalSerCommitSeqNo</span>   <span class='Parentheses'>((</span><a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a><span class='Parentheses'>) </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The SERIALIZABLEXACT struct contains information needed for each 
 * serializable database transaction to support SSI techniques. 
 * 
 * A home-grown list is maintained in shared memory to manage these. 
 * An entry is used when the serializable transaction acquires a snapshot. 
 * Unless the transaction is rolled back, this entry must generally remain 
 * until all concurrent transactions have completed.  (There are special 
 * optimizations for READ ONLY transactions which often allow them to be 
 * cleaned up earlier.)  A transaction which is rolled back is cleaned up 
 * as soon as possible. 
 * 
 * Eligibility for cleanup of committed transactions is generally determined 
 * by comparing the transaction's finishedBefore field to 
 * SerializableGlobalXmin. 
 */ 
</span><a name="LN55"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SERIALIZABLEXACT</span> 
<span class='Delimiter'>{ 
</span><a name="LN57"></a>    <a href="lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Declare_Member'>vxid</span><span class='Delimiter'>;</span>  <span class='Comment_Multi_Line'>/* The executing process always has one of 
                                 * these. */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We use two numbers to track the order that transactions commit. Before 
     * commit, a transaction is marked as prepared, and prepareSeqNo is set. 
     * Shortly after commit, it's marked as committed, and commitSeqNo is set. 
     * This doesn't give a strict commit order, but these two values together 
     * are good enough for us, as we can always err on the safe side and 
     * assume that there's a conflict, if we can't be sure of the exact 
     * ordering of two commits. 
     * 
     * Note that a transaction is marked as prepared for a short period during 
     * commit processing, even if two-phase commit is not used. But with 
     * two-phase commit, a transaction can stay in prepared state for some 
     * time. 
     */ 
</span><a name="LN74"></a>    <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>prepareSeqNo</span><span class='Delimiter'>; 
</span><a name="LN75"></a>    <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>commitSeqNo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* these values are not both interesting at the same time */ 
</span>    <span class='Control'>union</span> 
    <span class='Delimiter'>{ 
</span><a name="LN80"></a>        <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>earliestOutConflictCommit</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* when committed with 
                                                         * conflict out */ 
</span><a name="LN82"></a>        <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>lastCommitBeforeSnapshot</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* when not committed or 
                                                         * no conflict out */ 
</span><a name="LN84"></a>    <span class='Delimiter'>}</span>           <span class='Declare_Member'>SeqNo</span><span class='Delimiter'>; 
</span><a name="LN85"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>outConflicts</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* list of write transactions whose data we 
                                 * couldn't read. */ 
</span><a name="LN87"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>inConflicts</span><span class='Delimiter'>;</span>    <span class='Comment_Multi_Line'>/* list of read transactions which couldn't 
                                 * see our write. */ 
</span><a name="LN89"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>predicateLocks</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* list of associated PREDICATELOCK objects */ 
</span><a name="LN90"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>finishedLink</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* list link in 
                                 * FinishedSerializableTransactions */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * for r/o transactions: list of concurrent r/w transactions that we could 
     * potentially have conflicts with, and vice versa for r/w transactions 
     */ 
</span><a name="LN97"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>possibleUnsafeConflicts</span><span class='Delimiter'>; 
</span> 
<a name="LN99"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>topXid</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* top level xid for the transaction, if one 
                                 * exists; else invalid */ 
</span><a name="LN101"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>finishedBefore</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* invalid means still running; else 
                                         * the struct expires when no 
                                         * serializable xids are before this. */ 
</span><a name="LN104"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xmin</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the transaction's snapshot xmin */ 
</span><a name="LN105"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>flags</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* OR'd combination of values defined below */ 
</span><a name="LN106"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>pid</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* pid of associated process */ 
</span><a name="LN107"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end SERIALIZABLEXACT &raquo; </span> <span class='Declare_Typedef'>SERIALIZABLEXACT</span><span class='Delimiter'>; 
</span> 
<a name="LN109"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_COMMITTED</span>            <span class='Number'>0x00000001</span>      <span class='Comment_Single_Line'>/* already committed */ 
</span><a name="LN110"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_PREPARED</span>             <span class='Number'>0x00000002</span>      <span class='Comment_Single_Line'>/* about to commit */ 
</span><a name="LN111"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_ROLLED_BACK</span>          <span class='Number'>0x00000004</span>      <span class='Comment_Single_Line'>/* already rolled back */ 
</span><a name="LN112"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_DOOMED</span>               <span class='Number'>0x00000008</span>      <span class='Comment_Single_Line'>/* will roll back */ 
</span><span class='Comment_Multi_Line'>/* 
 * The following flag actually means that the flagged transaction has a 
 * conflict out *to a transaction which committed ahead of it*.  It's hard 
 * to get that into a name of a reasonable length. 
 */ 
</span><a name="LN118"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_CONFLICT_OUT</span>         <span class='Number'>0x00000010</span> 
<a name="LN119"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_READ_ONLY</span>            <span class='Number'>0x00000020</span> 
<a name="LN120"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_DEFERRABLE_WAITING</span>   <span class='Number'>0x00000040</span> 
<a name="LN121"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_RO_SAFE</span>              <span class='Number'>0x00000080</span> 
<a name="LN122"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_RO_UNSAFE</span>            <span class='Number'>0x00000100</span> 
<a name="LN123"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_SUMMARY_CONFLICT_IN</span>  <span class='Number'>0x00000200</span> 
<a name="LN124"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SXACT_FLAG_SUMMARY_CONFLICT_OUT</span> <span class='Number'>0x00000400</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The following types are used to provide an ad hoc list for holding 
 * SERIALIZABLEXACT objects.  An HTAB is overkill, since there is no need to 
 * access these by key -- there are direct pointers to these objects where 
 * needed.  If a shared memory list is created, these types can probably be 
 * eliminated in favor of using the general solution. 
 */ 
</span><a name="LN133"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PredXactListElementData</span> 
<span class='Delimiter'>{ 
</span><a name="LN135"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>link</span><span class='Delimiter'>; 
</span><a name="LN136"></a>    <a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Declare_Member'>sxact</span><span class='Delimiter'>; 
</span><a name="LN137"></a>}   <span class='Declare_Typedef'>PredXactListElementData</span><span class='Delimiter'>; 
</span> 
<a name="LN139"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>PredXactListElement</span><span class='Delimiter'>; 
</span> 
<a name="LN141"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PredXactListElementDataSize</span> <span class='Operator'>\ 
</span>        <span class='Parentheses'>((</span><a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>)</span><a href="../c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN133"><span class='Ref_to_Struct'>PredXactListElementData</span></a><span class='Parentheses'>)))</span> 
 
<a name="LN144"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PredXactListData</span> 
<span class='Delimiter'>{ 
</span><a name="LN146"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>availableList</span><span class='Delimiter'>; 
</span><a name="LN147"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>activeList</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These global variables are maintained when registering and cleaning up 
     * serializable transactions.  They must be global across all backends, 
     * but are not needed outside the predicate.c source file. Protected by 
     * SerializableXactHashLock. 
     */ 
</span><a name="LN155"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>SxactGlobalXmin</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* global xmin for active serializable 
                                         * transactions */ 
</span><a name="LN157"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>SxactGlobalXminCount</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* how many active serializable 
                                         * transactions have this xmin */ 
</span><a name="LN159"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>WritableSxactCount</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* how many non-read-only serializable 
                                         * transactions are active */ 
</span><a name="LN161"></a>    <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>LastSxactCommitSeqNo</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* a strictly monotonically 
                                                 * increasing number for 
                                                 * commits of serializable 
                                                 * transactions */ 
</span>    <span class='Comment_Multi_Line'>/* Protected by SerializableXactHashLock. */ 
</span><a name="LN166"></a>    <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>CanPartialClearThrough</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* can clear predicate locks 
                                                 * and inConflicts for 
                                                 * committed transactions 
                                                 * through this seq no */ 
</span>    <span class='Comment_Multi_Line'>/* Protected by SerializableFinishedListLock. */ 
</span><a name="LN171"></a>    <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>HavePartialClearedThrough</span><span class='Delimiter'>;</span>   <span class='Comment_Multi_Line'>/* have cleared through this 
                                                 * seq no */ 
</span><a name="LN173"></a>    <a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Member'>OldCommittedSxact</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* shared copy of dummy sxact */ 
</span> 
<a name="LN175"></a>    <a href="predicate_internals.h.html#LN139"><span class='Ref_to_Typedef'>PredXactListElement</span></a> <span class='Declare_Member'>element</span><span class='Delimiter'>; 
</span><a name="LN176"></a>}<span class='Auto_Annotations'> &laquo; end PredXactListData &raquo; </span>   <span class='Declare_Typedef'>PredXactListData</span><span class='Delimiter'>; 
</span> 
<a name="LN178"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="predicate_internals.h.html#LN144"><span class='Ref_to_Struct'>PredXactListData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>PredXactList</span><span class='Delimiter'>; 
</span> 
<a name="LN180"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PredXactListDataSize</span> <span class='Operator'>\ 
</span>        <span class='Parentheses'>((</span><a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>)</span><a href="../c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN144"><span class='Ref_to_Struct'>PredXactListData</span></a><span class='Parentheses'>)))</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * The following types are used to provide lists of rw-conflicts between 
 * pairs of transactions.  Since exactly the same information is needed, 
 * they are also used to record possible unsafe transaction relationships 
 * for purposes of identifying safe snapshots for read-only transactions. 
 * 
 * When a RWConflictData is not in use to record either type of relationship 
 * between a pair of transactions, it is kept on an "available" list.  The 
 * outLink field is used for maintaining that list. 
 */ 
</span><a name="LN194"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RWConflictData</span> 
<span class='Delimiter'>{ 
</span><a name="LN196"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>outLink</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* link for list of conflicts out from a sxact */ 
</span><a name="LN197"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>inLink</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* link for list of conflicts in to a sxact */ 
</span><a name="LN198"></a>    <a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sxactOut</span><span class='Delimiter'>; 
</span><a name="LN199"></a>    <a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sxactIn</span><span class='Delimiter'>; 
</span><a name="LN200"></a>}   <span class='Declare_Typedef'>RWConflictData</span><span class='Delimiter'>; 
</span> 
<a name="LN202"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>RWConflict</span><span class='Delimiter'>; 
</span> 
<a name="LN204"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RWConflictDataSize</span> <span class='Operator'>\ 
</span>        <span class='Parentheses'>((</span><a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>)</span><a href="../c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN194"><span class='Ref_to_Struct'>RWConflictData</span></a><span class='Parentheses'>)))</span> 
 
<a name="LN207"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RWConflictPoolHeaderData</span> 
<span class='Delimiter'>{ 
</span><a name="LN209"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>availableList</span><span class='Delimiter'>; 
</span><a name="LN210"></a>    <a href="predicate_internals.h.html#LN202"><span class='Ref_to_Typedef'>RWConflict</span></a>  <span class='Declare_Member'>element</span><span class='Delimiter'>; 
</span><a name="LN211"></a>}   <span class='Declare_Typedef'>RWConflictPoolHeaderData</span><span class='Delimiter'>; 
</span> 
<a name="LN213"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="predicate_internals.h.html#LN207"><span class='Ref_to_Struct'>RWConflictPoolHeaderData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>RWConflictPoolHeader</span><span class='Delimiter'>; 
</span> 
<a name="LN215"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RWConflictPoolHeaderDataSize</span> <span class='Operator'>\ 
</span>        <span class='Parentheses'>((</span><a href="../c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>)</span><a href="../c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN207"><span class='Ref_to_Struct'>RWConflictPoolHeaderData</span></a><span class='Parentheses'>)))</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * The SERIALIZABLEXIDTAG struct identifies an xid assigned to a serializable 
 * transaction or any of its subtransactions. 
 */ 
</span><a name="LN223"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SERIALIZABLEXIDTAG</span> 
<span class='Delimiter'>{ 
</span><a name="LN225"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xid</span><span class='Delimiter'>; 
</span><a name="LN226"></a>} <span class='Declare_Typedef'>SERIALIZABLEXIDTAG</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The SERIALIZABLEXID struct provides a link from a TransactionId for a 
 * serializable transaction to the related SERIALIZABLEXACT record, even if 
 * the transaction has completed and its connection has been closed. 
 * 
 * These are created as new top level transaction IDs are first assigned to 
 * transactions which are participating in predicate locking.  This may 
 * never happen for a particular transaction if it doesn't write anything. 
 * They are removed with their related serializable transaction objects. 
 * 
 * The SubTransGetTopmostTransaction method is used where necessary to get 
 * from an XID which might be from a subtransaction to the top level XID. 
 */ 
</span><a name="LN241"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>SERIALIZABLEXID</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* hash key */ 
</span><a name="LN244"></a>    <a href="predicate_internals.h.html#LN223"><span class='Ref_to_Struct'>SERIALIZABLEXIDTAG</span></a> <span class='Declare_Member'>tag</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* data */ 
</span><a name="LN247"></a>    <a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Member'>myXact</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* pointer to the top level transaction data */ 
</span><a name="LN248"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>SERIALIZABLEXID</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The PREDICATELOCKTARGETTAG struct identifies a database object which can 
 * be the target of predicate locks. 
 * 
 * Note that the hash function being used doesn't properly respect tag 
 * length -- if the length of the structure isn't a multiple of four bytes it 
 * will go to a four byte boundary past the end of the tag.  If you change 
 * this struct, make sure any slack space is initialized, so that any random 
 * bytes in the middle or at the end are not included in the hash. 
 * 
 * TODO SSI: If we always use the same fields for the same type of value, we 
 * should rename these.  Holding off until it's clear there are no exceptions. 
 * Since indexes are relations with blocks and tuples, it's looking likely that 
 * the rename will be possible.  If not, we may need to divide the last field 
 * and use part of it for a target type, so that we know how to interpret the 
 * data.. 
 */ 
</span><a name="LN268"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PREDICATELOCKTARGETTAG</span> 
<span class='Delimiter'>{ 
</span><a name="LN270"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>locktag_field1</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* a 32-bit ID field */ 
</span><a name="LN271"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>locktag_field2</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* a 32-bit ID field */ 
</span><a name="LN272"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>locktag_field3</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* a 32-bit ID field */ 
</span><a name="LN273"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>locktag_field4</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* a 32-bit ID field */ 
</span><a name="LN274"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PREDICATELOCKTARGETTAG</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The PREDICATELOCKTARGET struct represents a database object on which there 
 * are predicate locks. 
 * 
 * A hash list of these objects is maintained in shared memory.  An entry is 
 * added when a predicate lock is requested on an object which doesn't 
 * already have one.  An entry is removed when the last lock is removed from 
 * its list. 
 */ 
</span><a name="LN285"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PREDICATELOCKTARGET</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* hash key */ 
</span><a name="LN288"></a>    <a href="predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Member'>tag</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* unique identifier of lockable object */ 
</span> 
    <span class='Comment_Multi_Line'>/* data */ 
</span><a name="LN291"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>predicateLocks</span><span class='Delimiter'>; </span><span class='Comment_Multi_Line'>/* list of PREDICATELOCK objects assoc. with 
                                 * predicate lock target */ 
</span><a name="LN293"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PREDICATELOCKTARGET</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The PREDICATELOCKTAG struct identifies an individual predicate lock. 
 * 
 * It is the combination of predicate lock target (which is a lockable 
 * object) and a serializable transaction which has acquired a lock on that 
 * target. 
 */ 
</span><a name="LN303"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PREDICATELOCKTAG</span> 
<span class='Delimiter'>{ 
</span><a name="LN305"></a>    <a href="predicate_internals.h.html#LN285"><span class='Ref_to_Struct'>PREDICATELOCKTARGET</span></a> <span class='Operator'>*</span><span class='Declare_Member'>myTarget</span><span class='Delimiter'>; 
</span><a name="LN306"></a>    <a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Member'>myXact</span><span class='Delimiter'>; 
</span><a name="LN307"></a>} <span class='Declare_Typedef'>PREDICATELOCKTAG</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The PREDICATELOCK struct represents an individual lock. 
 * 
 * An entry can be created here when the related database object is read, or 
 * by promotion of multiple finer-grained targets.  All entries related to a 
 * serializable transaction are removed when that serializable transaction is 
 * cleaned up.  Entries can also be removed when they are combined into a 
 * single coarser-grained lock entry. 
 */ 
</span><a name="LN318"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PREDICATELOCK</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* hash key */ 
</span><a name="LN321"></a>    <a href="predicate_internals.h.html#LN303"><span class='Ref_to_Struct'>PREDICATELOCKTAG</span></a> <span class='Declare_Member'>tag</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* unique identifier of lock */ 
</span> 
    <span class='Comment_Multi_Line'>/* data */ 
</span><a name="LN324"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>targetLink</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* list link in PREDICATELOCKTARGET's list of 
                                 * predicate locks */ 
</span><a name="LN326"></a>    <a href="shmem.h.html#LN27"><span class='Ref_to_Struct'>SHM_QUEUE</span></a>   <span class='Declare_Member'>xactLink</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* list link in SERIALIZABLEXACT's list of 
                                 * predicate locks */ 
</span><a name="LN328"></a>    <a href="predicate_internals.h.html#LN21"><span class='Ref_to_Typedef'>SerCommitSeqNo</span></a> <span class='Declare_Member'>commitSeqNo</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* only used for summarized predicate locks */ 
</span><a name="LN329"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PREDICATELOCK</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The LOCALPREDICATELOCK struct represents a local copy of data which is 
 * also present in the PREDICATELOCK table, organized for fast access without 
 * needing to acquire a LWLock.  It is strictly for optimization. 
 * 
 * Each serializable transaction creates its own local hash table to hold a 
 * collection of these.  This information is used to determine when a number 
 * of fine-grained locks should be promoted to a single coarser-grained lock. 
 * The information is maintained more-or-less in parallel to the 
 * PREDICATELOCK data, but because this data is not protected by locks and is 
 * only used in an optimization heuristic, it is allowed to drift in a few 
 * corner cases where maintaining exact data would be expensive. 
 * 
 * The hash table is created when the serializable transaction acquires its 
 * snapshot, and its memory is released upon completion of the transaction. 
 */ 
</span><a name="LN348"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>LOCALPREDICATELOCK</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* hash key */ 
</span><a name="LN351"></a>    <a href="predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Member'>tag</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* unique identifier of lockable object */ 
</span> 
    <span class='Comment_Multi_Line'>/* data */ 
</span><a name="LN354"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>held</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* is lock held, or just its children?  */ 
</span><a name="LN355"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>childLocks</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* number of child locks currently held */ 
</span><a name="LN356"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>LOCALPREDICATELOCK</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * The types of predicate locks which can be acquired. 
 */ 
</span><a name="LN362"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>PredicateLockTargetType</span> 
<span class='Delimiter'>{ 
</span><a name="LN364"></a>    <span class='Declare_Enum_Const'>PREDLOCKTAG_RELATION</span><span class='Delimiter'>, 
</span><a name="LN365"></a>    <span class='Declare_Enum_Const'>PREDLOCKTAG_PAGE</span><span class='Delimiter'>, 
</span><a name="LN366"></a>    <span class='Declare_Enum_Const'>PREDLOCKTAG_TUPLE</span> 
    <span class='Comment_Multi_Line'>/* TODO SSI: Other types may be needed for index locking */ 
</span><a name="LN368"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PredicateLockTargetType</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * This structure is used to quickly capture a copy of all predicate 
 * locks.  This is currently used only by the pg_lock_status function, 
 * which in turn is used by the pg_locks view. 
 */ 
</span><a name="LN376"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PredicateLockData</span> 
<span class='Delimiter'>{ 
</span><a name="LN378"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nelements</span><span class='Delimiter'>; 
</span><a name="LN379"></a>    <a href="predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Operator'>*</span><span class='Declare_Member'>locktags</span><span class='Delimiter'>; 
</span><a name="LN380"></a>    <a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Declare_Member'>xacts</span><span class='Delimiter'>; 
</span><a name="LN381"></a>} <span class='Declare_Typedef'>PredicateLockData</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * These macros define how we map logical IDs of lockable objects into the 
 * physical fields of PREDICATELOCKTARGETTAG.   Use these to set up values, 
 * rather than accessing the fields directly.  Note multiple eval of target! 
 */ 
</span><a name="LN389"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SET_PREDICATELOCKTARGETTAG_RELATION</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>dboid</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>reloid</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="predicate_internals.h.html#LN389"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field1 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN389"><span class='Ref_to_Parameter'>dboid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN389"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field2 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN389"><span class='Ref_to_Parameter'>reloid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN389"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field3 <span class='Operator'>= </span><a href="block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN389"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field4 <span class='Operator'>= </span><a href="off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Parentheses'>)</span> 
 
<a name="LN395"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SET_PREDICATELOCKTARGETTAG_PAGE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>dboid</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>reloid</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>blocknum</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="predicate_internals.h.html#LN395"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field1 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN395"><span class='Ref_to_Parameter'>dboid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN395"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field2 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN395"><span class='Ref_to_Parameter'>reloid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN395"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field3 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN395"><span class='Ref_to_Parameter'>blocknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN395"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field4 <span class='Operator'>= </span><a href="off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Parentheses'>)</span> 
 
<a name="LN401"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SET_PREDICATELOCKTARGETTAG_TUPLE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>dboid</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>reloid</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>blocknum</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>offnum</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field1 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>dboid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field2 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>reloid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field3 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>blocknum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field4 <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="predicate_internals.h.html#LN401"><span class='Ref_to_Parameter'>offnum</span></a><span class='Parentheses'>))</span> 
 
<a name="LN407"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>GET_PREDICATELOCKTARGETTAG_DB</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) (</span><a href="predicate_internals.h.html#LN407"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field1<span class='Parentheses'>)</span> 
<a name="LN409"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>GET_PREDICATELOCKTARGETTAG_RELATION</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="../postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) (</span><a href="predicate_internals.h.html#LN409"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field2<span class='Parentheses'>)</span> 
<a name="LN411"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>GET_PREDICATELOCKTARGETTAG_PAGE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a><span class='Parentheses'>) (</span><a href="predicate_internals.h.html#LN411"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field3<span class='Parentheses'>)</span> 
<a name="LN413"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>GET_PREDICATELOCKTARGETTAG_OFFSET</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>((</span><a href="off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a><span class='Parentheses'>) (</span><a href="predicate_internals.h.html#LN413"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field4<span class='Parentheses'>)</span> 
<a name="LN415"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>GET_PREDICATELOCKTARGETTAG_TYPE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>locktag</span><span class='Parentheses'>)</span>                             <span class='Operator'>\ 
</span>    <span class='Parentheses'>(((</span><a href="predicate_internals.h.html#LN415"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field4 <span class='Operator'>!= </span><a href="off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Parentheses'>)</span> <span class='Operator'>? </span><a href="predicate_internals.h.html#LN366"><span class='Ref_to_EnumConst'>PREDLOCKTAG_TUPLE</span></a> <span class='Operator'>: \ 
</span>     <span class='Parentheses'>(((</span><a href="predicate_internals.h.html#LN415"><span class='Ref_to_Parameter'>locktag</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>locktag_field3 <span class='Operator'>!= </span><a href="block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Parentheses'>)</span> <span class='Operator'>? </span><a href="predicate_internals.h.html#LN365"><span class='Ref_to_EnumConst'>PREDLOCKTAG_PAGE</span></a> <span class='Operator'>:</span>   <span class='Operator'>\ 
</span>      <a href="predicate_internals.h.html#LN364"><span class='Ref_to_EnumConst'>PREDLOCKTAG_RELATION</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Two-phase commit statefile records. There are two types: for each 
 * transaction, we generate one per-transaction record and a variable 
 * number of per-predicate-lock records. 
 */ 
</span><a name="LN425"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>TwoPhasePredicateRecordType</span> 
<span class='Delimiter'>{ 
</span><a name="LN427"></a>    <span class='Declare_Enum_Const'>TWOPHASEPREDICATERECORD_XACT</span><span class='Delimiter'>, 
</span><a name="LN428"></a>    <span class='Declare_Enum_Const'>TWOPHASEPREDICATERECORD_LOCK</span> 
<a name="LN429"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TwoPhasePredicateRecordType</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Per-transaction information to reconstruct a SERIALIZABLEXACT. Not 
 * much is needed because most of it not meaningful for a recovered 
 * prepared transaction. 
 * 
 * In particular, we do not record the in and out conflict lists for a 
 * prepared transaction because the associated SERIALIZABLEXACTs will 
 * not be available after recovery. Instead, we simply record the 
 * existence of each type of conflict by setting the transaction's 
 * summary conflict in/out flag. 
 */ 
</span><a name="LN442"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TwoPhasePredicateXactRecord</span> 
<span class='Delimiter'>{ 
</span><a name="LN444"></a>    <a href="../c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xmin</span><span class='Delimiter'>; 
</span><a name="LN445"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>flags</span><span class='Delimiter'>; 
</span><a name="LN446"></a>} <span class='Declare_Typedef'>TwoPhasePredicateXactRecord</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Per-lock state */ 
</span><a name="LN449"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TwoPhasePredicateLockRecord</span> 
<span class='Delimiter'>{ 
</span><a name="LN451"></a>    <a href="predicate_internals.h.html#LN268"><span class='Ref_to_Struct'>PREDICATELOCKTARGETTAG</span></a> <span class='Declare_Member'>target</span><span class='Delimiter'>; 
</span><a name="LN452"></a>    <a href="../c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>filler</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* to avoid length change in back-patched fix */ 
</span><a name="LN453"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TwoPhasePredicateLockRecord</span><span class='Delimiter'>; 
</span> 
<a name="LN455"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>TwoPhasePredicateRecord</span> 
<span class='Delimiter'>{ 
</span><a name="LN457"></a>    <a href="predicate_internals.h.html#LN425"><span class='Ref_to_Enum'>TwoPhasePredicateRecordType</span></a> <span class='Declare_Member'>type</span><span class='Delimiter'>; 
</span>    <span class='Control'>union</span> 
    <span class='Delimiter'>{ 
</span><a name="LN460"></a>        <a href="predicate_internals.h.html#LN442"><span class='Ref_to_Struct'>TwoPhasePredicateXactRecord</span></a> <span class='Declare_Member'>xactRecord</span><span class='Delimiter'>; 
</span><a name="LN461"></a>        <a href="predicate_internals.h.html#LN449"><span class='Ref_to_Struct'>TwoPhasePredicateLockRecord</span></a> <span class='Declare_Member'>lockRecord</span><span class='Delimiter'>; 
</span><a name="LN462"></a>    <span class='Delimiter'>}</span>           <span class='Declare_Member'>data</span><span class='Delimiter'>; 
</span><a name="LN463"></a>} <span class='Declare_Typedef'>TwoPhasePredicateRecord</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Define a macro to use for an "empty" SERIALIZABLEXACT reference. 
 */ 
</span><a name="LN468"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>InvalidSerializableXact</span> <span class='Parentheses'>((</span><a href="predicate_internals.h.html#LN55"><span class='Ref_to_Struct'>SERIALIZABLEXACT</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Function definitions for functions needing awareness of predicate 
 * locking internals. 
 */ 
</span><a name="LN475"></a><span class='Keyword'>extern </span><a href="predicate_internals.h.html#LN376"><span class='Ref_to_Struct'>PredicateLockData</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>GetPredicateLockStatusData</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN476"></a><span class='Keyword'>extern int </span><span class='Declare_Prototype'>GetSafeSnapshotBlockingPids</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>blocked_pid</span><span class='Delimiter'>, 
</span><a name="LN477"></a>                            <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>output</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>output_size</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* PREDICATE_INTERNALS_H */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>