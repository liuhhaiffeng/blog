<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\test\perl\PostgresNode.pm</title>
<LINK REL=StyleSheet HREF="../../../Perl_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\test\perl\PostgresNode.pm</b></p></td>
<td align='right'>
Wed Jun 14 08:26:14 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
 
<span class='Perl_POD'>=pod 
 
=head1 NAME 
 
PostgresNode - class representing PostgreSQL server instance 
 
=head1 SYNOPSIS 
 
  use PostgresNode; 
 
  my $node = get_new_node('mynode'); 
 
  # Create a data directory with initdb 
  $node-&GT;init(); 
 
  # Start the PostgreSQL server 
  $node-&GT;start(); 
 
  # Change a setting and restart 
  $node-&GT;append_conf('postgresql.conf', 'hot_standby = on'); 
  $node-&GT;restart(); 
 
  # run a query with psql, like: 
  #   echo 'SELECT 1' | psql -qAXt postgres -v ON_ERROR_STOP=1 
  $psql_stdout = $node-&GT;safe_psql('postgres', 'SELECT 1'); 
 
  # Run psql with a timeout, capturing stdout and stderr 
  # as well as the psql exit code. Pass some extra psql 
  # options. If there's an error from psql raise an exception. 
  my ($stdout, $stderr, $timed_out); 
  my $cmdret = $node-&GT;psql('postgres', 'SELECT pg_sleep(60)', 
      stdout =&GT; \$stdout, stderr =&GT; \$stderr, 
      timeout =&GT; 30, timed_out =&GT; \$timed_out, 
      extra_params =&GT; ['--single-transaction'], 
      on_error_die =&GT; 1) 
  print "Sleep timed out" if $timed_out; 
 
  # Similar thing, more convenient in common cases 
  my ($cmdret, $stdout, $stderr) = 
      $node-&GT;psql('postgres', 'SELECT 1'); 
 
  # run query every second until it returns 't' 
  # or times out 
  $node-&GT;poll_query_until('postgres', q|SELECT random() &LT; 0.1;|') 
    or print "timed out"; 
 
  # Do an online pg_basebackup 
  my $ret = $node-&GT;backup('testbackup1'); 
 
  # Take a backup of a running server 
  my $ret = $node-&GT;backup_fs_hot('testbackup2'); 
 
  # Take a backup of a stopped server 
  $node-&GT;stop; 
  my $ret = $node-&GT;backup_fs_cold('testbackup3') 
 
  # Restore it to create a new independent node (not a replica) 
  my $replica = get_new_node('replica'); 
  $replica-&GT;init_from_backup($node, 'testbackup'); 
  $replica-&GT;start; 
 
  # Stop the server 
  $node-&GT;stop('fast'); 
 
=head1 DESCRIPTION 
 
PostgresNode contains a set of routines able to work on a PostgreSQL node, 
allowing to start, stop, backup and initialize it with various options. 
The set of nodes managed by a given test is also managed by this module. 
 
In addition to node management, PostgresNode instances have some wrappers 
around Test::More functions to run commands with an environment set up to 
point to the instance. 
 
The IPC::Run module is required. 
 
=cut 
</span> 
<span class='Keyword'>package </span>PostgresNode<span class='Delimiter'>; 
</span> 
<span class='Control'>use</span> strict<span class='Delimiter'>; 
</span><span class='Control'>use</span> warnings<span class='Delimiter'>; 
</span> 
<span class='Control'>use</span> Config<span class='Delimiter'>; 
</span><span class='Control'>use</span> Cwd<span class='Delimiter'>; 
</span><span class='Control'>use</span> Exporter <span class='String'>'import'</span><span class='Delimiter'>; 
</span><span class='Control'>use</span> File<span class='Operator'>::</span>Basename<span class='Delimiter'>; 
</span><span class='Control'>use</span> File<span class='Operator'>::</span>Spec<span class='Delimiter'>; 
</span><span class='Control'>use</span> File<span class='Operator'>::</span>Temp <span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Control'>use</span> IPC<span class='Operator'>::</span><a href="../../backend/utils/Gen_dummy_probes.pl.html#LN33"><span class='Ref_to_Func'>Run</span></a><span class='Delimiter'>; 
</span><span class='Control'>use</span> RecursiveCopy<span class='Delimiter'>; 
</span><span class='Control'>use</span> Socket<span class='Delimiter'>; 
</span><span class='Control'>use</span> Test<span class='Operator'>::</span>More<span class='Delimiter'>; 
</span><span class='Control'>use</span> TestLib <span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Control'>use</span> Scalar<span class='Operator'>::</span>Util <span class='Keyword'>qw</span><span class='String'>(blessed)</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>our </span>@EXPORT <span class='Operator'>= </span><span class='Keyword'>qw</span><span class='String'>( 
</span>  <a href="PostgresNode.pm.html#LN867"><span class='Ref_to_Func'>get_new_node</span></a> 
<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>our </span><span class='Parentheses'>(</span>$test_localhost<span class='Delimiter'>, </span>$test_pghost<span class='Delimiter'>, </span>$last_port_assigned<span class='Delimiter'>, </span>@all_nodes<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Single_Line'># Windows path to virtual file system root 
</span> 
<span class='Keyword'>our </span>$vfs_path <span class='Operator'>= </span><span class='String'>''</span><span class='Delimiter'>; 
</span><span class='Control'>if</span> <span class='Parentheses'>(</span>$Config<span class='Delimiter'>{</span>osname<span class='Delimiter'>} </span><span class='Operator'>eq </span><span class='String'>'msys'</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    $vfs_path <span class='Operator'>= `</span>cd <span class='Operator'>/ && </span>pwd <span class='Operator'>-</span>W<span class='Operator'>`</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>chomp </span>$vfs_path<span class='Delimiter'>; 
} 
</span> 
INIT 
<span class='Delimiter'>{ 
</span> 
    <span class='Comment_Single_Line'># PGHOST is set once and for all through a single series of tests when 
</span>    <span class='Comment_Single_Line'># this module is loaded. 
</span>    $test_localhost <span class='Operator'>= </span><span class='String'>"127.0.0.1"</span><span class='Delimiter'>; 
</span>    $test_pghost <span class='Operator'>= 
</span>      $TestLib<span class='Operator'>::</span>windows_os <span class='Operator'>? </span>$test_localhost <span class='Operator'>: </span>TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN145"><span class='Ref_to_Func'>tempdir_short</span></a><span class='Delimiter'>; 
</span>    $ENV<span class='Delimiter'>{</span>PGHOST<span class='Delimiter'>}</span>     <span class='Operator'>= </span>$test_pghost<span class='Delimiter'>; 
</span>    $ENV<span class='Delimiter'>{</span>PGDATABASE<span class='Delimiter'>} </span><span class='Operator'>= </span><span class='String'>'postgres'</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Tracking of last port value assigned to accelerate free port lookup. 
</span>    $last_port_assigned <span class='Operator'>= </span><span class='Keyword'>int</span><span class='Parentheses'>(</span><span class='Keyword'>rand</span><span class='Parentheses'>() </span><span class='Operator'>* </span>16384<span class='Parentheses'>)</span> <span class='Operator'>+ </span>49152<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=head1 METHODS 
 
=over 
 
=item PostgresNode::new($class, $name, $pghost, $pgport) 
 
Create a new PostgresNode instance. Does not initdb or start it. 
 
You should generally prefer to use get_new_node() instead since it takes care 
of finding port numbers, registering instances for cleanup, etc. 
 
=cut 
</span> 
<a name="LN142"></a><span class='Control'>sub</span> <span class='Declare_Function'>new</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$class<span class='Delimiter'>, </span>$name<span class='Delimiter'>, </span>$pghost<span class='Delimiter'>, </span>$pgport<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$testname <span class='Operator'>= </span>basename<span class='Parentheses'>(</span>$0<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    $testname <span class='Operator'>=~ s</span><span class='String'>/\.[^.]+$//</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$self <span class='Operator'>= </span><span class='Delimiter'>{ 
</span>        _port    <span class='Operator'>=&GT; </span>$pgport<span class='Delimiter'>, 
</span>        _host    <span class='Operator'>=&GT; </span>$pghost<span class='Delimiter'>, 
</span>        _basedir <span class='Operator'>=&GT; </span>TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN135"><span class='Ref_to_Func'>tempdir</span></a><span class='Parentheses'>(</span><span class='String'>"data_"</span> <span class='Operator'>. </span>$name<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        _name    <span class='Operator'>=&GT; </span>$name<span class='Delimiter'>, 
</span>        _logfile <span class='Operator'>=&GT; </span><span class='String'>"$TestLib::log_path/${testname}_${name}.log"</span> <span class='Delimiter'>}; 
</span> 
    <span class='Keyword'>bless </span>$self<span class='Delimiter'>, </span>$class<span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN341"><span class='Ref_to_Func'>dump_info</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> $self<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;port() 
 
Get the port number assigned to the host. This won't necessarily be a TCP port 
open on the local host since we prefer to use unix sockets if possible. 
 
Use $node-&GT;connstr() if you want a connection string. 
 
=cut 
</span> 
<a name="LN171"></a><span class='Control'>sub</span> <span class='Declare_Function'>port</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_port<span class='Delimiter'>}; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;host() 
 
Return the host (like PGHOST) for this instance. May be a UNIX socket path. 
 
Use $node-&GT;connstr() if you want a connection string. 
 
=cut 
</span> 
<a name="LN187"></a><span class='Control'>sub</span> <span class='Declare_Function'>host</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_host<span class='Delimiter'>}; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;basedir() 
 
The directory all the node's files will be within - datadir, archive directory, 
backups, etc. 
 
=cut 
</span> 
<a name="LN202"></a><span class='Control'>sub</span> <span class='Declare_Function'>basedir</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_basedir<span class='Delimiter'>}; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;name() 
 
The name assigned to the node at creation time. 
 
=cut 
</span> 
<a name="LN216"></a><span class='Control'>sub</span> <span class='Declare_Function'>name</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_name<span class='Delimiter'>}; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;logfile() 
 
Path to the PostgreSQL log file for this instance. 
 
=cut 
</span> 
<a name="LN230"></a><span class='Control'>sub</span> <span class='Declare_Function'>logfile</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_logfile<span class='Delimiter'>}; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;connstr() 
 
Get a libpq connection string that will establish a connection to 
this node. Suitable for passing to psql, DBD::Pg, etc. 
 
=cut 
</span> 
<a name="LN245"></a><span class='Control'>sub</span> <span class='Declare_Function'>connstr</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$dbname<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgport <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pghost <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN187"><span class='Ref_to_Func'>host</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$dbname<span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span> <span class='String'>"port=$pgport host=$pghost"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Single_Line'># Escape properly the database string before using it, only 
</span>    <span class='Comment_Single_Line'># single quotes and backslashes need to be treated this way. 
</span>    $dbname <span class='Operator'>=~ s</span><span class='String'>#\\#\\\\#</span>g<span class='Delimiter'>; 
</span>    $dbname <span class='Operator'>=~ s</span><span class='String'>#\'#\\\'#</span>g<span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='String'>"port=$pgport host=$pghost dbname='$dbname'"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;data_dir() 
 
Returns the path to the data directory. postgresql.conf and pg_hba.conf are 
always here. 
 
=cut 
</span> 
<a name="LN272"></a><span class='Control'>sub</span> <span class='Declare_Function'>data_dir</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$res <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN202"><span class='Ref_to_Func'>basedir</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='String'>"$res/pgdata"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;archive_dir() 
 
If archiving is enabled, WAL files go here. 
 
=cut 
</span> 
<a name="LN287"></a><span class='Control'>sub</span> <span class='Declare_Function'>archive_dir</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$basedir <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN202"><span class='Ref_to_Func'>basedir</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='String'>"$basedir/archives"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;backup_dir() 
 
The output path for backups taken with $node-&GT;backup() 
 
=cut 
</span> 
<a name="LN302"></a><span class='Control'>sub</span> <span class='Declare_Function'>backup_dir</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$basedir <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN202"><span class='Ref_to_Func'>basedir</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='String'>"$basedir/backup"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;info() 
 
Return a string containing human-readable diagnostic information (paths, etc) 
about this node. 
 
=cut 
</span> 
<a name="LN318"></a><span class='Control'>sub</span> <span class='Declare_Function'>info</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$_info <span class='Operator'>= </span><span class='String'>''</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>open my </span>$fh<span class='Delimiter'>, </span><span class='String'>'&GT;'</span><span class='Delimiter'>, </span><span class='Operator'>\</span>$_info or <span class='Control'>die</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$fh <span class='String'>"Name: "</span> <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$fh <span class='String'>"Data directory: "</span> <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$fh <span class='String'>"Backup directory: "</span> <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN302"><span class='Ref_to_Func'>backup_dir</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$fh <span class='String'>"Archive directory: "</span> <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN287"><span class='Ref_to_Func'>archive_dir</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$fh <span class='String'>"Connection string: "</span> <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN245"><span class='Ref_to_Func'>connstr</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$fh <span class='String'>"Log file: "</span> <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN230"><span class='Ref_to_Func'>logfile</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>close </span>$fh or <span class='Control'>die</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $_info<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;dump_info() 
 
Print $node-&GT;info() 
 
=cut 
</span> 
<a name="LN341"></a><span class='Control'>sub</span> <span class='Declare_Function'>dump_info</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN318"><span class='Ref_to_Func'>info</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Single_Line'># Internal method to set up trusted pg_hba.conf for replication.  Not 
# documented because you shouldn't use it, it's called automatically if needed. 
</span><a name="LN350"></a><span class='Control'>sub</span> <span class='Declare_Function'>set_replication_conf</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgdata <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span> 
    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN187"><span class='Ref_to_Func'>host</span></a> <span class='Operator'>eq </span>$test_pghost 
      or <span class='Control'>die</span> <span class='String'>"set_replication_conf only works with the default host"</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>open my </span>$hba<span class='Delimiter'>, </span><span class='String'>'&GT;&GT;'</span><span class='Delimiter'>, </span><span class='String'>"$pgdata/pg_hba.conf"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$hba <span class='String'>"\n# Allow replication (set up by PostgresNode.pm)\n"</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>$TestLib<span class='Operator'>::</span>windows_os<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>print </span>$hba 
<span class='String'>"host replication all $test_localhost/32 sspi include_realm=1 map=regress\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Keyword'>close </span>$hba<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;init(...) 
 
Initialize a new cluster for testing. 
 
Authentication is set up so that only the current OS user can access the 
cluster. On Unix, we use Unix domain socket connections, with the socket in 
a directory that's only accessible to the current user to ensure that. 
On Windows, we use SSPI authentication to ensure the same (by pg_regress 
--config-auth). 
 
WAL archiving can be enabled on this node by passing the keyword parameter 
has_archiving =&GT; 1. This is disabled by default. 
 
postgresql.conf can be set up for replication by passing the keyword 
parameter allows_streaming =&GT; 'logical' or 'physical' (passing 1 will also 
suffice for physical replication) depending on type of replication that 
should be enabled. This is disabled by default. 
 
The new node is set up in a fast but unsafe configuration where fsync is 
disabled. 
 
=cut 
</span> 
<a name="LN393"></a><span class='Control'>sub</span> <span class='Declare_Function'>init</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>%params<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgdata <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$host   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN187"><span class='Ref_to_Func'>host</span></a><span class='Delimiter'>; 
</span> 
    $params<span class='Delimiter'>{</span>allows_streaming<span class='Delimiter'>} </span><span class='Operator'>= </span>0 <span class='Control'>unless</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>allows_streaming<span class='Delimiter'>}; 
</span>    $params<span class='Delimiter'>{</span>has_archiving<span class='Delimiter'>}</span>    <span class='Operator'>= </span>0 <span class='Control'>unless</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>has_archiving<span class='Delimiter'>}; 
</span> 
    <span class='Keyword'>mkdir </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN302"><span class='Ref_to_Func'>backup_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>mkdir </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN287"><span class='Ref_to_Func'>archive_dir</span></a><span class='Delimiter'>; 
</span> 
    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN159"><span class='Ref_to_Func'>system_or_bail</span></a><span class='Parentheses'>(</span><span class='String'>'initdb'</span><span class='Delimiter'>, </span><span class='String'>'-D'</span><span class='Delimiter'>, </span>$pgdata<span class='Delimiter'>, </span><span class='String'>'-A'</span><span class='Delimiter'>, </span><span class='String'>'trust'</span><span class='Delimiter'>, </span><span class='String'>'-N'</span><span class='Delimiter'>, 
</span>        @<span class='Delimiter'>{ </span>$params<span class='Delimiter'>{</span>extra<span class='Delimiter'>} }</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN159"><span class='Ref_to_Func'>system_or_bail</span></a><span class='Parentheses'>(</span>$ENV<span class='Delimiter'>{</span>PG_REGRESS<span class='Delimiter'>}, </span><span class='String'>'--config-auth'</span><span class='Delimiter'>, </span>$pgdata<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>open my </span>$conf<span class='Delimiter'>, </span><span class='String'>'&GT;&GT;'</span><span class='Delimiter'>, </span><span class='String'>"$pgdata/postgresql.conf"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$conf <span class='String'>"\n# Added by PostgresNode.pm\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$conf <span class='String'>"fsync = off\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$conf <span class='String'>"restart_after_crash = off\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$conf <span class='String'>"log_line_prefix = '%m [%p] %q%a '\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$conf <span class='String'>"log_statement = all\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span>$conf <span class='String'>"port = $port\n"</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>$params<span class='Delimiter'>{</span>allows_streaming<span class='Delimiter'>}</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>$params<span class='Delimiter'>{</span>allows_streaming<span class='Delimiter'>} </span><span class='Operator'>eq </span><span class='String'>"logical"</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Keyword'>print </span>$conf <span class='String'>"wal_level = logical\n"</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Keyword'>print </span>$conf <span class='String'>"wal_level = replica\n"</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"max_wal_senders = 5\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"max_replication_slots = 5\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"wal_keep_segments = 20\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"max_wal_size = 128MB\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"shared_buffers = 1MB\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"wal_log_hints = on\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"hot_standby = on\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"max_connections = 10\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"wal_level = minimal\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"max_wal_senders = 0\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>$TestLib<span class='Operator'>::</span>windows_os<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"listen_addresses = '$host'\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"unix_socket_directories = '$host'\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$conf <span class='String'>"listen_addresses = ''\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Keyword'>close </span>$conf<span class='Delimiter'>; 
</span> 
    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN350"><span class='Ref_to_Func'>set_replication_conf</span></a> <span class='Control'>if</span> $params<span class='Delimiter'>{</span>allows_streaming<span class='Delimiter'>}; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN799"><span class='Ref_to_Func'>enable_archiving</span></a>     <span class='Control'>if</span> $params<span class='Delimiter'>{</span>has_archiving<span class='Delimiter'>}; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;append_conf(filename, str) 
 
A shortcut method to append to files like pg_hba.conf and postgresql.conf. 
 
Does no validation or sanity checking. Does not reload the configuration 
after writing. 
 
A newline is automatically appended to the string. 
 
=cut 
</span> 
<a name="LN471"></a><span class='Control'>sub</span> <span class='Declare_Function'>append_conf</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$filename<span class='Delimiter'>, </span>$str<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$conffile <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a> <span class='Operator'>. </span><span class='String'>'/'</span> <span class='Operator'>. </span>$filename<span class='Delimiter'>; 
</span> 
    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN208"><span class='Ref_to_Func'>append_to_file</span></a><span class='Parentheses'>(</span>$conffile<span class='Delimiter'>, </span>$str <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;backup(backup_name) 
 
Create a hot backup with B&LT;pg_basebackup&GT; in subdirectory B&LT;backup_name&GT; of 
B&LT;&LT; $node-&GT;backup_dir &GT;&GT;, including the WAL. WAL files 
fetched at the end of the backup, not streamed. 
 
You'll have to configure a suitable B&LT;max_wal_senders&GT; on the 
target server since it isn't done by default. 
 
=cut 
</span> 
<a name="LN493"></a><span class='Control'>sub</span> <span class='Declare_Function'>backup</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$backup_name<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$backup_path <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN302"><span class='Ref_to_Func'>backup_dir</span></a> <span class='Operator'>. </span><span class='String'>'/'</span> <span class='Operator'>. </span>$backup_name<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port        <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name        <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>print </span><span class='String'>"# Taking pg_basebackup $backup_name from node \"$name\"\n"</span><span class='Delimiter'>; 
</span>    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN159"><span class='Ref_to_Func'>system_or_bail</span></a><span class='Parentheses'>(</span><span class='String'>'pg_basebackup'</span><span class='Delimiter'>, </span><span class='String'>'-D'</span><span class='Delimiter'>, </span>$backup_path<span class='Delimiter'>, </span><span class='String'>'-p'</span><span class='Delimiter'>, </span>$port<span class='Delimiter'>, 
</span>        <span class='String'>'--no-sync'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"# Backup finished\n"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=item $node-&GT;backup_fs_hot(backup_name) 
 
Create a backup with a filesystem level copy in subdirectory B&LT;backup_name&GT; of 
B&LT;&LT; $node-&GT;backup_dir &GT;&GT;, including WAL. 
 
Archiving must be enabled, as B&LT;pg_start_backup()&GT; and B&LT;pg_stop_backup()&GT; are 
used. This is not checked or enforced. 
 
The backup name is passed as the backup label to B&LT;pg_start_backup()&GT;. 
 
=cut 
</span> 
<a name="LN518"></a><span class='Control'>sub</span> <span class='Declare_Function'>backup_fs_hot</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$backup_name<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN542"><span class='Ref_to_Func'>_backup_fs</span></a><span class='Parentheses'>(</span>$backup_name<span class='Delimiter'>, </span>1<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=item $node-&GT;backup_fs_cold(backup_name) 
 
Create a backup with a filesystem level copy in subdirectory B&LT;backup_name&GT; of 
B&LT;&LT; $node-&GT;backup_dir &GT;&GT;, including WAL. The server must be 
stopped as no attempt to handle concurrent writes is made. 
 
Use B&LT;backup&GT; or B&LT;backup_fs_hot&GT; if you want to back up a running server. 
 
=cut 
</span> 
<a name="LN534"></a><span class='Control'>sub</span> <span class='Declare_Function'>backup_fs_cold</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$backup_name<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN542"><span class='Ref_to_Func'>_backup_fs</span></a><span class='Parentheses'>(</span>$backup_name<span class='Delimiter'>, </span>0<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Single_Line'># Common sub of backup_fs_hot and backup_fs_cold 
</span><a name="LN542"></a><span class='Control'>sub</span> <span class='Declare_Function'>_backup_fs</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$backup_name<span class='Delimiter'>, </span>$hot<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$backup_path <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN302"><span class='Ref_to_Func'>backup_dir</span></a> <span class='Operator'>. </span><span class='String'>'/'</span> <span class='Operator'>. </span>$backup_name<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port        <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name        <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>print </span><span class='String'>"# Taking filesystem backup $backup_name from node \"$name\"\n"</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>$hot<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>my </span>$stdout <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN969"><span class='Ref_to_Func'>safe_psql</span></a><span class='Parentheses'>(</span><span class='String'>'postgres'</span><span class='Delimiter'>, 
</span>            <span class='String'>"SELECT * FROM pg_start_backup('$backup_name');"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span><span class='String'>"# pg_start_backup: $stdout\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    RecursiveCopy<span class='Operator'>::</span><a href="RecursiveCopy.pm.html#LN58"><span class='Ref_to_Func'>copypath</span></a><span class='Parentheses'>(</span> 
        $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>, 
</span>        $backup_path<span class='Delimiter'>, 
</span>        filterfn <span class='Operator'>=&GT; </span><span class='Control'>sub</span> <span class='Delimiter'>{ 
</span>            <span class='Keyword'>my </span>$src <span class='Operator'>= </span><span class='Keyword'>shift</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span>$src <span class='Operator'>ne </span><span class='String'>'log'</span> and $src <span class='Operator'>ne </span><span class='String'>'postmaster.pid'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>$hot<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span> 
        <span class='Comment_Single_Line'># We ignore pg_stop_backup's return value. We also assume archiving 
</span>        <span class='Comment_Single_Line'># is enabled; otherwise the caller will have to copy the remaining 
</span>        <span class='Comment_Single_Line'># segments. 
</span>        <span class='Keyword'>my </span>$stdout <span class='Operator'>= 
</span>          $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN969"><span class='Ref_to_Func'>safe_psql</span></a><span class='Parentheses'>(</span><span class='String'>'postgres'</span><span class='Delimiter'>, </span><span class='String'>'SELECT * FROM pg_stop_backup();'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span><span class='String'>"# pg_stop_backup: $stdout\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Keyword'>print </span><span class='String'>"# Backup finished\n"</span><span class='Delimiter'>; 
} 
</span> 
 
 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;init_from_backup(root_node, backup_name) 
 
Initialize a node from a backup, which may come from this node or a different 
node. root_node must be a PostgresNode reference, backup_name the string name 
of a backup previously created on that node with $node-&GT;backup. 
 
Does not start the node after initializing it. 
 
A recovery.conf is not created. 
 
Streaming replication can be enabled on this node by passing the keyword 
parameter has_streaming =&GT; 1. This is disabled by default. 
 
Restoring WAL segments from archives using restore_command can be enabled 
by passing the keyword parameter has_restoring =&GT; 1. This is disabled by 
default. 
 
The backup is copied, leaving the original unmodified. pg_hba.conf is 
unconditionally set to enable replication connections. 
 
=cut 
</span> 
<a name="LN606"></a><span class='Control'>sub</span> <span class='Declare_Function'>init_from_backup</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$root_node<span class='Delimiter'>, </span>$backup_name<span class='Delimiter'>, </span>%params<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$backup_path <span class='Operator'>= </span>$root_node<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN302"><span class='Ref_to_Func'>backup_dir</span></a> <span class='Operator'>. </span><span class='String'>'/'</span> <span class='Operator'>. </span>$backup_name<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port        <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$node_name   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$root_name   <span class='Operator'>= </span>$root_node<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span> 
    $params<span class='Delimiter'>{</span>has_streaming<span class='Delimiter'>} </span><span class='Operator'>= </span>0 <span class='Control'>unless</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>has_streaming<span class='Delimiter'>}; 
</span>    $params<span class='Delimiter'>{</span>has_restoring<span class='Delimiter'>} </span><span class='Operator'>= </span>0 <span class='Control'>unless</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>has_restoring<span class='Delimiter'>}; 
</span> 
    <span class='Keyword'>print 
</span><span class='String'>"# Initializing node \"$node_name\" from backup \"$backup_name\" of node \"$root_name\"\n"</span><span class='Delimiter'>; 
</span>    <span class='Control'>die</span> <span class='String'>"Backup \"$backup_name\" does not exist at $backup_path"</span> 
      <span class='Control'>unless</span> <span class='Operator'>-</span>d $backup_path<span class='Delimiter'>; 
</span> 
    <span class='Keyword'>mkdir </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN302"><span class='Ref_to_Func'>backup_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>mkdir </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN287"><span class='Ref_to_Func'>archive_dir</span></a><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$data_path <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>rmdir</span><span class='Parentheses'>(</span>$data_path<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    RecursiveCopy<span class='Operator'>::</span><a href="RecursiveCopy.pm.html#LN58"><span class='Ref_to_Func'>copypath</span></a><span class='Parentheses'>(</span>$backup_path<span class='Delimiter'>, </span>$data_path<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>chmod</span><span class='Parentheses'>(</span>0700<span class='Delimiter'>, </span>$data_path<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Base configuration for this node 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN471"><span class='Ref_to_Func'>append_conf</span></a><span class='Parentheses'>( 
</span>        <span class='String'>'postgresql.conf'</span><span class='Delimiter'>, 
</span>        <span class='Operator'>qq</span><span class='String'>( 
</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a> <span class='Operator'>= </span>$port 
<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN756"><span class='Ref_to_Func'>enable_streaming</span></a><span class='Parentheses'>(</span>$root_node<span class='Parentheses'>) </span><span class='Control'>if</span> $params<span class='Delimiter'>{</span>has_streaming<span class='Delimiter'>}; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN771"><span class='Ref_to_Func'>enable_restoring</span></a><span class='Parentheses'>(</span>$root_node<span class='Parentheses'>) </span><span class='Control'>if</span> $params<span class='Delimiter'>{</span>has_restoring<span class='Delimiter'>}; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;start() 
 
Wrapper for pg_ctl start 
 
Start the node and wait until it is ready to accept connections. 
 
=cut 
</span> 
<a name="LN650"></a><span class='Control'>sub</span> <span class='Declare_Function'>start</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgdata <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span>    BAIL_OUT<span class='Parentheses'>(</span><span class='String'>"node \"$name\" is already running"</span><span class='Parentheses'>) </span><span class='Control'>if</span> <span class='Keyword'>defined </span>$self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_pid<span class='Delimiter'>}; 
</span>    <span class='Keyword'>print</span><span class='Parentheses'>(</span><span class='String'>"### Starting node \"$name\"\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$ret <span class='Operator'>= </span>TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN153"><span class='Ref_to_Func'>system_log</span></a><span class='Parentheses'>(</span><span class='String'>'pg_ctl'</span><span class='Delimiter'>, </span><span class='String'>'-D'</span><span class='Delimiter'>, </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>, </span><span class='String'>'-l'</span><span class='Delimiter'>, 
</span>        $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN230"><span class='Ref_to_Func'>logfile</span></a><span class='Delimiter'>, </span><span class='String'>'start'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>$ret <span class='Operator'>!= </span>0<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>print </span><span class='String'>"# pg_ctl start failed; logfile:\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN196"><span class='Ref_to_Func'>slurp_file</span></a><span class='Parentheses'>(</span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN230"><span class='Ref_to_Func'>logfile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        BAIL_OUT<span class='Parentheses'>(</span><span class='String'>"pg_ctl start failed"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN828"><span class='Ref_to_Func'>_update_pid</span></a><span class='Parentheses'>(</span>1<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;stop(mode) 
 
Stop the node using pg_ctl -m $mode and wait for it to stop. 
 
Note: if the node is already known stopped, this does nothing. 
However, if we think it's running and it's not, it's important for 
this to fail.  Otherwise, tests might fail to detect server crashes. 
 
=cut 
</span> 
<a name="LN683"></a><span class='Control'>sub</span> <span class='Declare_Function'>stop</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$mode<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgdata <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span>    $mode <span class='Operator'>= </span><span class='String'>'fast'</span> <span class='Control'>unless</span> <span class='Keyword'>defined </span>$mode<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Control'>unless</span> <span class='Keyword'>defined </span>$self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_pid<span class='Delimiter'>}; 
</span>    <span class='Keyword'>print </span><span class='String'>"### Stopping node \"$name\" using mode $mode\n"</span><span class='Delimiter'>; 
</span>    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN159"><span class='Ref_to_Func'>system_or_bail</span></a><span class='Parentheses'>(</span><span class='String'>'pg_ctl'</span><span class='Delimiter'>, </span><span class='String'>'-D'</span><span class='Delimiter'>, </span>$pgdata<span class='Delimiter'>, </span><span class='String'>'-m'</span><span class='Delimiter'>, </span>$mode<span class='Delimiter'>, </span><span class='String'>'stop'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN828"><span class='Ref_to_Func'>_update_pid</span></a><span class='Parentheses'>(</span>0<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;reload() 
 
Reload configuration parameters on the node. 
 
=cut 
</span> 
<a name="LN704"></a><span class='Control'>sub</span> <span class='Declare_Function'>reload</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgdata <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"### Reloading node \"$name\"\n"</span><span class='Delimiter'>; 
</span>    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN159"><span class='Ref_to_Func'>system_or_bail</span></a><span class='Parentheses'>(</span><span class='String'>'pg_ctl'</span><span class='Delimiter'>, </span><span class='String'>'-D'</span><span class='Delimiter'>, </span>$pgdata<span class='Delimiter'>, </span><span class='String'>'reload'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;restart() 
 
Wrapper for pg_ctl restart 
 
=cut 
</span> 
<a name="LN722"></a><span class='Control'>sub</span> <span class='Declare_Function'>restart</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>)</span>  <span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port    <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgdata  <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$logfile <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN230"><span class='Ref_to_Func'>logfile</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name    <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"### Restarting node \"$name\"\n"</span><span class='Delimiter'>; 
</span>    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN159"><span class='Ref_to_Func'>system_or_bail</span></a><span class='Parentheses'>(</span><span class='String'>'pg_ctl'</span><span class='Delimiter'>, </span><span class='String'>'-D'</span><span class='Delimiter'>, </span>$pgdata<span class='Delimiter'>, </span><span class='String'>'-l'</span><span class='Delimiter'>, </span>$logfile<span class='Delimiter'>, 
</span>        <span class='String'>'restart'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN828"><span class='Ref_to_Func'>_update_pid</span></a><span class='Parentheses'>(</span>1<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;promote() 
 
Wrapper for pg_ctl promote 
 
=cut 
</span> 
<a name="LN743"></a><span class='Control'>sub</span> <span class='Declare_Function'>promote</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>)</span>  <span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port    <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$pgdata  <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$logfile <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN230"><span class='Ref_to_Func'>logfile</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name    <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"### Promoting node \"$name\"\n"</span><span class='Delimiter'>; 
</span>    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN159"><span class='Ref_to_Func'>system_or_bail</span></a><span class='Parentheses'>(</span><span class='String'>'pg_ctl'</span><span class='Delimiter'>, </span><span class='String'>'-D'</span><span class='Delimiter'>, </span>$pgdata<span class='Delimiter'>, </span><span class='String'>'-l'</span><span class='Delimiter'>, </span>$logfile<span class='Delimiter'>, 
</span>        <span class='String'>'promote'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Single_Line'># Internal routine to enable streaming replication on a standby node. 
</span><a name="LN756"></a><span class='Control'>sub</span> <span class='Declare_Function'>enable_streaming</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$root_node<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$root_connstr <span class='Operator'>= </span>$root_node<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN245"><span class='Ref_to_Func'>connstr</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name         <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>print </span><span class='String'>"### Enabling streaming replication for node \"$name\"\n"</span><span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN471"><span class='Ref_to_Func'>append_conf</span></a><span class='Parentheses'>( 
</span>        <span class='String'>'recovery.conf'</span><span class='Delimiter'>, </span><span class='Operator'>qq</span><span class='String'>( 
</span>primary_conninfo<span class='Operator'>=</span><span class='String'>'$root_connstr application_name=$name'</span> 
standby_mode<span class='Operator'>=</span>on 
<span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Single_Line'># Internal routine to enable archive recovery command on a standby node 
</span><a name="LN771"></a><span class='Control'>sub</span> <span class='Declare_Function'>enable_restoring</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$root_node<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$path <span class='Operator'>= </span>$vfs_path <span class='Operator'>. </span>$root_node<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN287"><span class='Ref_to_Func'>archive_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>print </span><span class='String'>"### Enabling WAL restore for node \"$name\"\n"</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># On Windows, the path specified in the restore command needs to use 
</span>    <span class='Comment_Single_Line'># double back-slashes to work properly and to be able to detect properly 
</span>    <span class='Comment_Single_Line'># the file targeted by the copy command, so the directory value used 
</span>    <span class='Comment_Single_Line'># in this routine, using only one back-slash, need to be properly changed 
</span>    <span class='Comment_Single_Line'># first. Paths also need to be double-quoted to prevent failures where 
</span>    <span class='Comment_Single_Line'># the path contains spaces. 
</span>    $path <span class='Operator'>=~ s</span><span class='String'>{\\}{\\\\}g if ($TestLib::windows_os); 
</span>    <span class='Keyword'>my </span>$copy_command <span class='Operator'>= 
</span>      $TestLib<span class='Operator'>::</span>windows_os 
      <span class='Operator'>? qq</span><span class='String'>{copy "$path\\\\%f" "%p"}</span> 
      <span class='Operator'>: qq</span><span class='String'>{cp "$path/%f" "%p"}</span><span class='Delimiter'>; 
</span> 
    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN471"><span class='Ref_to_Func'>append_conf</span></a><span class='Parentheses'>( 
</span>        <span class='String'>'recovery.conf'</span><span class='Delimiter'>, </span><span class='Operator'>qq</span><span class='String'>( 
</span>restore_command <span class='Operator'>= </span><span class='String'>'$copy_command'</span> 
standby_mode <span class='Operator'>= </span>on 
<span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Single_Line'># Internal routine to enable archiving 
</span><a name="LN799"></a><span class='Control'>sub</span> <span class='Declare_Function'>enable_archiving</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$path   <span class='Operator'>= </span>$vfs_path <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN287"><span class='Ref_to_Func'>archive_dir</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name   <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>print </span><span class='String'>"### Enabling WAL archiving for node \"$name\"\n"</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># On Windows, the path specified in the restore command needs to use 
</span>    <span class='Comment_Single_Line'># double back-slashes to work properly and to be able to detect properly 
</span>    <span class='Comment_Single_Line'># the file targeted by the copy command, so the directory value used 
</span>    <span class='Comment_Single_Line'># in this routine, using only one back-slash, need to be properly changed 
</span>    <span class='Comment_Single_Line'># first. Paths also need to be double-quoted to prevent failures where 
</span>    <span class='Comment_Single_Line'># the path contains spaces. 
</span>    $path <span class='Operator'>=~ s</span><span class='String'>{\\}{\\\\}g if ($TestLib::windows_os); 
</span>    <span class='Keyword'>my </span>$copy_command <span class='Operator'>= 
</span>      $TestLib<span class='Operator'>::</span>windows_os 
      <span class='Operator'>? qq</span><span class='String'>{copy "%p" "$path\\\\%f"}</span> 
      <span class='Operator'>: qq</span><span class='String'>{cp "%p" "$path/%f"}</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Enable archive_mode and archive_command on node 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN471"><span class='Ref_to_Func'>append_conf</span></a><span class='Parentheses'>( 
</span>        <span class='String'>'postgresql.conf'</span><span class='Delimiter'>, </span><span class='Operator'>qq</span><span class='String'>( 
</span>archive_mode <span class='Operator'>= </span>on 
archive_command <span class='Operator'>= </span><span class='String'>'$copy_command'</span> 
<span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Single_Line'># Internal method 
</span><a name="LN828"></a><span class='Control'>sub</span> <span class='Declare_Function'>_update_pid</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$is_running<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$name <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># If we can open the PID file, read its first line and that's the PID we 
</span>    <span class='Comment_Single_Line'># want. 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>open my </span>$pidfile<span class='Delimiter'>, </span><span class='String'>'&LT;'</span><span class='Delimiter'>, </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN272"><span class='Ref_to_Func'>data_dir</span></a> <span class='Operator'>. </span><span class='String'>"/postmaster.pid"</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>chomp</span><span class='Parentheses'>(</span>$self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_pid<span class='Delimiter'>} </span><span class='Operator'>= &LT;</span>$pidfile<span class='Operator'>&GT;</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span><span class='String'>"# Postmaster PID for node \"$name\" is $self-&GT;{_pid}\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>close </span>$pidfile<span class='Delimiter'>; 
</span> 
        <span class='Comment_Single_Line'># If we found a pidfile when there shouldn't be one, complain. 
</span>        BAIL_OUT<span class='Parentheses'>(</span><span class='String'>"postmaster.pid unexpectedly present"</span><span class='Parentheses'>) </span><span class='Control'>unless</span> $is_running<span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    $self<span class='Operator'>-&GT;</span><span class='Delimiter'>{</span>_pid<span class='Delimiter'>} </span><span class='Operator'>= </span><span class='Keyword'>undef</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"# No postmaster PID for node \"$name\"\n"</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Complain if we expected to find a pidfile. 
</span>    BAIL_OUT<span class='Parentheses'>(</span><span class='String'>"postmaster.pid unexpectedly not present"</span><span class='Parentheses'>) </span><span class='Control'>if</span> $is_running<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item get_new_node(node_name) 
 
Build a new PostgresNode object, assigning a free port number. Standalone 
function that's automatically imported. 
 
Remembers the node, to prevent its port number from being reused for another 
node, and to ensure that it gets shut down when the test script exits. 
 
You should generally use this instead of PostgresNode::new(...). 
 
=cut 
</span> 
<a name="LN867"></a><span class='Control'>sub</span> <span class='Declare_Function'>get_new_node</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span>$name  <span class='Operator'>= </span><span class='Keyword'>shift</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$found <span class='Operator'>= </span>0<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$port  <span class='Operator'>= </span>$last_port_assigned<span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span>$found <span class='Operator'>== </span>0<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span> 
        <span class='Comment_Single_Line'># advance $port, wrapping correctly around range end 
</span>        $port <span class='Operator'>= </span>49152 <span class='Control'>if</span> <span class='Operator'>++</span>$port <span class='Operator'>&GT;= </span>65536<span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span><span class='String'>"# Checking port $port\n"</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Single_Line'># Check first that candidate port number is not included in 
</span>        <span class='Comment_Single_Line'># the list of already-registered nodes. 
</span>        $found <span class='Operator'>= </span>1<span class='Delimiter'>; 
</span>        <span class='Control'>foreach</span> <span class='Keyword'>my </span>$node <span class='Parentheses'>(</span>@all_nodes<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            $found <span class='Operator'>= </span>0 <span class='Control'>if</span> <span class='Parentheses'>(</span>$node<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a> <span class='Operator'>== </span>$port<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Single_Line'># Check to see if anything else is listening on this TCP port. 
</span>        <span class='Comment_Single_Line'># This is *necessary* on Windows, and seems like a good idea 
</span>        <span class='Comment_Single_Line'># on Unixen as well, even though we don't ask the postmaster 
</span>        <span class='Comment_Single_Line'># to open a TCP port on Unix. 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>$found <span class='Operator'>== </span>1<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Keyword'>my </span>$iaddr <span class='Operator'>= </span>inet_aton<span class='Parentheses'>(</span>$test_localhost<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Keyword'>my </span>$paddr <span class='Operator'>= </span>sockaddr_in<span class='Parentheses'>(</span>$port<span class='Delimiter'>, </span>$iaddr<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Keyword'>my </span>$proto <span class='Operator'>= </span><span class='Keyword'>getprotobyname</span><span class='Parentheses'>(</span><span class='String'>"tcp"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Keyword'>socket</span><span class='Parentheses'>(</span>SOCK<span class='Delimiter'>, </span>PF_INET<span class='Delimiter'>, </span>SOCK_STREAM<span class='Delimiter'>, </span>$proto<span class='Parentheses'>) 
</span>              or <span class='Control'>die</span> <span class='String'>"socket failed: $!"</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Single_Line'># As in postmaster, don't use SO_REUSEADDR on Windows 
</span>            <span class='Keyword'>setsockopt</span><span class='Parentheses'>(</span>SOCK<span class='Delimiter'>, </span>SOL_SOCKET<span class='Delimiter'>, </span>SO_REUSEADDR<span class='Delimiter'>, </span><span class='Keyword'>pack</span><span class='Parentheses'>(</span><span class='String'>"l"</span><span class='Delimiter'>, </span>1<span class='Parentheses'>))</span> 
              <span class='Control'>unless</span> $TestLib<span class='Operator'>::</span>windows_os<span class='Delimiter'>; 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>bind</span><span class='Parentheses'>(</span>SOCK<span class='Delimiter'>, </span>$paddr<span class='Parentheses'>) </span><span class='Operator'>&& </span><span class='Keyword'>listen</span><span class='Parentheses'>(</span>SOCK<span class='Delimiter'>, </span>SOMAXCONN<span class='Parentheses'>))</span> 
              or $found <span class='Operator'>= </span>0<span class='Delimiter'>; 
</span>            <span class='Keyword'>close</span><span class='Parentheses'>(</span>SOCK<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Keyword'>print </span><span class='String'>"# Found free port $port\n"</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Lock port number found by creating a new node 
</span>    <span class='Keyword'>my </span>$node <span class='Operator'>= </span><a href="PostgresNode.pm.html#LN142"><span class='Ref_to_Func'>new</span></a> PostgresNode<span class='Parentheses'>(</span>$name<span class='Delimiter'>, </span>$test_pghost<span class='Delimiter'>, </span>$port<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Add node to list of nodes 
</span>    <span class='Keyword'>push</span><span class='Parentheses'>(</span>@all_nodes<span class='Delimiter'>, </span>$node<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># And update port for next time 
</span>    $last_port_assigned <span class='Operator'>= </span>$port<span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> $node<span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Single_Line'># Automatically shut down any still-running nodes when the test script exits. 
# Note that this just stops the postmasters (in the same order the nodes were 
# created in).  Temporary PGDATA directories are deleted, in an unspecified 
# order, later when the File::Temp objects are destroyed. 
</span>END 
<span class='Delimiter'>{ 
</span> 
    <span class='Comment_Single_Line'># take care not to change the script's exit value 
</span>    <span class='Keyword'>my </span>$exit_code <span class='Operator'>= </span>$<span class='Operator'>?</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>foreach</span> <span class='Keyword'>my </span>$node <span class='Parentheses'>(</span>@all_nodes<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        $node<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN950"><span class='Ref_to_Func'>teardown_node</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    $<span class='Operator'>? = </span>$exit_code<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;teardown_node() 
 
Do an immediate stop of the node 
 
=cut 
</span> 
<a name="LN950"></a><span class='Control'>sub</span> <span class='Declare_Function'>teardown_node</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span>$self <span class='Operator'>= </span><span class='Keyword'>shift</span><span class='Delimiter'>; 
</span> 
    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN683"><span class='Ref_to_Func'>stop</span></a><span class='Parentheses'>(</span><span class='String'>'immediate'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;safe_psql($dbname, $sql) =&GT; stdout 
 
Invoke B&LT;psql&GT; to run B&LT;sql&GT; on B&LT;dbname&GT; and return its stdout on success. 
Die if the SQL produces an error. Runs with B&LT;ON_ERROR_STOP&GT; set. 
 
Takes optional extra params like timeout and timed_out parameters with the same 
options as psql. 
 
=cut 
</span> 
<a name="LN969"></a><span class='Control'>sub</span> <span class='Declare_Function'>safe_psql</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$dbname<span class='Delimiter'>, </span>$sql<span class='Delimiter'>, </span>%params<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$stdout<span class='Delimiter'>, </span>$stderr<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$ret <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN1075"><span class='Ref_to_Func'>psql</span></a><span class='Parentheses'>( 
</span>        $dbname<span class='Delimiter'>, </span>$sql<span class='Delimiter'>, 
</span>        %params<span class='Delimiter'>, 
</span>        stdout        <span class='Operator'>=&GT; \</span>$stdout<span class='Delimiter'>, 
</span>        stderr        <span class='Operator'>=&GT; \</span>$stderr<span class='Delimiter'>, 
</span>        on_error_die  <span class='Operator'>=&GT; </span>1<span class='Delimiter'>, 
</span>        on_error_stop <span class='Operator'>=&GT; </span>1<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># psql can emit stderr from NOTICEs etc 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>$stderr <span class='Operator'>ne </span><span class='String'>""</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>print </span><span class='String'>"#### Begin standard error\n"</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span>$stderr<span class='Delimiter'>; 
</span>        <span class='Keyword'>print </span><span class='String'>"\n#### End standard error\n"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    $stdout <span class='Operator'>=~ s</span><span class='String'>/\r//</span>g <span class='Control'>if</span> $TestLib<span class='Operator'>::</span>windows_os<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $stdout<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;psql($dbname, $sql, %params) =&GT; psql_retval 
 
Invoke B&LT;psql&GT; to execute B&LT;$sql&GT; on B&LT;$dbname&GT; and return the return value 
from B&LT;psql&GT;, which is run with on_error_stop by default so that it will 
stop running sql and return 3 if the passed SQL results in an error. 
 
As a convenience, if B&LT;psql&GT; is called in array context it returns an 
array containing ($retval, $stdout, $stderr). 
 
psql is invoked in tuples-only unaligned mode with reading of B&LT;.psqlrc&GT; 
disabled.  That may be overridden by passing extra psql parameters. 
 
stdout and stderr are transformed to UNIX line endings if on Windows. Any 
trailing newline is removed. 
 
Dies on failure to invoke psql but not if psql exits with a nonzero 
return code (unless on_error_die specified). 
 
If psql exits because of a signal, an exception is raised. 
 
=over 
 
=item stdout =&GT; \$stdout 
 
B&LT;stdout&GT;, if given, must be a scalar reference to which standard output is 
written.  If not given, standard output is not redirected and will be printed 
unless B&LT;psql&GT; is called in array context, in which case it's captured and 
returned. 
 
=item stderr =&GT; \$stderr 
 
Same as B&LT;stdout&GT; but gets standard error. If the same scalar is passed for 
both B&LT;stdout&GT; and B&LT;stderr&GT; the results may be interleaved unpredictably. 
 
=item on_error_stop =&GT; 1 
 
By default, the B&LT;psql&GT; method invokes the B&LT;psql&GT; program with ON_ERROR_STOP=1 
set, so SQL execution is stopped at the first error and exit code 2 is 
returned.  Set B&LT;on_error_stop&GT; to 0 to ignore errors instead. 
 
=item on_error_die =&GT; 0 
 
By default, this method returns psql's result code. Pass on_error_die to 
instead die with an informative message. 
 
=item timeout =&GT; 'interval' 
 
Set a timeout for the psql call as an interval accepted by B&LT;IPC::Run::timer&GT; 
(integer seconds is fine).  This method raises an exception on timeout, unless 
the B&LT;timed_out&GT; parameter is also given. 
 
=item timed_out =&GT; \$timed_out 
 
If B&LT;timeout&GT; is set and this parameter is given, the scalar it references 
is set to true if the psql call times out. 
 
=item extra_params =&GT; ['--single-transaction'] 
 
If given, it must be an array reference containing additional parameters to B&LT;psql&GT;. 
 
=back 
 
e.g. 
 
    my ($stdout, $stderr, $timed_out); 
    my $cmdret = $node-&GT;psql('postgres', 'SELECT pg_sleep(60)', 
        stdout =&GT; \$stdout, stderr =&GT; \$stderr, 
        timeout =&GT; 30, timed_out =&GT; \$timed_out, 
        extra_params =&GT; ['--single-transaction']) 
 
will set $cmdret to undef and $timed_out to a true value. 
 
    $node-&GT;psql('postgres', $sql, on_error_die =&GT; 1); 
 
dies with an informative message if $sql fails. 
 
=cut 
</span> 
<a name="LN1075"></a><span class='Control'>sub</span> <span class='Declare_Function'>psql</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$dbname<span class='Delimiter'>, </span>$sql<span class='Delimiter'>, </span>%params<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$stdout            <span class='Operator'>= </span>$params<span class='Delimiter'>{</span>stdout<span class='Delimiter'>}; 
</span>    <span class='Keyword'>my </span>$stderr            <span class='Operator'>= </span>$params<span class='Delimiter'>{</span>stderr<span class='Delimiter'>}; 
</span>    <span class='Keyword'>my </span>$timeout           <span class='Operator'>= </span><span class='Keyword'>undef</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$timeout_exception <span class='Operator'>= </span><span class='String'>'psql timed out'</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>@psql_params <span class='Operator'>= 
</span>      <span class='Parentheses'>(</span><span class='String'>'psql'</span><span class='Delimiter'>, </span><span class='String'>'-XAtq'</span><span class='Delimiter'>, </span><span class='String'>'-d'</span><span class='Delimiter'>, </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN245"><span class='Ref_to_Func'>connstr</span></a><span class='Parentheses'>(</span>$dbname<span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>'-f'</span><span class='Delimiter'>, </span><span class='String'>'-'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># If the caller wants an array and hasn't passed stdout/stderr 
</span>    <span class='Comment_Single_Line'># references, allocate temporary ones to capture them so we 
</span>    <span class='Comment_Single_Line'># can return them. Otherwise we won't redirect them at all. 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>wantarray</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$stdout<span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Keyword'>my </span>$temp_stdout <span class='Operator'>= </span><span class='String'>""</span><span class='Delimiter'>; 
</span>            $stdout <span class='Operator'>= \</span>$temp_stdout<span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$stderr<span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Keyword'>my </span>$temp_stderr <span class='Operator'>= </span><span class='String'>""</span><span class='Delimiter'>; 
</span>            $stderr <span class='Operator'>= \</span>$temp_stderr<span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    $params<span class='Delimiter'>{</span>on_error_stop<span class='Delimiter'>} </span><span class='Operator'>= </span>1 <span class='Control'>unless</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>on_error_stop<span class='Delimiter'>}; 
</span>    $params<span class='Delimiter'>{</span>on_error_die<span class='Delimiter'>}</span>  <span class='Operator'>= </span>0 <span class='Control'>unless</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>on_error_die<span class='Delimiter'>}; 
</span> 
    <span class='Keyword'>push </span>@psql_params<span class='Delimiter'>, </span><span class='String'>'-v'</span><span class='Delimiter'>, </span><span class='String'>'ON_ERROR_STOP=1'</span> <span class='Control'>if</span> $params<span class='Delimiter'>{</span>on_error_stop<span class='Delimiter'>}; 
</span>    <span class='Keyword'>push </span>@psql_params<span class='Delimiter'>, </span>@<span class='Delimiter'>{ </span>$params<span class='Delimiter'>{</span>extra_params<span class='Delimiter'>} } 
</span>      <span class='Control'>if</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>extra_params<span class='Delimiter'>}; 
</span> 
    $timeout <span class='Operator'>= 
</span>      IPC<span class='Operator'>::</span><a href="../../backend/utils/Gen_dummy_probes.pl.html#LN33"><span class='Ref_to_Func'>Run</span></a><span class='Operator'>::</span>timeout<span class='Parentheses'>(</span>$params<span class='Delimiter'>{</span>timeout<span class='Delimiter'>}, </span>exception <span class='Operator'>=&GT; </span>$timeout_exception<span class='Parentheses'>) 
</span>      <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$params<span class='Delimiter'>{</span>timeout<span class='Delimiter'>}</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    $<span class='Delimiter'>{ </span>$params<span class='Delimiter'>{</span>timed_out<span class='Delimiter'>} } </span><span class='Operator'>= </span>0 <span class='Control'>if</span> <span class='Keyword'>defined </span>$params<span class='Delimiter'>{</span>timed_out<span class='Delimiter'>}; 
</span> 
    <span class='Comment_Single_Line'># IPC::Run would otherwise append to existing contents: 
</span>    $$stdout <span class='Operator'>= </span><span class='String'>""</span> <span class='Control'>if</span> <span class='Keyword'>ref</span><span class='Parentheses'>(</span>$stdout<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    $$stderr <span class='Operator'>= </span><span class='String'>""</span> <span class='Control'>if</span> <span class='Keyword'>ref</span><span class='Parentheses'>(</span>$stderr<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$ret<span class='Delimiter'>; 
</span> 
   <span class='Comment_Single_Line'># Run psql and capture any possible exceptions.  If the exception is 
</span>   <span class='Comment_Single_Line'># because of a timeout and the caller requested to handle that, just return 
</span>   <span class='Comment_Single_Line'># and set the flag.  Otherwise, and for any other exception, rethrow. 
</span>   <span class='Comment_Single_Line'># 
</span>   <span class='Comment_Single_Line'># For background, see 
</span>   <span class='Comment_Single_Line'># http://search.cpan.org/~ether/Try-Tiny-0.24/lib/Try/Tiny.pm 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>local </span>$@<span class='Delimiter'>; 
</span>        <span class='Keyword'>eval </span><span class='Delimiter'>{ 
</span>            <span class='Keyword'>my </span>@ipcrun_opts <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Operator'>\</span>@psql_params<span class='Delimiter'>, </span><span class='String'>'&LT;'</span><span class='Delimiter'>, </span><span class='Operator'>\</span>$sql<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Keyword'>push </span>@ipcrun_opts<span class='Delimiter'>, </span><span class='String'>'&GT;'</span><span class='Delimiter'>,</span>  $stdout <span class='Control'>if</span> <span class='Keyword'>defined </span>$stdout<span class='Delimiter'>; 
</span>            <span class='Keyword'>push </span>@ipcrun_opts<span class='Delimiter'>, </span><span class='String'>'2&GT;'</span><span class='Delimiter'>, </span>$stderr <span class='Control'>if</span> <span class='Keyword'>defined </span>$stderr<span class='Delimiter'>; 
</span>            <span class='Keyword'>push </span>@ipcrun_opts<span class='Delimiter'>, </span>$timeout <span class='Control'>if</span> <span class='Keyword'>defined </span>$timeout<span class='Delimiter'>; 
</span> 
            IPC<span class='Operator'>::</span><a href="../../backend/utils/Gen_dummy_probes.pl.html#LN33"><span class='Ref_to_Func'>Run</span></a><span class='Operator'>::</span>run @ipcrun_opts<span class='Delimiter'>; 
</span>            $ret <span class='Operator'>= </span>$<span class='Operator'>?</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}; 
</span>        <span class='Keyword'>my </span>$exc_save <span class='Operator'>= </span>$@<span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>$exc_save<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span> 
            <span class='Comment_Single_Line'># IPC::Run::run threw an exception. re-throw unless it's a 
</span>            <span class='Comment_Single_Line'># timeout, which we'll handle by testing is_expired 
</span>            <span class='Control'>die</span> $exc_save 
              <span class='Control'>if</span> <span class='Parentheses'>(</span>blessed<span class='Parentheses'>(</span>$exc_save<span class='Parentheses'>) 
</span>                <span class='Operator'>|| </span>$exc_save <span class='Operator'>!~ /^\Q$timeout_exception\E/</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            $ret <span class='Operator'>= </span><span class='Keyword'>undef</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>die</span> <span class='String'>"Got timeout exception '$exc_save' but timer not expired?!"</span> 
              <span class='Control'>unless</span> $timeout<span class='Operator'>-&GT;</span>is_expired<span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$params<span class='Delimiter'>{</span>timed_out<span class='Delimiter'>}</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                $<span class='Delimiter'>{ </span>$params<span class='Delimiter'>{</span>timed_out<span class='Delimiter'>} } </span><span class='Operator'>= </span>1<span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>die</span> <span class='String'>"psql timed out: stderr: '$$stderr'\n"</span> 
                  <span class='Operator'>. </span><span class='String'>"while running '@psql_params'"</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>defined </span>$$stdout<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>chomp </span>$$stdout<span class='Delimiter'>; 
</span>        $$stdout <span class='Operator'>=~ s</span><span class='String'>/\r//</span>g <span class='Control'>if</span> $TestLib<span class='Operator'>::</span>windows_os<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>defined </span>$$stderr<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>chomp </span>$$stderr<span class='Delimiter'>; 
</span>        $$stderr <span class='Operator'>=~ s</span><span class='String'>/\r//</span>g <span class='Control'>if</span> $TestLib<span class='Operator'>::</span>windows_os<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Single_Line'># See http://perldoc.perl.org/perlvar.html#%24CHILD_ERROR 
</span>    <span class='Comment_Single_Line'># We don't use IPC::Run::Simple to limit dependencies. 
</span>    <span class='Comment_Single_Line'># 
</span>    <span class='Comment_Single_Line'># We always die on signal. 
</span>    <span class='Keyword'>my </span>$core <span class='Operator'>= </span>$ret <span class='Operator'>& </span>128 <span class='Operator'>? </span><span class='String'>" (core dumped)"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>; 
</span>    <span class='Control'>die</span> <span class='String'>"psql exited with signal "</span> 
      <span class='Operator'>. </span><span class='Parentheses'>(</span>$ret <span class='Operator'>& </span>127<span class='Parentheses'>) 
</span>      <span class='Operator'>. </span><span class='String'>"$core: '$$stderr' while running '@psql_params'"</span> 
      <span class='Control'>if</span> $ret <span class='Operator'>& </span>127<span class='Delimiter'>; 
</span>    $ret <span class='Operator'>= </span>$ret <span class='Operator'>&GT;&GT; </span>8<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>$ret <span class='Operator'>&& </span>$params<span class='Delimiter'>{</span>on_error_die<span class='Delimiter'>}</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>die</span> <span class='String'>"psql error: stderr: '$$stderr'\nwhile running '@psql_params'"</span> 
          <span class='Control'>if</span> $ret <span class='Operator'>== </span>1<span class='Delimiter'>; 
</span>        <span class='Control'>die</span> <span class='String'>"connection error: '$$stderr'\nwhile running '@psql_params'"</span> 
          <span class='Control'>if</span> $ret <span class='Operator'>== </span>2<span class='Delimiter'>; 
</span>        <span class='Control'>die</span> 
<span class='String'>"error running SQL: '$$stderr'\nwhile running '@psql_params' with sql '$sql'"</span> 
          <span class='Control'>if</span> $ret <span class='Operator'>== </span>3<span class='Delimiter'>; 
</span>        <span class='Control'>die</span> <span class='String'>"psql returns $ret: '$$stderr'\nwhile running '@psql_params'"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>wantarray</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span>$ret<span class='Delimiter'>, </span>$$stdout<span class='Delimiter'>, </span>$$stderr<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span> $ret<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;poll_query_until(dbname, query) 
 
Run a query once a second, until it returns 't' (i.e. SQL boolean true). 
Continues polling if psql returns an error result. Times out after 180 seconds. 
 
=cut 
</span> 
<a name="LN1221"></a><span class='Control'>sub</span> <span class='Declare_Function'>poll_query_until</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$dbname<span class='Delimiter'>, </span>$query<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$max_attempts <span class='Operator'>= </span>180<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$attempts     <span class='Operator'>= </span>0<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$stdout<span class='Delimiter'>, </span>$stderr<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span>$attempts <span class='Operator'>&LT; </span>$max_attempts<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>my </span>$cmd <span class='Operator'>= 
</span>          <span class='Delimiter'>[ </span><span class='String'>'psql'</span><span class='Delimiter'>, </span><span class='String'>'-XAt'</span><span class='Delimiter'>, </span><span class='String'>'-c'</span><span class='Delimiter'>, </span>$query<span class='Delimiter'>, </span><span class='String'>'-d'</span><span class='Delimiter'>, </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN245"><span class='Ref_to_Func'>connstr</span></a><span class='Parentheses'>(</span>$dbname<span class='Parentheses'>) </span><span class='Delimiter'>]; 
</span>        <span class='Keyword'>my </span>$result <span class='Operator'>= </span>IPC<span class='Operator'>::</span><a href="../../backend/utils/Gen_dummy_probes.pl.html#LN33"><span class='Ref_to_Func'>Run</span></a><span class='Operator'>::</span>run $cmd<span class='Delimiter'>, </span><span class='String'>'&GT;'</span><span class='Delimiter'>, </span><span class='Operator'>\</span>$stdout<span class='Delimiter'>, </span><span class='String'>'2&GT;'</span><span class='Delimiter'>, </span><span class='Operator'>\</span>$stderr<span class='Delimiter'>; 
</span> 
        <span class='Keyword'>chomp</span><span class='Parentheses'>(</span>$stdout<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        $stdout <span class='Operator'>=~ s</span><span class='String'>/\r//</span>g <span class='Control'>if</span> $TestLib<span class='Operator'>::</span>windows_os<span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>$stdout <span class='Operator'>eq </span><span class='String'>"t"</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>return</span> 1<span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Single_Line'># Wait a second before retrying. 
</span>        <span class='Keyword'>sleep </span>1<span class='Delimiter'>; 
</span>        $attempts<span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Single_Line'># The query result didn't change in 180 seconds. Give up. Print the stderr 
</span>    <span class='Comment_Single_Line'># from the last attempt, hopefully that's useful for debugging. 
</span>    diag $stderr<span class='Delimiter'>; 
</span>    <span class='Control'>return</span> 0<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;command_ok(...) 
 
Runs a shell command like TestLib::command_ok, but with PGPORT 
set so that the command will default to connecting to this 
PostgresNode. 
 
=cut 
</span> 
<a name="LN1263"></a><span class='Control'>sub</span> <span class='Declare_Function'>command_ok</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span>$self <span class='Operator'>= </span><span class='Keyword'>shift</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>local </span>$ENV<span class='Delimiter'>{</span>PGPORT<span class='Delimiter'>} </span><span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span> 
    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN220"><span class='Ref_to_Func'>command_ok</span></a><span class='Parentheses'>(</span>@_<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;command_fails(...) - TestLib::command_fails with our PGPORT 
 
See command_ok(...) 
 
=cut 
</span> 
<a name="LN1280"></a><span class='Control'>sub</span> <span class='Declare_Function'>command_fails</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span>$self <span class='Operator'>= </span><span class='Keyword'>shift</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>local </span>$ENV<span class='Delimiter'>{</span>PGPORT<span class='Delimiter'>} </span><span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span> 
    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN227"><span class='Ref_to_Func'>command_fails</span></a><span class='Parentheses'>(</span>@_<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;command_like(...) 
 
TestLib::command_like with our PGPORT. See command_ok(...) 
 
=cut 
</span> 
<a name="LN1297"></a><span class='Control'>sub</span> <span class='Declare_Function'>command_like</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span>$self <span class='Operator'>= </span><span class='Keyword'>shift</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>local </span>$ENV<span class='Delimiter'>{</span>PGPORT<span class='Delimiter'>} </span><span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span> 
    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN291"><span class='Ref_to_Func'>command_like</span></a><span class='Parentheses'>(</span>@_<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;issues_sql_like(cmd, expected_sql, test_name) 
 
Run a command on the node, then verify that $expected_sql appears in the 
server log file. 
 
Reads the whole log file so be careful when working with large log outputs. 
The log file is truncated prior to running the command, however. 
 
=cut 
</span> 
<a name="LN1318"></a><span class='Control'>sub</span> <span class='Declare_Function'>issues_sql_like</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$cmd<span class='Delimiter'>, </span>$expected_sql<span class='Delimiter'>, </span>$test_name<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span> 
    <span class='Keyword'>local </span>$ENV<span class='Delimiter'>{</span>PGPORT<span class='Delimiter'>} </span><span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>truncate </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN230"><span class='Ref_to_Func'>logfile</span></a><span class='Delimiter'>, </span>0<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$result <span class='Operator'>= </span>TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN167"><span class='Ref_to_Func'>run_log</span></a><span class='Parentheses'>(</span>$cmd<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    ok<span class='Parentheses'>(</span>$result<span class='Delimiter'>, </span><span class='String'>"@$cmd exit code 0"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$log <span class='Operator'>= </span>TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN196"><span class='Ref_to_Func'>slurp_file</span></a><span class='Parentheses'>(</span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN230"><span class='Ref_to_Func'>logfile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    like<span class='Parentheses'>(</span>$log<span class='Delimiter'>, </span>$expected_sql<span class='Delimiter'>, </span><span class='String'>"$test_name: SQL found in server log"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;run_log(...) 
 
Runs a shell command like TestLib::run_log, but with PGPORT set so 
that the command will default to connecting to this PostgresNode. 
 
=cut 
</span> 
<a name="LN1340"></a><span class='Control'>sub</span> <span class='Declare_Function'>run_log</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span>$self <span class='Operator'>= </span><span class='Keyword'>shift</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>local </span>$ENV<span class='Delimiter'>{</span>PGPORT<span class='Delimiter'>} </span><span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN171"><span class='Ref_to_Func'>port</span></a><span class='Delimiter'>; 
</span> 
    TestLib<span class='Operator'>::</span><a href="TestLib.pm.html#LN167"><span class='Ref_to_Func'>run_log</span></a><span class='Parentheses'>(</span>@_<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;lsn(mode) 
 
Look up WAL locations on the server: 
 
 * insert location (master only, error on replica) 
 * write location (master only, error on replica) 
 * flush location (master only, error on replica) 
 * receive location (always undef on master) 
 * replay location (always undef on master) 
 
mode must be specified. 
 
=cut 
</span> 
<a name="LN1365"></a><span class='Control'>sub</span> <span class='Declare_Function'>lsn</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$mode<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>%modes <span class='Operator'>= </span><span class='Parentheses'>( 
</span>        <span class='String'>'insert'</span>  <span class='Operator'>=&GT; </span><span class='String'>'pg_current_wal_insert_lsn()'</span><span class='Delimiter'>, 
</span>        <span class='String'>'flush'</span>   <span class='Operator'>=&GT; </span><span class='String'>'pg_current_wal_flush_lsn()'</span><span class='Delimiter'>, 
</span>        <span class='String'>'write'</span>   <span class='Operator'>=&GT; </span><span class='String'>'pg_current_wal_lsn()'</span><span class='Delimiter'>, 
</span>        <span class='String'>'receive'</span> <span class='Operator'>=&GT; </span><span class='String'>'pg_last_wal_receive_lsn()'</span><span class='Delimiter'>, 
</span>        <span class='String'>'replay'</span>  <span class='Operator'>=&GT; </span><span class='String'>'pg_last_wal_replay_lsn()'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    $mode <span class='Operator'>= </span><span class='String'>'&LT;undef&GT;'</span> <span class='Control'>if</span> <span class='Operator'>!</span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$mode<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>die</span> <span class='String'>"unknown mode for 'lsn': '$mode', valid modes are "</span> 
      <span class='Operator'>. </span><span class='Keyword'>join</span><span class='Parentheses'>(</span><span class='String'>', '</span><span class='Delimiter'>, </span><span class='Keyword'>keys </span>%modes<span class='Parentheses'>) 
</span>      <span class='Control'>if</span> <span class='Operator'>!</span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$modes<span class='Delimiter'>{</span>$mode<span class='Delimiter'>}</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$result <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN969"><span class='Ref_to_Func'>safe_psql</span></a><span class='Parentheses'>(</span><span class='String'>'postgres'</span><span class='Delimiter'>, </span><span class='String'>"SELECT $modes{$mode}"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>chomp</span><span class='Parentheses'>(</span>$result<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>$result <span class='Operator'>eq </span><span class='String'>''</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span> $result<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;wait_for_catchup(standby_name, mode, target_lsn) 
 
Wait for the node with application_name standby_name (usually from node-&GT;name) 
until its replication location in pg_stat_replication equals or passes the 
upstream's WAL insert point at the time this function is called. By default 
the replay_lsn is waited for, but 'mode' may be specified to wait for any of 
sent|write|flush|replay. 
 
If there is no active replication connection from this peer, waits until 
poll_query_until timeout. 
 
Requires that the 'postgres' db exists and is accessible. 
 
target_lsn may be any arbitrary lsn, but is typically $master_node-&GT;lsn('insert'). 
 
This is not a test. It die()s on failure. 
 
=cut 
</span> 
<a name="LN1413"></a><span class='Control'>sub</span> <span class='Declare_Function'>wait_for_catchup</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$standby_name<span class='Delimiter'>, </span>$mode<span class='Delimiter'>, </span>$target_lsn<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    $mode <span class='Operator'>= </span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$mode<span class='Parentheses'>) </span><span class='Operator'>? </span>$mode <span class='Operator'>: </span><span class='String'>'replay'</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>%valid_modes <span class='Operator'>= 
</span>      <span class='Parentheses'>(</span><span class='String'>'sent'</span> <span class='Operator'>=&GT; </span>1<span class='Delimiter'>, </span><span class='String'>'write'</span> <span class='Operator'>=&GT; </span>1<span class='Delimiter'>, </span><span class='String'>'flush'</span> <span class='Operator'>=&GT; </span>1<span class='Delimiter'>, </span><span class='String'>'replay'</span> <span class='Operator'>=&GT; </span>1<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>die</span> <span class='String'>"unknown mode $mode for 'wait_for_catchup', valid modes are "</span> 
      <span class='Operator'>. </span><span class='Keyword'>join</span><span class='Parentheses'>(</span><span class='String'>', '</span><span class='Delimiter'>, </span><span class='Keyword'>keys</span><span class='Parentheses'>(</span>%valid_modes<span class='Parentheses'>))</span> 
      <span class='Control'>unless</span> <span class='Keyword'>exists</span><span class='Parentheses'>(</span>$valid_modes<span class='Delimiter'>{</span>$mode<span class='Delimiter'>}</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Allow passing of a PostgresNode instance as shorthand 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>blessed<span class='Parentheses'>(</span>$standby_name<span class='Parentheses'>) </span><span class='Operator'>&& </span>$standby_name<span class='Operator'>-&GT;</span>isa<span class='Parentheses'>(</span><span class='String'>"PostgresNode"</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        $standby_name <span class='Operator'>= </span>$standby_name<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>die</span> <span class='String'>'target_lsn must be specified'</span> <span class='Control'>unless</span> <span class='Keyword'>defined</span><span class='Parentheses'>(</span>$target_lsn<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"Waiting for replication conn "</span> 
      <span class='Operator'>. </span>$standby_name <span class='Operator'>. </span><span class='String'>"'s "</span> 
      <span class='Operator'>. </span>$mode 
      <span class='Operator'>. </span><span class='String'>"_lsn to pass "</span> 
      <span class='Operator'>. </span>$target_lsn <span class='Operator'>. </span><span class='String'>" on "</span> 
      <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$query <span class='Operator'>= 
qq</span><span class='String'>[SELECT '$target_lsn' &LT;= ${mode}_lsn FROM pg_catalog.pg_stat_replication WHERE application_name = '$standby_name';]</span><span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN1221"><span class='Ref_to_Func'>poll_query_until</span></a><span class='Parentheses'>(</span><span class='String'>'postgres'</span><span class='Delimiter'>, </span>$query<span class='Parentheses'>) 
</span>      or <span class='Control'>die</span> <span class='String'>"timed out waiting for catchup, current location is "</span> 
      <span class='Operator'>. </span><span class='Parentheses'>(</span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN969"><span class='Ref_to_Func'>safe_psql</span></a><span class='Parentheses'>(</span><span class='String'>'postgres'</span><span class='Delimiter'>, </span>$query<span class='Parentheses'>) </span><span class='Operator'>|| </span><span class='String'>'(unknown)'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"done\n"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;wait_for_slot_catchup(slot_name, mode, target_lsn) 
 
Wait for the named replication slot to equal or pass the supplied target_lsn. 
The location used is the restart_lsn unless mode is given, in which case it may 
be 'restart' or 'confirmed_flush'. 
 
Requires that the 'postgres' db exists and is accessible. 
 
This is not a test. It die()s on failure. 
 
If the slot is not active, will time out after poll_query_until's timeout. 
 
target_lsn may be any arbitrary lsn, but is typically $master_node-&GT;lsn('insert'). 
 
Note that for logical slots, restart_lsn is held down by the oldest in-progress tx. 
 
=cut 
</span> 
<a name="LN1463"></a><span class='Control'>sub</span> <span class='Declare_Function'>wait_for_slot_catchup</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$slot_name<span class='Delimiter'>, </span>$mode<span class='Delimiter'>, </span>$target_lsn<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    $mode <span class='Operator'>= </span><span class='Keyword'>defined</span><span class='Parentheses'>(</span>$mode<span class='Parentheses'>) </span><span class='Operator'>? </span>$mode <span class='Operator'>: </span><span class='String'>'restart'</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span>$mode <span class='Operator'>eq </span><span class='String'>'restart'</span> <span class='Operator'>|| </span>$mode <span class='Operator'>eq </span><span class='String'>'confirmed_flush'</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>die</span> <span class='String'>"valid modes are restart, confirmed_flush"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>die</span> <span class='String'>'target lsn must be specified'</span> <span class='Control'>unless</span> <span class='Keyword'>defined</span><span class='Parentheses'>(</span>$target_lsn<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"Waiting for replication slot "</span> 
      <span class='Operator'>. </span>$slot_name <span class='Operator'>. </span><span class='String'>"'s "</span> 
      <span class='Operator'>. </span>$mode 
      <span class='Operator'>. </span><span class='String'>"_lsn to pass "</span> 
      <span class='Operator'>. </span>$target_lsn <span class='Operator'>. </span><span class='String'>" on "</span> 
      <span class='Operator'>. </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN216"><span class='Ref_to_Func'>name</span></a> <span class='Operator'>. </span><span class='String'>"\n"</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$query <span class='Operator'>= 
qq</span><span class='String'>[SELECT '$target_lsn' &LT;= ${mode}_lsn FROM pg_catalog.pg_replication_slots WHERE slot_name = '$slot_name';]</span><span class='Delimiter'>; 
</span>    $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN1221"><span class='Ref_to_Func'>poll_query_until</span></a><span class='Parentheses'>(</span><span class='String'>'postgres'</span><span class='Delimiter'>, </span>$query<span class='Parentheses'>) 
</span>      or <span class='Control'>die</span> <span class='String'>"timed out waiting for catchup, current location is "</span> 
      <span class='Operator'>. </span><span class='Parentheses'>(</span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN969"><span class='Ref_to_Func'>safe_psql</span></a><span class='Parentheses'>(</span><span class='String'>'postgres'</span><span class='Delimiter'>, </span>$query<span class='Parentheses'>) </span><span class='Operator'>|| </span><span class='String'>'(unknown)'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>print </span><span class='String'>"done\n"</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;query_hash($dbname, $query, @columns) 
 
Execute $query on $dbname, replacing any appearance of the string __COLUMNS__ 
within the query with a comma-separated list of @columns. 
 
If __COLUMNS__ does not appear in the query, its result columns must EXACTLY 
match the order and number (but not necessarily alias) of supplied @columns. 
 
The query must return zero or one rows. 
 
Return a hash-ref representation of the results of the query, with any empty 
or null results as defined keys with an empty-string value. There is no way 
to differentiate between null and empty-string result fields. 
 
If the query returns zero rows, return a hash with all columns empty. There 
is no way to differentiate between zero rows returned and a row with only 
null columns. 
 
=cut 
</span> 
<a name="LN1508"></a><span class='Control'>sub</span> <span class='Declare_Function'>query_hash</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$dbname<span class='Delimiter'>, </span>$query<span class='Delimiter'>, </span>@columns<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Control'>die</span> <span class='String'>'calls in array context for multi-row results not supported yet'</span> 
      <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>wantarray</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># Replace __COLUMNS__ if found 
</span>    <span class='Keyword'>substr</span><span class='Parentheses'>(</span>$query<span class='Delimiter'>, </span>index<span class='Parentheses'>(</span>$query<span class='Delimiter'>, </span><span class='String'>'__COLUMNS__'</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>length</span><span class='Parentheses'>(</span><span class='String'>'__COLUMNS__'</span><span class='Parentheses'>))</span> <span class='Operator'>= 
</span>      <span class='Keyword'>join</span><span class='Parentheses'>(</span><span class='String'>', '</span><span class='Delimiter'>, </span>@columns<span class='Parentheses'>) 
</span>      <span class='Control'>if</span> index<span class='Parentheses'>(</span>$query<span class='Delimiter'>, </span><span class='String'>'__COLUMNS__'</span><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span>0<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$result <span class='Operator'>= </span>$self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN969"><span class='Ref_to_Func'>safe_psql</span></a><span class='Parentheses'>(</span>$dbname<span class='Delimiter'>, </span>$query<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Single_Line'># hash slice, see http://stackoverflow.com/a/16755894/398670 . 
</span>    <span class='Comment_Single_Line'># 
</span>    <span class='Comment_Single_Line'># Fills the hash with empty strings produced by x-operator element 
</span>    <span class='Comment_Single_Line'># duplication if result is an empty row 
</span>    <span class='Comment_Single_Line'># 
</span>    <span class='Keyword'>my </span>%val<span class='Delimiter'>; 
</span>    @val<span class='Delimiter'>{</span>@columns<span class='Delimiter'>} </span><span class='Operator'>= 
</span>      $result <span class='Operator'>ne </span><span class='String'>''</span> <span class='Operator'>? </span><span class='Keyword'>split</span><span class='Parentheses'>(</span>qr<span class='Operator'>/\|/</span><span class='Delimiter'>, </span>$result<span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Parentheses'>(</span><span class='String'>''</span><span class='Delimiter'>,</span><span class='Parentheses'>) </span>x <span class='Keyword'>scalar</span><span class='Parentheses'>(</span>@columns<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Operator'>\</span>%val<span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;slot(slot_name) 
 
Return hash-ref of replication slot data for the named slot, or a hash-ref with 
all values '' if not found. Does not differentiate between null and empty string 
for fields, no field is ever undef. 
 
The restart_lsn and confirmed_flush_lsn fields are returned verbatim, and also 
as a 2-list of [highword, lowword] integer. Since we rely on Perl 5.8.8 we can't 
"use bigint", it's from 5.20, and we can't assume we have Math::Bigint from CPAN 
either. 
 
=cut 
</span> 
<a name="LN1546"></a><span class='Control'>sub</span> <span class='Declare_Function'>slot</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$slot_name<span class='Parentheses'>) </span><span class='Operator'>= </span>@_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>@columns <span class='Operator'>= </span><span class='Parentheses'>( 
</span>        <span class='String'>'plugin'</span><span class='Delimiter'>, </span><span class='String'>'slot_type'</span><span class='Delimiter'>,</span>  <span class='String'>'datoid'</span><span class='Delimiter'>, </span><span class='String'>'database'</span><span class='Delimiter'>, 
</span>        <span class='String'>'active'</span><span class='Delimiter'>, </span><span class='String'>'active_pid'</span><span class='Delimiter'>, </span><span class='String'>'xmin'</span><span class='Delimiter'>,</span>   <span class='String'>'catalog_xmin'</span><span class='Delimiter'>, 
</span>        <span class='String'>'restart_lsn'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN1508"><span class='Ref_to_Func'>query_hash</span></a><span class='Parentheses'>( 
</span>        <span class='String'>'postgres'</span><span class='Delimiter'>, 
</span><span class='String'>"SELECT __COLUMNS__ FROM pg_catalog.pg_replication_slots WHERE slot_name = '$slot_name'"</span><span class='Delimiter'>, 
</span>        @columns<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=item $node-&GT;pg_recvlogical_upto(self, dbname, slot_name, endpos, timeout_secs, ...) 
 
Invoke pg_recvlogical to read from slot_name on dbname until LSN endpos, which 
corresponds to pg_recvlogical --endpos.  Gives up after timeout (if nonzero). 
 
Disallows pg_recvlogical from internally retrying on error by passing --no-loop. 
 
Plugin options are passed as additional keyword arguments. 
 
If called in scalar context, returns stdout, and die()s on timeout or nonzero return. 
 
If called in array context, returns a tuple of (retval, stdout, stderr, timeout). 
timeout is the IPC::Run::Timeout object whose is_expired method can be tested 
to check for timeout. retval is undef on timeout. 
 
=cut 
</span> 
<a name="LN1578"></a><span class='Control'>sub</span> <span class='Declare_Function'>pg_recvlogical_upto</span> 
<span class='Delimiter'>{ 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$self<span class='Delimiter'>, </span>$dbname<span class='Delimiter'>, </span>$slot_name<span class='Delimiter'>, </span>$endpos<span class='Delimiter'>, </span>$timeout_secs<span class='Delimiter'>, </span>%plugin_options<span class='Parentheses'>) </span><span class='Operator'>= 
</span>      @_<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span><span class='Parentheses'>(</span>$stdout<span class='Delimiter'>, </span>$stderr<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>$timeout_exception <span class='Operator'>= </span><span class='String'>'pg_recvlogical timed out'</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>die</span> <span class='String'>'slot name must be specified'</span> <span class='Control'>unless</span> <span class='Keyword'>defined</span><span class='Parentheses'>(</span>$slot_name<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>die</span> <span class='String'>'endpos must be specified'</span>    <span class='Control'>unless</span> <span class='Keyword'>defined</span><span class='Parentheses'>(</span>$endpos<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Keyword'>my </span>@cmd <span class='Operator'>= </span><span class='Parentheses'>(</span> 
        <span class='String'>'pg_recvlogical'</span><span class='Delimiter'>, </span><span class='String'>'-S'</span><span class='Delimiter'>, </span>$slot_name<span class='Delimiter'>, </span><span class='String'>'--dbname'</span><span class='Delimiter'>, 
</span>        $self<span class='Operator'>-&GT;</span><a href="PostgresNode.pm.html#LN245"><span class='Ref_to_Func'>connstr</span></a><span class='Parentheses'>(</span>$dbname<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Keyword'>push </span>@cmd<span class='Delimiter'>, </span><span class='String'>'--endpos'</span><span class='Delimiter'>, </span>$endpos<span class='Delimiter'>; 
</span>    <span class='Keyword'>push </span>@cmd<span class='Delimiter'>, </span><span class='String'>'-f'</span><span class='Delimiter'>, </span><span class='String'>'-'</span><span class='Delimiter'>, </span><span class='String'>'--no-loop'</span><span class='Delimiter'>, </span><span class='String'>'--start'</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Keyword'>my </span><span class='Parentheses'>(</span>$k<span class='Delimiter'>, </span>$v<span class='Parentheses'>) </span><span class='Operator'>= </span><span class='Keyword'>each </span>%plugin_options<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>die</span> <span class='String'>"= is not permitted to appear in replication option name"</span> 
          <span class='Control'>if</span> <span class='Parentheses'>(</span>$k <span class='Operator'>=~ </span>qr<span class='Operator'>/=/</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Keyword'>push </span>@cmd<span class='Delimiter'>, </span><span class='String'>"-o"</span><span class='Delimiter'>, </span><span class='String'>"$k=$v"</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Keyword'>my </span>$timeout<span class='Delimiter'>; 
</span>    $timeout <span class='Operator'>= 
</span>      IPC<span class='Operator'>::</span><a href="../../backend/utils/Gen_dummy_probes.pl.html#LN33"><span class='Ref_to_Func'>Run</span></a><span class='Operator'>::</span>timeout<span class='Parentheses'>(</span>$timeout_secs<span class='Delimiter'>, </span>exception <span class='Operator'>=&GT; </span>$timeout_exception<span class='Parentheses'>) 
</span>      <span class='Control'>if</span> $timeout_secs<span class='Delimiter'>; 
</span>    <span class='Keyword'>my </span>$ret <span class='Operator'>= </span>0<span class='Delimiter'>; 
</span> 
    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Keyword'>local </span>$@<span class='Delimiter'>; 
</span>        <span class='Keyword'>eval </span><span class='Delimiter'>{ 
</span>            IPC<span class='Operator'>::</span><a href="../../backend/utils/Gen_dummy_probes.pl.html#LN33"><span class='Ref_to_Func'>Run</span></a><span class='Operator'>::</span>run<span class='Parentheses'>(</span><span class='Operator'>\</span>@cmd<span class='Delimiter'>, </span><span class='String'>"&GT;"</span><span class='Delimiter'>, </span><span class='Operator'>\</span>$stdout<span class='Delimiter'>, </span><span class='String'>"2&GT;"</span><span class='Delimiter'>, </span><span class='Operator'>\</span>$stderr<span class='Delimiter'>, </span>$timeout<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            $ret <span class='Operator'>= </span>$<span class='Operator'>?</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}; 
</span>        <span class='Keyword'>my </span>$exc_save <span class='Operator'>= </span>$@<span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>$exc_save<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span> 
            <span class='Comment_Single_Line'># IPC::Run::run threw an exception. re-throw unless it's a 
</span>            <span class='Comment_Single_Line'># timeout, which we'll handle by testing is_expired 
</span>            <span class='Control'>die</span> $exc_save 
              <span class='Control'>if</span> <span class='Parentheses'>(</span>blessed<span class='Parentheses'>(</span>$exc_save<span class='Parentheses'>) </span><span class='Operator'>|| </span>$exc_save <span class='Operator'>!~ </span>qr<span class='Operator'>/$timeout_exception/</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            $ret <span class='Operator'>= </span><span class='Keyword'>undef</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>die</span> <span class='String'>"Got timeout exception '$exc_save' but timer not expired?!"</span> 
              <span class='Control'>unless</span> $timeout<span class='Operator'>-&GT;</span>is_expired<span class='Delimiter'>; 
</span> 
            <span class='Control'>die</span> 
<span class='String'>"$exc_save waiting for endpos $endpos with stdout '$stdout', stderr '$stderr'"</span> 
              <span class='Control'>unless</span> <span class='Keyword'>wantarray</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}; 
</span> 
    $stdout <span class='Operator'>=~ s</span><span class='String'>/\r//</span>g <span class='Control'>if</span> $TestLib<span class='Operator'>::</span>windows_os<span class='Delimiter'>; 
</span>    $stderr <span class='Operator'>=~ s</span><span class='String'>/\r//</span>g <span class='Control'>if</span> $TestLib<span class='Operator'>::</span>windows_os<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>wantarray</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span>$ret<span class='Delimiter'>, </span>$stdout<span class='Delimiter'>, </span>$stderr<span class='Delimiter'>, </span>$timeout<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>die</span> 
<span class='String'>"pg_recvlogical exited with code '$ret', stdout '$stdout' and stderr '$stderr'"</span> 
          <span class='Control'>if</span> $ret<span class='Delimiter'>; 
</span>        <span class='Control'>return</span> $stdout<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Perl_POD'>=pod 
 
=back 
 
=cut 
</span> 
1<span class='Delimiter'>; 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>